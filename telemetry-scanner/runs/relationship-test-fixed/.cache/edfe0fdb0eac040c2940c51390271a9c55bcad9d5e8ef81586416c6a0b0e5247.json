[
  [
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Text;\nusing System.Threading;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Web.Common.Helpers;\n\nusing DocuSign.DynamicSettings;\nusing DocuSign.Monitoring;\n\nnamespace ADEXS.Web.Common;\n/// <summary>\n/// Temporary Base class to redirect the ASHX API call to new Controller API as part of the effort of web migration to .net6\n/// This will eventually cleaned up once we move to .net6\n/// </summary>\npublic abstract class BaseApiHandler : IHttpHandler\n{\n\t[EventSource(\"Exception\", \"CLM.FeatureFlags.PopulateFeatureFlagContext\")]\n\t[Counter(\"Exception\", \"CLM.FeatureFlags.PopulateFeatureFlagContext\", InstanceProperty = \"Description\")]\n\tprivate static ExceptionEventSource _featureFlagContextExceptionEventSource = new ExceptionEventSource();\n\n\tprivate static readonly IDiscreetLogger Logger = DiscreetLogger.GetLogger(typeof(BaseApiHandler));\n\n\t// reletive path for new controller api. ex) \"A/TileView/GetTiles\"\n\t// where full url is https://localhost/atlas/A/TileView/GetTiles\n\tprotected abstract string Path { get; }\n\n\tpublic virtual bool IsReusable { get; set; }\n\n\tpublic virtual void ProcessRequest(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tPopulateFeatureFlagContext(AtlasContext.Current.UserAccount, context);\n\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to Populate Feature Flag Context: {LogData()}\", ex);\n\t\t}\n\n\t\tif (ShouldRedirectHelper())\n\t\t{\n\t\t\tRedirect(context);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tHandleRequest(context);\n\t\t}\n\t}\n\n\tprotected abstract bool ShouldRedirect();\n\tprotected abstract void HandleRequest(HttpContext context);\n\n\tprivate string LogData()\n\t{\n\t\treturn $\"aid:{AtlasContext.Current.AccountId} uid:{AtlasContext.Current.UserAccountUid} relativeUrl: {Path}\";\n\t}\n\tprivate void Redirect(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t\t}\n\n\t\t\t// Get the original path info\n\t\t\tvar pathInfo = !string.IsNullOrEmpty(context.Request.PathInfo) ? context.Request.PathInfo : \"\";\n\n\t\t\t// Get the original query string\n\t\t\tvar queryString = context.Request.QueryString;\n\n\t\t\t// URL-encode pathInfo and queryString before building the new URL\n\t\t\tvar encodedPathInfo = HttpUtility.UrlPathEncode(pathInfo);\n\t\t\tvar encodedQueryString = ToUrlEncodedQueryString(queryString);\n\n\t\t\tvar baseUrl = AtlasUrlHelper.WebApplicationBasePath();\n\t\t\tvar newUrl = $\"{baseUrl}/{Path}{encodedPathInfo}{encodedQueryString}\";\n\n\t\t\t// Set the status code to 307 Temporary Redirect\n\t\t\tcontext.Response.StatusCode = Microsoft.AspNetCore.Http.StatusCodes.Status307TemporaryRedirect;\n\n\t\t\t// Set the Location header with the new Controller URL\n\t\t\tcontext.Response.AddHeader(\"Location\", newUrl);\n\n\t\t}\n\t\tcatch (ThreadAbortException)\n\t\t{\n\t\t\t// Do nothing intentionally.\n\t\t\t// The above Redirect call is *meant* to abort the thread with an exception and we do _not_ want it caught by the below catch block.\n\t\t\t// See this article for why we are catching it here and why we do nothing in this block.\n\t\t\t// https://learn.microsoft.com/en-us/dotnet/standard/threading/destroying-threads#handling-threadabortexception\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to Redirect: {LogData()}\", ex);\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprivate bool ShouldRedirectHelper()\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn ShouldRedirect();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to evaluate ShouldRedirect: {LogData()}\", ex);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void PopulateFeatureFlagContext(UserAccount currentUser, HttpContext context)\n\t{\n\t\tif (context == null)\n\t\t{\n\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t}\n\n\t\tif (currentUser == null || !ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId > 0)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = AtlasContext.Current.AccountId;\n\t\t\t}\n\t\t\telse if (context.Request.QueryString[Constants.QueryStringParameters.AccountIdAbbreviated] != null)\n\t\t\t{\n\t\t\t\tif (int.TryParse(context.Request.QueryString[Constants.QueryStringParameters.AccountIdAbbreviated], out var accountId))\n\t\t\t\t{\n\t\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = accountId;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = currentUser.AccountId;\n\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.UserId] = currentUser.Uid;\n\t\t\tif (currentUser.Account != null)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountType] = currentUser.Account.AccountType;\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.PlanName] = NpsUtilities.GetPlanIdName(currentUser.Account);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t_featureFlagContextExceptionEventSource.Emit(ex);\n\t\t}\n\t}\n\n\tprivate static string ToUrlEncodedQueryString(NameValueCollection collection)\n\t{\n\t\tif (collection == null || collection.Count == 0)\n\t\t{\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\tvar builder = new StringBuilder();\n\t\tvar first = true;\n\t\tfor (var i = 0; i < collection.Count; i++)\n\t\t{\n\t\t\tvar key = collection.GetKey(i);\n\t\t\tvar value = collection.Get(i);\n\t\t\tbuilder.Append(first ? '?' : '&');\n\t\t\tfirst = false;\n\t\t\tbuilder.Append(HttpUtility.UrlEncode(key));\n\t\t\tbuilder.Append('=');\n\t\t\tbuilder.Append(HttpUtility.UrlEncode(value));\n\t\t}\n\n\t\treturn builder.ToString();\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Threading;\nusing System.Web;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.RequestHeaders;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.MVC;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\nusing log4net;\n\nnamespace ADEXS.Web.Common.Profile\n{\n\tpublic class ProfileModule : IHttpModule\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(\"ADEXS.Web.Common\");\n\n\n\t\tprivate PerformanceLog _performanceLog;\n\t\tprivate IDisposable _logContext;\n\n\t\t[EventSource(\"Session Size\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Size\", \"CLM.SessionState\", DisplayUnit = CounterUnit.kilobytes,\n\t\t\tRanges = new double[10] { 1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 20000 },\n\t\t\tMeasureProperty = \"Count\", InstanceProperty = \"Description\", ShowVolume = true)]\n\t\tprivate static readonly CountEventSource _sessionSizeEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Session Serialization Timing\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Serialization Timing\", \"CLM.SessionState\", DisplayUnit = CounterUnit.milliseconds,\n\t\t\tRanges = new double[10] { 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t\tMeasureProperty = \"Duration\", SuccessProperty = \"Success\", InstanceProperty = \"Description\")]\n\t\tprivate static readonly TimingEventSource _sessionSerializationTimingEventSource = new TimingEventSource();\n\n\t\t[EventSource(\"Large Session\", \"CLM.SessionState\")]\n\t\t[Counter(\"Large Session\", \"CLM.SessionState\")]\n\t\tprivate static readonly PropertyBagEventSource _largeSessionEventSource = new PropertyBagEventSource();\n\n\t\t/// <summary>\n\t\t/// You will need to configure this module in the web.config file of your\n\t\t/// web and register it with IIS before being able to use it. For more information\n\t\t/// see the following link: http://go.microsoft.com/?linkid=8101007\n\t\t/// </summary>\n\t\t#region IHttpModule Members\n\n\t\tpublic void Dispose()\n\t\t{\n\t\t\t//clean-up code here.\n\t\t}\n\n\t\tpublic void Init(HttpApplication context)\n\t\t{\n\t\t\t// Below is an example of how you can handle LogRequest event and provide\n\t\t\t// custom logging implementation for it\n\t\t\tcontext.BeginRequest += OnBeginRequest;\n\t\t\tcontext.PreRequestHandlerExecute += OnPreRequestHandlerExecute;\n\t\t\tcontext.PostRequestHandlerExecute += OnPostRequestHandlerExecute;\n\t\t\tcontext.EndRequest += OnEndRequest;\n\t\t\tcontext.Error += OnError;\n\t\t}\n\n\t\t/* IIS request life cycle BeginRequest ->  AuthenticateRequest -> AuthorizeRequest -> ResolveRequestCache -> AcquireRequestState ->\n\t\t * PreRequestHandlerExecute -> ProcessRequest -> PostRequestHandlerExecute -> ReleaseRequestState -> UpdateRequestCache -> EndRequest */\n\n\t\tprivate void OnBeginRequest(object sender, EventArgs e)\n\t\t{\n\t\t\tif (_performanceLog == null)\n\t\t\t\t_performanceLog = new PerformanceLog();\n\n\t\t\t_performanceLog.Start(HttpContext.Current.Request);\n\t\t}\n\n\t\tprivate void OnPostRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(HttpContext.Current);\n\t\t\tLogSessionSize(HttpContext.Current?.Session);\n\t\t\t_performanceLog.SetSession(HttpContext.Current?.Session);\n\t\t}\n\n\t\tprivate void OnPreRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tHttpContext context = HttpContext.Current;\n\t\t\t\tAtlasContext.Reset();\n\n\t\t\t\t// MonitoringContext is initialized in the ScmLogRequestHttpModule module on\n\t\t\t\t// BeginRequest. This runs before this event handler. By this time the\n\t\t\t\t// CorrelationToken is set. Including getting it from the X-DocuSign-CorrelationToken header if available.\n\t\t\t\tGuid corrId = MonitoringContext.CorrelationToken ?? Guid.Empty;\n\t\t\t\tif (Guid.Empty == corrId)\n\t\t\t\t{\n\t\t\t\t\t// Only in extremely unlikely scenario\n\t\t\t\t\tGuid.TryParse(AtlasContext.Current.TransactionId, out corrId);\n\t\t\t\t\tMonitoringContext.CorrelationToken = corrId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAtlasContext.Current.TransactionId = corrId.ToString();\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t// Now we'll have TransactionId, CorrelationId, and CorrelationToken all set to the same value. Three is a crowd?...\n\t\t\t\t_logContext = LogContext.Set(AtlasContext.Current.TransactionId);\n\n\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"ServiceLocator:\\n{ServiceLocator.Container.WhatDoIHave(typeof(ILogContextStore))}\");\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Reset();\n\t\t\t\tif (context != null)\n\t\t\t\t{\n\t\t\t\t\tif (context.Request != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tAtlasContext.Current.ClientIpAddress = IPAddressUtil.FetchIpAddress(context.Request);\n\t\t\t\t\t\tAtlasContext.Current.ClientUserAgent = context.Request.UserAgent;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Similar code exists for web services, which don't use session.\n\t\t\t\t\t// That code is in SetContextIds\n\t\t\t\t\tHttpSessionState session = context.Session;\n\t\t\t\t\tif (session != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tUserAccount user = CommonData.CurrentUser;\n\t\t\t\t\t\tif (user != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAtlasContext.Current.AccountId = user.AccountId;\n\t\t\t\t\t\t\tAtlasContext.Current.UserAccountUid = user.Uid;\n\t\t\t\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = user.AccountId == int.MinValue ? \"null\" : user.AccountId.ToString();\n\n\t\t\t\t\t\t\tvar userContextSetter = AtlasWebDependencyResolver.ScopedInstance?.GetService<IUserContextSetter>();\n\t\t\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"The user's AccountId: {user.AccountId} for user id: {user.Uid} in OnPreRequestHandlerExecute.\");\n\t\t\t\t\t\t\t\t// ensure that DI consumers have access the user/account context\n\t\t\t\t\t\t\t\tuserContextSetter.AccountId = user.AccountId;\n\t\t\t\t\t\t\t\tuserContextSetter.UserId = user.Uid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII(\"No UserContextSetter is available - account context propagation will not work.\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar docusignAccountId = CommonData.DocuSignAccountId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignAccountId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignAccountId = docusignAccountId;\n\n\t\t\t\t\t\t\tvar docusignUserId = CommonData.DocuSignUserId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignUserId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignUserId = docusignUserId;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnPreRequestHandlerExecute in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Measuring session size ATL-56207\n\t\t/// </summary>\n\t\tprivate static void LogSessionSize(HttpSessionState session)\n\t\t{\n\t\t\tif (session == null || !Configuration.GetBooleanAppSetting(\"EnableSessionSizeLogging\", false))\n\t\t\t\treturn;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong totalSessionBytes = 0;\n\t\t\t\tstring largestItemKey = string.Empty;\n\t\t\t\tlong largestItemSizeBytes = 0;\n\t\t\t\tint itemCount = 0;\n\n\t\t\t\tusing (OperationTimer sessionSerializationTimer = _sessionSerializationTimingEventSource.CreateTimer())\n\t\t\t\t{\n\t\t\t\t\tBinaryFormatter formatter = new BinaryFormatter();\n\t\t\t\t\tforeach (var sessionKey in session)\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (Stream s = new MemoryStream())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring key = (string)sessionKey;\n\t\t\t\t\t\t\tvar item = session[key];\n\t\t\t\t\t\t\tif (item != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titemCount++;\n\n\t\t\t\t\t\t\t\tformatter.Serialize(s, item);\n\n\t\t\t\t\t\t\t\tif (s.Length > largestItemSizeBytes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlargestItemKey = key;\n\t\t\t\t\t\t\t\t\tlargestItemSizeBytes = s.Length;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttotalSessionBytes += s.Length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsessionSerializationTimer.SetResult(true);\n\t\t\t\t}\n\n\t\t\t\t_sessionSizeEventSource.Emit(totalSessionBytes);\n\n\t\t\t\tif (totalSessionBytes > Configuration.GetInt64AppSetting(\"LargeSessionSizeLoggingThreshold\", 1000000)) // default to 1MB\n\t\t\t\t{\n\t\t\t\t\tstring aid = AtlasContext.Current?.AccountId.ToString();\n\t\t\t\t\tstring userId = AtlasContext.Current?.UserAccountUid.ToString();\n\n\t\t\t\t\tusing (var propertyBag = _largeSessionEventSource.CreateEventPropertyBag())\n\t\t\t\t\t{\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"AccountId\", aid);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"UserAccountUid\", userId);\n\n\t\t\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionId\", session.SessionID);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionSizeInBytes\", totalSessionBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemKey\", largestItemKey);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemSizeInBytes\", largestItemSizeBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"TotalSessionItemCount\", itemCount.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"ThreadId\", Thread.CurrentThread.ManagedThreadId.ToString());\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.InfoNoPII($\"Detected Large SessionState. AccountId {aid} UserAccountUid {userId} SessionId {session.SessionID} SessionSizeInBytes {totalSessionBytes} TotalItemCount {itemCount} Largest Item Key {largestItemKey} ({largestItemSizeBytes})\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Exception occurred while attempting to measure session.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnError(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//get latest exception (top level exception is probably an HTTPUnhandledException which contains underlying exceptions via .InnerException)\n\n\t\t\t\tException baseException = null;\n\t\t\t\tvar lastError = HttpContext.Current.Server.GetLastError();\n\t\t\t\tif (lastError == null)\n\t\t\t\t{\n\t\t\t\t\tvar allError = HttpContext.Current.AllErrors;\n\t\t\t\t\tif (allError != null && allError.Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseException = allError[allError.Length - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseException = lastError.GetBaseException();\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Stop(baseException);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnError in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnEndRequest(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (_performanceLog != null)\n\t\t\t\t{\n\t\t\t\t\t_performanceLog.Stop();\n\t\t\t\t\t_performanceLog.Dispose();\n\t\t\t\t\t_performanceLog = null;\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t_logContext = null;\n\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = \"null\";\n\n\t\t\t\t// we are no longer looking for outstanding DB transactions here.\n\t\t\t\t// because the module does not have to run in the same thread as the request handler\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnEndRequest in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAtlasContext.Current.CacheClient.FlushCache();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not clear the user settings on the thread for the request.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing ADEXS.Web.Telemetry;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\nusing ADEXS.Core.Domain.Utilities;\n\nnamespace ADEXS.Web.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.WebNet\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring.HttpModules, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions; Matches 3 keywords: SetTag, OpenTelemetry, middleware",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag",
        "Import: DocuSign.Monitoring",
        "middleware",
        "Import: DocuSign.CLM.Monitoring.HttpModules",
        "Pattern: Instrumentation",
        "Pattern: Activity.Current",
        "OpenTelemetry",
        "Pattern: Monitoring",
        "Pattern: OpenTelemetry",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/Middlewares/LogAsyncRequestHttpMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.API.Allocation.Telemetry;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.API.Allocation.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.API.Allocation\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Matches 2 keywords: SetTag, middleware",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag",
        "middleware"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Telemetry;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.Web.Common.AspNetCore.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic abstract class ScmLogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic ScmLogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tprotected ScmLogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Matches 2 keywords: SetTag, middleware",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag",
        "middleware"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ProfileMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing log4net;\n\nusing Microsoft.AspNetCore.Http;\n\nusing Microsoft.AspNetCore.Http.Features;\n\nnamespace ADEXS.Web.Common.AspNetCore.Middlewares;\n\npublic sealed class ProfileMiddleware : IDisposable\n{\n\tprivate static readonly IDiscreetLogger Log = DiscreetLogger.GetLogger(typeof(ProfileMiddleware));\n\tprivate readonly RequestDelegate _next;\n\tprivate IDisposable? _logContext;\n\n\t[EventSource(\"Session Size\", \"CLM.SessionState\")]\n\t[Counter(\n\t\t\"Session Size\",\n\t\t\"CLM.SessionState\",\n\t\tDisplayUnit = CounterUnit.kilobytes,\n\t\tRanges = new double[10] { 1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 20000 },\n\t\tMeasureProperty = \"Count\",\n\t\tInstanceProperty = \"Description\",\n\t\tShowVolume = true)]\n\tprivate static readonly CountEventSource SessionSizeEventSource = new CountEventSource();\n\n\t[EventSource(\"Session Serialization Timing\", \"CLM.SessionState\")]\n\t[Counter(\n\t\t\"Session Serialization Timing\",\n\t\t\"CLM.SessionState\",\n\t\tDisplayUnit = CounterUnit.milliseconds,\n\t\tRanges = new double[10] { 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\tMeasureProperty = \"Duration\",\n\t\tSuccessProperty = \"Success\",\n\t\tInstanceProperty = \"Description\")]\n\tprivate static readonly TimingEventSource SessionSerializationTimingEventSource = new TimingEventSource();\n\n\t[EventSource(\"Large Session\", \"CLM.SessionState\")]\n\t[Counter(\"Large Session\", \"CLM.SessionState\")]\n\tprivate static readonly PropertyBagEventSource LargeSessionEventSource = new PropertyBagEventSource();\n\n\t// Avoid using HttpContext.Session directly because it will throw an exception if the session is not available.\n\tprivate static bool HasSession(HttpContext context) =>\n\t\tcontext?.Features?.Get<ISessionFeature>() != null && context?.Session != null;\n\n\tpublic ProfileMiddleware(RequestDelegate next)\n\t{\n\t\t_next = next;\n\t}\n\n\tpublic async Task InvokeAsync(HttpContext context)\n\t{\n\t\tif (context != null)\n\t\t{\n\t\t\t// Do something with context near the beginning of request processing.\n\t\t\tOnPreRequestHandlerExecute(context);\n\n\t\t\tawait _next.Invoke(context);\n\n\t\t\t// Clean up.\n\t\t\tOnPostRequestHandlerExecute(context);\n\t\t\tOnEndRequest();\n\t\t}\n\t}\n\n\tpublic void Dispose()\n\t{\n\t\t_logContext?.Dispose();\n\t}\n\n\tprivate void OnPreRequestHandlerExecute(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tLog.DebugNoPII(\"OnPreRequestHandlerExecute called.\");\n\t\t\tAtlasContext.Reset();\n\n\t\t\t// MonitoringContext is initialized in the AbstractLogRequestHttpMiddleware on\n\t\t\t// BeginRequest. This runs before this event handler. By this time the\n\t\t\t// CorrelationToken is set. Including getting it from the X-DocuSign-CorrelationToken header if available.\n\t\t\tvar corrId = MonitoringContext.CorrelationToken ?? Guid.Empty;\n\t\t\tif (corrId == Guid.Empty)\n\t\t\t{\n\t\t\t\t// Only in extremely unlikely scenario\n\t\t\t\tif (Guid.TryParse(AtlasContext.Current.TransactionId, out corrId))\n\t\t\t\t{\n\t\t\t\t\tLog.WarnNoPII(\n\t\t\t\t\t\t\"MonitoringContext.CorrelationToken was not set, but AtlasContext.Current.TransactionId was set. Using it to set MonitoringContext.CorrelationToken.\");\n\t\t\t\t\tMonitoringContext.CorrelationToken = corrId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog.WarnNoPII(\n\t\t\t\t\t\t\"MonitoringContext.CorrelationToken was not set, and AtlasContext.Current.TransactionId was not a valid Guid. Using Guid.Empty.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"MonitoringContext.CorrelationToken set to: {corrId}\");\n\t\t\t\tAtlasContext.Current.TransactionId = corrId.ToString();\n\t\t\t}\n\n\t\t\t// Overwrite TransactionId to use Activity.Current.Id\n\t\t\tif (!string.IsNullOrWhiteSpace(Activity.Current?.Id))\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Activity.Current.Id is set to: {Activity.Current.Id}. Overwriting AtlasContext.Current.TransactionId.\");\n\t\t\t\tAtlasContext.Current.TransactionId = Activity.Current.Id;\n\t\t\t}\n\n\t\t\tLog.DebugNoPII($\"AtlasContext.Current.TransactionId set to: {AtlasContext.Current.TransactionId}\");\n\t\t\t_logContext?.Dispose();\n\t\t\t_logContext = LogContext.Set(AtlasContext.Current.TransactionId);\n\n\t\t\tif (Log.IsDebugEnabled)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"ServiceLocator:\\n{ServiceLocator.Container.WhatDoIHave(typeof(ILogContextStore))}\");\n\t\t\t}\n\n\t\t\tif (context.Connection != null)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Connection RemoteIpAddress: {context.Connection.RemoteIpAddress?.ToString()}\");\n\t\t\t\tAtlasContext.Current.ClientIpAddress = context.Connection.RemoteIpAddress?.ToString();\n\t\t\t}\n\n\t\t\tif (context.Request != null)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Request Path: {context.Request.Path}\");\n\t\t\t\tAtlasContext.Current.ClientUserAgent = context.Request.Headers?.UserAgent.ToString();\n\t\t\t}\n\n\t\t\t// Similar code exists for web services, which don't use session.\n\t\t\t// That code is in SetContextIds\n\t\t\tif (HasSession(context))\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Session Id: {context.Session.Id}\");\n\t\t\t\tvar user = CommonData.CurrentUser;\n\t\t\t\tif (user != null)\n\t\t\t\t{\n\t\t\t\t\tLog.DebugNoPII($\"User AccountId: {user.AccountId}, User Uid: {user.Uid}\");\n\t\t\t\t\tAtlasContext.Current.AccountId = user.AccountId;\n\t\t\t\t\tAtlasContext.Current.UserAccountUid = user.Uid;\n\t\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] =\n\t\t\t\t\t\tuser.AccountId == int.MinValue ? \"null\" : user.AccountId.ToString();\n\n\t\t\t\t\tvar docusignAccountId = CommonData.DocuSignAccountId;\n\t\t\t\t\tif (!string.IsNullOrEmpty(docusignAccountId))\n\t\t\t\t\t{\n\t\t\t\t\t\tLog.DebugNoPII($\"DocuSign AccountId: {docusignAccountId}\");\n\t\t\t\t\t\tAtlasContext.Current.DocuSignAccountId = docusignAccountId;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar docusignUserId = CommonData.DocuSignUserId;\n\t\t\t\t\tif (!string.IsNullOrEmpty(docusignUserId))\n\t\t\t\t\t{\n\t\t\t\t\t\tLog.DebugNoPII($\"DocuSign UserId: {docusignUserId}\");\n\t\t\t\t\t\tAtlasContext.Current.DocuSignUserId = docusignUserId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog.DebugNoPII(\"No user found in session.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog.DebugNoPII(\"No session found.\");\n\t\t\t}\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Error setting AtlasContext.Current properties.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n\n\tprivate static void OnPostRequestHandlerExecute(HttpContext context)\n\t{\n\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\tif (HasSession(context))\n\t\t{\n\t\t\tLogSessionSize(context.Session);\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Measuring session size ATL-56207\n\t/// </summary>\n\tprivate static void LogSessionSize(ISession session)\n\t{\n\t\tif (!Configuration.GetBooleanAppSetting(\"EnableSessionSizeLogging\", false))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tlong totalSessionBytes = 0;\n\t\t\tvar largestItemKey = string.Empty;\n\t\t\tlong largestItemSizeBytes = 0;\n\t\t\tvar itemCount = 0;\n\n\t\t\tusing (var sessionSerializationTimer = SessionSerializationTimingEventSource.CreateTimer())\n\t\t\t{\n\t\t\t\tforeach (var sessionKey in session.Keys)\n\t\t\t\t{\n\t\t\t\t\tif (session.TryGetValue(sessionKey, out var bytes))\n\t\t\t\t\t{\n\t\t\t\t\t\titemCount++;\n\t\t\t\t\t\tif (bytes.Length > largestItemSizeBytes)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlargestItemKey = sessionKey;\n\t\t\t\t\t\t\tlargestItemSizeBytes = bytes.Length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttotalSessionBytes += bytes.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsessionSerializationTimer.SetResult(true);\n\t\t\t}\n\n\t\t\tSessionSizeEventSource.Emit(totalSessionBytes);\n\n\t\t\t// default to 1MB\n\t\t\tif (totalSessionBytes > Configuration.GetInt64AppSetting(\"LargeSessionSizeLoggingThreshold\", 1000000))\n\t\t\t{\n\t\t\t\tvar aid = AtlasContext.Current?.AccountId.ToString();\n\t\t\t\tvar userId = AtlasContext.Current?.UserAccountUid.ToString();\n\n\t\t\t\tusing (var propertyBag = LargeSessionEventSource.CreateEventPropertyBag())\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"AccountId\", aid);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"UserAccountUid\", userId);\n\n\t\t\t\t\tif (Log.IsDebugEnabled)\n\t\t\t\t\t{\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionId\", session.Id);\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionSizeInBytes\", totalSessionBytes.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemKey\", largestItemKey);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemSizeInBytes\", largestItemSizeBytes.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TotalSessionItemCount\", itemCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ThreadId\", Environment.CurrentManagedThreadId.ToString());\n\t\t\t\t}\n\n\t\t\t\tLog.InfoNoPII(\n\t\t\t\t\t$\"Detected Large SessionState. AccountId {aid} UserAccountUid {userId} SessionId {session.Id} SessionSizeInBytes {totalSessionBytes} TotalItemCount {itemCount} Largest Item Key {largestItemKey} ({largestItemSizeBytes})\");\n\t\t\t}\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Exception occurred while attempting to measure session.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n\n\tprivate void OnEndRequest()\n\t{\n\t\ttry\n\t\t{\n\t\t\t_logContext?.Dispose();\n\t\t\t_logContext = null;\n\t\t\tLogicalThreadContext.Properties[\"accountid\"] = \"null\";\n\n\t\t\t// we are no longer looking for outstanding DB transactions here.\n\t\t\t// because the module does not have to run in the same thread as the request handler\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Trouble OnEndRequest in ProfileModule.\", ex);\n\t\t\tex.Report();\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tAtlasContext.Current.CacheClient.FlushCache();\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Could not clear the user settings on the thread for the request.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Matches 2 keywords: SetTag, middleware",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag",
        "middleware"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Filters/MvcAuditedRequestAttribute.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\n#if NETFRAMEWORK\nusing System.Web;\nusing System.Web.Mvc;\nusing System.Web.Routing;\nusing ADEXS.Web.CommonUI.Helpers;\n#else\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.AspNetCore.Http;\n#endif\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Extensions;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.DynamicSettings;\nusing DocuSign.Monitoring;\nusing ADEXS.Core.Domain.Utilities;\n\nnamespace ADEXS.Web.CommonUI.MVC.Filters\n{\n\tpublic abstract class MvcAuditedRequestAttribute : ActionFilterAttribute, IActionFilter, IExceptionFilter\n\t{\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Duration\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Duration\", \"CLM.API\",\n\t\t/// InstanceProperty = \"Description\",\n\t\t/// DisplayUnit = CounterUnit.milliseconds,\n\t\t/// Ranges = new double[10] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t/// MeasureProperty = \"Duration\",\n\t\t/// SuccessProperty = \"Success\")]\n\t\t/// static readonly TimingEventSource apiEventSource = new TimingEventSource();\n\t\t/// </summary>\n\t\tprotected abstract TimingEventSource ApiEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Attempts\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Attempts\", \"CLM.API\", InstanceProperty = \"Description\")]\n\t\t/// static readonly SimpleEventSource attemptEventSource = new SimpleEventSource();\n\t\t/// </summary>\n\t\tprotected abstract SimpleEventSource AttemptEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the timing Stopwatch instance will be stored.\n\t\t/// Example: \"ClmApi.Stopwatch\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_StopWatch { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the the name of the counter instance will be stored.\n\t\t/// Example: \"ClmApi.InstanceName\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_CounterInstance { get; }\n\n\t\tprivate static string NO_CONTROLLER_STRING = \"_no-controller_\";\n\t\tprivate static string NO_ACTION_NAME = \"_no-action_\";\n\t\tprivate static string NO_HTTP_VERB = \"_no-verb_\";\n\n\t\tpublic override void OnActionExecuting(ActionExecutingContext filterContext)\n\t\t{\n#if NETFRAMEWORK\n\t\t\tstring controllerName = filterContext.ActionDescriptor.ControllerDescriptor.ControllerName;\n\t\t\tServiceContext.Log(DataPoint.ApiController, controllerName);\n\t\t\tstring actionName = filterContext.ActionDescriptor.ActionName;\n\t\t\tServiceContext.Log(DataPoint.Action, actionName);\n#else\n\t\t\tvar controllerName = filterContext.ActionDescriptor.RouteValues[\"controller\"] ?? NO_CONTROLLER_STRING;\n\t\t\tServiceContext.Log(DataPoint.ApiController, controllerName);\n\t\t\tvar actionName = filterContext.ActionDescriptor.RouteValues[\"action\"] ?? NO_ACTION_NAME;\n\t\t\tServiceContext.Log(DataPoint.Action, actionName);\n#endif\n\n\t\t\tif (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.ControllerName] = controllerName;\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.ActionName] = actionName;\n\t\t\t}\n\n\t\t\tvar httpContext = filterContext.HttpContext;\n#if NETFRAMEWORK\n\t\t\tstring counterInstanceName = FormatInstanceName(controllerName, actionName, httpContext.Request.HttpMethod);\n#else\n\t\t\tvar counterInstanceName = FormatInstanceName(controllerName, actionName, httpContext.Request.Method);\n#endif\n\t\t\tAttemptEventSource.Emit(counterInstanceName);\n\n#if NETFRAMEWORK\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext?.ApplicationInstance?.Context);\n#else\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n#endif\n\n\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\thttpContext.Items[PropName_StopWatch] = sw;\n\t\t\thttpContext.Items[PropName_CounterInstance] = counterInstanceName;\n\n\t\t\tif (ApplicationSettings.EnableFeatureFlags && ApplicationSettings.TestFeatureFlagEvaluation)\n\t\t\t{\n\t\t\t\tint intSetting = AtlasFeatureFlags.DummyIntSetting;\n\t\t\t\tstring stringSetting = AtlasFeatureFlags.DummyStringSetting;\n\t\t\t\tServiceContext.Log(\n\t\t\t\t\tDataPoint.ApiRequestLogging,\n\t\t\t\t\t$\"intSetting: {intSetting} | stringSetting: {stringSetting}\");\n\t\t\t}\n\t\t}\n\n\t\tpublic override void OnActionExecuted(ActionExecutedContext filterContext)\n\t\t{\n\t\t\tSetCommonDataPoints();\n\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(filterContext.HttpContext);\n\t\t\tFinalizeLogging(sw, instanceName, false);\n\t\t}\n\n\t\tpublic virtual void OnException(ExceptionContext filterContext)\n\t\t{\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(filterContext.HttpContext);\n\t\t\tbool isServerError = IsServerError(filterContext.Exception);\n\t\t\tif (filterContext.Exception != null)\n\t\t\t{\n\t\t\t\tfilterContext.Exception.Trace().Report();\n\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, filterContext.Exception.Message);\n\t\t\t}\n\n\t\t\tFinalizeLogging(sw, instanceName, isServerError);\n\t\t}\n\n#if NETFRAMEWORK\n\t\tprivate (Stopwatch sw, string instanceName) GetStopWatchAndInstanceName(HttpContextBase context)\n\t\t{\n\t\t\tStopwatch sw = context.Items[PropName_StopWatch] as Stopwatch;\n\t\t\tif (null == sw)\n\t\t\t{\n\t\t\t\tsw = Stopwatch.StartNew();\n\t\t\t}\n\n\t\t\tstring instanceName = context.Items[PropName_CounterInstance] as string;\n\t\t\tif (null == instanceName)\n\t\t\t{\n\t\t\t\tinstanceName = FormatInstanceName(context);\n\t\t\t}\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n#else\n\t\tprivate (Stopwatch sw, string instanceName) GetStopWatchAndInstanceName(HttpContext context)\n\t\t{\n\t\t\tvar sw = context.Items[PropName_StopWatch] as Stopwatch ?? Stopwatch.StartNew();\n\n\t\t\tvar instanceName = context.Items[PropName_CounterInstance] as string ?? FormatInstanceName(context);\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n#endif\n\n#if NETFRAMEWORK\n\t\tprotected virtual string FormatInstanceName(HttpContextBase httpContext)\n\t\t{\n\t\t\tstring controllerName = NO_CONTROLLER_STRING;\n\t\t\tstring actionName = NO_ACTION_NAME;\n\t\t\tstring httpMethod = NO_HTTP_VERB;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tRouteData rd = httpContext.Request.RequestContext.RouteData;\n\t\t\t\tactionName = rd.GetRequiredString(\"action\");\n\t\t\t\tcontrollerName = rd.GetRequiredString(\"controller\");\n\t\t\t\thttpMethod = httpContext.Request.HttpMethod;\n\t\t\t}\n\t\t\tcatch(Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t\treturn FormatInstanceName(controllerName, actionName, httpMethod);\n\t\t}\n#else\n\t\tprotected virtual string FormatInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tobject? actionNameObj = null;\n\t\t\tobject? controllerNameObj = null;\n\t\t\tvar httpMethod = NO_HTTP_VERB;\n\t\t\ttry\n\t\t\t{\n\t\t\t\thttpContext.Request.RouteValues.TryGetValue(\"action\", out actionNameObj);\n\t\t\t\thttpContext.Request.RouteValues.TryGetValue(\"controller\", out controllerNameObj);\n\t\t\t\thttpMethod = httpContext.Request.Method;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\n\t\t\tvar controllerName = controllerNameObj as string ?? NO_CONTROLLER_STRING;\n\t\t\tvar actionName = actionNameObj as string ?? NO_ACTION_NAME;\n\t\t\treturn FormatInstanceName(controllerName, actionName, httpMethod);\n\t\t}\n#endif\n\n\t\tprotected virtual string FormatInstanceName(string controllerName, string actionName, string httpMethod)\n\t\t{\n\t\t\treturn $\"{controllerName}.{actionName}.{httpMethod}\";\n\t\t}\n\n\t\tprivate void FinalizeLogging(Stopwatch sw, string instanceName, bool isError)\n\t\t{\n\t\t\tTimeSpan apiRunTime = TimeSpan.MinValue;\n\t\t\tif (sw != null)\n\t\t\t{\n\t\t\t\tapiRunTime = sw.Elapsed;\n\t\t\t}\n\n\t\t\tApiEventSource.Emit(apiRunTime, !isError, instanceName);\n\t\t}\n\n\t\tprotected virtual bool IsServerError(Exception exception)\n\t\t{\n\t\t\tbool isError = !(exception is AdexsDisplayException);\n\n\t\t\treturn isError;\n\t\t}\n\n\n\t\tpublic static void SetCommonDataPoints()\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId != int.MinValue)\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, AtlasContext.Current.AccountId);\n\t\t\tif (AtlasContext.Current.UserAccountUid != Guid.Empty)\n\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\tif (AtlasContext.Current.UserAccount != null)\n\t\t\t\tServiceContext.Log(DataPoint.AccountType, Enum.GetName(typeof(Enums.AccountType), AtlasContext.Current.UserAccount.Account.AccountType));\n\t\t}\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (2 occurrences); Contains method call: SetTag (2 times)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/HttpRequestAuditHelper.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Extensions;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nnamespace ADEXS.Web.CommonUI.Helpers\n{\n\tpublic abstract class HttpRequestAuditHelper\n\t{\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Duration\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Duration\", \"CLM.API\",\n\t\t///\tInstanceProperty = \"Description\",\n\t\t///\tDisplayUnit = CounterUnit.milliseconds,\n\t\t///\tRanges = new double[10] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t///\tMeasureProperty = \"Duration\",\n\t\t///\tSuccessProperty = \"Success\")]\n\t\t/// static readonly TimingEventSource apiEventSource = new TimingEventSource();\n\t\t/// </summary>\n\t\tprotected abstract TimingEventSource ApiEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Attempts\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Attempts\", \"CLM.API\", InstanceProperty = \"Description\")]\n\t\t/// static readonly SimpleEventSource attemptEventSource = new SimpleEventSource();\n\t\t/// </summary>\n\t\tprotected abstract SimpleEventSource AttemptEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the timing Stopwatch instance will be stored.\n\t\t/// Example: \"ClmApi.Stopwatch\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_StopWatch { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the the name of the counter instance will be stored.\n\t\t/// Example: \"ClmApi.InstanceName\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_CounterInstance { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which any error will be stored.\n\t\t/// Example: \"ClmApi.Error\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_Error { get; }\n\n\t\t/// <summary>\n\t\t/// Implementations are intended to be used as singletons.\n\t\t/// </summary>\n\t\tprotected HttpRequestAuditHelper()\n\t\t{\n\t\t}\n\n\t\tpublic static void SetCommonDataPoints()\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId != int.MinValue)\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, AtlasContext.Current.AccountId);\n\t\t\tif (AtlasContext.Current.UserAccountUid != Guid.Empty)\n\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\tif (AtlasContext.Current.UserAccount != null)\n\t\t\t\tServiceContext.Log(DataPoint.AccountType, Enum.GetName(typeof(Enums.AccountType), AtlasContext.Current.UserAccount.Account.AccountType));\n\t\t}\n\n\t\tpublic virtual void BeginRequest(HttpContext httpContext)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n\n\t\t\tif (httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring counterInstanceName = FormatInstanceName(httpContext);\n\t\t\tAttemptEventSource.Emit(counterInstanceName);\n\n\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\thttpContext.Items[PropName_StopWatch] = sw;\n\t\t\thttpContext.Items[PropName_CounterInstance] = counterInstanceName;\n\t\t}\n\n\t\tpublic virtual void EndRequest(HttpContext httpContext)\n\t\t{\n\t\t\tif(httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSetCommonDataPoints();\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(httpContext);\n\n\t\t\tbool isError = false;\n\t\t\tException exError = httpContext.Items[PropName_Error] as Exception;\n\t\t\tif (null != exError && !(exError is AdexsDisplayException))\n\t\t\t{\n\t\t\t\tisError = true;\n\t\t\t}\n\n\t\t\tFinalizeLogging(sw, instanceName, isError);\n\t\t}\n\n\t\tpublic virtual void SetError(HttpContext httpContext, Exception ex)\n\t\t{\n\t\t\tif(httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(null != ex)\n\t\t\t{\n\t\t\t\tex.Trace().Report();\n\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, ex.Message);\n\t\t\t\thttpContext.Items[PropName_Error] = ex;\n\t\t\t}\n\t\t}\n\n\t\tprivate (Stopwatch, string) GetStopWatchAndInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tStopwatch sw = httpContext.Items[PropName_StopWatch] as Stopwatch;\n\t\t\tif (null == sw)\n\t\t\t{\n\t\t\t\tsw = Stopwatch.StartNew();\n\t\t\t}\n\n\t\t\tstring instanceName = httpContext.Items[PropName_CounterInstance] as string;\n\t\t\tif (null == instanceName)\n\t\t\t{\n\t\t\t\tinstanceName = FormatInstanceName(httpContext);\n\t\t\t}\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n\n\t\tprotected virtual string FormatInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tvar pageName = \"_no-page_\";\n\t\t\tvar httpMethod = \"_no-verb_\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\thttpMethod = httpContext.Request.HttpMethod;\n\t\t\t\tpageName = httpContext.Request.Url.Segments.Last();\n\t\t\t}\n\t\t\tcatch(Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t\t\n\t\t\treturn FormatInstanceName(pageName, httpMethod);\n\t\t}\n\n\t\tprotected virtual string FormatInstanceName(string pageName, string httpMethod)\n\t\t{\n\t\t\treturn $\"{pageName}.{httpMethod}\";\n\t\t}\n\n\t\tprivate void FinalizeLogging(Stopwatch sw, string instanceName, bool isError)\n\t\t{\n\t\t\tTimeSpan apiRunTime = TimeSpan.MinValue;\n\t\t\tif (sw != null)\n\t\t\t{\n\t\t\t\tapiRunTime = sw.Elapsed;\n\t\t\t}\n\n\t\t\tApiEventSource.Emit(apiRunTime, !isError, instanceName);\n\t\t}\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
      "content": "\ufeff// BUGBUG: ATL-71924 Move code dependent on System.Web out of Core.Domain\n#if NETFRAMEWORK\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.ServiceFramework.Helpers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.FeatureFlags;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing log4net;\nusing log4net.Config;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing ApplicationInfo = ADEXS.Core.Domain.Utilities.ApplicationInfo;\n\nnamespace ADEXS.Web.Common;\n\n/// <summary>\n/// Base class for all SCM web applications.\n/// </summary>\npublic abstract class ScmHttpApplication : HttpApplication\n{\n\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\t/// <summary>\n\t/// Don't use the standard Application_Start(). .Net picks one via reflection\n\t/// and runs it. Ends up being this one here, not the one in the derived class.\n\t/// </summary>\n\tprotected void ApplicationStart()\n\t{\n\t\t// log4net initialization\n\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n\t\tXmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\tConfigurationHelper.InitializeConfiguration();\n\n\t\tif (ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\n\t\t// Use MSF specific env variable, fallback to app settings.\n\t\tvar appName = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? AppConfig.AppName(ApplicationInfo.Name);\n\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? SiteConfig.Environment(\"Unknown\");\n\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\n\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\tapplicationName: appName,\n\t\t\tappVersion: typeof(ScmHttpApplication).Assembly.GetName().Version.ToString(),\n\t\t\tenvironmentName: environment,\n\t\t\tsiteName: site,\n\t\t\tpartitionName: partition,\n\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\tshouldEnableLogFileListener: () => Configuration.GetBooleanAppSetting(\"KazmonEnableLogFileListener\", false));\n\n\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t{\n\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\tassembly: typeof(ScmHttpApplication).Assembly,\n\t\t\t\t\tconfigureTracer: tracerProviderBuilder =>\n\t\t\t\t\t{\n\t\t\t\t\t\t_ = tracerProviderBuilder\n\t\t\t\t\t\t\n\t\t\t\t\t\t.AddAspNetInstrumentation(options =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t})\n\t\t\t\t\t.AddSource(typeof(RedisSessionStateProviderWrapper).FullName);\n\t\t\t\t\t},\n\t\t\t\t\tconfigureMeter: o => o.AddAspNetInstrumentation(options => options.Enrich = (HttpContext context, ref TagList tags) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!tags.Any(t => t.Key == \"http.route\") &&\n\t\t\t\t\t\t\tcontext.Request != null &&\n\t\t\t\t\t\t\t(context.Request.Url.AbsolutePath.EndsWith(\"aspx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"asmx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"ashx\", StringComparison.OrdinalIgnoreCase)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttags.Add(\"url.path\", context.Request.Url.AbsolutePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}))).GetAwaiter().GetResult();\n\t\t\t}\n\t\t}\n\n\t\tif (!ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This one stays the standard Application_End(), as no derive class overrides it.\n\t/// </summary>\n\tprotected virtual void Application_End()\n\t{\n\t\ttry\n\t\t{\n\t\t\tLogManager.Shutdown();\n\t\t}\n\t\tcatch { }\n\n\t\tUninitializeFeatureFlags();\n\n\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t{\n\t\t\t// Run synchronously\n\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t}\n\n\t\tKazmonMonitoring.ShutdownKazmon();\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to initialize feature flags.\n\t/// </summary>\n\tprotected virtual void InitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t}\n\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application shutdown to uninitialize feature flags.\n\t/// </summary>\n\tprotected virtual void UninitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to bootstrap the dependency injection container.\n\t/// </summary>\n\tprotected virtual void Bootstrap()\n\t{\n\t}\n}\n\n#endif\n",
      "search_score": 100,
      "search_reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: OpenTelemetry.Metrics",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: DocuSign.CLM.Monitoring",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
        "Import: OpenTelemetry.Metrics",
        "Import: OpenTelemetry.Trace",
        "Pattern: OpenTelemetry",
        "Pattern: Instrumentation",
        "Pattern: Monitoring",
        "Pattern: Metrics",
        "Pattern: UseOpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/internal/AtlasCustomerSupport/Global.asax.cs",
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.ServiceFramework.Helpers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FeatureFlags;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow;\nusing ADEXS.ElasticCore;\nusing ADEXS.FeatureFlags;\nusing ADEXS.MQ;\nusing DocuSign.CLM.Monitoring;\nusing log4net.Config;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing Constants = ADEXS.Core.Types.Constants;\n\nnamespace AtlasCustomerSupport\n{\n\t/// <summary>\n\t/// Summary description for Global.\n\t/// </summary>\n\tpublic class Global : System.Web.HttpApplication\n\t{\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(Global));\n\n\t\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\n\t\t/// <summary>\n\t\t/// Required designer variable.\n\t\t/// </summary>\n\t\tprivate System.ComponentModel.IContainer components = null;\n\n\t\tpublic Global()\n\t\t{\n\t\t\tInitializeComponent();\n\t\t}\n\n\t\tprotected void Application_Start(Object sender, EventArgs e)\n\t\t{\n\t\t\t// Initialize log4net.  This should eventually be replaced by\n\t\t\t// code in AssemblyInfo.cs once the new log4net version is out.\n\t\t\t// (Added for log4net 1.2.0 Beta 8).\n\t\t\t// TODO: we are using log4net 2.0.8, so this is not needed, we should migrate this code to use AssemblyInfo.cs.\n\t\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n\t\t\tXmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\t\tConfigurationHelper.InitializeConfiguration();\n\n\t\t\tBootstrapper.Bootstrap(() => new List<IServiceRegistry> {\n\t\t\t\tnew MessageQueueRegistry(),\n\t\t\t\tnew WebCoreDomainRegistry(),\n\t\t\t\tnew CoreWorkflowRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew ElasticCoreRegistry(),\n\t\t\t\tnew FeatureFlagRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew AppFeatureFlagsRegistry<PSOToolFeatureFlagsConfiguration>(),\n\t\t\t\tnew OneConfigServiceRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew ServiceConfigServiceRegistry(WebCoreDomainRegistry.OneConfigPath, \"PsoToolConfig.ini\"),\n\t\t\t\tnew AtlasCustomerSupportRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew CoreServiceFrameworkRegistry(),\n\t\t\t});\n\n\t\t\t// Use MSF specific env variable, fallback to app settings.\n\t\t\tvar appName = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? AppConfig.AppName(\"PSOTool\");\n\t\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\t\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? SiteConfig.Environment(\"Unknown\");\n\t\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\n\t\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\t\tapplicationName: appName,\n\t\t\t\tappVersion: typeof(Global).Assembly.GetName().Version.ToString(),\n\t\t\t\tenvironmentName: environment,\n\t\t\t\tsiteName: site,\n\t\t\t\tpartitionName: partition,\n\t\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\t\tshouldEnableLogFileListener: () => Configuration.GetBooleanAppSetting(\"KazmonEnableLogFileListener\", false));\n\n\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t\t{\n\t\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t\t{\n\t\t\t\t\t// Run synchronously\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: typeof(Global).Assembly,\n\t\t\t\t\t\tconfigureTracer: o => o.AddAspNetInstrumentation(),\n\t\t\t\t\t\tconfigureMeter: o => o.AddAspNetInstrumentation(options => options.Enrich = (HttpContext context, ref TagList tags) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!tags.Any(t => t.Key == \"http.route\") &&\n\t\t\t\t\t\t\t\tcontext.Request != null &&\n\t\t\t\t\t\t\t\t(context.Request.Url.AbsolutePath.EndsWith(\"aspx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"asmx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"ashx\", StringComparison.OrdinalIgnoreCase)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttags.Add(\"url.path\", context.Request.Url.AbsolutePath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}))).GetAwaiter().GetResult();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t\t}\n\t\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t\t}\n\t\t}\n\n\t\tprotected void Session_Start(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_BeginRequest(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_EndRequest(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_AuthenticateRequest(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_Error(Object sender, EventArgs e)\n\t\t{\n\t\t\tException exception = Server.GetLastError();\n\t\t\tif (exception == null)\n\t\t\t{\n\t\t\t\tException[] allError = HttpContext.Current?.AllErrors;\n\t\t\t\tif (allError != null && allError.Length > 0)\n\t\t\t\t\texception = allError[allError.Length - 1];\n\t\t\t}\n\t\t\tvar guid = Activity.Current?.Id ?? Guid.NewGuid().ToString();\n\t\t\tvar message = $\"An unhandled exception occured. ReferenceId: {guid}\";\n\t\t\t_log.ErrorNoPII(message, exception);\n\t\t\tResponse.Redirect($\"Error.aspx?{Constants.QueryStringParameters.MessageRef}={guid}\");\n\n\t\t\texception?.Trace().Report();\n\t\t}\n\n\t\tprotected void Session_End(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_End(Object sender, EventArgs e)\n\t\t{\n\t\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t\t}\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t\t}\n\n\t\t\tKazmonMonitoring.ShutdownKazmon();\n\t\t}\n\n\t\t#region Web Form Designer generated code\n\t\t/// <summary>\n\t\t/// Required method for Designer support - do not modify\n\t\t/// the contents of this method with the code editor.\n\t\t/// </summary>\n\t\tprivate void InitializeComponent()\n\t\t{\n\t\t\tthis.components = new System.ComponentModel.Container();\n\t\t}\n\t\t#endregion\n\t}\n}\n\n",
      "search_score": 100,
      "search_reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: DocuSign.CLM.Monitoring",
        "Import: OpenTelemetry.Metrics",
        "Import: OpenTelemetry.Trace",
        "Pattern: Activity.Current",
        "Pattern: OpenTelemetry",
        "Pattern: Instrumentation",
        "Pattern: Monitoring",
        "Pattern: Metrics",
        "Pattern: UseOpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
      "content": "\ufeff#if NET\n#nullable enable\n\nusing ADEXS.Caching.OpenTelemetry.Extensions;\nusing ADEXS.Core.ServiceFramework.Extensions;\nusing ADEXS.Core.Util.Cache;\nusing ADEXS.CqlCorePersistence.AspNet.Logging;\nusing ADEXS.CqlCorePersistence.OpenTelemetry;\nusing ADEXS.CqlCorePersistence;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.MQ.MqConfiguration;\nusing ADEXS.ServiceFramework.Options;\n\nusing DocuSign.Msf.AspNet.HeaderPropagation.Extensions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\nusing DocuSign.Msf.AspNet.OpenTelemetry;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Options;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nusing OpenTelemetry.Exporter;\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing RabbitMQ.Client;\n\nusing ConfigurationProvider = ADEXS.Core.Util.Cache.ConfigurationProvider;\nusing ADEXS.AtlasDataManipulationService.Extensions;\n\nnamespace ADEXS.AtlasDataManipulationService;\n\npublic class Startup\n{\n\tprivate const string ServiceName = \"clm-data-manipulation\";\n\n\tprivate readonly IConfiguration _configuration;\n\n\tprivate readonly IWebHostEnvironment _webHostEnvironment;\n\n\tpublic Startup(IConfiguration configuration, IWebHostEnvironment webHostEnvironment)\n\t{\n\t\t_configuration = configuration;\n\t\t_webHostEnvironment = webHostEnvironment;\n\t}\n\n\t// This method gets called by the runtime. Use this method to add services to the container.\n\t// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940\n\tpublic void ConfigureServices(IServiceCollection services)\n\t{\n\t\t// We need to update config sooner than Hosting startup.\n\t\tConfigurationProvider.UseConfiguration(_configuration);\n\t\tApplicationSettingsCache.Flush();\n\n\t\tservices\n\t\t\t.Configure<ServicedComponentHostedServiceOptions>(\n\t\t\t\t_configuration.GetSection(ServicedComponentHostedServiceOptions.Section))\n\t\t\t.Configure<VersionEndpointOptions>(_configuration.GetSection(VersionEndpointOptions.Section))\n\t\t\t.Configure<ForwardedHeadersOptions>(_configuration.GetSection(\"ForwardedHeaders\"))\n\t\t\t.Configure<ForwardedHeadersOptions>(options =>\n\t\t\t{\n\t\t\t\toptions.KnownProxies.Clear();\n\t\t\t\toptions.KnownNetworks.Clear();\n\t\t\t}); ;\n\n\t\tvar telemetryConsoleTargets = _configuration\n\t\t\t.GetSection(\"Telemetry:Console:Targets\")\n\t\t\t?.Get<ConsoleExporterOutputTargets>();\n\n\t\tservices\n\t\t\t.AddHttpContextAccessor()\n\t\t\t.AddServiceHealthChecks(_configuration)\n\t\t\t.AddAtlasDataManipulationHealthChecks(_configuration);\n\n\t\tservices.AddHeaderPropagation(options => options.ConfigureMicroservices())\n\t\t\t.AddComponentsInstrumentation()\n\t\t\t.AddServiceTelemetry(\n\t\t\t\tServiceName,\n\t\t\t\tconfigureTracer: options =>\n\t\t\t\t{\n\t\t\t\t\toptions\n\t\t\t\t\t\t.AddHttpClientInstrumentation()\n\t\t\t\t\t\t.AddSqlClientInstrumentation()\n\t\t\t\t\t\t.AddRedisInstrumentation()\n\t\t\t\t\t\t.ConfigureRedisCacheInstrumentation()\n\t\t\t\t\t\t.AddScmCassandraPersistenceInstrumentation();\n\n\t\t\t\t\tif (telemetryConsoleTargets != null)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions.AddConsoleExporter(o => o.Targets = telemetryConsoleTargets.Value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tconfigureMeter: options =>\n\t\t\t\t{\n\t\t\t\t\toptions\n\t\t\t\t\t\t.AddHttpClientInstrumentation()\n\t\t\t\t\t\t.AddServiceMetrics()\n\t\t\t\t\t\t.AddProcessInstrumentation()\n\t\t\t\t\t\t.AddCassandraInstrumentation()\n\t\t\t\t\t\t.AddScmCassandraPersistenceInstrumentation()\n\t\t\t\t\t\t.AddRedisCacheMetrics();\n\n\t\t\t\t\tif (telemetryConsoleTargets != null)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions.AddConsoleExporter(o => o.Targets = telemetryConsoleTargets.Value);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.AddVersionEndpoint()\n\t\t\t.AddSingleton<IConnectionFactory>(sp =>\n\t\t\t{\n\t\t\t\tvar configuration = sp.GetRequiredService<RabbitMessageQueueWrapperConnectionConfig>();\n\n\t\t\t\treturn new ConnectionFactory\n\t\t\t\t{\n\t\t\t\t\tUri = RabbitMessageQueueWrapperConnectionConfig.BuildUri(),\n\t\t\t\t\tClientProvidedName = configuration.GetClientDefinedConnectionName(),\n\t\t\t\t\tAutomaticRecoveryEnabled = true\n\t\t\t\t};\n\t\t\t});\n\n\t\tservices.AddSingleton<ICassandraSettings, ScmCassandraSettings>();\n\t\tservices.AddSingleton<IAtlasCassandraCluster, AtlasCassandraCluster>();\n\t}\n\tpublic void Configure(IApplicationBuilder app)\n\t{\n\t\tif (_configuration.GetValue<bool>(\"CassandraWireLogging\"))\n\t\t{\n\t\t\tapp.WireCassandraLogging();\n\t\t}\n\n\t\tif (_webHostEnvironment.IsDevelopment())\n\t\t{\n\t\t\tapp.UseDeveloperExceptionPage();\n\t\t}\n\n\t\tapp.UseHeaderPropagation();\n\n\t\tapp.UseRouting();\n\n\t\tapp.UseEndpoints(endpoints =>\n\t\t{\n\t\t\tendpoints.MapServiceHealthChecks();\n\n\t\t\tendpoints.MapVersionEndpoint($\"{ServiceName}/v1/version\");\n\n\t\t\tendpoints.MapGet(\"/\", () => $\"No WebAPI defined for {ServiceName}\");\n\t\t});\n\t}\n}\n\n#nullable restore\n#endif\n",
      "search_score": 100,
      "search_reasoning": "Telemetry infrastructure: Import: ADEXS.Caching.OpenTelemetry.Extensions, Import: ADEXS.CqlCorePersistence.OpenTelemetry, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: ADEXS.Caching.OpenTelemetry.Extensions",
        "Import: ADEXS.CqlCorePersistence.OpenTelemetry",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry",
        "Import: OpenTelemetry.Exporter",
        "Import: OpenTelemetry.Metrics",
        "Import: OpenTelemetry.Trace",
        "Pattern: OpenTelemetry",
        "Pattern: Instrumentation",
        "Pattern: Metrics",
        "Pattern: ConfigureServices",
        "Config file: startup.cs"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Controllers/WorkflowActivitiesController.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Core.Workflow;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Exceptions;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Utility;\nusing DocuSign.CLM.API.WorkflowActivities.Models;\nusing DocuSign.Monitoring;\n\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\nusing ActivityContext = DocuSign.CLM.API.WorkflowActivities.Models.ActivityContext;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace DocuSign.CLM.API.WorkflowActivities.Controllers;\n\n[ApiController]\n[Authorize]\n[Route($\"{Constants.OnPremApiRoutePrefix}/[controller]\")] // OnPrem routing\n[Route($\"{WorkflowActivitiesConstants.ServiceUrlPrefix}[controller]\")] // Cloud routing\npublic partial class WorkflowActivitiesController : Controller\n{\n\tprivate readonly ILogger _logger;\n\tprivate readonly IWorkflowDesignToWorkflowMapMapper _workflowDesignToWorkflowMapMapper;\n\n\tpublic WorkflowActivitiesController(\n\t\tIServiceInstrumentation serviceInstrumentation,\n\t\tIWorkflowDesignToWorkflowMapMapper workflowDesignToWorkflowMapMapper,\n\t\tILoggerFactory loggerFactory)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t_workflowDesignToWorkflowMapMapper = workflowDesignToWorkflowMapMapper;\n\t\t_logger = loggerFactory.CreateLogger(GetType());\n\t}\n\n\t[HttpPost(\"execute\")]\n\t[ProducesResponseType(typeof(ActivityOutput), (int)HttpStatusCode.OK)]\n\tpublic async Task<IActionResult> ExecuteActivityAsync([FromBody] ActivityContext activityContext)\n\t{\n\t\tValidationUtils.ValidateActivityExecuteContext(activityContext, _logger, out var accountId, out var userAccountUid);\n\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityContext.ActivityJsonDefinition);\n\t\t\t\tvar output = winsActivity.Execute(activityContext.WorkflowActivityContext);\n\n\t\t\t\tvar activityOutput = new ActivityOutput\n\t\t\t\t{\n\t\t\t\t\tWorkflowActivityContext = activityContext.WorkflowActivityContext\n\t\t\t\t};\n\t\t\t\tactivityOutput.InstanceActivityOutput.AddRange(output);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Ok(activityOutput));\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to execute the activity due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t[HttpPut(\"callback\")]\n\t[ProducesResponseType(typeof(ActivityOutput), (int)HttpStatusCode.OK)]\n\tpublic async Task<IActionResult> ExecuteCallbackAsync([FromBody] ActivityCallbackContext activityCallbackContext)\n\t{\n\t\tValidationUtils.ValidateActivityCallbackContext(activityCallbackContext, _logger, out var accountId, out var userAccountUid);\n\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityCallbackContext.ActivityJsonDefinition);\n\t\t\t\tvar output = winsActivity.ExecuteCallback(activityCallbackContext.WorkflowActivityContext, activityCallbackContext.Name, activityCallbackContext.Payload);\n\n\t\t\t\tvar activityOutput = new ActivityOutput\n\t\t\t\t{\n\t\t\t\t\tWorkflowActivityContext = activityCallbackContext.WorkflowActivityContext\n\t\t\t\t};\n\t\t\t\tactivityOutput.InstanceActivityOutput.AddRange(output);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Ok(activityOutput));\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to execute the activity callback due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\t[HttpPut(\"humanCallback\")]\n\t[ProducesResponseType(typeof(HumanActivityOutput), (int)HttpStatusCode.OK)]\n\tpublic async Task<IActionResult> ExecuteHumanCallbackAsync(\n\t\t[FromBody] ActivityCallbackContext activityCallbackContext)\n\t{\n\t\tValidationUtils.ValidateActivityCallbackContext(activityCallbackContext, _logger, out var accountId,\n\t\t\tout var userAccountUid);\n\t\tValidationUtils.ValidateJson(activityCallbackContext.Payload, _logger);\n\t\tHumanAssignmentPayload humanAssignmentPayload;\n\t\ttry\n\t\t{\n\t\t\thumanAssignmentPayload =\n\t\t\t\tJsonSerializer.Deserialize<HumanAssignmentPayload>(activityCallbackContext.Payload);\n\t\t\tValidationUtils.ValidateHumanAssignmentPayload(humanAssignmentPayload);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tvar msg =\n\t\t\t\t$\"Failed to execute the human activity callback due to JSON deserialization error: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t_logger.LogError(ex, msg);\n\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\tthrow new WorkflowActivitiesApiException(HttpStatusCode.BadRequest, msg);\n\t\t}\n\n\t\tusing (_logger.BeginScope(\"AccountId: {AccountId}, UserAccountUid: {UserAccountUid}\", accountId, userAccountUid))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity =\n\t\t\t\t\t_workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId,\n\t\t\t\t\t\tactivityCallbackContext.ActivityJsonDefinition);\n\t\t\t\tvar assignmentCompleteEvent = new AssignmentCompleteEvent()\n\t\t\t\t{\n\t\t\t\t\tAccountId = accountId,\n\t\t\t\t\tAssignmentId = humanAssignmentPayload.AssignmentUid,\n\t\t\t\t\tStatus = humanAssignmentPayload.AssignmentStatus\n\t\t\t\t};\n\t\t\t\tvar output = winsActivity.ExecuteHumanCallbackViaApi(\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext,\n\t\t\t\t\tassignmentCompleteEvent,\n\t\t\t\t\tout var completeWorkItemResponse);\n\n\t\t\t\tvar activityOutput = new HumanActivityOutput\n\t\t\t\t{\n\t\t\t\t\tWorkflowActivityContext = activityCallbackContext.WorkflowActivityContext,\n\t\t\t\t\tWaitForNextStep = completeWorkItemResponse.WaitForNextStep,\n\t\t\t\t};\n\t\t\t\tactivityOutput.InstanceActivityOutput.AddRange(output);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Ok(activityOutput));\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg =\n\t\t\t\t\t$\"Failed to execute the human activity callback due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\t[HttpPatch(\"complete\")]\n\t[ProducesResponseType(typeof(ActivityCompleteResponse), (int)HttpStatusCode.OK)]\n\tpublic async Task<IActionResult> CheckActivityForCompletionAsync([FromBody] ActivityContext activityContext)\n\t{\n\t\tValidationUtils.ValidateActivityExecuteContext(activityContext, _logger, out var accountId, out var userAccountUid);\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityContext.ActivityJsonDefinition);\n\t\t\t\tvar output = activityContext.WorkflowActivityContext.InstanceActivity.Output;\n\t\t\t\tvar activityCompleteResponse = new ActivityCompleteResponse { ActivityOutput = null };\n\t\t\t\tif (winsActivity.CanBeMarkedAsCompleted(activityContext.WorkflowActivityContext, ref output))\n\t\t\t\t{\n\t\t\t\t\tactivityContext.WorkflowActivityContext.InstanceActivity.Output = output;\n\t\t\t\t\tvar instanceActivityOutputs = winsActivity.OnActivityCompleted(activityContext.WorkflowActivityContext);\n\t\t\t\t\tvar activityOutput = new ActivityOutput\n\t\t\t\t\t{\n\t\t\t\t\t\tWorkflowActivityContext = activityContext.WorkflowActivityContext\n\t\t\t\t\t};\n\t\t\t\t\tactivityOutput.InstanceActivityOutput.AddRange(instanceActivityOutputs);\n\n\t\t\t\t\tactivityCompleteResponse.ActivityOutput = activityOutput;\n\t\t\t\t}\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Ok(activityCompleteResponse));\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to check the activity for completion due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\t[HttpPatch(\"finish\")]\n\t[ProducesResponseType((int)HttpStatusCode.Accepted)]\n\tpublic async Task<IActionResult> FinishActivityAsync([FromBody] ActivityContext activityContext)\n\t{\n\t\tValidationUtils.ValidateActivityExecuteContext(activityContext, _logger, out var accountId, out var userAccountUid);\n\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityContext.ActivityJsonDefinition);\n\t\t\t\twinsActivity.ActivityFinished(activityContext.WorkflowActivityContext);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Accepted());\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to finish activity due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\t[HttpDelete(\"abort\")]\n\t[ProducesResponseType((int)HttpStatusCode.NoContent)]\n\tpublic async Task<IActionResult> AbortActivityAsync([FromBody] ActivityContext activityContext)\n\t{\n\t\tValidationUtils.ValidateActivityExecuteContext(activityContext, _logger, out var accountId, out var userAccountUid);\n\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityContext.ActivityJsonDefinition);\n\t\t\t\twinsActivity.OnActivityAborted(activityContext.WorkflowActivityContext);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(NoContent());\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to abort activity due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "search_score": 95,
      "search_reasoning": "Telemetry infrastructure: Import: DocuSign.Monitoring, Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid), Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: DocuSign.Monitoring",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope(\"AccountId: {AccountId}, UserAccountUid: {UserAccountUid}\", accountId, userAccountUid))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Pattern: Instrumentation",
        "Pattern: Monitoring",
        "Pattern: StartActivity"
      ],
      "is_main_file": true
    }
  ],
  "Batch 1 (LogAsyncRequestHttpMiddleware.cs): \u2022 The requirement is to add two extra attributes (HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION) to the existing HTTP-request span generated for every web request.  \n\u2022 LogAsyncRequestHttpMiddleware.cs is a middleware whose purpose is to \u201clog requests to KazMon\u201d and already interacts with telemetry abstractions (PropertyBagEventSource, DocuSign.Monitoring, etc.).  \n\u2022 Because it sits in the ASP.NET Core pipeline, the middleware has direct access to both HttpContext.Request.Headers and HttpContext.Response.Headers, making it the ideal place to extract the Referer and Location values.  \n\u2022 The middleware is the location where the Activity/Span is either created or enriched; therefore the two new tags can be set on Activity.Current (or the span object used in this code) without touching any other files.  \n\u2022 No other files are needed to satisfy this requirement, as the capture and tagging can be done entirely inside LogAsyncRequestHttpMiddleware.cs.\nBatch 2 (BaseApiHandler.cs): \u2022 The telemetry requirement targets HTTP-level data (request header \u201cReferer\u201d and response header \u201cLocation\u201d) that is available at runtime inside ASP.NET handlers.  \n\u2022 BaseApiHandler.cs is an IHttpHandler that executes for every legacy \u201c.ashx\u201d web request. It receives the active HttpContext, giving direct access to:\n  \u2013 HttpContext.Request.Headers[\"Referer\"]  \n  \u2013 HttpContext.Response.Headers[\"Location\"]  \n\u2022 The file already references System.Diagnostics and DocuSign.Monitoring, indicating that Activity/Span instrumentation is in place or easily extendable (e.g., Activity.Current?.SetTag).  \n\u2022 Because each request flows through this handler before control passes to the migrated .NET 6 controllers, adding two Activity tags here will attach them to the existing HTTP request span for the CLM web application.  \n\u2022 No other files are necessary; adding SetTag (or equivalent) calls in BaseApiHandler\u2019s processing method (ProcessRequest / ExecuteAsync, etc.) will fulfill the requirement.\n\nTherefore, modifying BaseApiHandler.cs alone can close the telemetry gap.\nBatch 3 (ProfileModule.cs): \u2022 ProfileModule.cs is an IHttpModule that hooks into the ASP-NET request pipeline (BeginRequest, EndRequest, etc.), giving it direct access to both HttpRequest and HttpResponse objects.  \n\u2022 It already references DocuSign.CLM.Monitoring and DocuSign.Monitoring, which indicates existing span / Activity instrumentation infrastructure that can be extended by calling SetTag / AddAttribute.  \n\u2022 Inside these event handlers we can read Request.Headers[\"Referer\"] and Response.Headers[\"Location\"] and attach them to the currently active HTTP request span, fulfilling the requirement.  \n\u2022 No other files are needed; all necessary context and telemetry hooks are available in this single module.\nBatch 4 (WinsService.cs): Cannot solve gap - \u2022 The telemetry requirement targets normal HTTP request spans and needs access to Request.Headers[\"Referer\"] and Response.Headers[\"Location\"].  \n\u2022 WinsService.cs is a gRPC service implementation (imports Grpc.Core and derives from a generated service base).  \n\u2022 gRPC requests are transported over HTTP/2 but do not expose classic HTTP\u2010level headers such as \u201cReferer\u201d or \u201cLocation\u201d through the ASP-NET request/response objects.  \n\u2022 The file shows only internal span creation (OpenTelemetry.ActivitySource / Tracer) and business logic; it never touches the ASP-NET HttpContext, Request, or Response where the required headers would reside.  \n\u2022 Therefore this file cannot capture or attach HTTP_REFERER or HTTP_RESPONSE_REDIRECT_LOCATION attributes to the web application\u2019s HTTP spans. A middleware or MVC controller layer that has direct access to HttpContext would be needed instead.\n\nHence this group cannot close the described telemetry gap.\nBatch 5 (WinsService.Trace.cs): Cannot solve gap - \u2022 The requirement targets HTTP-request spans and needs access to the incoming Request.Headers[\"Referer\"] and the outgoing Response.Headers[\"Location\"].  \n\u2022 WinsService.Trace.cs only offers a generic helper (StartActivity) for creating internal Activity objects. It has no visibility into the ASP.NET HTTP pipeline, no Request/Response objects, and no span representing an HTTP request.  \n\u2022 Because the file group contains only this trace helper, there is no place where HTTP headers can be read or tags attached to an HTTP span.  \n\u2022 Therefore, this group cannot directly implement the required telemetry attributes; additional files that handle the actual HTTP requests would be necessary.\nBatch 6 (LogAsyncRequestHttpMiddleware.cs): \u2022 The telemetry requirement involves enriching every HTTP request span with two additional attributes derived from the incoming Request and outgoing Response headers.  \n\u2022 LogAsyncRequestHttpMiddleware.cs is a pipeline middleware that is already responsible for request/response telemetry.  \n  \u2013 It references OpenTelemetry-related namespaces (DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, DocuSign.Monitoring, etc.).  \n  \u2013 Middleware has direct access to HttpContext.Request and HttpContext.Response and already starts/updates spans (or at least attaches PropertyBagEventSource tags), meaning the instrumentation surface is in place.  \n\u2022 Therefore, this file can easily be extended to read Request.Headers[\"Referer\"] and Response.Headers[\"Location\"] and add them as span attributes via Activity.Current?.SetTag(...).  \n\u2022 No additional files are required because the change is purely additive to the existing middleware\u2019s telemetry logic.\nBatch 7 (LogAsyncRequestHttpMiddleware.cs): \u2022 The requirement targets HTTP-request spans and needs two extra attributes derived from HttpContext.Request/Response headers.  \n\u2022 LogAsyncRequestHttpMiddleware sits in the ASP.NET Core pipeline, so it naturally sees every incoming request and outgoing response.  \n\u2022 The file already performs telemetry work (inherits from AbstractLogRequestHttpMiddleware, references PropertyBagEventSource, DocuSign.Monitoring, Activity/DiagnosticSource logic). Therefore it is the right place to extend the existing span with SetTag/AddAttribute calls.  \n\u2022 No other files are necessary; the middleware alone has full access to both request and response headers and to the active Activity/Span, making it a single-point change to fulfill the instrumentation gap.\nBatch 8 (ScmLogAsyncRequestHttpMiddleware.cs): \u2022 The requirement is to enrich every HTTP-request span with two extra attributes taken from the incoming request and outgoing response headers.  \n\u2022 ScmLogAsyncRequestHttpMiddleware sits in the ASP.NET Core middleware chain and already performs request-level telemetry by delegating to IServiceInstrumentation and/or Activity APIs (it derives from AbstractLogRequestHttpMiddleware, which handles span creation).  \n\u2022 Because this middleware has access to both HttpContext.Request and HttpContext.Response and is executed for every request, it is the natural interception point to call:  \n  \u2013 activity?.SetTag(\"HTTP_REFERER\", context.Request.Headers[\"Referer\"]);  \n  \u2013 activity?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", context.Response.Headers[\"Location\"]);  \n\u2022 No other files are needed; the change is a straightforward additive instrumentation in the existing Invoke / InvokeAsync method of this middleware (or just after the next() call for the response header).  \n\u2022 Therefore, updating ScmLogAsyncRequestHttpMiddleware.cs alone can fully satisfy the telemetry requirement without touching unrelated code.\nBatch 9 (ProfileMiddleware.cs): \u2022 ProfileMiddleware.cs is an ASP-NET Core middleware that runs on every HTTP request, giving it direct access to HttpContext.Request and HttpContext.Response headers.  \n\u2022 The file is already instrumented for monitoring: it references DocuSign.CLM.Monitoring, DocuSign.Monitoring, uses EventSource and Counter attributes, and (in the omitted code) typically starts/uses Activities or spans for request profiling.  \n\u2022 Because it sits in the request pipeline and owns/extends existing spans, it is the natural place to call `Activity.Current?.SetTag(\"HTTP_REFERER\", ...)` and `Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", ...)`.  \n\u2022 No other files are needed; the requirement can be fulfilled by adding a few lines in this middleware where the span/activity is available.\nBatch 10 (MvcAuditedRequestAttribute.cs): \u2022 MvcAuditedRequestAttribute.cs is an MVC/ASP-NET ActionFilterAttribute that executes for every HTTP request processed by the CLM web application.  \n\u2022 The filter has direct access to both HttpContext.Request.Headers and HttpContext.Response.Headers in its OnActionExecuting / OnActionExecuted / OnResultExecuted methods.  \n\u2022 The file already references the internal monitoring libraries (DocuSign.CLM.Monitoring, DocuSign.Monitoring) indicating that an Activity/span is created or is available in this scope.  \n\u2022 Therefore, this single file is the appropriate insertion point to call Activity.Current?.SetTag(\"HTTP_REFERER\", \u2026) and Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", \u2026) (or the equivalent Monitoring API) without touching any other code.\nBatch 11 (HttpRequestAuditHelper.cs): \u2022 The requirement is to add two HTTP-header-based attributes to the existing \u201cHTTP Request\u201d spans.  \n\u2022 HttpRequestAuditHelper.cs is a central utility that already performs request/response auditing and instrumentation (references to DocuSign.CLM.Monitoring, Activity/EventSource attributes, etc.).  \n\u2022 Because it sits in the web layer (imports System.Web, System.Web.Mvc, and accesses HttpContext), it has direct access to both Request.Headers and Response.Headers, making it the correct location to read \u201cReferer\u201d and \u201cLocation\u201d headers.  \n\u2022 The file clearly participates in telemetry emission (mentions EventSource, Counter, Activity), so extending it with Activity/Span.SetTag/AddAttributes logic is straightforward and isolated\u2014no other files are required for this change.\nBatch 12 (ScmHttpApplication.cs): \u2022 ScmHttpApplication.cs is the Global.asax\u2010style entry point for the web app.  \n\u2022 It already references OpenTelemetry.Trace and configures ASP.NET instrumentation (AddAspNetInstrumentation / ActivitySource, etc.).  \n\u2022 Because this file has access to the current HttpContext (Request / Response) during pipeline events (BeginRequest, EndRequest, or via the AspNetInstrumentation Enrich callback), it is the right place to append attributes to the existing HTTP server Activity/spans.  \n\u2022 No other files are needed; a small change here\u2014adding an Enrich delegate or explicit Activity tag assignments\u2014can capture:\n  \u2013 Request.Headers[\"Referer\"]  \u279c HTTP_REFERER  \n  \u2013 Response.Headers[\"Location\"] \u279c HTTP_RESPONSE_REDIRECT_LOCATION  \n\u2022 Therefore, modifying ScmHttpApplication.cs alone can fulfill the telemetry requirement.\nBatch 13 (Global.asax.cs): \u2022 Global.asax.cs is the application-wide entry point for every HTTP request in this ASP.NET application and typically contains Application_BeginRequest / Application_EndRequest or similar handlers.  \n\u2022 The file already references OpenTelemetry.Trace (and likely starts or enriches spans for incoming HTTP requests), indicating an existing telemetry pipeline that can be extended.  \n\u2022 Within these global request/response events we have direct access to HttpContext.Current.Request.Headers[\"Referer\"] and HttpContext.Current.Response.Headers[\"Location\"], exactly the two values required.  \n\u2022 Therefore, adding Activity.Current?.SetTag(\"HTTP_REFERER\", \u2026) and Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", \u2026) (or equivalent Attribute API) in this file will satisfy the requirement without touching other files.\nBatch 14 (Startup.cs): \u2022 The requirement is to enrich every HTTP-request span with two additional tags derived from the incoming request and outgoing response headers.  \n\u2022 The most straightforward way to achieve this in an ASP.NET Core app is to register a small piece of middleware that:\n  1. Reads Activity.Current (the span created by ASP.NET or an OpenTelemetry middleware already configured in Startup.cs).  \n  2. Adds the HTTP_REFERER tag before the request is executed.  \n  3. Adds the HTTP_RESPONSE_REDIRECT_LOCATION tag after the next middleware returns, when the response headers are available.  \n\u2022 Startup.cs is where the existing OpenTelemetry and other middlewares are configured (`UseRouting`, `UseEndpoints`, etc.). It therefore has direct access to the request pipeline and is the correct place to insert the extra middleware without touching other files.  \n\u2022 No other files are necessary; the logic can be expressed inline in Startup.cs or by calling an extension method from there.\nBatch 15 (WorkflowActivitiesController.cs): \u2022 WorkflowActivitiesController.cs is an ASP-NET Core MVC controller that directly handles incoming HTTP requests for the CLM web application, making it the right execution context to enrich the existing HTTP request span.  \n\u2022 The file imports DocuSign.Monitoring and already uses Activity/Telemetry helpers, so there is an existing span (Activity.Current) that can be extended via SetTag/SetBaggage.  \n\u2022 Within each controller action you have access to HttpContext.Request.Headers and HttpContext.Response.Headers, giving you the exact value sources required:  \n  \u2013 Request.Headers[\"Referer\"]  \u2192  HTTP_REFERER  \n  \u2013 Response.Headers[\"Location\"] \u2192 HTTP_RESPONSE_REDIRECT_LOCATION  \n\u2022 Because the requirement is limited to adding two attributes and no cross-cutting base class appears in this single-file group, only WorkflowActivitiesController.cs needs modification.\nBatch 16 (EmsRestClient.cs): \u2022 EmsRestClient.cs performs outbound HTTP calls for the CLM web application and already references DocuSign.CLM.Monitoring / DocuSign.Monitoring namespaces.  \n\u2022 Because monitoring code is present, existing HTTP request spans are very likely started (Activity/Span creation).  \n\u2022 Within the same execution scope we have access to both the outgoing HttpRequestMessage (so we can read Request.Headers[\"Referer\"]) and the HttpResponseMessage (so we can read Response.Headers[\"Location\"]).  \n\u2022 Therefore we can directly extend the span in EmsRestClient.cs by adding the two required attributes (HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION) without touching other files.\nBatch 17 (AbstractServicedComponent.cs): Cannot solve gap - The only file in this group, AbstractServicedComponent.cs, is a generic service-framework base class. Although it references monitoring libraries (DocuSign.CLM.Monitoring), its responsibilities appear to be service initialization, health checks, configuration, and MQ processing\u2014not HTTP request handling. The telemetry requirement targets the web application's HTTP request spans and needs access to Request.Headers and Response.Headers. This file (and the group) does not interact with HttpContext or perform HTTP instrumentation, so it cannot capture or add the required HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION attributes. Therefore, this file group cannot directly solve the telemetry gap."
]