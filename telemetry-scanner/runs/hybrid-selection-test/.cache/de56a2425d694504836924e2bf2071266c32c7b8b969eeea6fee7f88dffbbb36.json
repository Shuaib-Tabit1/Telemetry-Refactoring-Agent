{
  "selected_files": [
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class DetectTypeProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class VideoInfoProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net.Mime;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.PhysicalStorage;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FileIO;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.MimeLookup;\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.ContentStorage;\n\nnamespace ADEXS.DetectTypeService\n{\n\tpublic partial class DetectTypeProcessor : CommonTaskProcessor<DetectTypeTaskPayload>\n\t{\n\t\tprivate readonly IAtlasPersistenceFactory _atlasPersistenceFactory;\n\n\t\tprivate readonly IAtlasPhysicalStorageFactory _atlasPhysicalStorageFactory;\n\n\t\tprivate readonly IMimeDetector _mimeDetector;\n\n\t\tprivate readonly IDetectTypeServiceFeaturesConfig _featuresConfig;\n\n\t\tpublic DetectTypeProcessor()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IAtlasPersistenceFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IAtlasPhysicalStorageFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IMimeDetector>(),\n\t\t\t\tServiceLocator.GetInstance<IServiceInstrumentation>(),\n\t\t\t\tServiceLocator.GetInstance<IDetectTypeServiceFeaturesConfig>())\n\t\t{\n\t\t}\n\n\t\tpublic DetectTypeProcessor(\n\t\t\tIAtlasPersistenceFactory atlasPersistenceFactory,\n\t\t\tIAtlasPhysicalStorageFactory atlasPhysicalStorageFactory,\n\t\t\tIMimeDetector mimeDetector,\n\t\t\tIServiceInstrumentation serviceInstrumentation,\n\t\t\tIDetectTypeServiceFeaturesConfig featuresConfig)\n\t\t{\n\t\t\t_atlasPersistenceFactory = atlasPersistenceFactory;\n\t\t\t_atlasPhysicalStorageFactory = atlasPhysicalStorageFactory;\n\t\t\t_mimeDetector = mimeDetector;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t\t_featuresConfig = featuresConfig;\n\t\t}\n\n\t\tpublic override ProcessTaskResult ProcessTask()\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t// get and report the status of whether Optimizely is the feature flag provider\n\t\t\tLogger.InfoNoPII($\"Verification: IsOptimizelyVerificationFlagEnabled is {_featuresConfig.IsOptimizelyVerificationFlagEnabled} for account '{Task.AccountId}' (context accountId: '{AtlasContext.Current.AccountId}')\");\n\n\t\t\tProcessTaskResult result = new ProcessTaskResult();\n\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\tvar fileDataPersistence = _atlasPersistenceFactory.Get<IFileDataPersistence>(Task.AccountId);\n\n\t\t\tFileData fd = fileDataPersistence.LoadByUid(DeserializedPayload.FileDataUid);\n\t\t\tif (fd == null)\n\t\t\t{\n\t\t\t\tLogger.WarnNoPII($\"FileDataUid {DeserializedPayload.FileDataUid} does not exist in the db; ignoring\");\n\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\tresult.Message = \"Filedata Doesn't Exist\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// first try and detect the MIME type\n\t\t\t\t\tstring mimeType;\n\t\t\t\t\tusing (TempFile temp = new TempFile(fd.Extension))\n\t\t\t\t\t{\n\t\t\t\t\t\t//We could possibly optimize this by reading the first 256 bytes and passing them to the underlying COM library urlmon.dll.\n\t\t\t\t\t\t//See https://msdn.microsoft.com/en-us/library/ms775107(v=vs.85).aspx (FindMimeFromData function)\n\t\t\t\t\t\t_atlasPhysicalStorageFactory.GetPhysicalStorage(fd.AccountId).GetFile(fd.AccountId, fd.FileName, StorageConstants.StorageFormat.Native, temp.FileName);\n\t\t\t\t\t\tmimeType = _mimeDetector.DetectMimeType(temp.FileName);\n\t\t\t\t\t}\n\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected MIME type '{0}' for fileDataUid {1}.\", mimeType, fd.FileDataUid);\n\n\t\t\t\t\t// if still not sure try to map the extension to the MIME type\n\t\t\t\t\tif (string.IsNullOrEmpty(mimeType) || (mimeType == MediaTypeNames.Application.Octet))\n\t\t\t\t\t{\n\t\t\t\t\t\tmimeType = FileUtil.GetMimeTypeByExtension(fd.Extension);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Matched extension to MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\n\t\t\t\t\t// once we have a new MIME type, save it\n\t\t\t\t\tif (!string.IsNullOrEmpty(mimeType) && mimeType != fd.MIMEType)\n\t\t\t\t\t{\n\t\t\t\t\t\tfileDataPersistence.UpdateMIMEType(fd.Uid, mimeType);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected and set MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\t\t\te.Trace();\n\t\t\t\t\tLogger.ErrorNoPII($\"Failed to process fileDataUid {fd.FileDataUid} with exception \", e);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tTask.LastErrorMessage = e.Message;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.ErrorNoPII($\"Failed to mark fileDataUid {fd.FileDataUid} as failed with exception \", e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactivity?.SetQueueTaskResultTags(Task, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.MQ;\nusing ADEXS.Core.Domain;\nusing System.Threading;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing System.IO;\nusing ADEXS.Core.Domain.Model;\nusing System.Diagnostics;\n\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.ServiceFramework;\nusing CLM.MessageDefines;\nusing CLM.MessageDefines.Constants;\nusing CLM.MessageDefines.Interfaces;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\n\nusing StructureMap;\nusing ADEXS.MqWorkers.Config.Context;\nusing ADEXS.MqWorkers.Extensions;\nusing ADEXS.MqWorkers.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.MqWorkers.Config;\n\nnamespace ADEXS.Services.MessageWorkerService\n{\n\t//Should probably make an interface that encapsulates the methods for loading and\n\t//updating the Tasks so that we don't have to be tied to MessageQueues for this type of worker\n\tpublic class DispatchedWorker<T, U> : AbstractServiceQueue<T> where T : class, IQueueTask, new() where U : class, ITaskProcessor<T>, new()\n\t{\n\t\tprivate const string DESIRED_WORKER_COUNT = \"_WorkerCount\";\n\t\tprivate const string DESIRED_WORKER_MULTIPLIER = \"_WorkerMultiplier\";\n\t\tprivate const string TASK_DISPATCHERS = \"_TaskDispatchers\";\n\t\tprivate const string DESIRED_STAND_ALONE = \"_StandAlone\";\n\t\tprivate const string DEFAULT_TASK_DISPATCHERS = \"DefaultTaskDispatchers\";\n\t\tprivate const int DEFAULT_WORKER_COUNT = 5;\n\t\tprivate const double DEAFULT_CORE_TO_WORKER_MULTIPLIER = 0;\n\t\tprivate readonly string TASKPROCESSOR = Configuration.GetStringAppSetting(PROCESSSTART_NAME, \"ADEXS.TaskProcessor.exe\");\n\t\tprivate const string PROCESSSTART_NAME = \"PROCESSSTART_NAME\";\n\t\tprivate string _typeName;\n\t\tprivate readonly TaskTypes _taskType;\n\t\tprivate bool _standAlone;\n\n\t\tprivate readonly IContainer _container;         // optionally injected DI container\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate readonly Func<U> _createProcessor;\n\t\tprivate int _fetchMod;\n\n\t\t[ThreadStatic]\n\t\tprivate static int _errorCount = 0;\n\n\t\tpublic override string Name => base.Name + TypeName;\n\n\t\t[EventSource(\"Workers\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly PropertyBagEventSource _workersEventSource = new PropertyBagEventSource();\n\n\t\t[Counter(\"Workers Count\", \"CLM.DispatchedWorker\", MeasureProperty = \"Count\", InstanceProperty = \"Description\")]\n\t\t[EventSource(\"Workers Count\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly CountEventSource _workersCountEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\")]\n\t\t[Counter(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\", InstanceProperty = \"Description\")]\n\t\tprivate static ExceptionEventSource _workerLoggingExceptionEventSource = new ExceptionEventSource();\n\n\t\tstatic DispatchedWorker()\n\t\t{\n\t\t\t// Kazmon emits from a generic type do not work without this call\n\t\t\tMonitoringRuntime.RegisterGenericType(typeof(DispatchedWorker<T, U>));\n\t\t}\n\n\t\tpublic string TypeName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\t_typeName ??= _taskType.ToString();\n\t\t\t\treturn _typeName;\n\t\t\t}\n\t\t}\n\n\t\tpublic IMessageQueueWrapperFactory MessageQueueWrapperFactory { get; set; }\n\n\t\t/// <summary>\n\t\t/// Legacy Constructor -- delegates to the new overload; passes DI container extracted from ServiceLocator.\n\t\t/// This method will be deprecated in the future -- prefer the (IServicedComponent, IContainer) overload.\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this dispatched worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\tpublic DispatchedWorker(IServicedComponent component, TaskTypes taskType, IWatchedSingletonConfig<ISiteConfig> siteConfig) : this(component, taskType, ServiceLocator.Container, Activator.CreateInstance<U>, siteConfig)\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor overload that accepts a DI container (stepping stone to moving away from SL pattern).\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\t/// <param name=\"container\">the DI container for service discovery and IOC</param>\n\t\tinternal DispatchedWorker(IServicedComponent component, TaskTypes taskType, IContainer container, Func<U> processorFactory, IWatchedSingletonConfig<ISiteConfig> siteConfig) : base(component)\n\t\t{\n\t\t\t_container = container;\n\t\t\t_createProcessor = processorFactory ?? (() => new U());\n\t\t\tServiceLocator.BuildUp(this);\n\t\t\t_taskType = taskType;\n\t\t\t//This is here to prevent a regression following ATL-81324\n\t\t\tif (TypeName != typeof(T).Name)\n\t\t\t\tthrow new ArgumentException($\"Failed to initialize DispatchedWorker: Task Name ({typeof(T).Name}) must match task type ({TypeName})\");\n\t\t\t_waitOnNoItems = false;\n\t\t\t_standAlone = Configuration.GetBooleanAppSetting(TypeName + DESIRED_STAND_ALONE, false);\n\t\t\tif (_standAlone) _log.DebugNoPII($\"Worker running in StandAlone mode for {TypeName}\");\n\t\t\t_siteConfig = siteConfig;\n\t\t}\n\n\t\tprivate ProcessTaskResult RunExternalTaskProcessor(ProcessTaskRequest taskRequest)\n\t\t{\n\t\t\tvar accountId = taskRequest.Task.AccountId;\n\t\t\tbool useAnonymousPipes = TasksManagementFeatureFlags.UseAnonymousPipeForExternalTaskProcessors &&\n\t\t\t                         Configuration.GetBooleanAppSetting(\n\t\t\t\t                         $\"{accountId}_UseAnonymousPipeForExternalTaskProcessors\", true);\n\t\t\t_log.InfoNoPII(useAnonymousPipes\n\t\t\t\t? \"Worker using Anonymous Pipes for Request and Results\"\n\t\t\t\t: \"Worker using Temp Files for Request and Results\");\n\t\t\tExternalTaskWorker externalTaskWorker = ExternalTaskWorkerFactory.GetExternalTaskWorker(useAnonymousPipes);\n\t\t\treturn externalTaskWorker.RunExternalProcessor(taskRequest,TASKPROCESSOR);\n\t\t}\n\n\t\tprotected override int MaxQueueDepth()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_WorkerMaxQueueDepth\", Configuration.GetInt32AppSetting(TypeName + WORKER_MAXSET, WORKER_MAXSET_DEFAULT)) * DesiredWorkerCount();\n\t\t}\n\n\t\tprotected override IList<T> Fetch(int fetchCount)\n\t\t{\n\t\t\tList<T> tasks = new List<T>();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPeriodicPulse();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not pulse for ''{TypeName}''.\", ex);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttasks = FetchFromQueues(fetchCount);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not load the items for the queue: {TypeName}\", ex);\n\t\t\t\t_lastFetchDate = DateTime.UtcNow;\n\t\t\t}\n\n\t\t\tAttemptRestorePropertiesFromPayload(tasks);\n\n\t\t\treturn tasks;\n\t\t}\n\n\t\tprivate List<T> FetchFromQueues(int fetchCount)\n\t\t{\n\t\t\tvar queuePaths = DefaultQueue.GetWorkerMqPaths(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\n\t\t\t// keep incrementing to pull from a different queue on each fetch, fetching from all queues seems to have an adverse effect on the channels\n\t\t\t_fetchMod %= queuePaths.Length;\n\t\t\tvar queuePath = queuePaths[_fetchMod];\n\t\t\t_fetchMod++;\n\n\t\t\treturn FetchSingleQueue(fetchCount, queuePath);\n\t\t}\n\n\t\tprivate List<T> FetchSingleQueue(int fetchCount, string path)\n\t\t{\n\t\t\tbool isMainPath = path == DefaultQueue.GetWorkerMqPath(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\t\t\tint waitTime = isMainPath ? TaskUtilities.InitialReceiveWaitMS(TypeName) : Configuration.GetInt32AppSetting(\"InitialReceiveWaitAdditionalQueueMS\", 20);\n\t\t\tusing (IMessageQueueWrapper pdfMQ = MessageQueueWrapperFactory.CreateReceiveInstance(Configuration.GetStringAppSetting(TypeName + \"_WorkerMQPath\", path)))\n\t\t\t{\n\t\t\t\treturn pdfMQ.ReceiveMultiple<T>(waitTime, MQApplicationSettings.DefaultExtraReceiveWaitMS, fetchCount);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Restore the task type properties from the payload. This will only live temporarily as we move\n\t\t/// all tasks toward using the CommonTask payload. If we fail to restore from properties we should log to kazmon\n\t\t/// but we should not not block tasks from getting processed. We are also logging when we find a task\n\t\t/// without a payload set.\n\t\t/// </summary>\n\t\tprivate void AttemptRestorePropertiesFromPayload(List<T> tasks)\n\t\t{\n\t\t\t// App Setting to disable this behavior just in case of issues\n\t\t\tvar restoreFromPayload = Configuration.GetBooleanAppSetting($\"RestoreTaskFromPayload_All\", true) &&\n\t\t\t\tConfiguration.GetBooleanAppSetting($\"RestoreTaskFromPayload_{TypeName}\", true);\n\n\t\t\tforeach (var task in tasks)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (task is CommonTask cTask)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string.IsNullOrEmpty(cTask.Payload))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Log to kazmon to ensure that we don't miss any tasks\n\t\t\t\t\t\t\tCommonTaskPayloadHelper.CommonTaskPayloadMissingEventSource.Emit(1, cTask.Label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (restoreFromPayload)\n\t\t\t\t\t\t\t\tcTask.RestorePropertiesFromPayload();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tCommonTaskPayloadHelper.PayloadRestoreExceptionEventSource.Emit(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate QueueItemType _lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\tpublic override void AdjustWorkers()\n\t\t{\n\t\t\tbase.AdjustWorkers();\n\n\t\t\tint desiredWorkerCount = DesiredWorkerCount(out double multiplier);\n\t\t\tSetEnabled(desiredWorkerCount > 0);\n\t\t\tQueueItemType currentQueueStatus = (desiredWorkerCount > 0) ? QueueItemType.QueueStarted : QueueItemType.QueueStopped;\n\t\t\tif (currentQueueStatus == _lastSentQueueStatus) return;\n\n\t\t\tEmitWorkerConfiguration(currentQueueStatus, desiredWorkerCount, multiplier);\n\t\t\tstring adminQueuePath = \"Unset\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tT startTask = new T\n\t\t\t\t{\n\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\tQueueItemType = currentQueueStatus,\n\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t};\n\n\t\t\t\tif (!_standAlone)\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueuePath = GetAdminQueuePath(machine);\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(adminQueuePath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(startTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = currentQueueStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:AdjustWorkers - Could not contact the administration queue: \" + adminQueuePath, ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitWorkerConfiguration(QueueItemType queueItemtype, int desiredWorkerCount, double multiplier)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_workersCountEventSource.Emit(desiredWorkerCount, TypeName);\n\n\t\t\t\tusing (var propertyBag = _workersEventSource.CreateEventPropertyBag(queueItemtype.ToString()))\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TaskType\", TypeName);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"DesiredWorkerCount\", desiredWorkerCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"Multiplier\", multiplier.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ProcessorCount\", Environment.ProcessorCount.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_workerLoggingExceptionEventSource.Emit(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetMachineName() => System.Net.Dns.GetHostName();\n\t\tprivate string GetTaskTypeName() => typeof(T).FullName;\n\n\t\tprivate static int _queueStateTouchIntervalMin = 60;\n\t\tprivate DateTime _nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\n\t\tprotected virtual void PeriodicPulse()\n\t\t{\n\t\t\tif (_nextStateTouchTime < DateTime.UtcNow)\n\t\t\t{\n\t\t\t\tQueueStatePersistence.AuthenticationInstance.Touch(GetMachineName(), GetTaskTypeName());\n\t\t\t\t_nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Blast the local queue back to the dispatcher so that it can be\n\t\t/// dispatched to another worker.\n\t\t///\n\t\t/// Also sends a disable me message\n\t\t/// </summary>\n\t\tpublic override void Stop()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//Try to do a prelim kill before the stop of the workers\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch\n\t\t\t{\n\t\t\t\t_log.DebugNoPII(\"Didn't kill processes first time\");\n\t\t\t}\n\n\t\t\tbase.Stop();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSetEnabled(false);\n\t\t\t\tif (!_standAlone && (_lastSentQueueStatus != QueueItemType.QueueStopped))\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tT stopTask = new T\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\t\t\tQueueItemType = QueueItemType.QueueStopped,\n\t\t\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(machine)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(stopTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\t\t\t}\n\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:Stop - Exception generated during stop:\", ex);\n\t\t\t}\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStopped, 0, 0);\n\t\t}\n\n\t\tprivate void KillTaskProcessors()\n\t\t{\n\t\t\tvar nestedContainer = CreateNestedContainer(null);\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);  // necessary to determine if processor would run out-of-process\n\t\t\t// attempt to kill any active out-of-process processors\n\t\t\tif (processor.RunInSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t\t\tstring processName = Path.GetFileNameWithoutExtension(TASKPROCESSOR);\n\t\t\t\tProcess[] tokill = System.Diagnostics.Process.GetProcessesByName(processName);\n\t\t\t\tif (tokill.Length > 0)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"Killing {processName} processes.\");\n\t\t\t\t\tforeach (Process p in tokill)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Failed to kill process with pid: {p.Id}\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void SetEnabled(bool enable)\n\t\t{\n\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\t\t\tbool alreadySet = false;\n\t\t\tstring taskTypeName = GetTaskTypeName();\n\t\t\t_log.DebugNoPII($\"Task type: {taskTypeName}, enable set to {enable}\");\n\n\t\t\tforeach (QueueState state in QueueStatePersistence.AuthenticationInstance.LoadAll())\n\t\t\t{\n\t\t\t\tif (state.MachineName.Equals(GetMachineName(), StringComparison.InvariantCultureIgnoreCase)\n\t\t\t\t\t&& state.TaskTypeName == taskTypeName)\n\t\t\t\t{\n\t\t\t\t\tif (enable)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine already exists for task type {taskTypeName}, attempting to enable it\");\n\t\t\t\t\t\tRegisterQueueState(state);\n\t\t\t\t\t\talreadySet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine exists for task type {taskTypeName}, attempting to disable it\");\n\t\t\t\t\t\tstate.Enabled = false;\n\t\t\t\t\t\tQueueStatePersistence.AuthenticationInstance.Save(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (enable && !alreadySet)\n\t\t\t{\n\t\t\t\t// must be a new entry in the queuestate table\n\t\t\t\t_log.DebugNoPII($\"Machine does not already exist for task type {taskTypeName}, attempting to create it\");\n\t\t\t\tRegisterQueueState(null);\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// This will either create the queuestate or update\n\t\t/// it as enabled.\n\t\t/// </summary>\n\t\tprivate void RegisterQueueState(QueueState queueState)\n\t\t{\n\t\t\tif (queueState == null)\n\t\t\t{\n\t\t\t\tqueueState = new QueueState();\n\t\t\t\tType taskType = typeof(T);\n\t\t\t\tqueueState.MachineName = GetMachineName();\n\t\t\t\tqueueState.TaskAssemblyName = taskType.Assembly.GetName().Name;\n\t\t\t\tqueueState.TaskTypeName = GetTaskTypeName();\n\t\t\t\t_log.DebugNoPII($\"Creating new entry in QueueState for tasktype: {queueState.TaskTypeName}\");\n\t\t\t}\n\n\t\t\tqueueState.Enabled = true;\n\t\t\tqueueState.WorkerCount = DesiredWorkerCount(out double multiplier);\n\n\t\t\t_log.DebugNoPII($\"Saving QueueState for task type: {queueState.TaskTypeName} with properties - machine name: {queueState.MachineName},\" +\n\t\t\t\t$\"assembly name: {queueState.TaskAssemblyName} enabled: {queueState.Enabled}, worker count: {queueState.WorkerCount}\");\n\n\t\t\tQueueStatePersistence.AuthenticationInstance.Save(queueState);\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStarted, queueState.WorkerCount, multiplier);\n\t\t}\n\n\t\tprotected override TaskResult Process(T task, out string message)\n\t\t{\n\t\t\tmessage = null;\n\n\t\t\tAtlasContext.Current.AccountId = task.AccountId;\n\t\t\tAtlasContext.Current.TransactionId = task.CorrelationId;\n\t\t\tif (task is IUserTask usrTask)\n\t\t\t{\n\t\t\t\tAtlasContext.Current.UserAccountUid = usrTask.UserAccountUid;\n\t\t\t}\n\n\t\t\tGuid corrToken;\n\t\t\tGuid.TryParse(task.CorrelationId, out corrToken);\n\n\t\t\tusing var activity = StartActivity(task, corrToken);\n\n\t\t\tstring telemetryLabel = task.Label;\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\tusing (var logger = new TaskServiceRequestEventLogger(corrToken, telemetryLabel))\n\t\t\t{\n\t\t\t\t// introduces request-scoped container for user context state (and any other future per-request DI state)\n\t\t\t\tusing var nestedContainer = CreateNestedContainer(AtlasContext.Current);\n\n\t\t\t\t// The DataPoint enum is defined in DocuSign sources. Trying to use some, hopefully with close enough semantics.\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, task.AccountId);\n\t\t\t\tServiceContext.Log(DataPoint.QueueItemId, task.UniqueId);\n\t\t\t\tServiceContext.Log(DataPoint.TimeQueued, $\"{task.CreatedDate:yyyy-MM-dd HH:mm:ss.fff}\");\n\t\t\t\tif (Guid.Empty != AtlasContext.Current.UserAccountUid)\n\t\t\t\t{\n\t\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The nugget inside the monitoring wrapper.\n\t\t\t\t\tTaskResult taskResult = ProcessTask(task, nestedContainer, out message, activity);\n\n\t\t\t\t\tServiceContext.Log(DataPoint.ApiStatus, $\"{taskResult}\");\n\t\t\t\t\tlogger.Success = (taskResult != TaskResult.Failure);\n\t\t\t\t\tactivity?.SetStatusFromTask(taskResult);\n\t\t\t\t\treturn taskResult;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tex.Trace().Report();\n\t\t\t\t\tthrow;\n \t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (!logger.Success && null != message)\n\t\t\t\t\t{\n\t\t\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate TaskResult ProcessTask(T task, IContainer nestedContainer, out string message, Activity activity)\n\t\t{\n\t\t\tProcessTaskResult result = new ProcessTaskResult() { Message = \"Context Set\" };\n\n\t\t\tif (TaskUtilities.CheckSuspendedTaskTypeForAccount(TypeName, task.AccountId))\n\t\t\t{\n\t\t\t\tmessage = $\"task failed because Aid {task.AccountId} is in the suspended account list for {TypeName}\";\n\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\ttask.ErrorCount = int.MaxValue;\n\t\t\t\treturn TaskResult.Failure;\n\t\t\t}\n\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);\n\n\t\t\tAtlasContext.Current.ActionType = processor.ActionType;\n\n\t\t\tif (processor.RunInSeparateProcess && !processor.HandleSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t \t\tProcessTaskRequest taskRequest = new ProcessTaskRequest()\n\t\t\t\t{\n\t\t\t\t\tAccountId = AtlasContext.Current.AccountId,\n\t\t\t\t\tUserAccountUid = AtlasContext.Current.UserAccountUid,\n\t\t\t\t\tActionType = AtlasContext.Current.ActionType,\n\t\t\t\t\tProcessorTypeName = processor.GetType().AssemblyQualifiedName,\n\t\t\t\t\tTask = task,\n\t\t\t\t\tTaskType = _taskType,\n\t\t\t\t\tCorrelationToken = MonitoringContext.CorrelationToken ?? Guid.Empty\n\t\t\t\t};\n\t\t\t\tresult = RunExternalTaskProcessor(taskRequest);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprocessor.Task = task;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tprocessor.PreProcess();\n\t\t\t\t\tresult = processor.ProcessTask();\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tprocessor.PostProcess();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = result.Message;\n\n\t\t\tactivity?.SetQueueTaskResultTags(task, new MqWorkers.DispatchedWorker.ProcessTaskResult { Message = message });\n\n\t\t\treturn result.TaskResult;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an instance of the ITaskProcessor that should be used when processing a request.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This method takes into account whether we are using a scoped DI container, and if so, will\n\t\t/// attempt to get the task processor from there to ensure that other scoped DI services (eg user context)\n\t\t/// are also correctly set up. If the supplied `container` parameter is null we create a non-scoped\n\t\t/// processor instance, otherwise we demand it from the container (which may throw if none is registered).\n\t\t/// </remarks>\n\t\t/// <param name=\"container\">Optional (nullable) DI container from which we acquire scoped processors</param>\n\t\t/// <returns>An instance of ITaskProcessor{T} that can process the task.</returns>\n\t\tprivate U CreateTaskProcessor(IContainer container)\n\t\t{\n\t\t\t// NOTE: If we have a nested DI container, defer to it for the ITaskProcessor instance.\n\t\t\t//       If there is no nested container, or it doesn't have a ITaskProcessor registered,\n\t\t\t//       instantiate one one locally.\n\t\t\treturn container?.GetInstance<U>() ?? _createProcessor.Invoke();\n\t\t}\n\n\t\tprotected override void UpdateFailure(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//this will requeue it if needed\n\t\t\t\ttask.QueueItemType = QueueItemType.Ack;\n\t\t\t}, () =>\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Again errors should pause the movement of the items.\n\t\t\t\t * For this worker.\n\t\t\t\t */\n\t\t\t\tif (_errorCount++ % Configuration.GetInt32AppSetting(\"ErrorCountSleepMod\", 100) == 0)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(SleepMilliSeconds());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateUnlock(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//task will requeue it\n\t\t\t\ttask.QueueItemType = QueueItemType.Task;\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateSuccess(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.QueueItemType = QueueItemType.Completed;\n\t\t\t});\n\t\t}\n\n\t\tprivate void SendTaskStatusUpdate(T task, Action beforeSend, Action afterSend = null)\n\t\t{\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\t{\n\t\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\n\t\t\t\tbeforeSend();\n\n\t\t\t\tstring sendMachine = task.SendMachine; // Send() changes the SendMachine property, so store it here in case we need to restore it after an exception.\n\n\t\t\t\tusing (IMessageQueueWrapper adminQueue = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(task.SendMachine)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueue.Send(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Detected IOException.  Will retry once.\", ioe);\n\n\t\t\t\t\t\tadminQueue.ReSend(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Restore original SendMachine, for the sake of the UpdateFailure() call from AbstractServiceQueue.\n\t\t\t\t\t\ttask.SendMachine = sendMachine;\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (afterSend != null)\n\t\t\t\t{\n\t\t\t\t\tafterSend();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Crate a nested DI container for the user context (and potentially other request-scoped DI state).\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// Introduced as part of ATL-72998 to add support for feature flag integration, which requires access to\n\t\t/// the request-scoped Account/User identity for flag resolution decisions.\n\t\t/// </remarks>\n\t\t/// <param name=\"atlasContext\">Atlas request context for this request/task</param>\n\t\t/// <returns>Disposable DI container for this request-scoped state</returns>\n\t\tprivate IContainer CreateNestedContainer(IAtlasContext atlasContext)\n\t\t{\n\t\t\tvar nestedContainer = _container.GetNestedContainer();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (atlasContext != null)\n\t\t\t\t{\n\t\t\t\t\tvar userContextSetter = nestedContainer.TryGetInstance<IUserContextSetter>();\n\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tuserContextSetter.AccountId = atlasContext.AccountId;\n\t\t\t\t\t\tuserContextSetter.UserId = atlasContext.UserAccountUid; // this may be null, but that's ok\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Should we have a specific OT telemetry event for this condition? It's most like incorrectly configured DI setup, but may not be a defect.\n\t\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire IUserContextSetter - transactionId {atlasContext.TransactionId} will proceed without scoped user context.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar taskContextSetter = nestedContainer.TryGetInstance<ITaskTypeContextSetter>();\n\n\t\t\t\tif (taskContextSetter != null)\n\t\t\t\t{\n\t\t\t\t\ttaskContextSetter.TaskType = _taskType;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire ITaskTypeContextSetter - {TypeName} will proceed without scoped task type context.\");\n\t\t\t\t}\n\n\t\t\t\treturn nestedContainer;\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\tnestedContainer?.Dispose();  // avoid leaking nested container\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic virtual int StandardSleepSeconds => 5;\n\t\tprotected override int SleepSeconds()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_SleepSeconds\", StandardSleepSeconds);\n\t\t}\n\n\t\tpublic virtual int StandardWorkerCount => DEFAULT_WORKER_COUNT;\n\n\t\tpublic override int DesiredWorkerCount()\n\t\t{\n\t\t\treturn DesiredWorkerCount(out _);\n\t\t}\n\n\t\tprivate int DesiredWorkerCount(out double multiplier)\n\t\t{\n\t\t\tmultiplier = 0;\n\t\t\tint count = -1;\n\t\t\tif (IsOneConfigEnabledForWorkerCount())\n\t\t\t{\n\t\t\t\tvar mqTasksconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IMqTasksConfig>>()?.Value;\n\t\t\t\tvar taskConfigs = mqTasksconfigs?.TaskConfigs;\n\t\t\t\tif (taskConfigs != null && taskConfigs.TryGetValue(TypeName, out var taskConfig))\n\t\t\t\t{\n\t\t\t\t\tcount = taskConfig.WorkerCount;\n\t\t\t\t\tmultiplier = taskConfig.WorkerMultiplier;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Failed to retrieve task configuration from INI file for TaskName: {TypeName}. Falling back to legacy processing.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count < 0)\n\t\t\t{\n\t\t\t\t// Rely on appsetting if oneConfig is disabled or if it cannot retrive from oneconfig\n\t\t\t\tcount = Configuration.GetInt32AppSetting(TypeName + DESIRED_WORKER_COUNT, StandardWorkerCount);\n\t\t\t\tmultiplier = Configuration.GetDoubleAppSetting(TypeName + DESIRED_WORKER_MULTIPLIER, DEAFULT_CORE_TO_WORKER_MULTIPLIER);\n\t\t\t}\n\n\t\t\t// we still want to be able to force the count to zero in order to turn off a worker group effectively\n\t\t\t// let's check the worker count based on the number of logical cores and a configured multiplier\n\t\t\tif (count != 0 && multiplier > 0)\n\t\t\t{\n\t\t\t\t// use the number of logical cores and a multiplier to determine a good worker count number.\n\t\t\t\tint numCores = Environment.ProcessorCount;\n\t\t\t\tcount = Math.Max((int)(numCores * multiplier), 1);  // we really never want a > 0 multiplier to cause a zero worker count\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tprivate bool IsOneConfigEnabledForWorkerCount()\n\t\t{\n\t\t\tbool isOneConfigEnabled = false;\n\t\t\tif(ConfigWrapper.UseOneConfigMqTasksConfig)\n\t\t\t{\n\t\t\t\tvar appconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOneConfigMqTasks_\" + appconfigs?.AppName, true))\n\t\t\t\t{\n\t\t\t\t\tisOneConfigEnabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isOneConfigEnabled;\n\t\t}\n\n\t\tprivate IEnumerable<string> DispatcherMachines()\n\t\t{\n\t\t\treturn StringUtil.Split('|', Configuration.GetStringAppSetting(TypeName + TASK_DISPATCHERS, Configuration.GetStringAppSetting(DEFAULT_TASK_DISPATCHERS, GetMachineName())));\n\t\t}\n\n\t\tprivate string GetAdminQueuePath(string machine)\n\t\t{\n\t\t\treturn string.Format(Configuration.GetStringAppSetting(TypeName + \"_EventMQPathFormat\", DefaultQueue.GetAdminMqPathFormat(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName))), machine ?? GetMachineName());\n\t\t}\n\n\t\tprivate Activity StartActivity(T task, Guid correlationToken) =>\n\t\t\tServiceInstrumentation.ActivitySource\n\t\t\t\t?.StartActivity(\n\t\t\t\t\ttask.Label ?? $\"{nameof(ADEXS.Services.MessageWorkerService)}\",\n\t\t\t\t\tActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
      "content": "using System.Collections.Generic;\n\nusing ADEXS.Atlas.Workflow.Activities;\nusing ADEXS.Atlas.Workflow.Readers;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.DocuSignUrl;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow;\nusing ADEXS.ElectronicSignature;\nusing ADEXS.Etl;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.MQ;\nusing ADEXS.OrchestrationIntegration;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.SForce.Core;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.API.WorkflowActivities;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Filters;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Filters.SwaggerDoc;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.IoC;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters;\n\nusing DocuSign.CLM.SmallBenClient;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\n\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.IdentityModel.Logging;\nusing Microsoft.IdentityModel.Tokens;\nusing Microsoft.OpenApi.Models;\n\nusing OpenTelemetry.Metrics;\n\nvar builder = ScmWebApplication.CreateScmWebService(args);\n\nbuilder.ConfigureDefaultScmWebService(\n\targs,\n\t() => new List<IServiceRegistry>\n\t{\n\t\tnew CoreServiceRegistry(),\n\t\tnew CoreWorkflowRegistry(),\n\t\tnew AtlasWorkflowReadersRegistry(),\n\t\tnew MessageQueueRegistry(),\n\t\tnew SmallBenClientRegistry(),\n\t\tnew CoreDomainRegistry(),\n\t\tnew EtlRegistry(),\n\t\tnew ESignatureRegistry(),\n\t\tnew SalesForceRegistry(),\n\t\tnew MergeEngineServiceRegistry(),\n\t\tnew AtlasWorkflowActivitiesRegistry(),\n\t\tnew OrchestrationIntegrationRegistry()\n\t},\n\tWorkflowActivitiesConstants.ServiceName,\n\tconfigureMeter: options =>\n\t{\n\t\toptions.AddView(instrumentName: \"workflowactivities.api.duration\",\n\t\t\tnew ExplicitBucketHistogramConfiguration\n\t\t\t{\n\t\t\t\tBoundaries = new double[] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 }\n\t\t\t});\n\t},\n\tappConfigFileName: \"WorkflowActivitiesApiConfig.ini\");\n\nbuilder.Services.AddWebCoreBasedConfigProviders();\n\n// We only enable JwtAuth when on-prem due to MSF -> onprem communication\nif (ApplicationSettings.EnvironmentType == EnvironmentType.OnPrem)\n{\n\tbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n\t.AddJwtBearer(options =>\n\t{\n\t\toptions.RequireHttpsMetadata = builder.Configuration.GetValue<bool>(\"Jwt_PublicKeyRequireHttps\", true);\n\t\toptions.Authority = new DocuSignAccountsServerUrl().AuthorityUrl();\n#pragma warning disable CA5404 // Do not disable token validation checks\n\t\toptions.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false };\n#pragma warning restore CA5404 // Do not disable token validation checks\n\t});\n\tbuilder.Services.AddAuthorization(options =>\n\t{\n\t\toptions.AddPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopePolicyName, policy =>\n\t\t\tpolicy.RequireClaim(\n\t\t\t\tADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopeClaimKey,\n\t\t\t\tADEXS.Core.Types.Constants.DocuSignAuthenticationScopes.ClmActivitiesExecute));\n\t\toptions.DefaultPolicy = options.GetPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopePolicyName);\n\t});\n}\nelse\n{\n\tbuilder.Services.AddAuthentication();\n\tbuilder.Services.AddAuthorization(options =>\n\t{\n\t\toptions.AddPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.AllowAllPolicyName, policy =>\n\t\t\tpolicy.Requirements.Add(new AllowAnonymousRequirement()));\n\t\toptions.DefaultPolicy = options.GetPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.AllowAllPolicyName);\n\t});\n\tbuilder.Services.AddSingleton<IAuthorizationHandler, AllowAnonymousHandler>();\n}\n\nbuilder.Services.AddWorkflowActivitiesServices();\n\nbuilder.Services.AddMvc(options =>\n{\n\toptions.Filters.Add(new GlobalActionFilter());\n\toptions.Filters.Add(new AuditedRequestAttribute());\n\toptions.Filters.Add(new WorkflowActivitiesExceptionFilterAttribute());\n});\n\n// Do not remove -- this is required for proper deserialization of InstanceVariables\nbuilder.Services.AddControllers().AddNewtonsoftJson();\nbuilder.Services.AddEndpointsApiExplorer();\n\nbuilder.Services.AddSwaggerGen(options =>\n{\n\toptions.CustomOperationIds(c => $\"{c.ActionDescriptor.RouteValues[\"action\"]}\");\n\toptions.SupportNonNullableReferenceTypes();\n\toptions.UseAllOfForInheritance();\n\toptions.SwaggerDoc(WorkflowActivitiesConstants.ServiceVersion, new OpenApiInfo\n\t{\n\t\tTitle = WorkflowActivitiesConstants.ServiceName,\n\t\tVersion = WorkflowActivitiesConstants.ServiceVersion\n\t});\n\toptions.DocumentFilter<PathFormatDocumentFilter>();\n\toptions.SchemaFilter<EnumNameSchemaFilter>();\n});\n\nbuilder.Services.AddSwaggerGenNewtonsoftSupport();\n\nbuilder.Services.AddSingleton<IMetricsEmitter, WorkflowActivitiesMetricsEmitter>();\n\nbuilder.Services.AddHttpClient();\n\nbuilder.Services.AddComponentsInstrumentation();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n\tIdentityModelEventSource.ShowPII = true;\n}\n\napp.UseCommonScmServices();\n\napp.UseMiddleware<LogRequestHttpMiddleware>();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.UseStaticFiles();\napp.UseStaticFiles($\"/{WorkflowActivitiesConstants.ServiceUrlPrefixNoTrailingSlash}\");\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{WorkflowActivitiesConstants.ServiceUrlPrefix}version\");\napp.MapVersionEndpoint($\"{WorkflowActivitiesConstants.ServiceVersion}/version\");\napp.MapControllers();\n\napp.RunScmWebService();\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
      "content": "\ufeff// BUGBUG: ATL-71924 Move code dependent on System.Web out of Core.Domain\n#if NETFRAMEWORK\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.ServiceFramework.Helpers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.FeatureFlags;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing log4net;\nusing log4net.Config;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing ApplicationInfo = ADEXS.Core.Domain.Utilities.ApplicationInfo;\n\nnamespace ADEXS.Web.Common;\n\n/// <summary>\n/// Base class for all SCM web applications.\n/// </summary>\npublic abstract class ScmHttpApplication : HttpApplication\n{\n\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\t/// <summary>\n\t/// Don't use the standard Application_Start(). .Net picks one via reflection\n\t/// and runs it. Ends up being this one here, not the one in the derived class.\n\t/// </summary>\n\tprotected void ApplicationStart()\n\t{\n\t\t// log4net initialization\n\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n\t\tXmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\tConfigurationHelper.InitializeConfiguration();\n\n\t\tif (ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\n\t\t// Use MSF specific env variable, fallback to app settings.\n\t\tvar appName = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? AppConfig.AppName(ApplicationInfo.Name);\n\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? SiteConfig.Environment(\"Unknown\");\n\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\n\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\tapplicationName: appName,\n\t\t\tappVersion: typeof(ScmHttpApplication).Assembly.GetName().Version.ToString(),\n\t\t\tenvironmentName: environment,\n\t\t\tsiteName: site,\n\t\t\tpartitionName: partition,\n\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\tshouldEnableLogFileListener: () => Configuration.GetBooleanAppSetting(\"KazmonEnableLogFileListener\", false));\n\n\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t{\n\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\tassembly: typeof(ScmHttpApplication).Assembly,\n\t\t\t\t\tconfigureTracer: tracerProviderBuilder =>\n\t\t\t\t\t{\n\t\t\t\t\t\t_ = tracerProviderBuilder\n\t\t\t\t\t\t\n\t\t\t\t\t\t.AddAspNetInstrumentation(options =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t})\n\t\t\t\t\t.AddSource(typeof(RedisSessionStateProviderWrapper).FullName);\n\t\t\t\t\t},\n\t\t\t\t\tconfigureMeter: o => o.AddAspNetInstrumentation(options => options.Enrich = (HttpContext context, ref TagList tags) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!tags.Any(t => t.Key == \"http.route\") &&\n\t\t\t\t\t\t\tcontext.Request != null &&\n\t\t\t\t\t\t\t(context.Request.Url.AbsolutePath.EndsWith(\"aspx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"asmx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"ashx\", StringComparison.OrdinalIgnoreCase)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttags.Add(\"url.path\", context.Request.Url.AbsolutePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}))).GetAwaiter().GetResult();\n\t\t\t}\n\t\t}\n\n\t\tif (!ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This one stays the standard Application_End(), as no derive class overrides it.\n\t/// </summary>\n\tprotected virtual void Application_End()\n\t{\n\t\ttry\n\t\t{\n\t\t\tLogManager.Shutdown();\n\t\t}\n\t\tcatch { }\n\n\t\tUninitializeFeatureFlags();\n\n\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t{\n\t\t\t// Run synchronously\n\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t}\n\n\t\tKazmonMonitoring.ShutdownKazmon();\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to initialize feature flags.\n\t/// </summary>\n\tprotected virtual void InitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t}\n\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application shutdown to uninitialize feature flags.\n\t/// </summary>\n\tprotected virtual void UninitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to bootstrap the dependency injection container.\n\t/// </summary>\n\tprotected virtual void Bootstrap()\n\t{\n\t}\n}\n\n#endif\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Activities.HumanActivities;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.ActivityProperties;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.ExpressionService.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Config;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\nusing ADEXS.WINS.Interfaces;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\n\nusing Platform.Common;\n\nusing SCMAppenders;\n\nusing static ADEXS.Atlas.Workflow.Activities.Handlers.InstanceHandler;\n\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing InstanceVariable = ADEXS.Core.Domain.Model.Workflow.InstanceVariable;\nusing LoggingHelper = ADEXS.Atlas.Workflow.Activities.Infrastructure.LoggingHelper;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing UserAccount = ADEXS.Core.Domain.Model.UserAccount;\n\nnamespace ADEXS.WINS.Engine\n{\n\t/// <summary>\n\t/// An instance of a workflow -- a specific example of a definition.\n\t/// This class contains methods for controlling it, but all such calls should actually be fed through\n\t/// WorkflowManager so they can be queued, etc.\n\t/// </summary>\n\tpublic class WorkflowInstance : IWINSControlInstance\n    {\n        public const int SQL_SEVERITY_LEVEL_TRANSIENT = 12;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowInstance));\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IInstanceVariableGovernance _instanceVariableGovernance;\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepository;\n\t\tprivate IGovernor _governor;\n\t\tprivate IInstanceHandler _instanceHandler;\n\t\tprivate IServiceInstrumentation _serviceInstrumentation;\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> _workflowClientConfig;\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate ICacheRepository _cacheRepository;\n\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => (_instanceVariableGovernance ?? (_instanceVariableGovernance = ServiceLocator.GetInstance<IInstanceVariableGovernance>()));\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository ?? (_workflowSettingRepository = ServiceLocator.GetInstance<IWorkflowSettingRepository>());\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\t\tprivate IInstanceHandler InstanceHandler => _instanceHandler ?? (_instanceHandler = ServiceLocator.GetInstance<IInstanceHandler>());\n\n\n\t\tprivate IServiceInstrumentation ServiceInstrumentation => _serviceInstrumentation ?? (_serviceInstrumentation = ServiceLocator.GetInstance<IServiceInstrumentation>());\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> WorkflowClientConfig => _workflowClientConfig ?? (_workflowClientConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>());\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> SiteConfig => _siteConfig ?? (_siteConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>());\n\t\tprivate ICacheRepository CacheRepository => _cacheRepository ?? (_cacheRepository = ServiceLocator.GetInstance<ICacheRepository>());\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig ?? (_workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\n\t\t/// <summary>\n\t\t/// Loads (and locks) an existing instance.  Fails if the instance doesn't exist or can't be locked.\n\t\t/// </summary>\n\t\tpublic static WorkflowInstance LoadExisting(int accountId, Guid instanceUid, IWINSDataStore data)\n        {\n\t        DateTime lockExpirationDate;\n            InstancePersistence.LockResult lockResult = data.LockInstance(accountId, instanceUid, out lockExpirationDate);\n            switch (lockResult)\n            {\n                case InstancePersistence.LockResult.AlreadyCompleted:\n                    throw new InstanceAlreadyCompletedException(string.Format(\"InstanceUid {0} is already completed\", instanceUid));\n                case InstancePersistence.LockResult.DoesNotExist:\n                    throw new ApplicationException(string.Format(\"Invalid instanceUid {0}\", instanceUid));\n                case InstancePersistence.LockResult.LockedByOther:\n                    throw new InstanceLockedException(string.Format(\"InstanceUid {0} is locked by another process\", instanceUid));\n                case InstancePersistence.LockResult.Locked:\n                    // This is our success condition\n                    break;\n                default:\n                    throw new ApplicationException(string.Format(\"Unhandled lockResult for instanceUid {0}: {1}\", instanceUid, lockResult));\n            }\n            Instance instance = data.LoadInstanceByUid(accountId, Constants.WorkflowUser, instanceUid);\n            if (instance == null) throw new ApplicationException(string.Format(\"Failed to load workflow instanceUid {1} for account {0}.\", accountId, instanceUid));\n\n\t\t\ttry\n            {\n                if (instance.ScopeUid != Guid.Empty)\n                {\n                    Scope scope = ServiceLocator.GetInstance<IDocumentScopeRepository>().GetScopeByUid(accountId, instance.ScopeUid);\n                    if (scope != null)\n                        instance.ScopeName = scope.Name;\n                }\n            }\n            catch (Exception ex)\n            {\n                // the failure to load the scope should not cause the failure to load the instance, log it and move on\n                _log.WarnNoPII(string.Format(\"Could not load the scope '{0}' for workflow instance '{1}'.\", instance.ScopeUid, instanceUid), ex);\n            }\n\n\t\t\tRevision revision = data.LoadRevisionByUid(accountId, Constants.WorkflowUser, instance.RevisionUid);\n            if (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, instance.RevisionUid));\n            // ATL-68146: Populate RevisionCreatedDate here, because LoadInstanceByUid() doesn't populate it.\n            instance.RevisionCreatedDate = revision.CreatedDate;\n            WorkflowMap workflowMap = null;\n            instance.DefinitionUid = revision.DefinitionUid;\n\n\t\t\ttry\n            {\n\t            workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n            }\n            catch (InvalidDesignDefinitionException ex)\n            {\n\t            try\n\t            {\n\t\t            new WorkflowInstance(instance, data).Abort(UserAccount.WorkflowUserAccount(accountId), ex.Message);\n\t            }\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Error aborting workflow instance '{instanceUid}' with invalid definition\", e);\n\t\t\t\t}\n\n\t            throw;\n            }\n\n            var workflowInstance = new WorkflowInstance(instance, workflowMap, data);\n\t        workflowInstance.LockExpirationDate = lockExpirationDate;\n\t        return workflowInstance;\n\n        }\n\n        private readonly IWINSDataStore _data;\n        private readonly WorkflowMap _workflowMap;\n        private Instance _instance;\n\n        // The count of the activities that have been generated by this particular in-memory instance.  This doesn't get persisted anywhere, so is\n        // cleared whenever this WorkflowInstance gets unloaded (eg, when it enters into a Waiting state).\n        // It's use is to detect runaway workflows.\n        public const int MAX_IN_MEMORY_ACTIVITY_COUNT = 5000;\n        private int _inMemoryActivityCount = 0;\n\t\tprivate int _activityExecutionCountEnforcedLimit = 0;\n\t\tprivate Guid _revisionUid = Guid.Empty;\n\t\tprivate Guid _definitionUid = Guid.Empty;\n\t\tprivate DateTime _revisionCreatedDate = DateTime.MinValue;\n\t\tprivate bool _isActivityExecutionLimitReached = false;\n\n\t\tprivate readonly object _lockObject = new object();\n        private readonly IDictionary<Guid, InstanceActivity> _unfinishedActivities = new Dictionary<Guid, InstanceActivity>();\n        private readonly Queue<Event> _queuedControlEvents = new Queue<Event>();\n        private readonly Queue<Event> _queuedEvents = new Queue<Event>();\n\n        private readonly Dictionary<string, ContentDefinition> _contentDefinitions = new Dictionary<string, ContentDefinition>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, InstanceVariable> _variables = new Dictionary<string, InstanceVariable>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, IXmlVariableDefinition> _xmlVariableDefinitions = new Dictionary<string, IXmlVariableDefinition>(StringComparer.InvariantCultureIgnoreCase);\n\n        private readonly TimedLock _lock;\n\n        // Kind of a hack -- this is kept around so that if we end the instance without reaching the End step, we have an activity that we can\n        // log the message to.\n        private Guid _lastActivityUid;\n\n        private WorkflowInstance(Instance instance, IWINSDataStore data)\n        {\n\t        _data = data;\n\t        _lock = new TimedLock(instance.Uid.ToString());\n\t        _instance = instance;\n\t\t\t_revisionUid = _instance.RevisionUid;\n\t\t\t_revisionCreatedDate = instance.RevisionCreatedDate;\n\t        LastProcessDate = DateTime.UtcNow;\n\t\t\t_definitionUid = _instance.DefinitionUid;\n\t\t}\n\n\t\tpublic WorkflowInstance(Instance instance, WorkflowMap workflowMap, IWINSDataStore data) : this(instance, data)\n        {\n            _workflowMap = workflowMap;\n            // Load up any incomplete activities.  This is pointless to do for a new workflow, but it's not expensive either,\n            // so we simply avoid trying to figure that out and simply do it.\n            QueueIncompleteActivities();\n        }\n\n        /// <summary>\n        /// The AccountId this instance is running in.\n        /// </summary>\n        public int AccountId { get { return _instance.AccountId; } }\n\n        public Dictionary<string, ContentDefinition> ContentDefinitions { get { return _contentDefinitions; } }\n\n        public IWINSDataStore DataStore { get { return _data; } }\n\n        public TimedLock ThreadLock { get { return _lock; } }\n\n        /// <summary>\n        /// An in-memory, non-persisted value -- this is used when workers are finding instances to do work on.\n        /// It acts to make the WorkflowManager more FIFO, so that some workflows don't continually get ignored in favor of\n        /// newer work coming in.\n        /// </summary>\n        public DateTime LastProcessDate { get; private set; }\n\n        /// <summary>\n        /// The model Instance object; I didn't call this Instance because I didn't want it confused with a singleton pattern, and because\n        /// I didn't like seeing \"instance.Instance\".\n        /// </summary>\n        public Instance Model { get { return _instance; } }\n\n\t\tpublic DateTime LockExpirationDate { get; set; }\n\n\t\t/// <summary>\n\t\t/// The instance's Uid.  Primary key.\n\t\t/// </summary>\n\t\tpublic Guid Uid { get { return _instance.Uid; } }\n\n        public Dictionary<string, InstanceVariable> Variables { get { return _variables; } }\n\n        public Dictionary<string, IXmlVariableDefinition> XmlVariableDefinitions { get { return _xmlVariableDefinitions; } }\n\n        public Enums.WorkflowStepStatus Status => _instance.Status;\n\n        public bool HasQueuedWork\n        {\n            get { return _queuedEvents.Count > 0 || _queuedControlEvents.Count > 0; }\n        }\n\n        public bool HasUnfinishedActivities\n        {\n            get { return _unfinishedActivities.Count > 0; }\n        }\n\n        public void QueueActivity(InstanceActivity instanceActivity)\n        {\n            lock (_lockObject)\n            {\n                _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            }\n        }\n\n\t\tpublic int ActivityExecutionCount { get; set; }\n\n\t\tpublic int ActivityExecutionCountEnforcedLimit => _activityExecutionCountEnforcedLimit;\n\n\t\tpublic bool IsActivityExecutionLimitReached => _isActivityExecutionLimitReached;\n\n\t\tpublic Guid RevisionUid => _revisionUid;\n\n\t\tpublic Guid DefinitionUid => _definitionUid;\n\n\t\tpublic DateTime RevisionCreatedDate => _revisionCreatedDate;\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\t/// <param name=\"previousActivity\"></param>\n\t\t/// <param name=\"linkName\"></param>\n\t\t/// <param name=\"localContextId\"></param>\n\t\t/// <param name=\"followEmptyPathByDefault\"></param>\n\t\t/// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n\t\tpublic void QueueActivitiesByLink(InstanceActivity previousActivity, string linkName, int localContextId = 0, bool followEmptyPathByDefault = true, bool useLinkName = false)\n        {\n            IEnumerable<WorkflowMap.Link> links;\n            bool found = false;\n            if (_workflowMap.TryGetLinks(previousActivity.Name, linkName, out links))\n            {\n                foreach (WorkflowMap.Link link in links)\n                {\n                    QueueActivityByName(previousActivity, link.ToName, localContextId, linkName, useLinkName);\n                    found = true;\n                }\n            }\n            // If we got no matches, try to go for the default (empty) output.\n            if (followEmptyPathByDefault && !found && !string.IsNullOrEmpty(linkName)) QueueActivitiesByLink(previousActivity, string.Empty, localContextId);\n        }\n\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"previousActivity\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"localContextId\"></param>\n        /// <param name=\"linkName\"></param>\n        /// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n        public void QueueActivityByName(InstanceActivity previousActivity, string name, int localContextId = 0, string linkName = null, bool useLinkName = false)\n        {\n            IWINSActivity activity;\n            if (!_workflowMap.TryGetActivity(name, out activity)) throw new ApplicationException(string.Format(\"InstanceUid {0}: Tried to execute invalid activity '{1}'\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, name)));\n\n            if (localContextId <= 0) localContextId = (previousActivity == null ? int.MinValue : previousActivity.LocalContextId);\n\n            // Create a new activity\n            InstanceActivity instanceActivity = new InstanceActivity\n            {\n                AccountId = _instance.AccountId,\n                InstanceUid = _instance.Uid,\n                Name = name,\n                ActivityTypeName = activity.LegacyElementName(),\n                Status = Enums.WorkflowStepStatus.Pending,\n                InputActivityOutput = useLinkName ? linkName : (previousActivity == null ? string.Empty : previousActivity.Output),\n                InputActivityUid = (previousActivity == null ? Guid.Empty : previousActivity.Uid),\n                LocalContextId = localContextId,\n                IsWinsActivity = true,\n                CreatedDate = DateTime.UtcNow //make sure that the in memory copy has a value\n            };\n\n            try\n            {\n                _data.CreateActivity(instanceActivity);\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorWithPII($\"Failed to queue activity {{0}} for instance {_instance?.Uid} in account {_instance?.AccountId}\", ex, name);\n                _data.ActivityFailure(_instance, instanceActivity);\n            }\n\n            _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            QueueActivity(instanceActivity);\n        }\n\n        public void QueueEvent(Event e)\n        {\n            if (_instance.Status != Enums.WorkflowStepStatus.Failed && _instance.Status != Enums.WorkflowStepStatus.Aborted)\n            {\n                lock (_lockObject)\n                {\n                    Queue<Event> queue = (e.IsControlEvent ? _queuedControlEvents : _queuedEvents);\n                    if (e.Uid != Guid.Empty)\n                    {\n                        // Ensure this item isn't already in the list\n                        if (queue.Any(e2 => e2.Uid == e.Uid)) return;\n                    }\n                    queue.Enqueue(e);\n                    WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventQueued\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n                    wrk.Log();\n\t            }\n            }\n        }\n\n        public void QueueIncompleteActivities()\n        {\n            InstanceActivities activities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n            if (activities == null || activities.Count == 0) return;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in activities) _unfinishedActivities[activity.Uid] = activity;\n            }\n\n        }\n\n        public bool CheckActivityForCompletion(InstanceActivity instanceActivity)\n        {\n            // We only care about Waiting steps.\n            if (instanceActivity.Status != Enums.WorkflowStepStatus.Waiting) return false;\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.DebugNoPII($\"CheckActivityForCompletion called for ActivityUid {instanceActivity.Uid} ({instanceActivity.Name}).\");\n\t            try\n\t            {\n\t\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\t\t            ctx.CheckForCompletion();\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t            _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n\t\t\t            SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            return true;\n\t\t            }\n                    _log.DebugWithPII($\"CheckActivityForCompletion completed for Activity ({{0}}) in status: {instanceActivity.Status}.\", instanceActivity.Name);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n                    _log.ErrorNoPII($\"CheckActivityForCompletion failed.\", e);\n\t            }\n            }\n            return false;\n        }\n\n        public bool DoNextTask()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t        CheckAndHandleInstanceStateChanges();\n\n\t\t\t// If we're in a non-processing state, we want to respond only to control events.\n\t\t\t// If we have no control events, we can just skip everything else.\n\t\t\tif (!_ShouldProcessEvent())\n\t        {\n\t\t        return _ExecuteFirstEvent(controlOnly: true);\n\t        }\n\n\t        // If we have any queued events, do one of those.\n\t        if (_ExecuteFirstEvent(controlOnly: false)) return true;\n\n\t        if (!_ShouldProcess()) return false;\n\n\t        // Otherwise, check to see if any activities need to be executed; if so, do those.\n\t        if (_ExecuteFirstActivity()) return true;\n\n\t        // If we get here, it might be that we have some unfinished activities in the database that for some reason weren't loaded into memory.\n\t        // Check for that, and, if so, load them now.\n\t        QueueIncompleteActivities();\n\t        // Try to execute an activity again -- we may have just loaded some\n\t        if (_ExecuteFirstActivity()) return true;\n\t        // If we can complete a waiting activity, do that.\n\t        if (_CheckWaitingActivities()) return true;\n\n\t        // Otherwise, we've got nothing to do and can quit.\n\t        if (!HasQueuedWork && !HasUnfinishedActivities)\n\t        {\n\t\t        _MarkCompleted();\n\t\t\t\t// If we processed nothing (the activity count is 0) we don't want to mark ourselves as waiting.  This is mostly because\n\t\t\t\t// we don't want to update our UpdatedDate (see ATL-20570).  This case occurs when our workflow is already waiting and has been\n\t\t\t\t// picked up for the day and each activity checked to see if it's done waiting.  We don't want this to trigger an update if\n\t\t\t\t// nothing has actually changed.\n\t        }\n\t        else if (_inMemoryActivityCount > 0 || _instance.Status != Enums.WorkflowStepStatus.Waiting)\n\t        {\n\t\t\t\tvar workflowConfig = WorkflowConfig(_instance.AccountId);\n\t\t\t\tvar enableSmallBenRateLimits = workflowConfig?.EnableSmallBenRateLimits ?? false;\n\n\t\t\t\tif (_instance.Status == Enums.WorkflowStepStatus.Paused\n\t\t\t\t    && ((string.Equals(ADEXS.Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.EnableExpressionApiRateLimit, \"live\", StringComparison.OrdinalIgnoreCase)\n\t\t\t\t         && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit)\n\t\t\t\t\t|| (enableSmallBenRateLimits && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit)))\n\t\t\t\t{\n\t\t\t\t\t// keep throttled workflows in paused status\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_MarkWaiting();\n\t\t\t}\n\n\t\t    return false;\n        }\n\n        public void ExecuteActivity(InstanceActivity instanceActivity)\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteActivity called for Activity ({{0}}).\", instanceActivity.Name);\n\t            IWINSWorkflowContext ctx = null;\n\t            Stopwatch sw = Stopwatch.StartNew();\n\t            try\n\t            {\n\t\t            _lastActivityUid = instanceActivity.Uid;\n\n\t\t\t\t\tif (!_ShouldProcess()) throw new ApplicationException(string.Format(\"InstanceUid {0} is in an invalid state to execute activity {1}\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, instanceActivity.Name)));\n\n\t\t            // Check for runaway workflows.\n\t\t            if (++_inMemoryActivityCount >= MAX_IN_MEMORY_ACTIVITY_COUNT)\n\t\t            {\n\t\t\t            _log.WarnNoPII(string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t\t            throw new PublicException(PublicException.FailReason.InvalidState, string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t            }\n\n\t\t\t\t\t// Governance, check if activity execution limit has been reached\n\t\t\t\t\tif (PauseWhenActivityExecutionLimitReached())\n\t\t\t\t\t{\n\t\t\t\t\t\t// In this case, the workflow is paused, purge date is set and an e-mail has been sent to support team.\n\t\t\t\t\t\t// The current activity will not be executed, unless the limits are increased and the workflow resumed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_data.ActivityExecuting(_instance, instanceActivity);\n\n\t\t            ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\t\tif (!ShouldUseScopeEventHandler() && IsTrackItActivity(activity))\n\t\t\t\t\t{\n\t\t\t\t\t\tFireWorkflowScopeEvent(null, ScopeEventType.StepInitiated, activity, ctx);\n\t\t\t\t\t}\n\n\t\t\t\t\tactivity.Execute(ctx);\n\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n\t\t\t\t\tif (e is ArgumentNullException && ctx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar message =\n\t\t\t\t            string.Format(Resources.WINSResources.ActionFailed_ReferenceID_0, Guid.NewGuid()) +\n\t\t\t\t            $\". Inst: {instanceActivity.AccountId} '{instanceActivity.InstanceUid}'.\";\n\t\t\t            _log.ErrorNoPII(message, e);\n\t\t\t\t\t\t_data.CreateInstanceHistory(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, message, true);\n\t\t            }\n\n\t\t\t\t\t// Oh my...\n\t\t\t\t\t// Look at this catch block.\n\t\t\t\t\tbool isTransient = e is TransientException;\n\t\t            bool useFailureOutput = ctx != null && activity.HasFailureOutput;\n\n\t\t            if (isTransient) throw new TransientException(e);\n\t\t            if (useFailureOutput)\n\t\t            {\n\t\t\t\t\t\tctx.ActivityVariables.Set(\"Failure\", e.Message);\n\t\t\t\t\t\tctx.MarkAsCompleted(AbstractActivity.OUTPUT_FAILURE);\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.ActivityFailure(_instance, instanceActivity);\n\t\t\t            if (ctx == null) ctx = _CreateContext(activity, instanceActivity);\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\ttry\n\t\t\t            {\n\t\t\t\t            if (_instance.Status == Enums.WorkflowStepStatus.Failed)\n\t\t\t\t            {\n\t\t\t\t\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInstanceHandler.Fail(ctx, activity, GetUnfinishedWINSWorkflowContextsWINSActivities(instanceActivity.EndDate));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAccountId = ctx.AccountId,\n\t\t\t\t\t\t\t\t\t\tScopeUid = ctx.ScopeUid,\n\t\t\t\t\t\t\t\t\t\tScopeName = ctx.ScopeName,\n\t\t\t\t\t\t\t\t\t\tStepName = instanceActivity.Name,\n\t\t\t\t\t\t\t\t\t\tStepDisplayName = GetActivityDisplayName(activity, ctx),\n\t\t\t\t\t\t\t\t\t\tStepTypeName = instanceActivity.ActivityTypeName,\n\t\t\t\t\t\t\t\t\t\tStepUid = instanceActivity.Uid,\n\t\t\t\t\t\t\t\t\t\tPeriodStart = instanceActivity.EndDate,\n\t\t\t\t\t\t\t\t\t\tEventType = (int)ScopeEventType.WorkflowFailed,\n\t\t\t\t\t\t\t\t\t\tOutput = instanceActivity.Output,\n\t\t\t\t\t\t\t\t\t\tWorkflowUid = ctx.WorkflowInstanceUid,\n\t\t\t\t\t\t\t\t\t\tWorkflowName = ctx.WorkflowName\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tEventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n\n\t\t\t\t\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Failed, instanceActivity.EndDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t            }\n\t\t\t            catch (Exception ex)\n\t\t\t            {\n\t\t\t\t        _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.WorkflowFailed}\", ex);\n\t\t\t            }\n\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n\t\t            }\n\t            }\n\t            finally\n\t            {\n\t\t            ActivityExecutionCount++;\n\t            }\n\t\t\t}\n        }\n\n        public void ExecuteCallback(InstanceActivity instanceActivity, string name, object value)\n        {\n            LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteCallback called for Activity ({{0}}) with callback {name}.\", instanceActivity.Name);\n\n\t            if (!(_ShouldProcess(instanceActivity) && _ShouldProcessEvent()))\n\t            {\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoWithPII($\"ExecuteCallback did not complete because the activity was already completed. Activity {{0}} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}. Instance status: {Model.Status}\", instanceActivity.Name);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _log.ErrorWithPII($\"InstanceUid {Uid} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}.  Instance status: {Model.Status}\");\n\t\t\t\t\t}\n\t\t            return;\n\t\t\t\t}\n\n\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\ttry\n\t\t        {\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t            activity.ExecuteCallback(ctx, name, value);\n\n\t\t            if (_instance.Status != Enums.WorkflowStepStatus.Aborted)\n\t\t            {\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\n\t\t\t\t\t// Throw so that the calling method will handle re-queuing the failed event\n\t\t\t\t\t// When resumed we will retry the recurring reminder callback\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t            catch (Exception e)\n\t            {\n\t\t\t\t\t// Note that we don't fail the workflow here -- see ATL-21019\n\t\t\t\t\tif (instanceActivity.Status == Enums.WorkflowStepStatus.Completed ||\n\t\t                Model.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoNoPII($\"The callback is unnecessary: workflow activity '{instanceActivity.Uid}' [{instanceActivity.Status}] or instance '{instanceActivity.InstanceUid}' [{Model.Status}] has already completed.\");\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t\t\t\tvar pe = e as PublicException;\n\t\t\t\t\t\t_log.ErrorNoPII($\"ExecuteCallback failed.\", pe?.InnerException ?? e);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void ExecuteEvent(Event e, bool queueOnFailure = true)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            if (e == null) return;\n\n            using var span = StartActivity();\n\n            using (ScmNDC.Push(BuildNDCTags(e)))\n            {\n\t            // If we have Uid but the lock expired we don't want to process the event as it was persisted and some other worker probably has already picked it.\n\t            if (e.Uid != Guid.Empty && e.LockExpirationDate <= LastProcessDate)\n\t            {\n\t\t            _log.InfoNoPII($\"Aborting event execution - ExecuteEvent called with an event that has an expired lock ({e.LockExpirationDate}) for callback {e.CallbackName}.\");\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t\t            return;\n\t            }\n\n\t            _log.InfoNoPII($\"ExecuteEvent called with callback {e.CallbackName}.\");\n\t            try\n\t            {\n\t\t            Stopwatch sw = Stopwatch.StartNew();\n\t\t            if (e.ActivityUid == Guid.Empty)\n\t\t            {\n\t\t\t            // We expect these to be control codes\n\t\t\t            string comment = (e.CallbackObject == null ? \"\" : e.CallbackObject.ToString());\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            case Event.ControlNames.Abort:\n\t\t\t\t\t            Abort(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForAccountCancel:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tSetPurgeDateForAccountCancel();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForRevisionSuspended:\n\t\t\t\t\t\t\t\tPauseForRevisionSuspended(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.ResumeForSuspendedRevision:\n\t\t\t\t\t\t\t\t ResumeForSuspendedRevision(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.Pause:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t            case Event.ControlNames.Resume:\n\t\t\t\t\t            Resume(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.ResumeFromError:\n\t\t\t\t\t            ResumeFromError(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.StartActivity:\n\t\t\t\t\t            QueueActivityByName(null, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            default:\n\t\t\t\t\t            throw new ApplicationException(string.Format(\"Unhandled event {0}\", e.CallbackName));\n\t\t\t            }\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            // These *may* be control codes.  If they're not control codes, then\n\t\t\t            // we expect them to be a callback to an activity.\n\t\t\t            InstanceActivity activity;\n\t\t\t            if (!_unfinishedActivities.TryGetValue(e.ActivityUid, out activity)) activity = _data.LoadActivityByUid(_instance.AccountId, Constants.WorkflowUser, e.ActivityUid);\n\t\t\t            if (activity == null || activity.InstanceUid != e.InstanceUid) throw new ApplicationException(string.Format(\"Invalid ActivityUid {0} for InstanceUid {1}\", e.ActivityUid, e.InstanceUid));\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            // TODO: Start specific steps, fire specific outputs, complete specific steps, etc.\n\t\t\t\t            default:\n\t\t\t\t\t            ExecuteCallback(activity, e.CallbackName, e.CallbackObject);\n\t\t\t\t\t            break;\n\t\t\t            }\n\t\t            }\n\t\t            if (e.Uid != Guid.Empty) _data.EventSuccess(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventExecuted\")\n\t\t\t\t\t{\n\t\t\t\t\t\tTotalMs = sw.ElapsedMilliseconds,\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid, WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t            wrk.Log();\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t            catch (Exception excp)\n\t            {\n\t\t            _log.ErrorNoPII($\"Error processing eventUid {e.Uid} ({e.CallbackName}).\", excp);\n\t\t            if (!queueOnFailure) throw;\n\t\t            if (e.Uid == Guid.Empty)\n\t\t            {\n\t\t\t            e.NextProcessDate = _data.NextProcessDate();\n\t\t\t            e.ErrorCount = 1;\n\t\t\t            e.LastErrorMessage = excp.Message;\n\t\t\t            _data.CreateEvent(e);\n\t\t\t            WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnExecuteException\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t\t};\n\t\t\t            wrk.Log();\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.EventFailure(e.AccountId, e.Uid, _data.NextProcessDate(), excp.Message);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void Abort(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in _unfinishedActivities.Values)\n                {\n\t                try\n\t                {\n\t\t                IWINSActivity winsActivity = _SafeGetActivity(activity);\n\t\t                IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n\t\t                winsActivity.OnActivityAborted(ctx);\n\t                }\n\t                catch (Exception ex)\n\t                {\n\t\t                _log.ErrorNoPII(string.Format(\"Failed OnActivityAborted AccountId {0}, ActivityUid {1}\", user.AccountId, activity.Uid), ex);\n\t\t\t\t\t}\n                }\n                new WorkflowControlInstance(Model).Abort(user, comment);\n\n\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t{\n\t\t\t\t\tInstanceHandler.Abort(_instance, user, GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime.UtcNow));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Aborted, DateTime.UtcNow);\n\t\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowAborted);\n\t\t\t\t}\n\n\t\t\t\t_ForceReload();\n            }\n        }\n\n        public int SetPurgeDateForAccountCancel()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        var daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForAccountCancel();\n\t\t        _ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t        }\n        }\n\n        public void ClearPurgeDate()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        new WorkflowControlInstance(Model).ClearPurgeDate();\n\t\t        _ForceReload();\n\t        }\n        }\n\n\t\tpublic void Pause(UserAccount user, string comment)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Pause - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).Pause);\n\t\t}\n\n\t\tpublic void PauseForRevisionSuspended(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status == Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - No action taken, instance already paused\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).PauseForRevisionSuspended);\n\t\t}\n\n\t\tpublic void ResumeForSuspendedRevision(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status != Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, instance not paused. Status:{Model.Status}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if instance UpdatedBy has changed since the PauseForRevisionSuspended was invoked, if it has we do not want to do anything.\n\t\t\tif (Model.UpdatedBy != WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, UpdatedBy is not {WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - Resuming\");\n\t\t\tResume(user, comment);\n\t\t\tClearPurgeDate();\n\t\t}\n\n\t\tpublic bool PauseWhenActivityExecutionLimitReached()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Governance, check whether the number of executed activities exceeded the configured limit\n\t\t\t\t_isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(AccountId, Uid, _instance.RevisionUid, _instance.RevisionCreatedDate, ActivityExecutionCount, out _activityExecutionCountEnforcedLimit);\n\n\t\t\t\tif (_isActivityExecutionLimitReached)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum limit (Actual={ActivityExecutionCount}, EnforcedLimit={_activityExecutionCountEnforcedLimit}) and will be paused.\");\n\n\t\t\t\t\tPause(UserAccount.WorkflowUserAccount(AccountId), \"Workflow activity execution limit reached.\");\n\n\t\t\t\t\tTrySendActivityExecutionLimitExceedNotification(SetPurgeDateForAccountCancel());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' activity execution limit\", e);\n\t\t\t}\n\n\t\t\treturn _isActivityExecutionLimitReached;\n\t\t}\n\n\t\tpublic void PauseWhenThrottled(InstanceActivity activity, WorkflowApiRequestThrottledException exception)\n\t\t{\n\t\t\tRequires.NotNull(activity, nameof(InstanceActivity));\n\t\t\tRequires.NotNull(exception, nameof(WorkflowApiRequestThrottledException));\n\n\t\t\tif (exception.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.NotThrottled)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' is not throttled and will not be paused.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tactivity.Status = Enums.WorkflowStepStatus.Paused;\n\t\t\t\tvar throttledByApi = exception.ThrottledApiAsString();\n\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum {throttledByApi} request limit and will be paused. Message: {exception.Message}\");\n\n\t\t\t\tPauseInstance(UserAccount.WorkflowUserAccount(AccountId), $\"{throttledByApi} requests limit reached.\", new WorkflowControlInstance(Model).PauseForWorkflowRateLimitExceed);\n\n\t\t\t\t// Send notification\n\t\t\t\tswitch (exception.WorkflowThrottledStatus)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit:\n\t\t\t\t\t\tTrySendExpressionRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit:\n\t\t\t\t\t\tTrySendSmallBenRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_log.WarnNoPII(\"No notifications sent for unsupported throttle status\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mark instance as throttled for current workflow run session, WorkflowThrottledStatus property is not persisted and refreshed on reload\n\t\t\t\t_instance.WorkflowThrottledStatus = exception.WorkflowThrottledStatus;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception e)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' rate limit request limit with status {exception?.WorkflowThrottledStatus}\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublic int SetPurgeDateForWorkflowRateLimit()\n\t\t{\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tvar daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForWorkflowRateLimit();\n\t\t\t\t_ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid GetAdvancedWorkflowNotificationUserAccountUid()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while retrieving AdvancedWorkflowNotificationUserAccountUid for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\t\t}\n\n\t\tpublic void TrySendSmallBenRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\t// Send notification - pending ATL-90622\n\t\t}\n\n\t\tpublic void TrySendExpressionRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\tif (!ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetEnableWorkflowLimitNotifications(AccountId))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"EnableWorkflowLimitNotifications disabled for account {AccountId}, not sending expression rate limit exceeded notification\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (advancedWorkflowNotificationUserAccountUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {advancedWorkflowNotificationUserAccountUid} to receive expression rate limit exceeded notification\");\n\t\t\t\tUserAccount notificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, advancedWorkflowNotificationUserAccountUid);\n\n\t\t\t\tif (string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"AdvancedWorkflowNotificationUser '{advancedWorkflowNotificationUserAccountUid}' not found or missing email address. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar emailRecipients = new List<string>() { notificationUser.EmailAddress };\n\n\t\t\t\t_log.InfoNoPII($\"Sending expression rate limit exceeded notification to user '{advancedWorkflowNotificationUserAccountUid}' for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseExpressionRateLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowInstanceId = _instance.Id,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Resume(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).Resume(user, comment);\n                _ForceReload();\n            }\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Resume(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n        }\n\n        public void ResumeFromError(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).ResumeFromError(user, comment);\n                _ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.ResumeFromError(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n\t\t}\n\n        public void SaveToDatabase()\n        {\n            // We may have in-memory events that need to be saved to the db.\n\t\t\tPersistEvents();\n            _PersistVariables();\n        }\n\n        public void SaveEventsToDatabase()\n        {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPersistEvents();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save unsaved events for instance {Uid} to db\", e);\n\t\t\t}\n\t\t}\n\n\t    public void ArchiveVariables()\n        {\n            var incompleteActivities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, _instance.Uid);\n            // don't archive if there are any incomplete activites besides the one that has triggered this\n            if (incompleteActivities != null && incompleteActivities.Count > 1)\n            {\n                return;\n            }\n            _data.ArchiveVariables(AccountId, Constants.WorkflowUser, Uid);\n        }\n\n\t    public bool HasExistingLockExpired()\n\t    {\n\t\t    return LockExpirationDate < DateTime.UtcNow;\n\t    }\n\n\n        /// <summary>\n        /// Replaces variables provided in the dictionary returning replaced variables\n        /// </summary>\n        public void SetVariables(\n\t        InstanceActivity instanceActivity,\n\t        Dictionary<string, object> variables,\n\t        out List<InstanceVariable> oldVariables,\n\t        out bool areVariablesOverTotalSizeLimit,\n\t        out int totalVariablesSizeBytes,\n\t        out int totalVariablesSizeLimitBytes,\n\t\t\tout Dictionary<string, int> oversizedVariables,\n\t        out int variableValueSizeLimitBytes)\n        {\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            _log.DebugWithPII($\"SetVariables called for ActivityUid {instanceActivity.Uid} ({{0}}).\", instanceActivity.Name);\n\n            // We create the context so that the variable dictionaries get populated\n            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n            oldVariables = new List<InstanceVariable>();\n            var newVariables = UpdateVariablesHelper.PopulateContextVariables(ctx, this.Model, variables);\n\n            // Only set variables that are under the size limit\n\t\t\toversizedVariables = InstanceVariableGovernance.GetOversizedVariables(ctx.AccountId, newVariables, ctx.SubmittedDate, out variableValueSizeLimitBytes);\n\t\t\tforeach (InstanceVariable variable in newVariables)\n\t\t\t{\n\t\t\t\tif (!oversizedVariables.ContainsKey(variable.Name))\n\t\t\t\t{\n\t\t\t\t\toldVariables.Add(Variables[variable.Name]);\n\t\t\t\t\t// we could do \"ctx.Variables.Set(variable.Key, variable.Value);\" but that would log as the instanceActivity and we don't want that...\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Undo setting the variables, if the instance's total variable size exceeds the limit\n\t\t\tareVariablesOverTotalSizeLimit = InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(ctx.AccountId,\n\t\t\t\tVariables.Select(x => x.Value), ctx.SubmittedDate, activityConfiguration: null, out totalVariablesSizeBytes, out totalVariablesSizeLimitBytes);\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tforeach (InstanceVariable variable in oldVariables)\n\t\t\t\t{\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n        }\n\n        public DateTime GetLastAbortNotificationDate()\n        {\n\t        if (!_contextInitialized)\n\t        {\n\t\t        _LoadVariables();\n            }\n\n\t        if (_variables.TryGetValue(WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE, out InstanceVariable lastNotificationDate) &&\n\t            DateTime.TryParse(lastNotificationDate.Value.ToString(), out DateTime dateTime))\n\t        {\n\t\t        return dateTime;\n\t        }\n\n            return DateTime.MinValue;\n        }\n\n        public void SaveLastAbortNotificationDate(int accountId, Guid workflowInstanceUid, DateTime lastAbortNotificationDate)\n        {\n            var variable = InstanceVariable.CreateFromValue(\n\t            accountId,\n\t            workflowInstanceUid,\n\t            WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE,\n\t            Enums.WorkflowVariableType.Date,\n\t            lastAbortNotificationDate);\n\n            ServiceLocator.GetInstance<IInstanceVariablePersistence>().Save(Constants.WorkflowUser, variable);\n\n        }\n\n        /// <summary>\n        /// Called when we've finished work on an activity -- either executing it or performing a callback on it.\n        /// </summary>\n        private void _ActivityWorkCompleted(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx, Stopwatch sw)\n        {\n\t        // If it's flagged as completed, update in the db, queue up any next activities, and remove it from our list.\n            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n            {\n                _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n                SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t\tlock (_unfinishedActivities)\n                {\n                    if (_unfinishedActivities.ContainsKey(instanceActivity.Uid)) _unfinishedActivities.Remove(instanceActivity.Uid);\n                }\n            }\n            else\n            {\n                // Otherwise, it's still running.  Flag it as waiting so it doesn't get processed again.\n                instanceActivity.Status = Enums.WorkflowStepStatus.Waiting;\n                _data.SaveInstanceActivity(instanceActivity);\n            }\n\n            _log.InfoWithPII($\"_ActivityWorkCompleted done for Activity ({{0}}) in status: {instanceActivity.Status} ({sw.ElapsedMilliseconds} ms).\", instanceActivity.Name);\n\n\n            // log workload data\n            try\n            {\n                WorkflowWorkload ww = new WorkflowWorkload();\n                ww.Add(ctx);\n                ww.TotalMs = sw.ElapsedMilliseconds;\n\t\t\t\tww.StartTime = DateTime.UtcNow.AddMilliseconds(-ww.TotalMs);\n                ww.Status = instanceActivity.Status.ToString();\n                ww.Output = instanceActivity.Output;\n                ww.ActivityCreatedDate = instanceActivity.CreatedDate;\n                ww.ActivityStartDate = instanceActivity.StartDate;\n                if (DateTime.MinValue < instanceActivity.EndDate && instanceActivity.EndDate < DateTime.MaxValue)\n                    ww.ActivityEndDate = instanceActivity.EndDate;\n                if (DateTime.MinValue < _instance.CreatedDate && _instance.CreatedDate < DateTime.MaxValue)\n\t                ww.InstanceCreatedDate = _instance.CreatedDate;\n                ww.ActivityKind = activity.Kind.ToString();\n                ww.RevisionUid = _instance.RevisionUid.ToString();\n\t\t\t\tww.DefinitionUid = _instance.DefinitionUid.ToString();\n\t\t\t\tww.WorkflowDB = DataStore.GetDbNameForAccount(instanceActivity.AccountId);\n\n\t\t\t\tww.Log();\n            }\n            catch (Exception ex)\n            {\n                _log.WarnNoPII(\"Failed to log workload.\", ex);\n            }\n        }\n\n\t\tprivate void CompleteScopeStep(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n            try\n            {\n                if (IsTrackItActivity(activity))\n                {\n                    Documents documents = null;\n                    if (ctx.TrackActivity())\n                    {\n                        documents = ((ITrackItActivity)activity).GetDocuments(ctx);\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, instanceActivity.Uid,\n                            documents, instanceActivity.Output, instanceActivity.Status,\n                            instanceActivity.EndDate);\n                    }\n\n                    WorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n                    {\n                        AccountId = ctx.AccountId,\n                        Documents = documents?.Select(d => new WorkflowScopeEvent.DocumentDetail() { Uid = d.Uid, Name = d.Name }).ToList(),\n                        ScopeUid = ctx.ScopeUid,\n                        ScopeName = ctx.ScopeName,\n                        StepName = instanceActivity.Name,\n                        StepDisplayName = GetActivityDisplayName(activity, ctx),\n                        StepTypeName = instanceActivity.ActivityTypeName,\n                        StepUid = instanceActivity.Uid,\n                        PeriodStart = instanceActivity.EndDate,\n                        EventType = (int)ScopeEventType.StepFinished,\n                        Output = instanceActivity.Output,\n                        WorkflowUid = ctx.WorkflowInstanceUid,\n                        WorkflowName = ctx.WorkflowName\n                    };\n                    WorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n                    {\n                        EventData = scopeEventData\n                    };\n                    EventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.StepFinished}\", ex);\n            }\n        }\n\n        private void SaveInstanceActivityVariables(InstanceActivity instanceActivity, IWINSWorkflowContext ctx)\n        {\n\t        if (ctx.WorkflowUserAccount.Account.Settings.EnableWorkflowVariableHistory)\n\t        {\n\t\t        var instanceVariableRepository = ServiceLocator.GetInstance<IInstanceVariableRepository>();\n\t\t        instanceVariableRepository.SaveVariableHistory(instanceActivity.AccountId, ctx.WorkflowUserAccount.Uid,\n\t\t\t        instanceActivity.InstanceUid, instanceActivity.Uid, ctx.Variables.GetAllVariables());\n\t        }\n        }\n\n        private List<WINSWorkflowContextWINSActivity> GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime endDate)\n        {\n\t\t\tvar list = new List<WINSWorkflowContextWINSActivity>();\n\n\t\t\tif (!HasUnfinishedActivities) return list;\n\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values);\n            }\n\n            IWINSWorkflowContext ctx = null;\n            foreach (var activity in activities)\n            {\n                var winsActivity = _SafeGetActivity(activity);\n                ctx = _CreateContext(winsActivity, activity);\n\n                if (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n                {\n\t\t\t\t\tlist.Add(new WINSWorkflowContextWINSActivity { EndDate = endDate, WINSActivity = winsActivity, WINSWorkflowContext = ctx });\n\t\t\t\t}\n            }\n\n\t\t\treturn list;\n        }\n\n\t\tprivate void AbortOrFailScopeStep(Enums.WorkflowStepStatus status, DateTime endDate)\n\t\t{\n\t\t\tif (!HasUnfinishedActivities) return;\n\n\t\t\tList<InstanceActivity> activities;\n\t\t\tlock (_unfinishedActivities)\n\t\t\t{\n\t\t\t\tactivities = new List<InstanceActivity>(_unfinishedActivities.Values);\n\t\t\t}\n\t\t\tIWINSWorkflowContext ctx = null;\n\t\t\tforeach (var activity in activities)\n\t\t\t{\n\t\t\t\tvar winsActivity = _SafeGetActivity(activity);\n\t\t\t\tctx = _CreateContext(winsActivity, activity);\n\n\t\t\t\tif (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n\t\t\t\t{\n\t\t\t\t\tvar documents = ((ITrackItActivity)winsActivity).GetDocuments(ctx);\n\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, activity.Uid, documents, null, status, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool _CheckWaitingActivities()\n        {\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values.Where(n => n.Status == Enums.WorkflowStepStatus.Waiting));\n            }\n            bool success = false;\n            foreach (InstanceActivity activity in activities)\n            {\n                if (CheckActivityForCompletion(activity)) success = true;\n            }\n            return success;\n        }\n\n        private bool _contextInitialized = false;\n        private IWINSWorkflowContext _CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n            IWINSWorkflowContext ctx = CreateContext(activity, instanceActivity);\n            AtlasContext.Current.UserAccount = ctx.WorkflowUserAccount;\n            // Only do this once.  If it's been done, it's done.\n            if (_contextInitialized) return ctx;\n\n            // This all depends on the properties for the Start step.  We always want a Start step for normal processing;\n            // however, we don't necessarily have a Start step for our tests.\n            StartActivity start = _workflowMap.StartActivity;\n            if (start == null)\n            {\n                if (_data.IsTest) return ctx;\n                throw new ApplicationException(string.Format(\"Cannot find StartActivity for InstanceUid {0}\", _instance.Uid));\n            }\n\n            // Contents\n            string[][] contents = start.DefinedContents;\n            if (contents != null && contents.Length > 0)\n            {\n                foreach (string[] t in contents)\n                {\n                    ContentDefinition definition = new ContentDefinition(t);\n                    if (!_contentDefinitions.ContainsKey(definition.Name)) _contentDefinitions[definition.Name] = definition;\n                }\n            }\n\n            _LoadVariables();\n\n            // XML Variables\n            // Because XmlVariables have dependencies on the variables as well, it's easier to feed this through the xml variable handler\n            // rather than replicate the code.\n            List<IXmlVariableDefinition> definitions = start.DefinedXmlVariables;\n            if (definitions != null && definitions.Count > 0)\n            {\n                foreach (IXmlVariableDefinition definition in definitions)\n                {\n                    if (!_xmlVariableDefinitions.ContainsKey(definition.Name)) ctx.XmlVariables.Declare(definition, logMessage: false);\n                }\n            }\n\n            _contextInitialized = true;\n            return ctx;\n\t\t}\n\n        public IWINSWorkflowContext CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowContextFactory>().CreateWorkflowContext(this, activity, instanceActivity);\n        }\n\n\t\tprivate void _LoadVariables()\n        {\n\t        // Variables\n\t        Dictionary<string, InstanceVariable> variables = _data.LoadVariablesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n\t        foreach (InstanceVariable variable in variables.Values)\n\t        {\n\t\t        if (!_variables.ContainsKey(variable.Name)) _variables[variable.Name] = variable;\n\t        }\n        }\n\n        private bool _ExecuteFirstActivity()\n        {\n            InstanceActivity activity = null;\n            lock (_unfinishedActivities)\n            {\n                if (_unfinishedActivities.Count > 0) activity = _unfinishedActivities.Values.FirstOrDefault(n => n.Status == Enums.WorkflowStepStatus.Pending || n.Status == Enums.WorkflowStepStatus.Executing);\n            }\n            if (activity == null) return false;\n            ExecuteActivity(activity);\n            return true;\n        }\n\n        private bool _ExecuteFirstEvent(bool controlOnly = false)\n        {\n            // We always try to execute control events first.\n            Event e = null;\n            lock (_queuedControlEvents)\n            {\n                if (_queuedControlEvents.Count > 0) e = _queuedControlEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            // If we're only caring about control events, we can quit now.\n            if (controlOnly) return false;\n\n            // Otherwise, we do the same thing with the rest of the events.\n            lock (_queuedEvents)\n            {\n                if (_queuedEvents.Count > 0) e = _queuedEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            return false;\n        }\n\n        private void _ForceReload()\n        {\n            // Reload the object to get new state -- we do this inside the lock so that there's no race condition\n            // between this and a worker who may be working on the object\n            lock (_lockObject)\n            {\n                Guid instanceUid = Uid;\n                _instance = _data.LoadInstanceByUid(AccountId, Constants.WorkflowUser, instanceUid);\n                if (_instance == null) throw new ApplicationException(string.Format(\"Failed to reload instanceUid: {0}\", instanceUid));\n            }\n        }\n\n        private void _MarkCompleted()\n        {\n\t        if (_instance.IsCompleted)\n\t        {\n\t\t        _log.InfoNoPII($\"Instance {_instance.Uid} is already complete with status {_instance.Status}\");\n\t\t        return;\n\t        }\n\n            _PersistVariables();\n            bool endActivityFailure = _workflowMap.HasEndActivity() && !_instance.EndActivityReached;\n            Enums.WorkflowStepStatus endStatus = endActivityFailure ? Enums.WorkflowStepStatus.Failed : Enums.WorkflowStepStatus.Completed;\n            _data.SaveInstance(_instance);\n            _data.InstanceCompleted(_instance, endStatus);\n\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Complete(_instance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventType = _instance.Status == Enums.WorkflowStepStatus.Failed ? ScopeEventType.WorkflowFailed : ScopeEventType.WorkflowFinished;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t{\n\t\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\t\tPeriodStart = _instance.EndDate,\n\t\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\t\tWorkflowName = _instance.Name\n\t\t\t\t\t};\n\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t\t{\n\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t};\n\t\t\t\t\tEventRepo.FireEvent(_instance.AccountId, scopeEvent);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event {_instance.ScopeUid} for eventtype {eventType}\", ex);\n\t\t\t\t}\n\t\t\t}\n\n            if (endActivityFailure && _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                if (_lastActivityUid == Guid.Empty)\n                {\n                    _log.WarnNoPII($\"No activities for workflow.\");\n                }\n                else\n                {\n                    InstanceActivity activity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, _lastActivityUid);\n                    IWINSActivity winsActivity = _SafeGetActivity(activity);\n                    IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n                    LoggingHelper.LogActivityErrorNoPII(ctx, Resources.WINSResources.WorkflowExitedWithoutReachingTheEndActivity);\n                }\n\n            }\n            if (_instance.Status == Enums.WorkflowStepStatus.Completed || _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n            }\n        }\n\n        private void _MarkWaiting()\n        {\n            _PersistVariables();\n            _instance.Status = Enums.WorkflowStepStatus.Waiting;\n            _data.SaveInstance(_instance);\n        }\n\n        private void _PersistVariables()\n        {\n            InstanceVariables variables = new InstanceVariables();\n            foreach (InstanceVariable variable in _variables.Values) if (variable.IsModified) variables.Add(variable);\n            _data.SaveInstanceVariables(AccountId, Constants.WorkflowUser, variables);\n        }\n\n        private void PersistEvents()\n\t\t{\n\t\t\tlock (_queuedControlEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedControlEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedControlEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlock (_queuedEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        private void PersistEvent(Event e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_data.CreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_data.UnlockEvent(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventUnlockedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save event {e.Uid}, for instance {e.InstanceUid}, activity {e.ActivityUid}, and callback name {e.CallbackName} to db\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate IWINSActivity _SafeGetActivity(InstanceActivity instanceActivity)\n        {\n            try\n            {\n                IWINSActivity activity;\n                if (_workflowMap.TryGetActivity(instanceActivity.Name, out activity)) return activity;\n                // There is a problem with old MWF workflow data where the name of the activity is really the type name.\n                // Don't ask.  It's a stupid and boring story.\n                // But we still should handle it, at least for awhile.  So: if we get here because we didn't match name, we should see\n                // if we match type name.\n                // This whole thing is a huge hack that should get removed when it can.\n                InstanceActivity inputActivity = null;\n                if (instanceActivity.InputActivityUid != Guid.Empty) inputActivity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, instanceActivity.InputActivityUid);\n                if (_workflowMap.LegacyTryGetActivityByTypeName(instanceActivity.Name, inputActivity == null ? \"\" : inputActivity.Name, instanceActivity.InputActivityOutput ?? \"\", out activity))\n                {\n                    // Rename it so we get one less instance of this in the future\n                    instanceActivity.Name = activity.Name;\n                    return activity;\n                }\n                throw new ApplicationException(string.Format(\"Invalid activity name '{0}' for instanceUid '{1}'.\", instanceActivity.Name, instanceActivity.InstanceUid));\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"_SafeGetActivity failed.\", e);\n                return null;\n            }\n        }\n\n        private bool _ShouldProcess(InstanceActivity instanceActivity)\n        {\n            switch (instanceActivity.Status)\n            {\n                case Enums.WorkflowStepStatus.Executing:\n                case Enums.WorkflowStepStatus.Pending:\n                case Enums.WorkflowStepStatus.Waiting:\n                case Enums.WorkflowStepStatus.Aborted:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool _ShouldProcess()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        private bool _ShouldProcessEvent()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                    case Enums.WorkflowStepStatus.Aborted:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        //ITrackItActivity interface is implemented by activities whose data is tracked in DocumentScope and ScopeEvent tables.\n        private bool IsTrackItActivity(IWINSActivity activity)\n        {\n            return activity is ITrackItActivity;\n        }\n\n\t\tprivate void FireWorkflowScopeEvent(UserAccount user, ScopeEventType eventType, IWINSActivity activity = null, IWINSWorkflowContext ctx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo\n\t\t\t\t{\n\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\tPeriodStart = DateTime.UtcNow,\n\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\tWorkflowName = _instance.Name,\n\t\t\t\t\tEventBy = user == null ? null : new WorkflowScopeEvent.Assignee() { Email = user.EmailAddress, Name = user.FriendlyName, Uid = user.Uid }\n\t\t\t\t};\n\n\t\t\t\tif (activity != null && ctx != null)\n\t\t\t\t{\n\t\t\t\t\tscopeEventData.StepName = ctx.ActivityName;\n\t\t\t\t\tscopeEventData.StepDisplayName = GetActivityDisplayName(activity, ctx);\n\t\t\t\t\tscopeEventData.StepTypeName = ctx.ActivityTypeName;\n\t\t\t\t\tscopeEventData.StepUid = ctx.ActivityUid;\n\t\t\t\t}\n\n\t\t\t\tEventRepo.FireEvent(_instance.AccountId, new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t{\n\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event scopeUid: {_instance.ScopeUid}, instanceUid: {_instance.Uid} eventType: {eventType}\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void RemoveProperties(InstanceActivity instanceActivity, IWINSActivity activity)\n\t    {\n\t\t    // We need to delete properties if this is not a human activity or WaitForNextStepAfterCompletion is not set\n\t\t    if (activity is AbstractHumanActivity && ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetWaitForNextStepAfterCompletion(instanceActivity.AccountId))\n\t\t    {\n\t\t\t\t_data.DeleteActivityPropertiesWithExclusion(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, new List<string> { nameof(AbstractHumanActivity.WaitForNextStep) });\n\t\t\t\t_log.InfoNoPII(\"Removing activity properties except WaitForNextStep\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    _data.DeleteActivityProperties(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid);\n\t\t\t    _log.InfoNoPII(\"Removing activity properties\");\n\t\t    }\n\t    }\n\n\t\tprivate string[] BuildNDCTags(InstanceActivity instanceActivity) => instanceActivity != null ? new[] { $\"ActivityId:{instanceActivity.Uid}\",$\"W:{instanceActivity.InstanceUid}\" } : new string[] { };\n\t    private string[] BuildNDCTags(Event e) => e != null ? new[] { $\"ActivityId:{e.ActivityUid}\", $\"W:{e.InstanceUid}\" } : new string[] { };\n\n\t\t/// <summary>\n\t\t/// Try to send an e-mail to support when a workflow instance activity execution account exceeds configured threshold.\n\t\t/// </summary>\n\t\t/// <param name=\"pausedPurgeDays\">Number of days to purge workflow related data</param>\n\t\t/// <returns>\n\t\t/// True\t-> Success.\n\t\t/// False\t-> Fail to send email.\n\t\t/// </returns>\n\t\tprivate bool TrySendActivityExecutionLimitExceedNotification(int pausedPurgeDays)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\t// Support should get the email\n\t\t\t\tvar supportEmailAddress = WorkflowSettingRepository.GetSupportNotificationEmailAddress(AccountId);\n\t\t\t\tif (!string.IsNullOrEmpty(supportEmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(supportEmailAddress);\n\t\t\t\t}\n\n\t\t\t\t// Also send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive activity execution limit exceeded notification\");\n\t\t\t\t\tnotificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, notificationUserUid);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Email support address setting is empty, and there is no AdvancedWorkflowNotificationUser configured. Thus, not sending activity execution limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Sending activity execution limit exceeded notification to {emailRecipients.Count} {(emailRecipients.Count > 1 ? \"recipients\" : \"recipient\")} for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseActivityExecutionLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowRevisionUid = _instance.RevisionUid,\n\t\t\t\t\tNumberOfActivitiesExecuted = ActivityExecutionCount,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetActivityDisplayName(IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n\t\t\treturn activity is AbstractHumanActivity abstractHumanActivity\n\t\t\t\t? abstractHumanActivity.ActivityDisplayName.Evaluate(ctx)\n\t\t\t\t: null;\n\t\t}\n\n\t\tprivate bool ShouldUseScopeEventHandler() => WorkflowFeatureFlags.UseScopeEventHandler &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t Model?.EngineVersion == Core.Workflow.Constants.EngineVersionV2;\n\n\t\tprivate void PauseInstance(UserAccount user, string comment, Action<UserAccount, string> pauseMethod)\n\t\t{\n\t\t\tRequires.NotNull(pauseMethod, nameof(pauseMethod));\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tpauseMethod(user, comment);\n\t\t\t\t_ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Pause(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowPaused);\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{\n\t\t\tvar environmentType = SiteConfig?.Value?.EnvironmentType;\n\t\t\tvar isGrpcEnabled = WorkflowClientConfig?.Value?.IsGrpcClientEnabled == true;\n\n\t\t\tvar isRunningOnCloudWithGrpcEnabled = environmentType == Core.Util.Config.EnvironmentType.Cloud && isGrpcEnabled;\n\n\t\t\tif (isRunningOnCloudWithGrpcEnabled && InstanceStateChangedHelper.IsInstanceStateChanged(_instance.Uid, ActivityExecutionCount, CacheRepository, WorkflowSettingRepository))\n\t\t\t{\n\t\t\t\t_ForceReload();\n\t\t\t\tInstanceStateChangedHelper.RemoveInstanceStateChanged(_instance.Uid, CacheRepository);\n\t\t\t}\n\t\t}\n    }\n}\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
      "content": "#if NET\n#nullable enable\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService\n{\n    private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore\n#endif\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing CLM.MessageDefines.Event;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.Services.MessageWorkerService.Event;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Interfaces;\nusing CLM.MessageDefines.Constants;\nusing DocuSign.CLM.Monitoring;\nusing SCMAppenders;\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing DocuSign.DynamicSettings;\nusing ADEXS.Core.Workflow.Services.Interfaces;\nusing ADEXS.Core.Workflow.Config;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\n\nnamespace ADEXS.WINS.Engine\n{\n\tpublic class WorkflowManager\n\t{\n\t\tprivate delegate void InstanceSetupDelegate(WorkflowInstance instance);\n\n\t\tpublic static readonly string DefaultEventMSMQName = \"AtlasEventsForWins\";\n\t\tpublic static readonly string MSMQPathAtlasEventsFormat = \"FormatName:Direct=OS:{0}\\\\Private$\\\\{1}\";\n\n\t\tprivate static WorkflowManager _instance = null;\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowManager));\n\n\t\t// Abort notification milestones\n\t\tprivate const int OneDay = 1;\n\t\tprivate const int OneWeek = 7;\n\t\tprivate const int OneMonth = 30;\n\t\tprivate const double TenPercent = .1;\n\t\tprivate const double TwentyFivePercent = .25;\n\t\tprivate const double FiftyPercent = .5;\n\n\t\tpublic static WorkflowManager Instance\n\t\t{\n\t\t\tget { return _instance ?? (_instance = new WorkflowManager(new WINSDataStore())); }\n\t\t\tprotected set { _instance = value; }\n\t\t}\n\n\t\tpublic delegate void NeedWorkEvent();\n\t\tpublic delegate void WorkReceivedEvent();\n\n\t\tpublic event NeedWorkEvent OnNeedWorkEvent;\n\t\tpublic event WorkReceivedEvent OnWorkReceivedEvent;\n\n\t\tprivate readonly IWINSDataStore _data;\n\t\tprivate readonly ThreadSafeDictionary<Guid, WorkflowInstance> _instances = new ThreadSafeDictionary<Guid, WorkflowInstance>();\n\t\tprivate readonly ThreadSafeDictionary<int, Enums.AccountStatus> _recentAccountStatus = new ThreadSafeDictionary<int, Enums.AccountStatus>();\n\t\t// Set to true when we're given work; if this is true and we have no more work for the workers (GetFirstUnlockedInstance returns null),\n\t\t// this will signal the NeedWorkEvent and set itself to false.  \n\t\tprivate bool _signalNeedWork = false;\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepo;\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepo => (_workflowSettingRepo ?? (_workflowSettingRepo = ServiceLocator.GetInstance<IWorkflowSettingRepository>()));\n\n\t\tprivate IGovernor _governor;\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\n\t\tprivate IRevisionService _revisionService;\n\t\tprivate IRevisionService RevisionService => _revisionService ?? (_revisionService = ServiceLocator.GetInstance<IRevisionService>());\n\n\t\t// Integration Tests pass false for the selfRegister param so they do not cause erroneous event registration\n\t\tpublic WorkflowManager(IWINSDataStore data, bool selfRegister = true)\n\t\t{\n\t\t\t_data = data;\n\t\t\tstring configuredLocalQueueName = Path.GetFileNameWithoutExtension(Configuration.GetStringAppSetting(\n\t\t\t\tEventDispatchedWorkerEventsSettings.EventDispatchedWorkerEventQueuePath,\n\t\t\t\tstring.Format(MSMQPathAtlasEventsFormat, Environment.MachineName, DefaultEventMSMQName)));\n\n\t\t\t// self register for AccountStatusEvent\n\t\t\tEventRegistration reg = new EventRegistration\n\t\t\t{\n\t\t\t\tDestPath = string.Format(MSMQPathAtlasEventsFormat, Environment.MachineName, configuredLocalQueueName),\n\t\t\t\tEvent = ScmEnums.EventType.AccountStatus,\n\t\t\t};\n\t\t\tServiceLocator.GetInstance<IEventRepository>().SelfRegisterForEvent(UserAccount.WorkflowUserAccount(Constants.AllAccounts), reg);\n\n\t\t\t// self register for WorkflowSuspended\n\t\t\treg = new EventRegistration\n\t\t\t{\n\t\t\t\tDestPath = string.Format(MSMQPathAtlasEventsFormat, Environment.MachineName, configuredLocalQueueName),\n\t\t\t\tEvent = ScmEnums.EventType.WorkflowRevisionSuspension,\n\t\t\t};\n\t\t\tServiceLocator.GetInstance<IEventRepository>().SelfRegisterForEvent(UserAccount.WorkflowUserAccount(Constants.AllAccounts), reg);\n\t\t}\n\n\t\tinternal bool AccountWasRecentlySuspended(int accountId)\n\t\t{\n\t\t\tvar isSuspended =  _recentAccountStatus.ContainsKey(accountId) && _recentAccountStatus[accountId] == Enums.AccountStatus.Suspended;\n\t\t\tif (isSuspended) return true;\n\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetIsSuspended(accountId);\n\t\t}\n\n\t\tinternal bool AccountWasRecentlyCancelled(int accountId)\n\t\t{\n\t\t\treturn _recentAccountStatus.ContainsKey(accountId) && _recentAccountStatus[accountId] == Enums.AccountStatus.Cancelled;\n\t\t}\n\n\t\tinternal bool AccountCanHaveActiveWorkflow(Enums.AccountStatus status)\n\t\t{\n\t\t\treturn (status == Enums.AccountStatus.Suspended || status == Enums.AccountStatus.Paid || status == Enums.AccountStatus.Trial);\n\t\t}\n\n\t\tinternal void ProcessAccountStatusChange(int accountId, Enums.AccountStatus status)\n\t\t{\n\t\t\t_recentAccountStatus[accountId] = status;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// This app setting name references \"Abort\" for historical reasons.\n\t\t\t\t// Check is actually to see whether we should Pause workflow instances, not Abort them\n\t\t\t\tif (!AccountCanHaveActiveWorkflow(status) && Configuration.GetBooleanAppSetting(\"WorkflowManagerAbortWorkflowOnAccountStatus\", true))\n\t\t\t\t{\n\t\t\t\t\t_data.PauseAllWorkflowsForAccountCancel(accountId, Constants.WorkflowUser);\n\t\t\t\t\t_data.SetPurgeDateForAllPausedWorkflows(accountId, Constants.WorkflowUser);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"WorkflowManager:ProcessAccountStatusChange - Trouble aborting workflow for account Id {accountId}.\", ex);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Suspends revision and pauses all workflow instances of the revision\n\t\t/// </summary>\n\t\tinternal void SuspendRevision(int accountId, Guid revisionUid)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar revision = _data.LoadRevisionByUid(accountId, Constants.WorkflowUser, revisionUid);\n\t\t\t\tif (revision != null && revision.Status == Enums.WorkflowRevisionStatus.Suspended)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"WorkflowManager:SuspendRevision - Status is already {revision.Status} for revision Id {revisionUid} in  account Id {accountId} - No action taken.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"WorkflowManager:SuspendRevision - Suspending revision Id {revisionUid} in account Id {accountId}\");\n\t\t\t\t_data.SuspendRevision(accountId, Constants.WorkflowUser, revisionUid); // Set revision status\n\n\t\t\t\tif (!Core.Domain.FeatureFlags.WorkflowFeatureFlags.DisablePauseEventsForRevisionSuspended)\n\t\t\t\t{\n\t\t\t\t\t_data.InsertPausesForRevisionSuspendedEvents(accountId, Constants.WorkflowUser, revisionUid); // Inserts PauseForRevisionSuspended workflow events\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"WorkflowManager:SuspendRevision - Pause for Revision suspended is disabled, revision Id {revisionUid} in account Id {accountId}\");\n\t\t\t\t}\n\n\t\t\t\tTrySendRevisionSuspensionNotification(revision);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t\t_log.ErrorNoPII($\"WorkflowManager:SuspendRevision - Trouble setting revision status/inserting PauseForRevisionSuspended workflow events for revision Id {revisionUid} in  account Id {accountId}.\", ex);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Unsuspends revision and resumes all workflow instances of the revision\n\t\t/// </summary>\n\t\tinternal void UnsuspendRevision(int accountId, Guid revisionUid)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar revision = _data.LoadRevisionByUid(accountId, Constants.WorkflowUser, revisionUid);\n\t\t\t\tif (revision != null && revision.Status == Enums.WorkflowRevisionStatus.Published)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"WorkflowManager:UnsuspendRevision - Status is already {revision.Status} for revision Id {revisionUid} in  account Id {accountId} - No action taken.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t_log.WarnNoPII($\"WorkflowManager:SuspendRevision - Unsuspending revision Id {revisionUid} in  account Id {accountId}\");\n\t\t\t\t_data.UnsuspendRevision(accountId, Constants.WorkflowUser, revisionUid); // Set revision status\n\t\t\t\t_data.InsertResumeForSuspendedRevisionEvents(accountId, Constants.WorkflowUser, revisionUid); // Inserts ResumeForSuspendedRevision workflow events\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t\t_log.ErrorNoPII($\"WorkflowManager:UnsuspendRevision - Trouble setting revision status/inserting PauseForRevisionSuspended workflow events for revision Id {revisionUid} in  account Id {accountId}.\", ex);\n\t\t\t}\n\t\t}\n\n\t\tinternal void UpdateRecentAccountStatus(int accountId, Enums.AccountStatus status)\n\t\t{\n\t\t\t_recentAccountStatus[accountId] = status;\n\t\t\t_log.InfoNoPII($\"WorkflowManager:UpdateRecentAccountStatus - updating account {accountId} to status {status}\");\n\t\t}\n\n\t\tpublic int Count { get { return _instances.Count; } }\n\n\t\t/// <summary>\n\t\t/// Creates a new instance.\n\t\t/// </summary>\n\t\tpublic Guid CreateNewInstance(int accountId, Guid revisionUid, StartParameters startParameters, Guid instanceUid = default(Guid), bool ignoreLimit = false)\n\t\t{\n\t\t\tRevision revision = _data.LoadRevisionByUid(accountId, Constants.WorkflowUser, revisionUid);\n\t\t\tif (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, revisionUid));\n\t\t\tValidateRevisionIsNotSuspended(accountId, revision);\n\n\t\t\tWorkflowMap workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n\t\t\treturn CreateNewInstance(accountId, revision, workflowMap, startParameters, instanceUid, ignoreLimit);\n\t\t}\n\n\t\tpublic Guid CreateNewInstance(int accountId, Revision revision, WorkflowMap workflowMap, StartParameters startParameters, Guid instanceUid = default(Guid), bool ignoreLimit = false )\n\t\t{\n\t\t\tValidateRevisionIsNotSuspended(accountId, revision);\n\n\t\t\tvar documentScopeRepository = ServiceLocator.GetInstance<IDocumentScopeRepository>();\n\n\t\t\tInstance instance = new Instance(revision)\n\t\t\t{\n\t\t\t\tStartBPMUserUid = startParameters.Submitter == null ? Guid.Empty : startParameters.Submitter.Uid,\n\t\t\t\tParametersXml = startParameters.ParametersXml,\n\t\t\t\tParentActivityUid = startParameters.ParentActivityUid,\n\t\t\t\tAlertParent = startParameters.AlertParent,\n\t\t\t\tUid = instanceUid,\n\t\t\t\tScopeUid = startParameters.ScopeUid == Guid.Empty? Guid.NewGuid() : startParameters.ScopeUid,\n\t\t\t\tSourceType = startParameters.SourceType,\n\t\t\t\tSourceId = startParameters.SourceId\n\t\t\t};\n\t\t\tif (!string.IsNullOrWhiteSpace(startParameters.RoutingApprovalInstanceName))\n\t\t\t{\n\t\t\t\tinstance.Name = startParameters.RoutingApprovalInstanceName;\n\t\t\t\tinstance.FromApproval = true;\n\t\t\t}\n\n\t\t\tinstance.ScopeName = documentScopeRepository.GetScopeByUid(accountId, instance.ScopeUid)?.Name;\n\n\t\t\tif (string.IsNullOrEmpty(instance.ParametersXml)) instance.ParametersXml = WorkflowParameterBuilder.GetEmptyParametersAsString();\n\n\t\t\t// If we don't save successfully, but it's for a handled reason (eg, duplicate) then we just quit now.\n\t\t\tif (_data.CreateInstance(instance) != InstancePersistence.CreateResult.Success) return instance.Uid;\n\n\t\t\t// At this point we have a newly created instance\n\t\t\tGovernor.IncrementStartInstanceCount(accountId);\n\n\t\t\tif (startParameters.InitialVariables != null && startParameters.InitialVariables.Count > 0)\n\t\t\t{\n\t\t\t\tInstanceVariables variables = new InstanceVariables();\n\t\t\t\tforeach (InstanceVariable initialVariable in startParameters.InitialVariables)\n\t\t\t\t{\n\t\t\t\t\tInstanceVariable variable = new InstanceVariable(initialVariable.AccountId, instance.Uid, initialVariable.Name, initialVariable.Type);\n\t\t\t\t\tvariable.Value = initialVariable.Value;\n\t\t\t\t\tvariable.IsSecret = initialVariable.IsSecret;\n\n\t\t\t\t\tvariables.Add(variable);\n\t\t\t\t}\n\t\t\t\t_data.SaveInstanceVariables(accountId, Constants.WorkflowUser, variables);\n\t\t\t}\n\n\t\t\tbool reachedMaxInstancesInMemory = false;\n\t\t\tbool alreadyMaxedOutForAccount = false;\n\t\t\tbool isInPenaltyBox = false;\n\t\t\tif ((reachedMaxInstancesInMemory = !ignoreLimit && IsFull) || \n\t\t\t    (alreadyMaxedOutForAccount = AlreadyMaxedOutForAccount(instance.AccountId)) || \n\t\t\t    (isInPenaltyBox = Governor.IsInPenaltyBox(instance.AccountId)))\n\t\t\t{\n\t\t\t\t// Someone should process this when they can get around to it.\n\t\t\t\tUnlockInstance(instance.AccountId, instance.Uid, nextProcessDate: DateTime.MinValue);\n\n\t\t\t\tif(reachedMaxInstancesInMemory)\n\t\t\t\t{\n\t\t\t\t\tLogInstanceDeferredMaxInstancesInMemory(instance);\n\t\t\t\t}\n\t\t\t\telse if(alreadyMaxedOutForAccount)\n\t\t\t\t{\n\t\t\t\t\tLogInstanceDeferredMaxedOutForAccount(instance);\n\t\t\t\t}\n\t\t\t\telse if(isInPenaltyBox)\n\t\t\t\t{\n\t\t\t\t\tLogInstanceDeferredGovernanceLimitReached(instance);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWorkflowInstance workflowInstance = new WorkflowInstance(instance, workflowMap, _data);\n\t\t\t\tQueueInstance(workflowInstance, ignoreLimit);\n\t\t\t}\n\n\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t{\n\t\t\t\tAccountId = instance.AccountId,\n\t\t\t\tScopeUid = instance.ScopeUid,\n\t\t\t\tScopeName = instance.ScopeName,\n\t\t\t\tWorkflowUid = instance.Uid,\n\t\t\t\tWorkflowId = instance.Id,\n\t\t\t\tWorkflowName = instance.Name,\n\t\t\t\tVersionNumber = revision.VersionNumber,\n\t\t\t\tRevisionNumber = revision.RevisionNumber,\n\t\t\t\tPeriodStart = instance.CreatedDate,\n\t\t\t\tEventType = (int)ScopeEventType.WorkflowStarted,\n                EventBy = startParameters.Submitter == null ? null : new WorkflowScopeEvent.Assignee() { Email = startParameters.Submitter.EmailAddress, Name = startParameters.Submitter.FriendlyName, Uid = startParameters.Submitter.Uid }\n            };\n\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(instance.AccountId, instance.Uid)\n\t\t\t{\n\t\t\t\tEventData = scopeEventData\n\t\t\t};\n\t\t\tEventRepo.FireEvent(instance.AccountId, scopeEvent);\n\n\t\t\treturn instance.Uid;\n\t\t}\n\n\t\tpublic IWINSDataStore DataStore { get { return _data; } } \n\n\t\t/// <summary>\n\t\t/// Executes an event and waits for it to be completed (synchronously); this method does not return until that has occurred,\n\t\t/// or an exception has occurred.  Timing out is an exception.\n\t\t/// </summary>\n\t\tpublic void ExecuteEvent(Event evt)\n\t\t{\n\t\t\tDateTime timeout = DateTime.UtcNow.AddSeconds(ApplicationSettings.WinsWaitForIdleTimeoutSeconds);\n\t\t\twhile (DateTime.UtcNow <= timeout)\n\t\t\t{\n\t\t\t\tException e;\n                // Note: This will give up if it can't get the threadlock for the instance -- this may\n                // occur if there is another path on the workflow that is infinitely looping or similar. \n                // Ideally, this would be able to force the other worker/thread to stop and give up the lock,\n                // but that is currently not implemented.\n                WorkflowInstance instance = _LoadExisting(evt.AccountId, evt.InstanceUid, out var wasInMemory, n => n.ThreadLock.TryLock(ThreadOwnerId, _data.LockExpirationDate(), out e));\n\t\t\t\tif (instance != null && instance.ThreadLock.TryLock(ThreadOwnerId, _data.LockExpirationDate(), out e))\n\t\t\t\t{\n\t\t\t\t\ttry\n                    {\n                        // Because we're acting synchronously here, we don't queue on failures -- the exception will alert\n                        // the client instead.\n                        instance.ExecuteEvent(evt, queueOnFailure: false);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} finally\n\t\t\t\t\t{\n\t\t\t\t\t\tinstance.ThreadLock.Unlock(ThreadOwnerId);\n\t\t\t\t\t\tFireOnWorkReceived();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.Threading.Thread.Sleep(500);\n\t\t\t}\n\t\t\tthrow new TimeoutException(string.Format(\"Failed to process event {0} for instanceUid {1}\", evt.CallbackName, evt.InstanceUid));\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Number of additional instances this manager wants to have in memory\n\t\t/// </summary>\n\t\tpublic int FreeCapacity()\n\t\t{\n\t\t\tint capacity = MaxInstancesInMemory - Count;\n\t\t\treturn Math.Max(capacity, 0);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Gets a control instance that lets us abort/pause/resume/resume from errors.\n\t\t/// Ideally this returns us a normal instance (with all the baggage that entails -- it'll be locked, ensuring no\n\t\t/// other service is processing it, etc).\n\t\t/// If we can't return a normal instance (eg, locked by another service), it returns the stripped down WorkflowControlInstance\n\t\t/// instead as a fallback.\n\t\t/// \n\t\t/// The advantage of returning a normal instance when we can is a) locking (so no other service is processing it), and b) immediate\n\t\t/// notification to any workers that the things in a different state.\n\t\t/// </summary>\n\t\tpublic IWINSControlInstance GetControlInstance(int accountId, Guid instanceUid)\n\t\t{\n\t\t\tWorkflowInstance instance = LoadExisting(accountId, instanceUid);\n\t\t\tif (instance != null) return instance;\n\t\t\treturn new WorkflowControlInstance(accountId, instanceUid);\n\t\t}\n\n\t\tpublic WorkflowInstance GetNextInstance(int lastAccountIdServiced = int.MinValue)\n\t\t{\n\t\t\tWorkflowInstance instance = GetFirstUnlockedInstance(lastAccountIdServiced);\n\t\t\tif (instance == null) return null;\n\t\t\tstring message = null;\n\t\t\t//If Inmemory instance has already expired; then unfinished activities might not reflect the correct status; hence remove the instance so that is can be worked upon later. \n\t\t\tif (!instance.HasExistingLockExpired())\n\t\t\t{\n\t\t\t\t// Ensure it's still locked in the database -- if it's not, we should remove it here.\n\t\t\t\tInstancePersistence.LockResult lockResult;\n\t\t\t\tif (LockInstance(instance.AccountId, instance, out lockResult))\n\t\t\t\t{\n\t\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = instance.AccountId;\n\t\t\t\t\tGovernor.IncrementInstanceCount(instance.AccountId);\n\t\t\t\t\treturn instance;\n\t\t\t\t}\n\t\t\t\t// If we get here, we couldn't lock it in the db.  We should remove it.\n\t\t\t\tmessage = $\"Failed to lock instanceUid {instance.Uid} for lock owner {_data.LockOwner()}, received result: {lockResult}\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmessage = $\"Lock has already expired on in-memory instance with instanceUid {instance.Uid} for lock owner {_data.LockOwner()}, lockexpirationdate: {instance.LockExpirationDate}\";\n\t\t\t}\n\n\t\t\t_log.InfoNoPII(message);\n\t\t\tRemoveInstance(instance, message: message);\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic bool IsFull { get { return Count >= MaxInstancesInMemory; } }\n\n\t\tpublic bool IsAcceptingWork { get; set; } = true;\n\n\t\tinternal bool AlreadyMaxedOutForAccount(int accountId)\n\t\t{\n\t\t\tif (Count < 1)\n\t\t\t{ // no need to do the calculation if we are idle\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tint totalPerAccount = 0;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing (_instances.GetReadLock())\n\t\t\t\t{\n\t\t\t\t\ttotalPerAccount = _instances.Values.Count(instance => instance.AccountId == accountId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\t// if we fail to count it should not cause a failure\n\t\t\t\t_log.WarnNoPII(string.Format(\"AlreadyMaxedOutForAccount could not count instances for accountId {0}.\", accountId), ex);\n\t\t\t}\n\n\t\t\t// if adding one more for an account puts us over our configured max\n\t\t\tif ((((decimal)totalPerAccount + 1) / ((decimal)MaxInstancesInMemory)) >= (decimal)WorkflowSettingRepo.GetWorkflowManagerAccountMaxPercentOfWork())\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic bool CanResume(Instance instance)\n\t\t{\n\t\t\tif (IsRevisionExecutionSuspended(instance.AccountId, instance.RevisionUid)) return false;\n\t\t\tif (instance.ParentActivityUid == Guid.Empty) return true;\n\t\t\tvar parentActivity = _data.LoadActivityByUid(instance.AccountId, Constants.WorkflowUser, instance.ParentActivityUid);\n\t\t\tif (parentActivity == null) return true;\n\t\t\tvar parentInstance = _data.LoadInstanceByUid(instance.AccountId, Constants.WorkflowUser, parentActivity.InstanceUid);\n\t\t\tif (parentInstance == null) return true;\n\t\t\tif (!instance.IsCompleted && (parentInstance.Status == Enums.WorkflowStepStatus.Aborted ||\n\t\t\t    parentInstance.Status == Enums.WorkflowStepStatus.Failed))\n\t\t\t{\n\t\t\t\tWINSManager client = new WINSManager();\n\t\t\t\tclient.KillWorkflow(UserAccount.WorkflowUserAccount(instance.AccountId), instance.Uid, Resources.WINSResources.AbortedBecauseParentAborted);\n\t\t\t\t_log.InfoNoPII(string.Format(\"Parent of instance {0} failed or was aborted\", instance.Uid));\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic bool ShouldAbortInstance(Instance instance)\n\t\t{\n\t\t\tif (WorkflowSettingRepo.GetAutomaticAbort(instance.AccountId))\n\t\t\t{\n\t\t\t\tvar daysExecuting = (int) Math.Floor((DateTime.UtcNow - instance.CreatedDate).Duration().TotalDays);\n\t\t\t\treturn (daysExecuting > GetExecutionDaysBeforeAbort(instance));\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic WorkflowInstance LoadExisting(int accountId, Guid instanceUid)\n\t\t{\n\t\t\treturn _LoadExisting(accountId, instanceUid, out var wasInMemory, setup: null);\n\t\t}\n\n\t\tprivate DateTime? GetLastAbortNotificationDate(Instance instance)\n\t\t{\n\t\t\tWorkflowInstance workflowInstance = LoadExisting(instance.AccountId, instance.Uid);\n\t\t\treturn workflowInstance?.GetLastAbortNotificationDate();\n\t\t}\n\n\t\tprivate bool TrySaveLastAbortNotificationDate(Instance instance, DateTime lastAbortNotificationDate)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowInstance workflowInstance = LoadExisting(instance.AccountId, instance.Uid);\n\t\t\t\tif (workflowInstance == null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tworkflowInstance.SaveLastAbortNotificationDate(instance.AccountId, instance.Uid, lastAbortNotificationDate);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not save last abort notification date.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic bool ShouldSendAbortNotification(Instance instance, out Enums.WorkflowAbortNotificationType abortNotificationType)\n\t\t{\n\t\t\tabortNotificationType = Enums.WorkflowAbortNotificationType.None;\n\n\t\t\tif (!WorkflowSettingRepo.GetEnableAbortNotifications(instance.AccountId) || !WorkflowSettingRepo.GetAutomaticAbort(instance.AccountId))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tint daysExecuting = (int) Math.Floor((DateTime.UtcNow - instance.CreatedDate).Duration().TotalDays);\n\t\t\tvar lastAbortNotificationDateLazy = new Lazy<DateTime?>(() => GetLastAbortNotificationDate(instance));\n\t\t\tint daysBeforeAbort = GetExecutionDaysBeforeAbort(instance);\n\t\t\tDateTime abortDate = instance.CreatedDate.AddDays(daysBeforeAbort);\n\n\t\t\treturn ShouldSendAbortNotification(daysExecuting, lastAbortNotificationDateLazy, abortDate, daysBeforeAbort, out abortNotificationType);\n\t\t}\n\n\t\tpublic bool ShouldSendAbortNotification(int daysExecuting, Lazy<DateTime?> lastAbortNotificationDateLazy, DateTime abortDate, int daysBeforeAbort, out Enums.WorkflowAbortNotificationType abortNotificationType)\n\t\t{\n\t\t\tabortNotificationType = Enums.WorkflowAbortNotificationType.None;\n\n\t\t\t// No need to check last abort notification date if we aren't even half way there\n\t\t\t// Or if the workflow has been executing for longer than allowed\n\t\t\tint daysTillAbort = daysBeforeAbort - daysExecuting;\n\t\t\tif (daysTillAbort > (FiftyPercent * daysBeforeAbort) || daysTillAbort < 0)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Don't send notification if we can't get last abort notification date\n\t\t\tDateTime? lastAbortNotificationDate = lastAbortNotificationDateLazy.Value;\n\t\t\tif (lastAbortNotificationDate == null)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not get last abort notification date.\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tint daysBetweenLastNotificationAndAbort = (int) Math.Ceiling((abortDate - lastAbortNotificationDate.Value).TotalDays);\n\t\t\tif (daysTillAbort <= OneDay)\n\t\t\t{\n\t\t\t\tabortNotificationType = Enums.WorkflowAbortNotificationType.OneDay;\n\t\t\t\treturn daysBetweenLastNotificationAndAbort > OneDay;\n\t\t\t}\n\t\t\telse if (daysTillAbort <= OneWeek)\n\t\t\t{\n\t\t\t\tabortNotificationType = Enums.WorkflowAbortNotificationType.OneWeek;\n\t\t\t\treturn daysBetweenLastNotificationAndAbort > OneWeek;\n\t\t\t}\n\t\t\telse if (daysTillAbort <= OneMonth)\n\t\t\t{\n\t\t\t\tabortNotificationType = Enums.WorkflowAbortNotificationType.OneMonth;\n\t\t\t\treturn daysBetweenLastNotificationAndAbort > OneMonth;\n\t\t\t}\n\t\t\telse if (daysTillAbort < (TenPercent * daysBeforeAbort))\n\t\t\t{\n\t\t\t\tabortNotificationType = Enums.WorkflowAbortNotificationType.TenPercent;\n\t\t\t\treturn daysBetweenLastNotificationAndAbort >= (TenPercent * daysBeforeAbort);\n\t\t\t}\n\t\t\telse if (daysTillAbort < (TwentyFivePercent * daysBeforeAbort))\n\t\t\t{\n\t\t\t\tabortNotificationType = Enums.WorkflowAbortNotificationType.TwentyFivePercent;\n\t\t\t\treturn daysBetweenLastNotificationAndAbort >= (TwentyFivePercent * daysBeforeAbort);\n\t\t\t}\n\t\t\telse if (daysTillAbort < (FiftyPercent * daysBeforeAbort))\n\t\t\t{\n\t\t\t\tabortNotificationType = Enums.WorkflowAbortNotificationType.FiftyPercent;\n\t\t\t\treturn daysBetweenLastNotificationAndAbort >= (FiftyPercent * daysBeforeAbort);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool TrySendAbortNotification(Instance instance, Enums.WorkflowAbortNotificationType abortNotificationType)\n\t\t{\n\t\t\t_log.InfoNoPII(\"Sending abort notification for instance.\");\n\n\t\t\t// Don't send the email if we're unable to persist the date, so that we don't send duplicates\n\t\t\tDateTime? previousLastAbortNotificationDate = GetLastAbortNotificationDate(instance);\n\t\t\tif (previousLastAbortNotificationDate == null || !TrySaveLastAbortNotificationDate(instance, DateTime.UtcNow))\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not get or set last abort notification date.\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccounts accountSuperAdmins = ServiceLocator.GetInstance<IUserAccountRepository>()\n\t\t\t\t\t.LoadByAccountIdAndRole(instance.AccountId, Enums.UserRole.Primary);\n\n\t\t\t\tvar email = new WorkflowAbortNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = instance.AccountId,\n\t\t\t\t\tRecipients = accountSuperAdmins,\n\t\t\t\t\tAbortDate = instance.CreatedDate.AddDays(GetExecutionDaysBeforeAbort(instance)),\n\t\t\t\t\tNotificationType = abortNotificationType,\n\t\t\t\t\tWorkflowId = instance.Id,\n\t\t\t\t\tWorkflowName = instance.Name\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not send abort notification.\", ex);\n\t\t\t\tTrySaveLastAbortNotificationDate(instance, previousLastAbortNotificationDate.Value);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic bool IsInstanceInMemory(Guid instanceUid)\n\t\t{\n\t\t\treturn _instances.ContainsKey(instanceUid);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns a locked and loaded instance or returns null\n\t\t/// </summary>\n\t\tpublic WorkflowInstance LoadAndLockExisting(int accountId, Guid instanceUid, out bool wasInMemory)\n        { \n            Exception e = null;\n            var workflowInstance = _LoadExisting(accountId, instanceUid, out wasInMemory, n => n.ThreadLock.TryLock(ThreadOwnerId, _data.LockExpirationDate(), out e));\n            if (e != null || workflowInstance == null)\n            {\n                _log.InfoNoPII($\"Failed to load and lock {instanceUid} for owner {ThreadOwnerId}\");\n                return null;\n            }\n\n            return workflowInstance;\n        }\n\n        private WorkflowInstance _LoadExisting(int accountId, Guid instanceUid, out bool wasInMemory, InstanceSetupDelegate setup = null)\n\t\t{\n\t\t\twasInMemory = _instances.TryGetValue(instanceUid, out WorkflowInstance instance);\n\n\t\t\t// If we are no longer accepting work, just return null\n\t\t\t// Unless the instance is already in memory and the caller hasn't passed a delegate method (ie tried to lock or queue the instance)\n\t\t\t// In which case we will just return the instance that's already in memory\n\t\t\tif (!IsAcceptingWork && !(wasInMemory && setup == null))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Did not load instanceUid {instanceUid} because manager is no longer accepting work.\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (wasInMemory)\n\t\t\t{\n\t\t\t\tif (setup != null) setup(instance);\n\t\t\t\treturn instance;\n\t\t\t}\n\n            instance = WorkflowInstance.LoadExisting(accountId, instanceUid, _data);\n\t\t\tif (instance == null) return null;\n\n\t\t\tif (!IsAcceptingWork)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Will not add instance to memory instanceUid {instanceUid} because manager is no longer accepting work.\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlock (_instances)\n\t\t\t{\n\t\t\t\tif (_instances.ContainsKey(instanceUid))\n\t\t\t\t{\n\t\t\t\t\tif (setup != null) setup(_instances[instanceUid]);\n\t\t\t\t\treturn _instances[instanceUid];\n\t\t\t\t}\n\t\t\t\tif (setup != null) setup(instance);\n\t\t\t\t_instances[instance.Uid] = instance;\n\t\t\t\t_log.DebugNoPII($\"Added instanceUid {instance.Uid}; {_instances.Count} instances in memory\");\n               \n                var workload = ManagerWorkload.CreateFromWorkflowInstance(\"InstanceAdded\", instance);\n\t\t\t\tworkload.InMemInstanceCount = _instances.Count;\n                workload.Log();\n\t\t\t\t\n                _signalNeedWork = true;\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\n\t\tpublic DateTime LockExpirationDate { get { return _data.LockExpirationDate(); } }\n\n\t\t/// <summary>\n\t\t/// Locks a workflow instance to this service; ensures that other services won't pick it up and work on it.\n\t\t/// Our locks have an expiration date -- calling this when we're already locked may still be done to set an\n\t\t/// expiration date further in the future.\n\t\t/// </summary>\n\t\tpublic bool LockInstance(int accountId, WorkflowInstance workflowInstance, out InstancePersistence.LockResult result)\n\t\t{\n\t\t\tDateTime lockExpirationDate;\n\t\t\tresult = _data.LockInstance(accountId, workflowInstance.Uid, out lockExpirationDate);\n\t\t\tworkflowInstance.LockExpirationDate = lockExpirationDate;\n\t\t\treturn result == InstancePersistence.LockResult.Locked;\n\t\t}\n\t\tpublic bool LockInstance(int accountId, WorkflowInstance workflowInstance)\n\t\t{\n\t\t\tInstancePersistence.LockResult result;\n\t\t\treturn LockInstance(accountId, workflowInstance, out result);\n\t\t}\n\n\t\tpublic string LockOwner { get { return _data.LockOwner(); } }\n\n\t\tpublic int MaxInstancesInMemory { get { return WorkflowSettingRepo.GetWorkflowMaxInstancesInMemory(); } }\n\n\t\t/// <summary>\n\t\t/// Queues up a new activity to be executed in a specifc instance; it will try to keep this in-memory, if possible,\n\t\t/// but it may simply write to the db if we're at our limit of in-memory items.\n\t\t/// </summary>\n\t\tpublic void QueueActivity(InstanceActivity instanceActivity)\n\t\t{\n\t\t\tif (instanceActivity == null) throw new ArgumentNullException(\"instanceActivity\");\n\t\t\tWorkflowInstance instance = _LoadExisting(instanceActivity.AccountId, instanceActivity.InstanceUid, out var wasInMemory, n => n.QueueActivity(instanceActivity));\n\t\t\tif (instance == null && instanceActivity.Uid == Guid.Empty) _data.CreateActivity(instanceActivity);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Queues up an event to be executed in a specifc instance; it will try to keep this in-memory, if possible,\n\t\t/// but it may simply write to the db if we're at our limit of in-memory items.\n\t\t/// </summary>\n\t\tpublic void QueueEvent(Event e)\n\t\t{\n\t\t\tif (e == null) throw new ArgumentNullException(\"e\");\n\t\t\tWorkflowInstance instance = null;\n\t\t\ttry\n\t\t\t{\n                instance = _LoadExisting(e.AccountId, e.InstanceUid, out var wasInMemory, n => n.QueueEvent(e));\n                \n\t\t\t}\n\t\t\tcatch (InstanceLockedException ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"QueueEvent: Instance locked, could not enqueue event in-memory, InstanceUid {e.InstanceUid} ActivityUid {e.ActivityUid} with callback {e.CallbackName}, creating event in data store instead: {ex.Message}\");\n\t\t\t}\n\t\t\tcatch (ApplicationException ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(string.Format(\"Exception queueing event for InstanceUid {0} ActivityUid {1} with callback {2}, creating event in data store instead.\", e.InstanceUid, e.ActivityUid, e.CallbackName), ex);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (instance == null && e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tCreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnNotQueued\") { WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId) };\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tFireOnWorkReceived();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Skips the in-memory queue check of the QueueEvent method and inserts into\n\t\t/// BPMEvent table for later consumption\n\t\t/// </summary>\n\t\tpublic void CreateEvent(Event e)\n\t\t{\n\t\t\tif (e == null) throw new ArgumentNullException(\"e\");\n\t\t\t_data.CreateEvent(e);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Queues up an instance to be processed by this service.  This may result in a no-op if we're\n\t\t/// already at our limit.  \n\t\t/// As a side effect, locks the instance to us if it's keeping it in memory (this will not occur if we're at our limit)\n\t\t/// </summary>\n\t\tpublic void QueueInstance(WorkflowInstance instance, bool ignoreLimit = false)\n\t\t{\n\t\t\tif (instance == null) throw new ArgumentNullException(\"instance\");\n\t\t\tif (_instances.ContainsKey(instance.Uid)) throw new ApplicationException(string.Format(\"Duplicate queueing of instanceUid {0}\", instance.Uid));\n\t\t\t// Don't bother if we're over our limit or we aren't accepting any more work\n\t\t\tif ((!ignoreLimit && IsFull) || !IsAcceptingWork)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Did not queue instanceUid {instance.Uid}. IsFull - {IsFull}; IsAcceptingWork - {IsAcceptingWork}\");\n\t\t\t\t// Someone should process this when they can get around to it.\n\t\t\t\tUnlockInstance(instance.AccountId, instance.Uid, nextProcessDate: DateTime.MinValue);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Don't bother if we can't lock it\n\t\t\tif (!LockInstance(instance.AccountId, instance)) return;\n\t\t\tbool success = false;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlock (_instances)\n\t\t\t\t{\n\t\t\t\t\t// Double check stuff now that we have our _instances lock\n\t\t\t\t\tif (_instances.ContainsKey(instance.Uid)) throw new ApplicationException(string.Format(\"Duplicate queueing of instanceUid {0}\", instance.Uid));\n\t\t\t\t\tif ((!ignoreLimit && IsFull) || !IsAcceptingWork)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII($\"Did not queue instanceUid {instance.Uid} after db lock. IsFull - {IsFull}; IsAcceptingWork - {IsAcceptingWork}\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t_instances.Add(instance.Uid, instance);\n\t\t\t\t\t_log.InfoNoPII($\"Queued instanceUid {instance.Uid}; {_instances.Count} instances in memory.\");\n                    \n                    var workload = ManagerWorkload.CreateFromWorkflowInstance(\"InstanceQueued\", instance);\n                    workload.InMemInstanceCount = _instances.Count;\n\t\t\t\t\tworkload.Log();\n\n\t\t\t\t\t_signalNeedWork = true;\n\t\t\t\t\tsuccess = true;\n\t\t\t\t}\n\t\t\t} finally\n\t\t\t{\n\t\t\t\tif (!success)\n\t\t\t\t{\n\t\t\t\t\t// Do not remove the instance if it's already in the queue\n\t\t\t\t\tif (!_instances.ContainsKey(instance.Uid))\n\t\t\t\t\t{\n\t\t\t\t\t\tRemoveInstance(instance, nextProcessDate: DateTime.MinValue, message: string.Format(\"Too many items in memory: {0} of {1}\", Count, MaxInstancesInMemory));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII($\"Instance {instance.Uid} is already in memory, so it will not be removed\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFireOnWorkReceived();\n\t\t}\n\n\t\tpublic void QueueInstance(Instance instance, bool ignoreLimit = false)\n\t\t{\n\t\t\tif (_instances.ContainsKey(instance.Uid)) return;\n\t\t\tif (!ignoreLimit && IsFull)\n\t\t\t{\n\t\t\t\t// Someone should process this when they can get around to it.\n\t\t\t\tUnlockInstance(instance.AccountId, instance.Uid, nextProcessDate: DateTime.MinValue);\n\t\t\t\tLogInstanceDeferredMaxInstancesInMemory(instance);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tWorkflowInstance wfInstance = WorkflowInstance.LoadExisting(instance.AccountId, instance.Uid, _data);\n\t\t\tQueueInstance(wfInstance, ignoreLimit);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Removes all of our locks on an instance, and removes it.  Use this when we know we're done with the instance.\n\t\t/// </summary>\n\t\tpublic void RemoveInstance(WorkflowInstance instance, DateTime? nextProcessDate = null, string message = null)\n\t\t{\n\t\t\tif (instance == null) throw new ArgumentNullException(\"instance\");\n\t\t\t// Reduce race conditions by making sure nobody else can lock, or has locked, the instance before trying to remove it\n\t\t\tif(!instance.ThreadLock.TryLock(ThreadOwnerId, DateTime.UtcNow.AddSeconds(10), out Exception ex))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Tried to remove instance {instance.Uid} while locked by another thread (Current:{ThreadOwnerId}, Owner:{instance.ThreadLock.Owner})\");\n\t\t\t\treturn;\n\t\t\t}\n\n            try\n            {\n                instance.SaveToDatabase();\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII(string.Format(\"Failed to save unsaved information for instance {0} to db\", instance.Uid), e);\n            }\n\n            // We reverse the locking mechanism (lock in memory first, then lock in db) here -- unlock db \n            // first, then unlock in memory to avoid any in-memory race conditions.\n            try\n\t\t\t{\n\t\t\t\tUnlockInstance(instance.AccountId, instance.Uid, nextProcessDate);\n\t\t\t}\n\t\t\tcatch (Exception excp)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(string.Format(\"Failed to unlock instanceUid {0} for lock owner {1}\", instance.Uid, _data.LockOwner()), excp);\n\t\t\t}\n\t\t\t\n\t\t\tlock (_instances)\n\t\t\t{\n\t\t\t\tException e;\n\t\t\t\tinstance.ThreadLock.TryUnlock(ThreadOwnerId, out e);\n\t\t\t\tif (_instances.ContainsKey(instance.Uid))\n\t\t\t\t{\n\t\t\t\t\t_instances.Remove(instance.Uid);\n                    var workload = ManagerWorkload.CreateFromWorkflowInstance(\"InstanceRemoved\", instance);\n                    workload.InMemInstanceCount = _instances.Count;\n\t\t\t\t\tworkload.Log();\n\t\t\t\t}\n\n\t\t\t\t_log.DebugNoPII($\"Removed instanceUid {instance.Uid} ({message ?? \"No message\"}); {_instances.Count} instances in memory\");\n\t\t\t}\n\n\t\t\t// Save any remaining events in queue on the off chance that an event came in between the last SaveToDatabase and the instance being removed\n\t\t\tinstance.SaveEventsToDatabase();\n\n\t\t\tGovernor.EmitActivityExecutionCountExceededTelemetry(instance.AccountId, instance.Uid, instance.RevisionUid, instance.RevisionCreatedDate, instance.ActivityExecutionCount, instance.ActivityExecutionCountEnforcedLimit, instance.IsActivityExecutionLimitReached);\n\n\t\t\t_signalNeedWork = true;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Removes locks and persist events/variables for all instances that are not being worked on by a thread\n\t\t/// Use this when manager needs to stop working\n\t\t/// </summary>\n\t\tpublic void RemoveAllUnlockedInstances(DateTime? nextProcessDate, string message)\n\t\t{\n\t\t\tusing (ScmNDC.Push($\"M:{message ?? \"No message\"}\"))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Removing all unlocked instances. Next process date {nextProcessDate}\");\n\t\t\t\tlock (_instances)\n\t\t\t\t{\n\t\t\t\t\t// Find all unlocked instances and lock them first, in case a thread is about to pick one up\n\t\t\t\t\tvar unlockedInstances = new List<Guid>();\n\t\t\t\t\tforeach (WorkflowInstance instance in _instances.Values)\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (ScmNDC.Push($\"W:{instance.Uid}\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Would be better to use a TryLockIfNotLocked method...\n\t\t\t\t\t\t\tif (instance.ThreadLock.IsLocked)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII(\"Instance is already locked.\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (instance.ThreadLock.TryLock(ThreadOwnerId, _data.LockExpirationDate(), out Exception ex))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tunlockedInstances.Add(instance.Uid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII(\"Could not lock instance.\", ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remove locks and persist all of the previously unlocked instances\n\t\t\t\t\tforeach (Guid instanceUid in unlockedInstances)\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (ScmNDC.Push($\"W:{instanceUid}\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.InfoNoPII(\"Attempting to remove instance\");\n\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tRemoveInstance(_instances[instanceUid], nextProcessDate, message);\n\t\t\t\t\t\t\t\t_log.InfoNoPII(\"Removed instance from memory, removed locks, and persisted events/variables\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.ErrorNoPII(\"Failed to remove locks on instance\", e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        public void RemoveLock(WorkflowInstance instance)\n        {\n            instance.ThreadLock.Unlock(ThreadOwnerId);\n            _log.DebugNoPII($\"Removed thread lock for instanceUid {instance.Uid}; {_instances.Count} instances in memory\");\n        }\n\n        /// <summary>\n        /// Unlocks an instance from us.  This should only be called when we're done with it.\n        /// </summary>\n        public void UnlockInstance(int accountId, Guid instanceUid, DateTime? nextProcessDate = null)\n        {\n            _data.UnlockInstance(accountId, instanceUid, nextProcessDate);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Goes through each instance, find the lockable one with the oldest lastprocessed date, and tries to lock it to this thread.  \n\t\t/// Will also attempt to give preference to an instance that is for an Account that was not last serviced.\n\t\t/// Returns it if it can, returns null if there's nothing it could do.\n\t\t/// </summary>\n\t\t/// <returns></returns>\n\t\tprivate WorkflowInstance GetFirstUnlockedInstance(int lastAccountIdServiced)\n\t\t{\n\t\t\tif (_instances.Count > 0)\n\t\t\t{\n\t\t\t\tstring owner = ThreadOwnerId;\n\t\t\t\tDateTime expiration = _data.LockExpirationDate();\n\n\t\t\t\tWorkflowInstance first = null;\n\t\t\t\tWorkflowInstance firstNew = null;\n\n\t\t\t\tlock (_instances)\n\t\t\t\t{\n\t\t\t\t\tvar instancesInPenaltyBox = new List<WorkflowInstance>();\n\t\t\t\t\tforeach (WorkflowInstance instance in _instances.Values)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!instance.ThreadLock.CanLock(owner)) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = instance.AccountId;\n\n\t\t\t\t\t\tif (Governor.IsInPenaltyBox(instance.AccountId))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinstancesInPenaltyBox.Add(instance);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// try to find the instance that is oldest in the list\n\t\t\t\t\t\tif (first == null || instance.LastProcessDate < first.LastProcessDate) first = instance;\n\t\t\t\t\t\tif (instance.AccountId != lastAccountIdServiced && (firstNew == null || instance.LastProcessDate < firstNew.LastProcessDate)) firstNew = instance;\n\t\t\t\t\t}\n\n\t\t\t\t\tforeach (WorkflowInstance instance in instancesInPenaltyBox)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII($\"Removing instance {instance.Uid} as it's account ({instance.AccountId}) is in the penalty box\");\n\t\t\t\t\t\tRemoveInstance(instance);\n\t\t\t\t\t\tLogInstanceDeferredGovernanceLimitReached(instance.Model);\n\t\t\t\t\t}\n\n\t\t\t\t\tException e;\n\t\t\t\t\tif (firstNew != null && firstNew.ThreadLock.TryLock(owner, expiration, out e)) return firstNew;\n\t\t\t\t\tif (first != null && first.ThreadLock.TryLock(owner, expiration, out e)) return first;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// This gets hit if we found no work to do.\n\t\t\tif (_signalNeedWork && OnNeedWorkEvent != null) OnNeedWorkEvent();\n\t\t\t_signalNeedWork = false;\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate static string ThreadOwnerId\n\t\t{\n\t\t\tget { return System.Threading.Thread.CurrentThread.ManagedThreadId.ToString(); }\n\t\t}\n\n\t\tprivate void FireOnWorkReceived()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (OnWorkReceivedEvent != null) OnWorkReceivedEvent();\n\t\t\t} catch\n\t\t\t{\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\n\t\tpublic void LogInstanceDeferredGovernanceLimitReached(Instance instance)\n\t\t{\n\t\t\tLogInstanceDeferred(instance, \"InstanceDeferredGovernanceLimitReached\");\n\t\t}\n\n\t\tpublic void LogInstanceDeferredMaxedOutForAccount(Instance instance)\n\t\t{\n\t\t\tLogInstanceDeferred(instance, \"InstanceDeferredMaxedOutForAccount\");\n\t\t}\n\n\t\tpublic void LogInstanceDeferredMaxInstancesInMemory(Instance instance)\n\t\t{\n\t\t\tLogInstanceDeferred(instance, \"InstanceDeferredMaxInstancesInMemory\");\n\t\t}\n\n\t\tprivate void LogInstanceDeferred(Instance instance, string action)\n        {\n\t\t\tvar workload = ManagerWorkload.CreateFromInstance(action, instance);\n\t\t\tworkload.WorkflowDB = DataStore.GetDbNameForAccount(instance.AccountId);\n            workload.InMemInstanceCount = _instances.Count;\n\t\t\tworkload.Log();\n\t\t}\n\n\t\tprivate int GetExecutionDaysBeforeAbort(Instance instance)\n\t\t{\n\t\t\tRevision revision =\n\t\t\t\t_data.LoadRevisionByUid(instance.AccountId, Constants.WorkflowUser, instance.RevisionUid);\n\n\t\t\tif (revision == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Revision does not exist {instance.RevisionUid}\");\n\t\t\t}\n\t\t\telse if(revision.CreatedDate >= WorkflowSettingRepo.GetExecutionDaysBeforeAbortEffectiveDate(instance.AccountId))\n\t\t\t{\n\t\t\t\treturn WorkflowSettingRepo.GetExecutionDaysBeforeAbort(instance.AccountId);\n\t\t\t}\n\n\t\t\treturn WorkflowSettingRepo.GetExecutionDaysBeforeAbortLegacy(instance.AccountId);\n\t\t}\n\n\t\tpublic bool IsRevisionExecutionSuspended(int accountId, Guid revisionUid)\n\t\t{\n\t\t\treturn RevisionService.IsRevisionSuspended(accountId, UserAccount.WorkflowUserAccount(accountId).Uid, revisionUid);\n\t\t}\n\n\t\tpublic bool IsInstanceRevisionExecutionSuspended(int accountId, Guid instanceUid, out Guid revisionUid)\n\t\t{\n\t\t\tGuid userAccountUid = UserAccount.WorkflowUserAccount(accountId).Uid;\n\t\t\tInstance instance = _data.LoadInstanceByUid(accountId, userAccountUid, instanceUid);\n\t\t\trevisionUid = instance.RevisionUid;\n\t\t\treturn IsRevisionExecutionSuspended(accountId, instance.RevisionUid);\n\t\t}\n\n\t\tprivate void ValidateRevisionIsNotSuspended(int accountId, Revision revision)\n\t\t{\n\t\t\tif (revision.Status == Enums.WorkflowRevisionStatus.Suspended)\n\t\t\t{\n\t\t\t\tstring message =\n\t\t\t\t\t$\"Revision {revision.Uid} for definition {revision.DefinitionUid} and account {accountId} is currently suspended\";\n\t\t\t\t_log.WarnNoPII(message);\n\t\t\t\tthrow new ApplicationException(message);\n\t\t\t}\n\t\t}\n\n\t\tprivate bool TrySendRevisionSuspensionNotification(Revision revision)\n\t\t{\n\t\t\tvar accountId = revision.AccountId;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = UserAccount.WorkflowUserAccount(accountId).Settings.AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive workflow revision suspension notification\");\n\t\t\t\t\tnotificationUser = ServiceLocator.GetInstance<UserAccountRepository>().LoadByUid(accountId, notificationUserUid);\n\t\t\t\t}\n\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Unable to send workflow revision suspension notification for account '{accountId}' and revision '{revision.Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar email = new WorkflowRevisionSuspensionNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = accountId,\n\t\t\t\t\tWorkflowRevisionUid = revision.Uid,\n\t\t\t\t\tWorkflowRevisionName = revision.Name,\n\t\t\t\t\tEmailRecipients = emailRecipients\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending workflow revision suspension notification for account '{accountId} and revision {revision.Uid}'\", ex);\n\t\t\t\tex.Report();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
      "content": "\ufeffusing System;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Domain.Repository.Workflow.PropertyExpressions;\n\nnamespace ADEXS.Atlas.Workflow.Activities.PropertyTypes\n{\n\t[Serializable]\n\tpublic class StringProperty : IProperty<string>\n\t{\n\t\tprivate readonly IPropertyExpression _propertyExpression;\n\n\t\tpublic StringProperty(IPropertyExpression propertyExpression)\n\t\t{\n\t\t\t_propertyExpression = propertyExpression;\n\t\t}\n\n\t\tbool IProperty.TryEvaluate(IWorkflowContext ctx, out object result)\n\t\t{\n\t\t\tstring value;\n\t\t\tbool valid = TryEvaluate(ctx, out value);\n\t\t\tresult = value;\n\t\t\treturn valid;\n\t\t}\n\n\t\tbool IProperty.TryEvaluateWithoutContext(out object result)\n\t\t{\n\t\t\tstring value;\n\t\t\tbool valid = TryEvaluateWithoutContext(out value);\n\t\t\tresult = value;\n\t\t\treturn valid;\n\t\t}\n\n\t\tpublic string Evaluate(IWorkflowContext ctx)\n\t\t{\n\t\t\tstring value;\n\t\t\tTryEvaluate(ctx, out value);\n\t\t\treturn value;\n\t\t}\n\n\t\tpublic bool IsEmpty\n\t\t{\n\t\t\tget { return _propertyExpression == null || _propertyExpression.IsEmpty; }\n\t\t}\n\n\t\tpublic object Serialize()\n\t\t{\n\t\t\treturn _propertyExpression.Serialize();\n\t\t}\n\n\t\tpublic string Text\n\t\t{\n\t\t\tget { return _propertyExpression.Text; }\n\t\t}\n\n\t\tpublic bool TryEvaluate(IWorkflowContext ctx, out string result)\n\t\t{\n\t\t\tstring errorMessage;\n\t\t\tif (!_propertyExpression.TryEvaluate(ctx, out result, out errorMessage)) return false;\n\t\t\tWorkflowExpression expression = WorkflowExpression.Evaluate(ctx, result);\n\t\t\tresult = expression.ProcessedExpression;\n\t\t\treturn expression.IsValid;\n\t\t}\n\n\t\tpublic bool TryEvaluateWithoutContext(out string result)\n\t\t{\n\t\t\tstring errorMessage;\n\t\t\tif (!_propertyExpression.TryEvaluateWithoutContext(out result, out errorMessage)) return false;\n\t\t\tWorkflowExpression expression = WorkflowExpression.EvaluateWithoutContext(result);\n\t\t\tresult = expression.ProcessedExpression;\n\t\t\treturn expression.IsValid;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// This exists so you can do 'MyActivity.MyProperty = \"blah\";'.  Mostly used by the unit tests.\n\t\t/// </summary>\n\t\tpublic static implicit operator StringProperty(string s)\n\t\t{\n\t\t\treturn new StringProperty(new StringPropertyExpression(\"Literal\", s));\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    }
  ],
  "reasoning_chain": "ReasoningChain(strategy=<ReasoningStrategy.CHAIN_OF_THOUGHT: 'chain_of_thought'>, steps=[ReasoningStep(step_number=1, description='Analysis', reasoning='Relevant files to modify for adding HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION attributes\\n\\n1. /Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs  \\n   \u2022 Why: This class is the custom HttpApplication that wires up request/response processing for the CLM-web sites. It is the earliest point where both the incoming request headers (\u201cReferer\u201d) and the outgoing response (\u201cLocation\u201d for 3xx) are simultaneously available, making it the natural place to enrich (or mutate) the existing HTTP request span.\\n\\n2. /Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs  \\n   \u2022 Why: All OpenTelemetry / Activity sources are configured in this startup file.  The ASP.NET-core instrumentation is typically registered here with AddAspNetCoreInstrumentation(\u2026).  The enrichment callback that injects the two new attributes can be plugged in here so it is applied application-wide.\\n\\n(The remaining candidate files are service/processor specific (.Trace.cs) or worker-service code that do not participate in the ASP.NET request pipeline.  They neither create nor enrich the HTTP request spans we need to modify.)\\n\\nConfidence: 0.63', conclusion='Reasoning completed', confidence=0.7, evidence=['LLM response'])], final_conclusion='Confidence: 0.63', overall_confidence=0.7, alternative_approaches=[])"
}