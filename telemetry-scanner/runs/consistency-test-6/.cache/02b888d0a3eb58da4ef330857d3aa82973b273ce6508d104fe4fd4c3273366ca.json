{
  "selected_files": [
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class DetectTypeProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class VideoInfoProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net.Mime;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.PhysicalStorage;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FileIO;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.MimeLookup;\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.ContentStorage;\n\nnamespace ADEXS.DetectTypeService\n{\n\tpublic partial class DetectTypeProcessor : CommonTaskProcessor<DetectTypeTaskPayload>\n\t{\n\t\tprivate readonly IAtlasPersistenceFactory _atlasPersistenceFactory;\n\n\t\tprivate readonly IAtlasPhysicalStorageFactory _atlasPhysicalStorageFactory;\n\n\t\tprivate readonly IMimeDetector _mimeDetector;\n\n\t\tprivate readonly IDetectTypeServiceFeaturesConfig _featuresConfig;\n\n\t\tpublic DetectTypeProcessor()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IAtlasPersistenceFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IAtlasPhysicalStorageFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IMimeDetector>(),\n\t\t\t\tServiceLocator.GetInstance<IServiceInstrumentation>(),\n\t\t\t\tServiceLocator.GetInstance<IDetectTypeServiceFeaturesConfig>())\n\t\t{\n\t\t}\n\n\t\tpublic DetectTypeProcessor(\n\t\t\tIAtlasPersistenceFactory atlasPersistenceFactory,\n\t\t\tIAtlasPhysicalStorageFactory atlasPhysicalStorageFactory,\n\t\t\tIMimeDetector mimeDetector,\n\t\t\tIServiceInstrumentation serviceInstrumentation,\n\t\t\tIDetectTypeServiceFeaturesConfig featuresConfig)\n\t\t{\n\t\t\t_atlasPersistenceFactory = atlasPersistenceFactory;\n\t\t\t_atlasPhysicalStorageFactory = atlasPhysicalStorageFactory;\n\t\t\t_mimeDetector = mimeDetector;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t\t_featuresConfig = featuresConfig;\n\t\t}\n\n\t\tpublic override ProcessTaskResult ProcessTask()\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t// get and report the status of whether Optimizely is the feature flag provider\n\t\t\tLogger.InfoNoPII($\"Verification: IsOptimizelyVerificationFlagEnabled is {_featuresConfig.IsOptimizelyVerificationFlagEnabled} for account '{Task.AccountId}' (context accountId: '{AtlasContext.Current.AccountId}')\");\n\n\t\t\tProcessTaskResult result = new ProcessTaskResult();\n\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\tvar fileDataPersistence = _atlasPersistenceFactory.Get<IFileDataPersistence>(Task.AccountId);\n\n\t\t\tFileData fd = fileDataPersistence.LoadByUid(DeserializedPayload.FileDataUid);\n\t\t\tif (fd == null)\n\t\t\t{\n\t\t\t\tLogger.WarnNoPII($\"FileDataUid {DeserializedPayload.FileDataUid} does not exist in the db; ignoring\");\n\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\tresult.Message = \"Filedata Doesn't Exist\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// first try and detect the MIME type\n\t\t\t\t\tstring mimeType;\n\t\t\t\t\tusing (TempFile temp = new TempFile(fd.Extension))\n\t\t\t\t\t{\n\t\t\t\t\t\t//We could possibly optimize this by reading the first 256 bytes and passing them to the underlying COM library urlmon.dll.\n\t\t\t\t\t\t//See https://msdn.microsoft.com/en-us/library/ms775107(v=vs.85).aspx (FindMimeFromData function)\n\t\t\t\t\t\t_atlasPhysicalStorageFactory.GetPhysicalStorage(fd.AccountId).GetFile(fd.AccountId, fd.FileName, StorageConstants.StorageFormat.Native, temp.FileName);\n\t\t\t\t\t\tmimeType = _mimeDetector.DetectMimeType(temp.FileName);\n\t\t\t\t\t}\n\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected MIME type '{0}' for fileDataUid {1}.\", mimeType, fd.FileDataUid);\n\n\t\t\t\t\t// if still not sure try to map the extension to the MIME type\n\t\t\t\t\tif (string.IsNullOrEmpty(mimeType) || (mimeType == MediaTypeNames.Application.Octet))\n\t\t\t\t\t{\n\t\t\t\t\t\tmimeType = FileUtil.GetMimeTypeByExtension(fd.Extension);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Matched extension to MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\n\t\t\t\t\t// once we have a new MIME type, save it\n\t\t\t\t\tif (!string.IsNullOrEmpty(mimeType) && mimeType != fd.MIMEType)\n\t\t\t\t\t{\n\t\t\t\t\t\tfileDataPersistence.UpdateMIMEType(fd.Uid, mimeType);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected and set MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\t\t\te.Trace();\n\t\t\t\t\tLogger.ErrorNoPII($\"Failed to process fileDataUid {fd.FileDataUid} with exception \", e);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tTask.LastErrorMessage = e.Message;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.ErrorNoPII($\"Failed to mark fileDataUid {fd.FileDataUid} as failed with exception \", e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactivity?.SetQueueTaskResultTags(Task, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.MQ;\nusing ADEXS.Core.Domain;\nusing System.Threading;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing System.IO;\nusing ADEXS.Core.Domain.Model;\nusing System.Diagnostics;\n\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.ServiceFramework;\nusing CLM.MessageDefines;\nusing CLM.MessageDefines.Constants;\nusing CLM.MessageDefines.Interfaces;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\n\nusing StructureMap;\nusing ADEXS.MqWorkers.Config.Context;\nusing ADEXS.MqWorkers.Extensions;\nusing ADEXS.MqWorkers.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.MqWorkers.Config;\n\nnamespace ADEXS.Services.MessageWorkerService\n{\n\t//Should probably make an interface that encapsulates the methods for loading and\n\t//updating the Tasks so that we don't have to be tied to MessageQueues for this type of worker\n\tpublic class DispatchedWorker<T, U> : AbstractServiceQueue<T> where T : class, IQueueTask, new() where U : class, ITaskProcessor<T>, new()\n\t{\n\t\tprivate const string DESIRED_WORKER_COUNT = \"_WorkerCount\";\n\t\tprivate const string DESIRED_WORKER_MULTIPLIER = \"_WorkerMultiplier\";\n\t\tprivate const string TASK_DISPATCHERS = \"_TaskDispatchers\";\n\t\tprivate const string DESIRED_STAND_ALONE = \"_StandAlone\";\n\t\tprivate const string DEFAULT_TASK_DISPATCHERS = \"DefaultTaskDispatchers\";\n\t\tprivate const int DEFAULT_WORKER_COUNT = 5;\n\t\tprivate const double DEAFULT_CORE_TO_WORKER_MULTIPLIER = 0;\n\t\tprivate readonly string TASKPROCESSOR = Configuration.GetStringAppSetting(PROCESSSTART_NAME, \"ADEXS.TaskProcessor.exe\");\n\t\tprivate const string PROCESSSTART_NAME = \"PROCESSSTART_NAME\";\n\t\tprivate string _typeName;\n\t\tprivate readonly TaskTypes _taskType;\n\t\tprivate bool _standAlone;\n\n\t\tprivate readonly IContainer _container;         // optionally injected DI container\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate readonly Func<U> _createProcessor;\n\t\tprivate int _fetchMod;\n\n\t\t[ThreadStatic]\n\t\tprivate static int _errorCount = 0;\n\n\t\tpublic override string Name => base.Name + TypeName;\n\n\t\t[EventSource(\"Workers\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly PropertyBagEventSource _workersEventSource = new PropertyBagEventSource();\n\n\t\t[Counter(\"Workers Count\", \"CLM.DispatchedWorker\", MeasureProperty = \"Count\", InstanceProperty = \"Description\")]\n\t\t[EventSource(\"Workers Count\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly CountEventSource _workersCountEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\")]\n\t\t[Counter(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\", InstanceProperty = \"Description\")]\n\t\tprivate static ExceptionEventSource _workerLoggingExceptionEventSource = new ExceptionEventSource();\n\n\t\tstatic DispatchedWorker()\n\t\t{\n\t\t\t// Kazmon emits from a generic type do not work without this call\n\t\t\tMonitoringRuntime.RegisterGenericType(typeof(DispatchedWorker<T, U>));\n\t\t}\n\n\t\tpublic string TypeName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\t_typeName ??= _taskType.ToString();\n\t\t\t\treturn _typeName;\n\t\t\t}\n\t\t}\n\n\t\tpublic IMessageQueueWrapperFactory MessageQueueWrapperFactory { get; set; }\n\n\t\t/// <summary>\n\t\t/// Legacy Constructor -- delegates to the new overload; passes DI container extracted from ServiceLocator.\n\t\t/// This method will be deprecated in the future -- prefer the (IServicedComponent, IContainer) overload.\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this dispatched worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\tpublic DispatchedWorker(IServicedComponent component, TaskTypes taskType, IWatchedSingletonConfig<ISiteConfig> siteConfig) : this(component, taskType, ServiceLocator.Container, Activator.CreateInstance<U>, siteConfig)\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor overload that accepts a DI container (stepping stone to moving away from SL pattern).\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\t/// <param name=\"container\">the DI container for service discovery and IOC</param>\n\t\tinternal DispatchedWorker(IServicedComponent component, TaskTypes taskType, IContainer container, Func<U> processorFactory, IWatchedSingletonConfig<ISiteConfig> siteConfig) : base(component)\n\t\t{\n\t\t\t_container = container;\n\t\t\t_createProcessor = processorFactory ?? (() => new U());\n\t\t\tServiceLocator.BuildUp(this);\n\t\t\t_taskType = taskType;\n\t\t\t//This is here to prevent a regression following ATL-81324\n\t\t\tif (TypeName != typeof(T).Name)\n\t\t\t\tthrow new ArgumentException($\"Failed to initialize DispatchedWorker: Task Name ({typeof(T).Name}) must match task type ({TypeName})\");\n\t\t\t_waitOnNoItems = false;\n\t\t\t_standAlone = Configuration.GetBooleanAppSetting(TypeName + DESIRED_STAND_ALONE, false);\n\t\t\tif (_standAlone) _log.DebugNoPII($\"Worker running in StandAlone mode for {TypeName}\");\n\t\t\t_siteConfig = siteConfig;\n\t\t}\n\n\t\tprivate ProcessTaskResult RunExternalTaskProcessor(ProcessTaskRequest taskRequest)\n\t\t{\n\t\t\tvar accountId = taskRequest.Task.AccountId;\n\t\t\tbool useAnonymousPipes = TasksManagementFeatureFlags.UseAnonymousPipeForExternalTaskProcessors &&\n\t\t\t                         Configuration.GetBooleanAppSetting(\n\t\t\t\t                         $\"{accountId}_UseAnonymousPipeForExternalTaskProcessors\", true);\n\t\t\t_log.InfoNoPII(useAnonymousPipes\n\t\t\t\t? \"Worker using Anonymous Pipes for Request and Results\"\n\t\t\t\t: \"Worker using Temp Files for Request and Results\");\n\t\t\tExternalTaskWorker externalTaskWorker = ExternalTaskWorkerFactory.GetExternalTaskWorker(useAnonymousPipes);\n\t\t\treturn externalTaskWorker.RunExternalProcessor(taskRequest,TASKPROCESSOR);\n\t\t}\n\n\t\tprotected override int MaxQueueDepth()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_WorkerMaxQueueDepth\", Configuration.GetInt32AppSetting(TypeName + WORKER_MAXSET, WORKER_MAXSET_DEFAULT)) * DesiredWorkerCount();\n\t\t}\n\n\t\tprotected override IList<T> Fetch(int fetchCount)\n\t\t{\n\t\t\tList<T> tasks = new List<T>();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPeriodicPulse();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not pulse for ''{TypeName}''.\", ex);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttasks = FetchFromQueues(fetchCount);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not load the items for the queue: {TypeName}\", ex);\n\t\t\t\t_lastFetchDate = DateTime.UtcNow;\n\t\t\t}\n\n\t\t\tAttemptRestorePropertiesFromPayload(tasks);\n\n\t\t\treturn tasks;\n\t\t}\n\n\t\tprivate List<T> FetchFromQueues(int fetchCount)\n\t\t{\n\t\t\tvar queuePaths = DefaultQueue.GetWorkerMqPaths(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\n\t\t\t// keep incrementing to pull from a different queue on each fetch, fetching from all queues seems to have an adverse effect on the channels\n\t\t\t_fetchMod %= queuePaths.Length;\n\t\t\tvar queuePath = queuePaths[_fetchMod];\n\t\t\t_fetchMod++;\n\n\t\t\treturn FetchSingleQueue(fetchCount, queuePath);\n\t\t}\n\n\t\tprivate List<T> FetchSingleQueue(int fetchCount, string path)\n\t\t{\n\t\t\tbool isMainPath = path == DefaultQueue.GetWorkerMqPath(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\t\t\tint waitTime = isMainPath ? TaskUtilities.InitialReceiveWaitMS(TypeName) : Configuration.GetInt32AppSetting(\"InitialReceiveWaitAdditionalQueueMS\", 20);\n\t\t\tusing (IMessageQueueWrapper pdfMQ = MessageQueueWrapperFactory.CreateReceiveInstance(Configuration.GetStringAppSetting(TypeName + \"_WorkerMQPath\", path)))\n\t\t\t{\n\t\t\t\treturn pdfMQ.ReceiveMultiple<T>(waitTime, MQApplicationSettings.DefaultExtraReceiveWaitMS, fetchCount);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Restore the task type properties from the payload. This will only live temporarily as we move\n\t\t/// all tasks toward using the CommonTask payload. If we fail to restore from properties we should log to kazmon\n\t\t/// but we should not not block tasks from getting processed. We are also logging when we find a task\n\t\t/// without a payload set.\n\t\t/// </summary>\n\t\tprivate void AttemptRestorePropertiesFromPayload(List<T> tasks)\n\t\t{\n\t\t\t// App Setting to disable this behavior just in case of issues\n\t\t\tvar restoreFromPayload = Configuration.GetBooleanAppSetting($\"RestoreTaskFromPayload_All\", true) &&\n\t\t\t\tConfiguration.GetBooleanAppSetting($\"RestoreTaskFromPayload_{TypeName}\", true);\n\n\t\t\tforeach (var task in tasks)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (task is CommonTask cTask)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string.IsNullOrEmpty(cTask.Payload))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Log to kazmon to ensure that we don't miss any tasks\n\t\t\t\t\t\t\tCommonTaskPayloadHelper.CommonTaskPayloadMissingEventSource.Emit(1, cTask.Label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (restoreFromPayload)\n\t\t\t\t\t\t\t\tcTask.RestorePropertiesFromPayload();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tCommonTaskPayloadHelper.PayloadRestoreExceptionEventSource.Emit(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate QueueItemType _lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\tpublic override void AdjustWorkers()\n\t\t{\n\t\t\tbase.AdjustWorkers();\n\n\t\t\tint desiredWorkerCount = DesiredWorkerCount(out double multiplier);\n\t\t\tSetEnabled(desiredWorkerCount > 0);\n\t\t\tQueueItemType currentQueueStatus = (desiredWorkerCount > 0) ? QueueItemType.QueueStarted : QueueItemType.QueueStopped;\n\t\t\tif (currentQueueStatus == _lastSentQueueStatus) return;\n\n\t\t\tEmitWorkerConfiguration(currentQueueStatus, desiredWorkerCount, multiplier);\n\t\t\tstring adminQueuePath = \"Unset\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tT startTask = new T\n\t\t\t\t{\n\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\tQueueItemType = currentQueueStatus,\n\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t};\n\n\t\t\t\tif (!_standAlone)\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueuePath = GetAdminQueuePath(machine);\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(adminQueuePath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(startTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = currentQueueStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:AdjustWorkers - Could not contact the administration queue: \" + adminQueuePath, ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitWorkerConfiguration(QueueItemType queueItemtype, int desiredWorkerCount, double multiplier)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_workersCountEventSource.Emit(desiredWorkerCount, TypeName);\n\n\t\t\t\tusing (var propertyBag = _workersEventSource.CreateEventPropertyBag(queueItemtype.ToString()))\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TaskType\", TypeName);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"DesiredWorkerCount\", desiredWorkerCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"Multiplier\", multiplier.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ProcessorCount\", Environment.ProcessorCount.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_workerLoggingExceptionEventSource.Emit(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetMachineName() => System.Net.Dns.GetHostName();\n\t\tprivate string GetTaskTypeName() => typeof(T).FullName;\n\n\t\tprivate static int _queueStateTouchIntervalMin = 60;\n\t\tprivate DateTime _nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\n\t\tprotected virtual void PeriodicPulse()\n\t\t{\n\t\t\tif (_nextStateTouchTime < DateTime.UtcNow)\n\t\t\t{\n\t\t\t\tQueueStatePersistence.AuthenticationInstance.Touch(GetMachineName(), GetTaskTypeName());\n\t\t\t\t_nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Blast the local queue back to the dispatcher so that it can be\n\t\t/// dispatched to another worker.\n\t\t///\n\t\t/// Also sends a disable me message\n\t\t/// </summary>\n\t\tpublic override void Stop()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//Try to do a prelim kill before the stop of the workers\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch\n\t\t\t{\n\t\t\t\t_log.DebugNoPII(\"Didn't kill processes first time\");\n\t\t\t}\n\n\t\t\tbase.Stop();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSetEnabled(false);\n\t\t\t\tif (!_standAlone && (_lastSentQueueStatus != QueueItemType.QueueStopped))\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tT stopTask = new T\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\t\t\tQueueItemType = QueueItemType.QueueStopped,\n\t\t\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(machine)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(stopTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\t\t\t}\n\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:Stop - Exception generated during stop:\", ex);\n\t\t\t}\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStopped, 0, 0);\n\t\t}\n\n\t\tprivate void KillTaskProcessors()\n\t\t{\n\t\t\tvar nestedContainer = CreateNestedContainer(null);\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);  // necessary to determine if processor would run out-of-process\n\t\t\t// attempt to kill any active out-of-process processors\n\t\t\tif (processor.RunInSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t\t\tstring processName = Path.GetFileNameWithoutExtension(TASKPROCESSOR);\n\t\t\t\tProcess[] tokill = System.Diagnostics.Process.GetProcessesByName(processName);\n\t\t\t\tif (tokill.Length > 0)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"Killing {processName} processes.\");\n\t\t\t\t\tforeach (Process p in tokill)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Failed to kill process with pid: {p.Id}\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void SetEnabled(bool enable)\n\t\t{\n\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\t\t\tbool alreadySet = false;\n\t\t\tstring taskTypeName = GetTaskTypeName();\n\t\t\t_log.DebugNoPII($\"Task type: {taskTypeName}, enable set to {enable}\");\n\n\t\t\tforeach (QueueState state in QueueStatePersistence.AuthenticationInstance.LoadAll())\n\t\t\t{\n\t\t\t\tif (state.MachineName.Equals(GetMachineName(), StringComparison.InvariantCultureIgnoreCase)\n\t\t\t\t\t&& state.TaskTypeName == taskTypeName)\n\t\t\t\t{\n\t\t\t\t\tif (enable)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine already exists for task type {taskTypeName}, attempting to enable it\");\n\t\t\t\t\t\tRegisterQueueState(state);\n\t\t\t\t\t\talreadySet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine exists for task type {taskTypeName}, attempting to disable it\");\n\t\t\t\t\t\tstate.Enabled = false;\n\t\t\t\t\t\tQueueStatePersistence.AuthenticationInstance.Save(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (enable && !alreadySet)\n\t\t\t{\n\t\t\t\t// must be a new entry in the queuestate table\n\t\t\t\t_log.DebugNoPII($\"Machine does not already exist for task type {taskTypeName}, attempting to create it\");\n\t\t\t\tRegisterQueueState(null);\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// This will either create the queuestate or update\n\t\t/// it as enabled.\n\t\t/// </summary>\n\t\tprivate void RegisterQueueState(QueueState queueState)\n\t\t{\n\t\t\tif (queueState == null)\n\t\t\t{\n\t\t\t\tqueueState = new QueueState();\n\t\t\t\tType taskType = typeof(T);\n\t\t\t\tqueueState.MachineName = GetMachineName();\n\t\t\t\tqueueState.TaskAssemblyName = taskType.Assembly.GetName().Name;\n\t\t\t\tqueueState.TaskTypeName = GetTaskTypeName();\n\t\t\t\t_log.DebugNoPII($\"Creating new entry in QueueState for tasktype: {queueState.TaskTypeName}\");\n\t\t\t}\n\n\t\t\tqueueState.Enabled = true;\n\t\t\tqueueState.WorkerCount = DesiredWorkerCount(out double multiplier);\n\n\t\t\t_log.DebugNoPII($\"Saving QueueState for task type: {queueState.TaskTypeName} with properties - machine name: {queueState.MachineName},\" +\n\t\t\t\t$\"assembly name: {queueState.TaskAssemblyName} enabled: {queueState.Enabled}, worker count: {queueState.WorkerCount}\");\n\n\t\t\tQueueStatePersistence.AuthenticationInstance.Save(queueState);\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStarted, queueState.WorkerCount, multiplier);\n\t\t}\n\n\t\tprotected override TaskResult Process(T task, out string message)\n\t\t{\n\t\t\tmessage = null;\n\n\t\t\tAtlasContext.Current.AccountId = task.AccountId;\n\t\t\tAtlasContext.Current.TransactionId = task.CorrelationId;\n\t\t\tif (task is IUserTask usrTask)\n\t\t\t{\n\t\t\t\tAtlasContext.Current.UserAccountUid = usrTask.UserAccountUid;\n\t\t\t}\n\n\t\t\tGuid corrToken;\n\t\t\tGuid.TryParse(task.CorrelationId, out corrToken);\n\n\t\t\tusing var activity = StartActivity(task, corrToken);\n\n\t\t\tstring telemetryLabel = task.Label;\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\tusing (var logger = new TaskServiceRequestEventLogger(corrToken, telemetryLabel))\n\t\t\t{\n\t\t\t\t// introduces request-scoped container for user context state (and any other future per-request DI state)\n\t\t\t\tusing var nestedContainer = CreateNestedContainer(AtlasContext.Current);\n\n\t\t\t\t// The DataPoint enum is defined in DocuSign sources. Trying to use some, hopefully with close enough semantics.\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, task.AccountId);\n\t\t\t\tServiceContext.Log(DataPoint.QueueItemId, task.UniqueId);\n\t\t\t\tServiceContext.Log(DataPoint.TimeQueued, $\"{task.CreatedDate:yyyy-MM-dd HH:mm:ss.fff}\");\n\t\t\t\tif (Guid.Empty != AtlasContext.Current.UserAccountUid)\n\t\t\t\t{\n\t\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The nugget inside the monitoring wrapper.\n\t\t\t\t\tTaskResult taskResult = ProcessTask(task, nestedContainer, out message, activity);\n\n\t\t\t\t\tServiceContext.Log(DataPoint.ApiStatus, $\"{taskResult}\");\n\t\t\t\t\tlogger.Success = (taskResult != TaskResult.Failure);\n\t\t\t\t\tactivity?.SetStatusFromTask(taskResult);\n\t\t\t\t\treturn taskResult;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tex.Trace().Report();\n\t\t\t\t\tthrow;\n \t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (!logger.Success && null != message)\n\t\t\t\t\t{\n\t\t\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate TaskResult ProcessTask(T task, IContainer nestedContainer, out string message, Activity activity)\n\t\t{\n\t\t\tProcessTaskResult result = new ProcessTaskResult() { Message = \"Context Set\" };\n\n\t\t\tif (TaskUtilities.CheckSuspendedTaskTypeForAccount(TypeName, task.AccountId))\n\t\t\t{\n\t\t\t\tmessage = $\"task failed because Aid {task.AccountId} is in the suspended account list for {TypeName}\";\n\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\ttask.ErrorCount = int.MaxValue;\n\t\t\t\treturn TaskResult.Failure;\n\t\t\t}\n\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);\n\n\t\t\tAtlasContext.Current.ActionType = processor.ActionType;\n\n\t\t\tif (processor.RunInSeparateProcess && !processor.HandleSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t \t\tProcessTaskRequest taskRequest = new ProcessTaskRequest()\n\t\t\t\t{\n\t\t\t\t\tAccountId = AtlasContext.Current.AccountId,\n\t\t\t\t\tUserAccountUid = AtlasContext.Current.UserAccountUid,\n\t\t\t\t\tActionType = AtlasContext.Current.ActionType,\n\t\t\t\t\tProcessorTypeName = processor.GetType().AssemblyQualifiedName,\n\t\t\t\t\tTask = task,\n\t\t\t\t\tTaskType = _taskType,\n\t\t\t\t\tCorrelationToken = MonitoringContext.CorrelationToken ?? Guid.Empty\n\t\t\t\t};\n\t\t\t\tresult = RunExternalTaskProcessor(taskRequest);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprocessor.Task = task;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tprocessor.PreProcess();\n\t\t\t\t\tresult = processor.ProcessTask();\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tprocessor.PostProcess();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = result.Message;\n\n\t\t\tactivity?.SetQueueTaskResultTags(task, new MqWorkers.DispatchedWorker.ProcessTaskResult { Message = message });\n\n\t\t\treturn result.TaskResult;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an instance of the ITaskProcessor that should be used when processing a request.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This method takes into account whether we are using a scoped DI container, and if so, will\n\t\t/// attempt to get the task processor from there to ensure that other scoped DI services (eg user context)\n\t\t/// are also correctly set up. If the supplied `container` parameter is null we create a non-scoped\n\t\t/// processor instance, otherwise we demand it from the container (which may throw if none is registered).\n\t\t/// </remarks>\n\t\t/// <param name=\"container\">Optional (nullable) DI container from which we acquire scoped processors</param>\n\t\t/// <returns>An instance of ITaskProcessor{T} that can process the task.</returns>\n\t\tprivate U CreateTaskProcessor(IContainer container)\n\t\t{\n\t\t\t// NOTE: If we have a nested DI container, defer to it for the ITaskProcessor instance.\n\t\t\t//       If there is no nested container, or it doesn't have a ITaskProcessor registered,\n\t\t\t//       instantiate one one locally.\n\t\t\treturn container?.GetInstance<U>() ?? _createProcessor.Invoke();\n\t\t}\n\n\t\tprotected override void UpdateFailure(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//this will requeue it if needed\n\t\t\t\ttask.QueueItemType = QueueItemType.Ack;\n\t\t\t}, () =>\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Again errors should pause the movement of the items.\n\t\t\t\t * For this worker.\n\t\t\t\t */\n\t\t\t\tif (_errorCount++ % Configuration.GetInt32AppSetting(\"ErrorCountSleepMod\", 100) == 0)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(SleepMilliSeconds());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateUnlock(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//task will requeue it\n\t\t\t\ttask.QueueItemType = QueueItemType.Task;\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateSuccess(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.QueueItemType = QueueItemType.Completed;\n\t\t\t});\n\t\t}\n\n\t\tprivate void SendTaskStatusUpdate(T task, Action beforeSend, Action afterSend = null)\n\t\t{\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\t{\n\t\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\n\t\t\t\tbeforeSend();\n\n\t\t\t\tstring sendMachine = task.SendMachine; // Send() changes the SendMachine property, so store it here in case we need to restore it after an exception.\n\n\t\t\t\tusing (IMessageQueueWrapper adminQueue = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(task.SendMachine)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueue.Send(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Detected IOException.  Will retry once.\", ioe);\n\n\t\t\t\t\t\tadminQueue.ReSend(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Restore original SendMachine, for the sake of the UpdateFailure() call from AbstractServiceQueue.\n\t\t\t\t\t\ttask.SendMachine = sendMachine;\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (afterSend != null)\n\t\t\t\t{\n\t\t\t\t\tafterSend();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Crate a nested DI container for the user context (and potentially other request-scoped DI state).\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// Introduced as part of ATL-72998 to add support for feature flag integration, which requires access to\n\t\t/// the request-scoped Account/User identity for flag resolution decisions.\n\t\t/// </remarks>\n\t\t/// <param name=\"atlasContext\">Atlas request context for this request/task</param>\n\t\t/// <returns>Disposable DI container for this request-scoped state</returns>\n\t\tprivate IContainer CreateNestedContainer(IAtlasContext atlasContext)\n\t\t{\n\t\t\tvar nestedContainer = _container.GetNestedContainer();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (atlasContext != null)\n\t\t\t\t{\n\t\t\t\t\tvar userContextSetter = nestedContainer.TryGetInstance<IUserContextSetter>();\n\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tuserContextSetter.AccountId = atlasContext.AccountId;\n\t\t\t\t\t\tuserContextSetter.UserId = atlasContext.UserAccountUid; // this may be null, but that's ok\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Should we have a specific OT telemetry event for this condition? It's most like incorrectly configured DI setup, but may not be a defect.\n\t\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire IUserContextSetter - transactionId {atlasContext.TransactionId} will proceed without scoped user context.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar taskContextSetter = nestedContainer.TryGetInstance<ITaskTypeContextSetter>();\n\n\t\t\t\tif (taskContextSetter != null)\n\t\t\t\t{\n\t\t\t\t\ttaskContextSetter.TaskType = _taskType;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire ITaskTypeContextSetter - {TypeName} will proceed without scoped task type context.\");\n\t\t\t\t}\n\n\t\t\t\treturn nestedContainer;\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\tnestedContainer?.Dispose();  // avoid leaking nested container\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic virtual int StandardSleepSeconds => 5;\n\t\tprotected override int SleepSeconds()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_SleepSeconds\", StandardSleepSeconds);\n\t\t}\n\n\t\tpublic virtual int StandardWorkerCount => DEFAULT_WORKER_COUNT;\n\n\t\tpublic override int DesiredWorkerCount()\n\t\t{\n\t\t\treturn DesiredWorkerCount(out _);\n\t\t}\n\n\t\tprivate int DesiredWorkerCount(out double multiplier)\n\t\t{\n\t\t\tmultiplier = 0;\n\t\t\tint count = -1;\n\t\t\tif (IsOneConfigEnabledForWorkerCount())\n\t\t\t{\n\t\t\t\tvar mqTasksconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IMqTasksConfig>>()?.Value;\n\t\t\t\tvar taskConfigs = mqTasksconfigs?.TaskConfigs;\n\t\t\t\tif (taskConfigs != null && taskConfigs.TryGetValue(TypeName, out var taskConfig))\n\t\t\t\t{\n\t\t\t\t\tcount = taskConfig.WorkerCount;\n\t\t\t\t\tmultiplier = taskConfig.WorkerMultiplier;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Failed to retrieve task configuration from INI file for TaskName: {TypeName}. Falling back to legacy processing.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count < 0)\n\t\t\t{\n\t\t\t\t// Rely on appsetting if oneConfig is disabled or if it cannot retrive from oneconfig\n\t\t\t\tcount = Configuration.GetInt32AppSetting(TypeName + DESIRED_WORKER_COUNT, StandardWorkerCount);\n\t\t\t\tmultiplier = Configuration.GetDoubleAppSetting(TypeName + DESIRED_WORKER_MULTIPLIER, DEAFULT_CORE_TO_WORKER_MULTIPLIER);\n\t\t\t}\n\n\t\t\t// we still want to be able to force the count to zero in order to turn off a worker group effectively\n\t\t\t// let's check the worker count based on the number of logical cores and a configured multiplier\n\t\t\tif (count != 0 && multiplier > 0)\n\t\t\t{\n\t\t\t\t// use the number of logical cores and a multiplier to determine a good worker count number.\n\t\t\t\tint numCores = Environment.ProcessorCount;\n\t\t\t\tcount = Math.Max((int)(numCores * multiplier), 1);  // we really never want a > 0 multiplier to cause a zero worker count\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tprivate bool IsOneConfigEnabledForWorkerCount()\n\t\t{\n\t\t\tbool isOneConfigEnabled = false;\n\t\t\tif(ConfigWrapper.UseOneConfigMqTasksConfig)\n\t\t\t{\n\t\t\t\tvar appconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOneConfigMqTasks_\" + appconfigs?.AppName, true))\n\t\t\t\t{\n\t\t\t\t\tisOneConfigEnabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isOneConfigEnabled;\n\t\t}\n\n\t\tprivate IEnumerable<string> DispatcherMachines()\n\t\t{\n\t\t\treturn StringUtil.Split('|', Configuration.GetStringAppSetting(TypeName + TASK_DISPATCHERS, Configuration.GetStringAppSetting(DEFAULT_TASK_DISPATCHERS, GetMachineName())));\n\t\t}\n\n\t\tprivate string GetAdminQueuePath(string machine)\n\t\t{\n\t\t\treturn string.Format(Configuration.GetStringAppSetting(TypeName + \"_EventMQPathFormat\", DefaultQueue.GetAdminMqPathFormat(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName))), machine ?? GetMachineName());\n\t\t}\n\n\t\tprivate Activity StartActivity(T task, Guid correlationToken) =>\n\t\t\tServiceInstrumentation.ActivitySource\n\t\t\t\t?.StartActivity(\n\t\t\t\t\ttask.Label ?? $\"{nameof(ADEXS.Services.MessageWorkerService)}\",\n\t\t\t\t\tActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Activities.HumanActivities;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.ActivityProperties;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.ExpressionService.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Config;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\nusing ADEXS.WINS.Interfaces;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\n\nusing Platform.Common;\n\nusing SCMAppenders;\n\nusing static ADEXS.Atlas.Workflow.Activities.Handlers.InstanceHandler;\n\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing InstanceVariable = ADEXS.Core.Domain.Model.Workflow.InstanceVariable;\nusing LoggingHelper = ADEXS.Atlas.Workflow.Activities.Infrastructure.LoggingHelper;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing UserAccount = ADEXS.Core.Domain.Model.UserAccount;\n\nnamespace ADEXS.WINS.Engine\n{\n\t/// <summary>\n\t/// An instance of a workflow -- a specific example of a definition.\n\t/// This class contains methods for controlling it, but all such calls should actually be fed through\n\t/// WorkflowManager so they can be queued, etc.\n\t/// </summary>\n\tpublic class WorkflowInstance : IWINSControlInstance\n    {\n        public const int SQL_SEVERITY_LEVEL_TRANSIENT = 12;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowInstance));\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IInstanceVariableGovernance _instanceVariableGovernance;\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepository;\n\t\tprivate IGovernor _governor;\n\t\tprivate IInstanceHandler _instanceHandler;\n\t\tprivate IServiceInstrumentation _serviceInstrumentation;\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> _workflowClientConfig;\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate ICacheRepository _cacheRepository;\n\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => (_instanceVariableGovernance ?? (_instanceVariableGovernance = ServiceLocator.GetInstance<IInstanceVariableGovernance>()));\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository ?? (_workflowSettingRepository = ServiceLocator.GetInstance<IWorkflowSettingRepository>());\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\t\tprivate IInstanceHandler InstanceHandler => _instanceHandler ?? (_instanceHandler = ServiceLocator.GetInstance<IInstanceHandler>());\n\n\n\t\tprivate IServiceInstrumentation ServiceInstrumentation => _serviceInstrumentation ?? (_serviceInstrumentation = ServiceLocator.GetInstance<IServiceInstrumentation>());\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> WorkflowClientConfig => _workflowClientConfig ?? (_workflowClientConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>());\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> SiteConfig => _siteConfig ?? (_siteConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>());\n\t\tprivate ICacheRepository CacheRepository => _cacheRepository ?? (_cacheRepository = ServiceLocator.GetInstance<ICacheRepository>());\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig ?? (_workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\n\t\t/// <summary>\n\t\t/// Loads (and locks) an existing instance.  Fails if the instance doesn't exist or can't be locked.\n\t\t/// </summary>\n\t\tpublic static WorkflowInstance LoadExisting(int accountId, Guid instanceUid, IWINSDataStore data)\n        {\n\t        DateTime lockExpirationDate;\n            InstancePersistence.LockResult lockResult = data.LockInstance(accountId, instanceUid, out lockExpirationDate);\n            switch (lockResult)\n            {\n                case InstancePersistence.LockResult.AlreadyCompleted:\n                    throw new InstanceAlreadyCompletedException(string.Format(\"InstanceUid {0} is already completed\", instanceUid));\n                case InstancePersistence.LockResult.DoesNotExist:\n                    throw new ApplicationException(string.Format(\"Invalid instanceUid {0}\", instanceUid));\n                case InstancePersistence.LockResult.LockedByOther:\n                    throw new InstanceLockedException(string.Format(\"InstanceUid {0} is locked by another process\", instanceUid));\n                case InstancePersistence.LockResult.Locked:\n                    // This is our success condition\n                    break;\n                default:\n                    throw new ApplicationException(string.Format(\"Unhandled lockResult for instanceUid {0}: {1}\", instanceUid, lockResult));\n            }\n            Instance instance = data.LoadInstanceByUid(accountId, Constants.WorkflowUser, instanceUid);\n            if (instance == null) throw new ApplicationException(string.Format(\"Failed to load workflow instanceUid {1} for account {0}.\", accountId, instanceUid));\n\n\t\t\ttry\n            {\n                if (instance.ScopeUid != Guid.Empty)\n                {\n                    Scope scope = ServiceLocator.GetInstance<IDocumentScopeRepository>().GetScopeByUid(accountId, instance.ScopeUid);\n                    if (scope != null)\n                        instance.ScopeName = scope.Name;\n                }\n            }\n            catch (Exception ex)\n            {\n                // the failure to load the scope should not cause the failure to load the instance, log it and move on\n                _log.WarnNoPII(string.Format(\"Could not load the scope '{0}' for workflow instance '{1}'.\", instance.ScopeUid, instanceUid), ex);\n            }\n\n\t\t\tRevision revision = data.LoadRevisionByUid(accountId, Constants.WorkflowUser, instance.RevisionUid);\n            if (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, instance.RevisionUid));\n            // ATL-68146: Populate RevisionCreatedDate here, because LoadInstanceByUid() doesn't populate it.\n            instance.RevisionCreatedDate = revision.CreatedDate;\n            WorkflowMap workflowMap = null;\n            instance.DefinitionUid = revision.DefinitionUid;\n\n\t\t\ttry\n            {\n\t            workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n            }\n            catch (InvalidDesignDefinitionException ex)\n            {\n\t            try\n\t            {\n\t\t            new WorkflowInstance(instance, data).Abort(UserAccount.WorkflowUserAccount(accountId), ex.Message);\n\t            }\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Error aborting workflow instance '{instanceUid}' with invalid definition\", e);\n\t\t\t\t}\n\n\t            throw;\n            }\n\n            var workflowInstance = new WorkflowInstance(instance, workflowMap, data);\n\t        workflowInstance.LockExpirationDate = lockExpirationDate;\n\t        return workflowInstance;\n\n        }\n\n        private readonly IWINSDataStore _data;\n        private readonly WorkflowMap _workflowMap;\n        private Instance _instance;\n\n        // The count of the activities that have been generated by this particular in-memory instance.  This doesn't get persisted anywhere, so is\n        // cleared whenever this WorkflowInstance gets unloaded (eg, when it enters into a Waiting state).\n        // It's use is to detect runaway workflows.\n        public const int MAX_IN_MEMORY_ACTIVITY_COUNT = 5000;\n        private int _inMemoryActivityCount = 0;\n\t\tprivate int _activityExecutionCountEnforcedLimit = 0;\n\t\tprivate Guid _revisionUid = Guid.Empty;\n\t\tprivate Guid _definitionUid = Guid.Empty;\n\t\tprivate DateTime _revisionCreatedDate = DateTime.MinValue;\n\t\tprivate bool _isActivityExecutionLimitReached = false;\n\n\t\tprivate readonly object _lockObject = new object();\n        private readonly IDictionary<Guid, InstanceActivity> _unfinishedActivities = new Dictionary<Guid, InstanceActivity>();\n        private readonly Queue<Event> _queuedControlEvents = new Queue<Event>();\n        private readonly Queue<Event> _queuedEvents = new Queue<Event>();\n\n        private readonly Dictionary<string, ContentDefinition> _contentDefinitions = new Dictionary<string, ContentDefinition>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, InstanceVariable> _variables = new Dictionary<string, InstanceVariable>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, IXmlVariableDefinition> _xmlVariableDefinitions = new Dictionary<string, IXmlVariableDefinition>(StringComparer.InvariantCultureIgnoreCase);\n\n        private readonly TimedLock _lock;\n\n        // Kind of a hack -- this is kept around so that if we end the instance without reaching the End step, we have an activity that we can\n        // log the message to.\n        private Guid _lastActivityUid;\n\n        private WorkflowInstance(Instance instance, IWINSDataStore data)\n        {\n\t        _data = data;\n\t        _lock = new TimedLock(instance.Uid.ToString());\n\t        _instance = instance;\n\t\t\t_revisionUid = _instance.RevisionUid;\n\t\t\t_revisionCreatedDate = instance.RevisionCreatedDate;\n\t        LastProcessDate = DateTime.UtcNow;\n\t\t\t_definitionUid = _instance.DefinitionUid;\n\t\t}\n\n\t\tpublic WorkflowInstance(Instance instance, WorkflowMap workflowMap, IWINSDataStore data) : this(instance, data)\n        {\n            _workflowMap = workflowMap;\n            // Load up any incomplete activities.  This is pointless to do for a new workflow, but it's not expensive either,\n            // so we simply avoid trying to figure that out and simply do it.\n            QueueIncompleteActivities();\n        }\n\n        /// <summary>\n        /// The AccountId this instance is running in.\n        /// </summary>\n        public int AccountId { get { return _instance.AccountId; } }\n\n        public Dictionary<string, ContentDefinition> ContentDefinitions { get { return _contentDefinitions; } }\n\n        public IWINSDataStore DataStore { get { return _data; } }\n\n        public TimedLock ThreadLock { get { return _lock; } }\n\n        /// <summary>\n        /// An in-memory, non-persisted value -- this is used when workers are finding instances to do work on.\n        /// It acts to make the WorkflowManager more FIFO, so that some workflows don't continually get ignored in favor of\n        /// newer work coming in.\n        /// </summary>\n        public DateTime LastProcessDate { get; private set; }\n\n        /// <summary>\n        /// The model Instance object; I didn't call this Instance because I didn't want it confused with a singleton pattern, and because\n        /// I didn't like seeing \"instance.Instance\".\n        /// </summary>\n        public Instance Model { get { return _instance; } }\n\n\t\tpublic DateTime LockExpirationDate { get; set; }\n\n\t\t/// <summary>\n\t\t/// The instance's Uid.  Primary key.\n\t\t/// </summary>\n\t\tpublic Guid Uid { get { return _instance.Uid; } }\n\n        public Dictionary<string, InstanceVariable> Variables { get { return _variables; } }\n\n        public Dictionary<string, IXmlVariableDefinition> XmlVariableDefinitions { get { return _xmlVariableDefinitions; } }\n\n        public Enums.WorkflowStepStatus Status => _instance.Status;\n\n        public bool HasQueuedWork\n        {\n            get { return _queuedEvents.Count > 0 || _queuedControlEvents.Count > 0; }\n        }\n\n        public bool HasUnfinishedActivities\n        {\n            get { return _unfinishedActivities.Count > 0; }\n        }\n\n        public void QueueActivity(InstanceActivity instanceActivity)\n        {\n            lock (_lockObject)\n            {\n                _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            }\n        }\n\n\t\tpublic int ActivityExecutionCount { get; set; }\n\n\t\tpublic int ActivityExecutionCountEnforcedLimit => _activityExecutionCountEnforcedLimit;\n\n\t\tpublic bool IsActivityExecutionLimitReached => _isActivityExecutionLimitReached;\n\n\t\tpublic Guid RevisionUid => _revisionUid;\n\n\t\tpublic Guid DefinitionUid => _definitionUid;\n\n\t\tpublic DateTime RevisionCreatedDate => _revisionCreatedDate;\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\t/// <param name=\"previousActivity\"></param>\n\t\t/// <param name=\"linkName\"></param>\n\t\t/// <param name=\"localContextId\"></param>\n\t\t/// <param name=\"followEmptyPathByDefault\"></param>\n\t\t/// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n\t\tpublic void QueueActivitiesByLink(InstanceActivity previousActivity, string linkName, int localContextId = 0, bool followEmptyPathByDefault = true, bool useLinkName = false)\n        {\n            IEnumerable<WorkflowMap.Link> links;\n            bool found = false;\n            if (_workflowMap.TryGetLinks(previousActivity.Name, linkName, out links))\n            {\n                foreach (WorkflowMap.Link link in links)\n                {\n                    QueueActivityByName(previousActivity, link.ToName, localContextId, linkName, useLinkName);\n                    found = true;\n                }\n            }\n            // If we got no matches, try to go for the default (empty) output.\n            if (followEmptyPathByDefault && !found && !string.IsNullOrEmpty(linkName)) QueueActivitiesByLink(previousActivity, string.Empty, localContextId);\n        }\n\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"previousActivity\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"localContextId\"></param>\n        /// <param name=\"linkName\"></param>\n        /// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n        public void QueueActivityByName(InstanceActivity previousActivity, string name, int localContextId = 0, string linkName = null, bool useLinkName = false)\n        {\n            IWINSActivity activity;\n            if (!_workflowMap.TryGetActivity(name, out activity)) throw new ApplicationException(string.Format(\"InstanceUid {0}: Tried to execute invalid activity '{1}'\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, name)));\n\n            if (localContextId <= 0) localContextId = (previousActivity == null ? int.MinValue : previousActivity.LocalContextId);\n\n            // Create a new activity\n            InstanceActivity instanceActivity = new InstanceActivity\n            {\n                AccountId = _instance.AccountId,\n                InstanceUid = _instance.Uid,\n                Name = name,\n                ActivityTypeName = activity.LegacyElementName(),\n                Status = Enums.WorkflowStepStatus.Pending,\n                InputActivityOutput = useLinkName ? linkName : (previousActivity == null ? string.Empty : previousActivity.Output),\n                InputActivityUid = (previousActivity == null ? Guid.Empty : previousActivity.Uid),\n                LocalContextId = localContextId,\n                IsWinsActivity = true,\n                CreatedDate = DateTime.UtcNow //make sure that the in memory copy has a value\n            };\n\n            try\n            {\n                _data.CreateActivity(instanceActivity);\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorWithPII($\"Failed to queue activity {{0}} for instance {_instance?.Uid} in account {_instance?.AccountId}\", ex, name);\n                _data.ActivityFailure(_instance, instanceActivity);\n            }\n\n            _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            QueueActivity(instanceActivity);\n        }\n\n        public void QueueEvent(Event e)\n        {\n            if (_instance.Status != Enums.WorkflowStepStatus.Failed && _instance.Status != Enums.WorkflowStepStatus.Aborted)\n            {\n                lock (_lockObject)\n                {\n                    Queue<Event> queue = (e.IsControlEvent ? _queuedControlEvents : _queuedEvents);\n                    if (e.Uid != Guid.Empty)\n                    {\n                        // Ensure this item isn't already in the list\n                        if (queue.Any(e2 => e2.Uid == e.Uid)) return;\n                    }\n                    queue.Enqueue(e);\n                    WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventQueued\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n                    wrk.Log();\n\t            }\n            }\n        }\n\n        public void QueueIncompleteActivities()\n        {\n            InstanceActivities activities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n            if (activities == null || activities.Count == 0) return;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in activities) _unfinishedActivities[activity.Uid] = activity;\n            }\n\n        }\n\n        public bool CheckActivityForCompletion(InstanceActivity instanceActivity)\n        {\n            // We only care about Waiting steps.\n            if (instanceActivity.Status != Enums.WorkflowStepStatus.Waiting) return false;\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.DebugNoPII($\"CheckActivityForCompletion called for ActivityUid {instanceActivity.Uid} ({instanceActivity.Name}).\");\n\t            try\n\t            {\n\t\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\t\t            ctx.CheckForCompletion();\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t            _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n\t\t\t            SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            return true;\n\t\t            }\n                    _log.DebugWithPII($\"CheckActivityForCompletion completed for Activity ({{0}}) in status: {instanceActivity.Status}.\", instanceActivity.Name);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n                    _log.ErrorNoPII($\"CheckActivityForCompletion failed.\", e);\n\t            }\n            }\n            return false;\n        }\n\n        public bool DoNextTask()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t        CheckAndHandleInstanceStateChanges();\n\n\t\t\t// If we're in a non-processing state, we want to respond only to control events.\n\t\t\t// If we have no control events, we can just skip everything else.\n\t\t\tif (!_ShouldProcessEvent())\n\t        {\n\t\t        return _ExecuteFirstEvent(controlOnly: true);\n\t        }\n\n\t        // If we have any queued events, do one of those.\n\t        if (_ExecuteFirstEvent(controlOnly: false)) return true;\n\n\t        if (!_ShouldProcess()) return false;\n\n\t        // Otherwise, check to see if any activities need to be executed; if so, do those.\n\t        if (_ExecuteFirstActivity()) return true;\n\n\t        // If we get here, it might be that we have some unfinished activities in the database that for some reason weren't loaded into memory.\n\t        // Check for that, and, if so, load them now.\n\t        QueueIncompleteActivities();\n\t        // Try to execute an activity again -- we may have just loaded some\n\t        if (_ExecuteFirstActivity()) return true;\n\t        // If we can complete a waiting activity, do that.\n\t        if (_CheckWaitingActivities()) return true;\n\n\t        // Otherwise, we've got nothing to do and can quit.\n\t        if (!HasQueuedWork && !HasUnfinishedActivities)\n\t        {\n\t\t        _MarkCompleted();\n\t\t\t\t// If we processed nothing (the activity count is 0) we don't want to mark ourselves as waiting.  This is mostly because\n\t\t\t\t// we don't want to update our UpdatedDate (see ATL-20570).  This case occurs when our workflow is already waiting and has been\n\t\t\t\t// picked up for the day and each activity checked to see if it's done waiting.  We don't want this to trigger an update if\n\t\t\t\t// nothing has actually changed.\n\t        }\n\t        else if (_inMemoryActivityCount > 0 || _instance.Status != Enums.WorkflowStepStatus.Waiting)\n\t        {\n\t\t\t\tvar workflowConfig = WorkflowConfig(_instance.AccountId);\n\t\t\t\tvar enableSmallBenRateLimits = workflowConfig?.EnableSmallBenRateLimits ?? false;\n\n\t\t\t\tif (_instance.Status == Enums.WorkflowStepStatus.Paused\n\t\t\t\t    && ((string.Equals(ADEXS.Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.EnableExpressionApiRateLimit, \"live\", StringComparison.OrdinalIgnoreCase)\n\t\t\t\t         && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit)\n\t\t\t\t\t|| (enableSmallBenRateLimits && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit)))\n\t\t\t\t{\n\t\t\t\t\t// keep throttled workflows in paused status\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_MarkWaiting();\n\t\t\t}\n\n\t\t    return false;\n        }\n\n        public void ExecuteActivity(InstanceActivity instanceActivity)\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteActivity called for Activity ({{0}}).\", instanceActivity.Name);\n\t            IWINSWorkflowContext ctx = null;\n\t            Stopwatch sw = Stopwatch.StartNew();\n\t            try\n\t            {\n\t\t            _lastActivityUid = instanceActivity.Uid;\n\n\t\t\t\t\tif (!_ShouldProcess()) throw new ApplicationException(string.Format(\"InstanceUid {0} is in an invalid state to execute activity {1}\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, instanceActivity.Name)));\n\n\t\t            // Check for runaway workflows.\n\t\t            if (++_inMemoryActivityCount >= MAX_IN_MEMORY_ACTIVITY_COUNT)\n\t\t            {\n\t\t\t            _log.WarnNoPII(string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t\t            throw new PublicException(PublicException.FailReason.InvalidState, string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t            }\n\n\t\t\t\t\t// Governance, check if activity execution limit has been reached\n\t\t\t\t\tif (PauseWhenActivityExecutionLimitReached())\n\t\t\t\t\t{\n\t\t\t\t\t\t// In this case, the workflow is paused, purge date is set and an e-mail has been sent to support team.\n\t\t\t\t\t\t// The current activity will not be executed, unless the limits are increased and the workflow resumed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_data.ActivityExecuting(_instance, instanceActivity);\n\n\t\t            ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\t\tif (!ShouldUseScopeEventHandler() && IsTrackItActivity(activity))\n\t\t\t\t\t{\n\t\t\t\t\t\tFireWorkflowScopeEvent(null, ScopeEventType.StepInitiated, activity, ctx);\n\t\t\t\t\t}\n\n\t\t\t\t\tactivity.Execute(ctx);\n\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n\t\t\t\t\tif (e is ArgumentNullException && ctx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar message =\n\t\t\t\t            string.Format(Resources.WINSResources.ActionFailed_ReferenceID_0, Guid.NewGuid()) +\n\t\t\t\t            $\". Inst: {instanceActivity.AccountId} '{instanceActivity.InstanceUid}'.\";\n\t\t\t            _log.ErrorNoPII(message, e);\n\t\t\t\t\t\t_data.CreateInstanceHistory(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, message, true);\n\t\t            }\n\n\t\t\t\t\t// Oh my...\n\t\t\t\t\t// Look at this catch block.\n\t\t\t\t\tbool isTransient = e is TransientException;\n\t\t            bool useFailureOutput = ctx != null && activity.HasFailureOutput;\n\n\t\t            if (isTransient) throw new TransientException(e);\n\t\t            if (useFailureOutput)\n\t\t            {\n\t\t\t\t\t\tctx.ActivityVariables.Set(\"Failure\", e.Message);\n\t\t\t\t\t\tctx.MarkAsCompleted(AbstractActivity.OUTPUT_FAILURE);\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.ActivityFailure(_instance, instanceActivity);\n\t\t\t            if (ctx == null) ctx = _CreateContext(activity, instanceActivity);\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\ttry\n\t\t\t            {\n\t\t\t\t            if (_instance.Status == Enums.WorkflowStepStatus.Failed)\n\t\t\t\t            {\n\t\t\t\t\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInstanceHandler.Fail(ctx, activity, GetUnfinishedWINSWorkflowContextsWINSActivities(instanceActivity.EndDate));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAccountId = ctx.AccountId,\n\t\t\t\t\t\t\t\t\t\tScopeUid = ctx.ScopeUid,\n\t\t\t\t\t\t\t\t\t\tScopeName = ctx.ScopeName,\n\t\t\t\t\t\t\t\t\t\tStepName = instanceActivity.Name,\n\t\t\t\t\t\t\t\t\t\tStepDisplayName = GetActivityDisplayName(activity, ctx),\n\t\t\t\t\t\t\t\t\t\tStepTypeName = instanceActivity.ActivityTypeName,\n\t\t\t\t\t\t\t\t\t\tStepUid = instanceActivity.Uid,\n\t\t\t\t\t\t\t\t\t\tPeriodStart = instanceActivity.EndDate,\n\t\t\t\t\t\t\t\t\t\tEventType = (int)ScopeEventType.WorkflowFailed,\n\t\t\t\t\t\t\t\t\t\tOutput = instanceActivity.Output,\n\t\t\t\t\t\t\t\t\t\tWorkflowUid = ctx.WorkflowInstanceUid,\n\t\t\t\t\t\t\t\t\t\tWorkflowName = ctx.WorkflowName\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tEventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n\n\t\t\t\t\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Failed, instanceActivity.EndDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t            }\n\t\t\t            catch (Exception ex)\n\t\t\t            {\n\t\t\t\t        _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.WorkflowFailed}\", ex);\n\t\t\t            }\n\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n\t\t            }\n\t            }\n\t            finally\n\t            {\n\t\t            ActivityExecutionCount++;\n\t            }\n\t\t\t}\n        }\n\n        public void ExecuteCallback(InstanceActivity instanceActivity, string name, object value)\n        {\n            LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteCallback called for Activity ({{0}}) with callback {name}.\", instanceActivity.Name);\n\n\t            if (!(_ShouldProcess(instanceActivity) && _ShouldProcessEvent()))\n\t            {\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoWithPII($\"ExecuteCallback did not complete because the activity was already completed. Activity {{0}} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}. Instance status: {Model.Status}\", instanceActivity.Name);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _log.ErrorWithPII($\"InstanceUid {Uid} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}.  Instance status: {Model.Status}\");\n\t\t\t\t\t}\n\t\t            return;\n\t\t\t\t}\n\n\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\ttry\n\t\t        {\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t            activity.ExecuteCallback(ctx, name, value);\n\n\t\t            if (_instance.Status != Enums.WorkflowStepStatus.Aborted)\n\t\t            {\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\n\t\t\t\t\t// Throw so that the calling method will handle re-queuing the failed event\n\t\t\t\t\t// When resumed we will retry the recurring reminder callback\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t            catch (Exception e)\n\t            {\n\t\t\t\t\t// Note that we don't fail the workflow here -- see ATL-21019\n\t\t\t\t\tif (instanceActivity.Status == Enums.WorkflowStepStatus.Completed ||\n\t\t                Model.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoNoPII($\"The callback is unnecessary: workflow activity '{instanceActivity.Uid}' [{instanceActivity.Status}] or instance '{instanceActivity.InstanceUid}' [{Model.Status}] has already completed.\");\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t\t\t\tvar pe = e as PublicException;\n\t\t\t\t\t\t_log.ErrorNoPII($\"ExecuteCallback failed.\", pe?.InnerException ?? e);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void ExecuteEvent(Event e, bool queueOnFailure = true)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            if (e == null) return;\n\n            using var span = StartActivity();\n\n            using (ScmNDC.Push(BuildNDCTags(e)))\n            {\n\t            // If we have Uid but the lock expired we don't want to process the event as it was persisted and some other worker probably has already picked it.\n\t            if (e.Uid != Guid.Empty && e.LockExpirationDate <= LastProcessDate)\n\t            {\n\t\t            _log.InfoNoPII($\"Aborting event execution - ExecuteEvent called with an event that has an expired lock ({e.LockExpirationDate}) for callback {e.CallbackName}.\");\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t\t            return;\n\t            }\n\n\t            _log.InfoNoPII($\"ExecuteEvent called with callback {e.CallbackName}.\");\n\t            try\n\t            {\n\t\t            Stopwatch sw = Stopwatch.StartNew();\n\t\t            if (e.ActivityUid == Guid.Empty)\n\t\t            {\n\t\t\t            // We expect these to be control codes\n\t\t\t            string comment = (e.CallbackObject == null ? \"\" : e.CallbackObject.ToString());\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            case Event.ControlNames.Abort:\n\t\t\t\t\t            Abort(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForAccountCancel:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tSetPurgeDateForAccountCancel();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForRevisionSuspended:\n\t\t\t\t\t\t\t\tPauseForRevisionSuspended(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.ResumeForSuspendedRevision:\n\t\t\t\t\t\t\t\t ResumeForSuspendedRevision(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.Pause:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t            case Event.ControlNames.Resume:\n\t\t\t\t\t            Resume(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.ResumeFromError:\n\t\t\t\t\t            ResumeFromError(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.StartActivity:\n\t\t\t\t\t            QueueActivityByName(null, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            default:\n\t\t\t\t\t            throw new ApplicationException(string.Format(\"Unhandled event {0}\", e.CallbackName));\n\t\t\t            }\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            // These *may* be control codes.  If they're not control codes, then\n\t\t\t            // we expect them to be a callback to an activity.\n\t\t\t            InstanceActivity activity;\n\t\t\t            if (!_unfinishedActivities.TryGetValue(e.ActivityUid, out activity)) activity = _data.LoadActivityByUid(_instance.AccountId, Constants.WorkflowUser, e.ActivityUid);\n\t\t\t            if (activity == null || activity.InstanceUid != e.InstanceUid) throw new ApplicationException(string.Format(\"Invalid ActivityUid {0} for InstanceUid {1}\", e.ActivityUid, e.InstanceUid));\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            // TODO: Start specific steps, fire specific outputs, complete specific steps, etc.\n\t\t\t\t            default:\n\t\t\t\t\t            ExecuteCallback(activity, e.CallbackName, e.CallbackObject);\n\t\t\t\t\t            break;\n\t\t\t            }\n\t\t            }\n\t\t            if (e.Uid != Guid.Empty) _data.EventSuccess(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventExecuted\")\n\t\t\t\t\t{\n\t\t\t\t\t\tTotalMs = sw.ElapsedMilliseconds,\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid, WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t            wrk.Log();\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t            catch (Exception excp)\n\t            {\n\t\t            _log.ErrorNoPII($\"Error processing eventUid {e.Uid} ({e.CallbackName}).\", excp);\n\t\t            if (!queueOnFailure) throw;\n\t\t            if (e.Uid == Guid.Empty)\n\t\t            {\n\t\t\t            e.NextProcessDate = _data.NextProcessDate();\n\t\t\t            e.ErrorCount = 1;\n\t\t\t            e.LastErrorMessage = excp.Message;\n\t\t\t            _data.CreateEvent(e);\n\t\t\t            WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnExecuteException\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t\t};\n\t\t\t            wrk.Log();\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.EventFailure(e.AccountId, e.Uid, _data.NextProcessDate(), excp.Message);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void Abort(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in _unfinishedActivities.Values)\n                {\n\t                try\n\t                {\n\t\t                IWINSActivity winsActivity = _SafeGetActivity(activity);\n\t\t                IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n\t\t                winsActivity.OnActivityAborted(ctx);\n\t                }\n\t                catch (Exception ex)\n\t                {\n\t\t                _log.ErrorNoPII(string.Format(\"Failed OnActivityAborted AccountId {0}, ActivityUid {1}\", user.AccountId, activity.Uid), ex);\n\t\t\t\t\t}\n                }\n                new WorkflowControlInstance(Model).Abort(user, comment);\n\n\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t{\n\t\t\t\t\tInstanceHandler.Abort(_instance, user, GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime.UtcNow));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Aborted, DateTime.UtcNow);\n\t\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowAborted);\n\t\t\t\t}\n\n\t\t\t\t_ForceReload();\n            }\n        }\n\n        public int SetPurgeDateForAccountCancel()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        var daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForAccountCancel();\n\t\t        _ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t        }\n        }\n\n        public void ClearPurgeDate()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        new WorkflowControlInstance(Model).ClearPurgeDate();\n\t\t        _ForceReload();\n\t        }\n        }\n\n\t\tpublic void Pause(UserAccount user, string comment)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Pause - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).Pause);\n\t\t}\n\n\t\tpublic void PauseForRevisionSuspended(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status == Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - No action taken, instance already paused\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).PauseForRevisionSuspended);\n\t\t}\n\n\t\tpublic void ResumeForSuspendedRevision(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status != Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, instance not paused. Status:{Model.Status}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if instance UpdatedBy has changed since the PauseForRevisionSuspended was invoked, if it has we do not want to do anything.\n\t\t\tif (Model.UpdatedBy != WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, UpdatedBy is not {WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - Resuming\");\n\t\t\tResume(user, comment);\n\t\t\tClearPurgeDate();\n\t\t}\n\n\t\tpublic bool PauseWhenActivityExecutionLimitReached()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Governance, check whether the number of executed activities exceeded the configured limit\n\t\t\t\t_isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(AccountId, Uid, _instance.RevisionUid, _instance.RevisionCreatedDate, ActivityExecutionCount, out _activityExecutionCountEnforcedLimit);\n\n\t\t\t\tif (_isActivityExecutionLimitReached)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum limit (Actual={ActivityExecutionCount}, EnforcedLimit={_activityExecutionCountEnforcedLimit}) and will be paused.\");\n\n\t\t\t\t\tPause(UserAccount.WorkflowUserAccount(AccountId), \"Workflow activity execution limit reached.\");\n\n\t\t\t\t\tTrySendActivityExecutionLimitExceedNotification(SetPurgeDateForAccountCancel());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' activity execution limit\", e);\n\t\t\t}\n\n\t\t\treturn _isActivityExecutionLimitReached;\n\t\t}\n\n\t\tpublic void PauseWhenThrottled(InstanceActivity activity, WorkflowApiRequestThrottledException exception)\n\t\t{\n\t\t\tRequires.NotNull(activity, nameof(InstanceActivity));\n\t\t\tRequires.NotNull(exception, nameof(WorkflowApiRequestThrottledException));\n\n\t\t\tif (exception.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.NotThrottled)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' is not throttled and will not be paused.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tactivity.Status = Enums.WorkflowStepStatus.Paused;\n\t\t\t\tvar throttledByApi = exception.ThrottledApiAsString();\n\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum {throttledByApi} request limit and will be paused. Message: {exception.Message}\");\n\n\t\t\t\tPauseInstance(UserAccount.WorkflowUserAccount(AccountId), $\"{throttledByApi} requests limit reached.\", new WorkflowControlInstance(Model).PauseForWorkflowRateLimitExceed);\n\n\t\t\t\t// Send notification\n\t\t\t\tswitch (exception.WorkflowThrottledStatus)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit:\n\t\t\t\t\t\tTrySendExpressionRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit:\n\t\t\t\t\t\tTrySendSmallBenRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_log.WarnNoPII(\"No notifications sent for unsupported throttle status\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mark instance as throttled for current workflow run session, WorkflowThrottledStatus property is not persisted and refreshed on reload\n\t\t\t\t_instance.WorkflowThrottledStatus = exception.WorkflowThrottledStatus;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception e)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' rate limit request limit with status {exception?.WorkflowThrottledStatus}\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublic int SetPurgeDateForWorkflowRateLimit()\n\t\t{\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tvar daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForWorkflowRateLimit();\n\t\t\t\t_ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid GetAdvancedWorkflowNotificationUserAccountUid()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while retrieving AdvancedWorkflowNotificationUserAccountUid for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\t\t}\n\n\t\tpublic void TrySendSmallBenRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\t// Send notification - pending ATL-90622\n\t\t}\n\n\t\tpublic void TrySendExpressionRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\tif (!ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetEnableWorkflowLimitNotifications(AccountId))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"EnableWorkflowLimitNotifications disabled for account {AccountId}, not sending expression rate limit exceeded notification\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (advancedWorkflowNotificationUserAccountUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {advancedWorkflowNotificationUserAccountUid} to receive expression rate limit exceeded notification\");\n\t\t\t\tUserAccount notificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, advancedWorkflowNotificationUserAccountUid);\n\n\t\t\t\tif (string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"AdvancedWorkflowNotificationUser '{advancedWorkflowNotificationUserAccountUid}' not found or missing email address. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar emailRecipients = new List<string>() { notificationUser.EmailAddress };\n\n\t\t\t\t_log.InfoNoPII($\"Sending expression rate limit exceeded notification to user '{advancedWorkflowNotificationUserAccountUid}' for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseExpressionRateLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowInstanceId = _instance.Id,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Resume(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).Resume(user, comment);\n                _ForceReload();\n            }\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Resume(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n        }\n\n        public void ResumeFromError(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).ResumeFromError(user, comment);\n                _ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.ResumeFromError(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n\t\t}\n\n        public void SaveToDatabase()\n        {\n            // We may have in-memory events that need to be saved to the db.\n\t\t\tPersistEvents();\n            _PersistVariables();\n        }\n\n        public void SaveEventsToDatabase()\n        {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPersistEvents();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save unsaved events for instance {Uid} to db\", e);\n\t\t\t}\n\t\t}\n\n\t    public void ArchiveVariables()\n        {\n            var incompleteActivities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, _instance.Uid);\n            // don't archive if there are any incomplete activites besides the one that has triggered this\n            if (incompleteActivities != null && incompleteActivities.Count > 1)\n            {\n                return;\n            }\n            _data.ArchiveVariables(AccountId, Constants.WorkflowUser, Uid);\n        }\n\n\t    public bool HasExistingLockExpired()\n\t    {\n\t\t    return LockExpirationDate < DateTime.UtcNow;\n\t    }\n\n\n        /// <summary>\n        /// Replaces variables provided in the dictionary returning replaced variables\n        /// </summary>\n        public void SetVariables(\n\t        InstanceActivity instanceActivity,\n\t        Dictionary<string, object> variables,\n\t        out List<InstanceVariable> oldVariables,\n\t        out bool areVariablesOverTotalSizeLimit,\n\t        out int totalVariablesSizeBytes,\n\t        out int totalVariablesSizeLimitBytes,\n\t\t\tout Dictionary<string, int> oversizedVariables,\n\t        out int variableValueSizeLimitBytes)\n        {\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            _log.DebugWithPII($\"SetVariables called for ActivityUid {instanceActivity.Uid} ({{0}}).\", instanceActivity.Name);\n\n            // We create the context so that the variable dictionaries get populated\n            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n            oldVariables = new List<InstanceVariable>();\n            var newVariables = UpdateVariablesHelper.PopulateContextVariables(ctx, this.Model, variables);\n\n            // Only set variables that are under the size limit\n\t\t\toversizedVariables = InstanceVariableGovernance.GetOversizedVariables(ctx.AccountId, newVariables, ctx.SubmittedDate, out variableValueSizeLimitBytes);\n\t\t\tforeach (InstanceVariable variable in newVariables)\n\t\t\t{\n\t\t\t\tif (!oversizedVariables.ContainsKey(variable.Name))\n\t\t\t\t{\n\t\t\t\t\toldVariables.Add(Variables[variable.Name]);\n\t\t\t\t\t// we could do \"ctx.Variables.Set(variable.Key, variable.Value);\" but that would log as the instanceActivity and we don't want that...\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Undo setting the variables, if the instance's total variable size exceeds the limit\n\t\t\tareVariablesOverTotalSizeLimit = InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(ctx.AccountId,\n\t\t\t\tVariables.Select(x => x.Value), ctx.SubmittedDate, activityConfiguration: null, out totalVariablesSizeBytes, out totalVariablesSizeLimitBytes);\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tforeach (InstanceVariable variable in oldVariables)\n\t\t\t\t{\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n        }\n\n        public DateTime GetLastAbortNotificationDate()\n        {\n\t        if (!_contextInitialized)\n\t        {\n\t\t        _LoadVariables();\n            }\n\n\t        if (_variables.TryGetValue(WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE, out InstanceVariable lastNotificationDate) &&\n\t            DateTime.TryParse(lastNotificationDate.Value.ToString(), out DateTime dateTime))\n\t        {\n\t\t        return dateTime;\n\t        }\n\n            return DateTime.MinValue;\n        }\n\n        public void SaveLastAbortNotificationDate(int accountId, Guid workflowInstanceUid, DateTime lastAbortNotificationDate)\n        {\n            var variable = InstanceVariable.CreateFromValue(\n\t            accountId,\n\t            workflowInstanceUid,\n\t            WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE,\n\t            Enums.WorkflowVariableType.Date,\n\t            lastAbortNotificationDate);\n\n            ServiceLocator.GetInstance<IInstanceVariablePersistence>().Save(Constants.WorkflowUser, variable);\n\n        }\n\n        /// <summary>\n        /// Called when we've finished work on an activity -- either executing it or performing a callback on it.\n        /// </summary>\n        private void _ActivityWorkCompleted(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx, Stopwatch sw)\n        {\n\t        // If it's flagged as completed, update in the db, queue up any next activities, and remove it from our list.\n            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n            {\n                _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n                SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t\tlock (_unfinishedActivities)\n                {\n                    if (_unfinishedActivities.ContainsKey(instanceActivity.Uid)) _unfinishedActivities.Remove(instanceActivity.Uid);\n                }\n            }\n            else\n            {\n                // Otherwise, it's still running.  Flag it as waiting so it doesn't get processed again.\n                instanceActivity.Status = Enums.WorkflowStepStatus.Waiting;\n                _data.SaveInstanceActivity(instanceActivity);\n            }\n\n            _log.InfoWithPII($\"_ActivityWorkCompleted done for Activity ({{0}}) in status: {instanceActivity.Status} ({sw.ElapsedMilliseconds} ms).\", instanceActivity.Name);\n\n\n            // log workload data\n            try\n            {\n                WorkflowWorkload ww = new WorkflowWorkload();\n                ww.Add(ctx);\n                ww.TotalMs = sw.ElapsedMilliseconds;\n\t\t\t\tww.StartTime = DateTime.UtcNow.AddMilliseconds(-ww.TotalMs);\n                ww.Status = instanceActivity.Status.ToString();\n                ww.Output = instanceActivity.Output;\n                ww.ActivityCreatedDate = instanceActivity.CreatedDate;\n                ww.ActivityStartDate = instanceActivity.StartDate;\n                if (DateTime.MinValue < instanceActivity.EndDate && instanceActivity.EndDate < DateTime.MaxValue)\n                    ww.ActivityEndDate = instanceActivity.EndDate;\n                if (DateTime.MinValue < _instance.CreatedDate && _instance.CreatedDate < DateTime.MaxValue)\n\t                ww.InstanceCreatedDate = _instance.CreatedDate;\n                ww.ActivityKind = activity.Kind.ToString();\n                ww.RevisionUid = _instance.RevisionUid.ToString();\n\t\t\t\tww.DefinitionUid = _instance.DefinitionUid.ToString();\n\t\t\t\tww.WorkflowDB = DataStore.GetDbNameForAccount(instanceActivity.AccountId);\n\n\t\t\t\tww.Log();\n            }\n            catch (Exception ex)\n            {\n                _log.WarnNoPII(\"Failed to log workload.\", ex);\n            }\n        }\n\n\t\tprivate void CompleteScopeStep(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n            try\n            {\n                if (IsTrackItActivity(activity))\n                {\n                    Documents documents = null;\n                    if (ctx.TrackActivity())\n                    {\n                        documents = ((ITrackItActivity)activity).GetDocuments(ctx);\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, instanceActivity.Uid,\n                            documents, instanceActivity.Output, instanceActivity.Status,\n                            instanceActivity.EndDate);\n                    }\n\n                    WorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n                    {\n                        AccountId = ctx.AccountId,\n                        Documents = documents?.Select(d => new WorkflowScopeEvent.DocumentDetail() { Uid = d.Uid, Name = d.Name }).ToList(),\n                        ScopeUid = ctx.ScopeUid,\n                        ScopeName = ctx.ScopeName,\n                        StepName = instanceActivity.Name,\n                        StepDisplayName = GetActivityDisplayName(activity, ctx),\n                        StepTypeName = instanceActivity.ActivityTypeName,\n                        StepUid = instanceActivity.Uid,\n                        PeriodStart = instanceActivity.EndDate,\n                        EventType = (int)ScopeEventType.StepFinished,\n                        Output = instanceActivity.Output,\n                        WorkflowUid = ctx.WorkflowInstanceUid,\n                        WorkflowName = ctx.WorkflowName\n                    };\n                    WorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n                    {\n                        EventData = scopeEventData\n                    };\n                    EventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.StepFinished}\", ex);\n            }\n        }\n\n        private void SaveInstanceActivityVariables(InstanceActivity instanceActivity, IWINSWorkflowContext ctx)\n        {\n\t        if (ctx.WorkflowUserAccount.Account.Settings.EnableWorkflowVariableHistory)\n\t        {\n\t\t        var instanceVariableRepository = ServiceLocator.GetInstance<IInstanceVariableRepository>();\n\t\t        instanceVariableRepository.SaveVariableHistory(instanceActivity.AccountId, ctx.WorkflowUserAccount.Uid,\n\t\t\t        instanceActivity.InstanceUid, instanceActivity.Uid, ctx.Variables.GetAllVariables());\n\t        }\n        }\n\n        private List<WINSWorkflowContextWINSActivity> GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime endDate)\n        {\n\t\t\tvar list = new List<WINSWorkflowContextWINSActivity>();\n\n\t\t\tif (!HasUnfinishedActivities) return list;\n\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values);\n            }\n\n            IWINSWorkflowContext ctx = null;\n            foreach (var activity in activities)\n            {\n                var winsActivity = _SafeGetActivity(activity);\n                ctx = _CreateContext(winsActivity, activity);\n\n                if (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n                {\n\t\t\t\t\tlist.Add(new WINSWorkflowContextWINSActivity { EndDate = endDate, WINSActivity = winsActivity, WINSWorkflowContext = ctx });\n\t\t\t\t}\n            }\n\n\t\t\treturn list;\n        }\n\n\t\tprivate void AbortOrFailScopeStep(Enums.WorkflowStepStatus status, DateTime endDate)\n\t\t{\n\t\t\tif (!HasUnfinishedActivities) return;\n\n\t\t\tList<InstanceActivity> activities;\n\t\t\tlock (_unfinishedActivities)\n\t\t\t{\n\t\t\t\tactivities = new List<InstanceActivity>(_unfinishedActivities.Values);\n\t\t\t}\n\t\t\tIWINSWorkflowContext ctx = null;\n\t\t\tforeach (var activity in activities)\n\t\t\t{\n\t\t\t\tvar winsActivity = _SafeGetActivity(activity);\n\t\t\t\tctx = _CreateContext(winsActivity, activity);\n\n\t\t\t\tif (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n\t\t\t\t{\n\t\t\t\t\tvar documents = ((ITrackItActivity)winsActivity).GetDocuments(ctx);\n\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, activity.Uid, documents, null, status, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool _CheckWaitingActivities()\n        {\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values.Where(n => n.Status == Enums.WorkflowStepStatus.Waiting));\n            }\n            bool success = false;\n            foreach (InstanceActivity activity in activities)\n            {\n                if (CheckActivityForCompletion(activity)) success = true;\n            }\n            return success;\n        }\n\n        private bool _contextInitialized = false;\n        private IWINSWorkflowContext _CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n            IWINSWorkflowContext ctx = CreateContext(activity, instanceActivity);\n            AtlasContext.Current.UserAccount = ctx.WorkflowUserAccount;\n            // Only do this once.  If it's been done, it's done.\n            if (_contextInitialized) return ctx;\n\n            // This all depends on the properties for the Start step.  We always want a Start step for normal processing;\n            // however, we don't necessarily have a Start step for our tests.\n            StartActivity start = _workflowMap.StartActivity;\n            if (start == null)\n            {\n                if (_data.IsTest) return ctx;\n                throw new ApplicationException(string.Format(\"Cannot find StartActivity for InstanceUid {0}\", _instance.Uid));\n            }\n\n            // Contents\n            string[][] contents = start.DefinedContents;\n            if (contents != null && contents.Length > 0)\n            {\n                foreach (string[] t in contents)\n                {\n                    ContentDefinition definition = new ContentDefinition(t);\n                    if (!_contentDefinitions.ContainsKey(definition.Name)) _contentDefinitions[definition.Name] = definition;\n                }\n            }\n\n            _LoadVariables();\n\n            // XML Variables\n            // Because XmlVariables have dependencies on the variables as well, it's easier to feed this through the xml variable handler\n            // rather than replicate the code.\n            List<IXmlVariableDefinition> definitions = start.DefinedXmlVariables;\n            if (definitions != null && definitions.Count > 0)\n            {\n                foreach (IXmlVariableDefinition definition in definitions)\n                {\n                    if (!_xmlVariableDefinitions.ContainsKey(definition.Name)) ctx.XmlVariables.Declare(definition, logMessage: false);\n                }\n            }\n\n            _contextInitialized = true;\n            return ctx;\n\t\t}\n\n        public IWINSWorkflowContext CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowContextFactory>().CreateWorkflowContext(this, activity, instanceActivity);\n        }\n\n\t\tprivate void _LoadVariables()\n        {\n\t        // Variables\n\t        Dictionary<string, InstanceVariable> variables = _data.LoadVariablesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n\t        foreach (InstanceVariable variable in variables.Values)\n\t        {\n\t\t        if (!_variables.ContainsKey(variable.Name)) _variables[variable.Name] = variable;\n\t        }\n        }\n\n        private bool _ExecuteFirstActivity()\n        {\n            InstanceActivity activity = null;\n            lock (_unfinishedActivities)\n            {\n                if (_unfinishedActivities.Count > 0) activity = _unfinishedActivities.Values.FirstOrDefault(n => n.Status == Enums.WorkflowStepStatus.Pending || n.Status == Enums.WorkflowStepStatus.Executing);\n            }\n            if (activity == null) return false;\n            ExecuteActivity(activity);\n            return true;\n        }\n\n        private bool _ExecuteFirstEvent(bool controlOnly = false)\n        {\n            // We always try to execute control events first.\n            Event e = null;\n            lock (_queuedControlEvents)\n            {\n                if (_queuedControlEvents.Count > 0) e = _queuedControlEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            // If we're only caring about control events, we can quit now.\n            if (controlOnly) return false;\n\n            // Otherwise, we do the same thing with the rest of the events.\n            lock (_queuedEvents)\n            {\n                if (_queuedEvents.Count > 0) e = _queuedEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            return false;\n        }\n\n        private void _ForceReload()\n        {\n            // Reload the object to get new state -- we do this inside the lock so that there's no race condition\n            // between this and a worker who may be working on the object\n            lock (_lockObject)\n            {\n                Guid instanceUid = Uid;\n                _instance = _data.LoadInstanceByUid(AccountId, Constants.WorkflowUser, instanceUid);\n                if (_instance == null) throw new ApplicationException(string.Format(\"Failed to reload instanceUid: {0}\", instanceUid));\n            }\n        }\n\n        private void _MarkCompleted()\n        {\n\t        if (_instance.IsCompleted)\n\t        {\n\t\t        _log.InfoNoPII($\"Instance {_instance.Uid} is already complete with status {_instance.Status}\");\n\t\t        return;\n\t        }\n\n            _PersistVariables();\n            bool endActivityFailure = _workflowMap.HasEndActivity() && !_instance.EndActivityReached;\n            Enums.WorkflowStepStatus endStatus = endActivityFailure ? Enums.WorkflowStepStatus.Failed : Enums.WorkflowStepStatus.Completed;\n            _data.SaveInstance(_instance);\n            _data.InstanceCompleted(_instance, endStatus);\n\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Complete(_instance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventType = _instance.Status == Enums.WorkflowStepStatus.Failed ? ScopeEventType.WorkflowFailed : ScopeEventType.WorkflowFinished;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t{\n\t\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\t\tPeriodStart = _instance.EndDate,\n\t\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\t\tWorkflowName = _instance.Name\n\t\t\t\t\t};\n\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t\t{\n\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t};\n\t\t\t\t\tEventRepo.FireEvent(_instance.AccountId, scopeEvent);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event {_instance.ScopeUid} for eventtype {eventType}\", ex);\n\t\t\t\t}\n\t\t\t}\n\n            if (endActivityFailure && _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                if (_lastActivityUid == Guid.Empty)\n                {\n                    _log.WarnNoPII($\"No activities for workflow.\");\n                }\n                else\n                {\n                    InstanceActivity activity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, _lastActivityUid);\n                    IWINSActivity winsActivity = _SafeGetActivity(activity);\n                    IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n                    LoggingHelper.LogActivityErrorNoPII(ctx, Resources.WINSResources.WorkflowExitedWithoutReachingTheEndActivity);\n                }\n\n            }\n            if (_instance.Status == Enums.WorkflowStepStatus.Completed || _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n            }\n        }\n\n        private void _MarkWaiting()\n        {\n            _PersistVariables();\n            _instance.Status = Enums.WorkflowStepStatus.Waiting;\n            _data.SaveInstance(_instance);\n        }\n\n        private void _PersistVariables()\n        {\n            InstanceVariables variables = new InstanceVariables();\n            foreach (InstanceVariable variable in _variables.Values) if (variable.IsModified) variables.Add(variable);\n            _data.SaveInstanceVariables(AccountId, Constants.WorkflowUser, variables);\n        }\n\n        private void PersistEvents()\n\t\t{\n\t\t\tlock (_queuedControlEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedControlEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedControlEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlock (_queuedEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        private void PersistEvent(Event e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_data.CreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_data.UnlockEvent(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventUnlockedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save event {e.Uid}, for instance {e.InstanceUid}, activity {e.ActivityUid}, and callback name {e.CallbackName} to db\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate IWINSActivity _SafeGetActivity(InstanceActivity instanceActivity)\n        {\n            try\n            {\n                IWINSActivity activity;\n                if (_workflowMap.TryGetActivity(instanceActivity.Name, out activity)) return activity;\n                // There is a problem with old MWF workflow data where the name of the activity is really the type name.\n                // Don't ask.  It's a stupid and boring story.\n                // But we still should handle it, at least for awhile.  So: if we get here because we didn't match name, we should see\n                // if we match type name.\n                // This whole thing is a huge hack that should get removed when it can.\n                InstanceActivity inputActivity = null;\n                if (instanceActivity.InputActivityUid != Guid.Empty) inputActivity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, instanceActivity.InputActivityUid);\n                if (_workflowMap.LegacyTryGetActivityByTypeName(instanceActivity.Name, inputActivity == null ? \"\" : inputActivity.Name, instanceActivity.InputActivityOutput ?? \"\", out activity))\n                {\n                    // Rename it so we get one less instance of this in the future\n                    instanceActivity.Name = activity.Name;\n                    return activity;\n                }\n                throw new ApplicationException(string.Format(\"Invalid activity name '{0}' for instanceUid '{1}'.\", instanceActivity.Name, instanceActivity.InstanceUid));\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"_SafeGetActivity failed.\", e);\n                return null;\n            }\n        }\n\n        private bool _ShouldProcess(InstanceActivity instanceActivity)\n        {\n            switch (instanceActivity.Status)\n            {\n                case Enums.WorkflowStepStatus.Executing:\n                case Enums.WorkflowStepStatus.Pending:\n                case Enums.WorkflowStepStatus.Waiting:\n                case Enums.WorkflowStepStatus.Aborted:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool _ShouldProcess()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        private bool _ShouldProcessEvent()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                    case Enums.WorkflowStepStatus.Aborted:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        //ITrackItActivity interface is implemented by activities whose data is tracked in DocumentScope and ScopeEvent tables.\n        private bool IsTrackItActivity(IWINSActivity activity)\n        {\n            return activity is ITrackItActivity;\n        }\n\n\t\tprivate void FireWorkflowScopeEvent(UserAccount user, ScopeEventType eventType, IWINSActivity activity = null, IWINSWorkflowContext ctx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo\n\t\t\t\t{\n\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\tPeriodStart = DateTime.UtcNow,\n\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\tWorkflowName = _instance.Name,\n\t\t\t\t\tEventBy = user == null ? null : new WorkflowScopeEvent.Assignee() { Email = user.EmailAddress, Name = user.FriendlyName, Uid = user.Uid }\n\t\t\t\t};\n\n\t\t\t\tif (activity != null && ctx != null)\n\t\t\t\t{\n\t\t\t\t\tscopeEventData.StepName = ctx.ActivityName;\n\t\t\t\t\tscopeEventData.StepDisplayName = GetActivityDisplayName(activity, ctx);\n\t\t\t\t\tscopeEventData.StepTypeName = ctx.ActivityTypeName;\n\t\t\t\t\tscopeEventData.StepUid = ctx.ActivityUid;\n\t\t\t\t}\n\n\t\t\t\tEventRepo.FireEvent(_instance.AccountId, new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t{\n\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event scopeUid: {_instance.ScopeUid}, instanceUid: {_instance.Uid} eventType: {eventType}\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void RemoveProperties(InstanceActivity instanceActivity, IWINSActivity activity)\n\t    {\n\t\t    // We need to delete properties if this is not a human activity or WaitForNextStepAfterCompletion is not set\n\t\t    if (activity is AbstractHumanActivity && ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetWaitForNextStepAfterCompletion(instanceActivity.AccountId))\n\t\t    {\n\t\t\t\t_data.DeleteActivityPropertiesWithExclusion(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, new List<string> { nameof(AbstractHumanActivity.WaitForNextStep) });\n\t\t\t\t_log.InfoNoPII(\"Removing activity properties except WaitForNextStep\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    _data.DeleteActivityProperties(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid);\n\t\t\t    _log.InfoNoPII(\"Removing activity properties\");\n\t\t    }\n\t    }\n\n\t\tprivate string[] BuildNDCTags(InstanceActivity instanceActivity) => instanceActivity != null ? new[] { $\"ActivityId:{instanceActivity.Uid}\",$\"W:{instanceActivity.InstanceUid}\" } : new string[] { };\n\t    private string[] BuildNDCTags(Event e) => e != null ? new[] { $\"ActivityId:{e.ActivityUid}\", $\"W:{e.InstanceUid}\" } : new string[] { };\n\n\t\t/// <summary>\n\t\t/// Try to send an e-mail to support when a workflow instance activity execution account exceeds configured threshold.\n\t\t/// </summary>\n\t\t/// <param name=\"pausedPurgeDays\">Number of days to purge workflow related data</param>\n\t\t/// <returns>\n\t\t/// True\t-> Success.\n\t\t/// False\t-> Fail to send email.\n\t\t/// </returns>\n\t\tprivate bool TrySendActivityExecutionLimitExceedNotification(int pausedPurgeDays)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\t// Support should get the email\n\t\t\t\tvar supportEmailAddress = WorkflowSettingRepository.GetSupportNotificationEmailAddress(AccountId);\n\t\t\t\tif (!string.IsNullOrEmpty(supportEmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(supportEmailAddress);\n\t\t\t\t}\n\n\t\t\t\t// Also send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive activity execution limit exceeded notification\");\n\t\t\t\t\tnotificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, notificationUserUid);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Email support address setting is empty, and there is no AdvancedWorkflowNotificationUser configured. Thus, not sending activity execution limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Sending activity execution limit exceeded notification to {emailRecipients.Count} {(emailRecipients.Count > 1 ? \"recipients\" : \"recipient\")} for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseActivityExecutionLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowRevisionUid = _instance.RevisionUid,\n\t\t\t\t\tNumberOfActivitiesExecuted = ActivityExecutionCount,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetActivityDisplayName(IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n\t\t\treturn activity is AbstractHumanActivity abstractHumanActivity\n\t\t\t\t? abstractHumanActivity.ActivityDisplayName.Evaluate(ctx)\n\t\t\t\t: null;\n\t\t}\n\n\t\tprivate bool ShouldUseScopeEventHandler() => WorkflowFeatureFlags.UseScopeEventHandler &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t Model?.EngineVersion == Core.Workflow.Constants.EngineVersionV2;\n\n\t\tprivate void PauseInstance(UserAccount user, string comment, Action<UserAccount, string> pauseMethod)\n\t\t{\n\t\t\tRequires.NotNull(pauseMethod, nameof(pauseMethod));\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tpauseMethod(user, comment);\n\t\t\t\t_ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Pause(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowPaused);\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{\n\t\t\tvar environmentType = SiteConfig?.Value?.EnvironmentType;\n\t\t\tvar isGrpcEnabled = WorkflowClientConfig?.Value?.IsGrpcClientEnabled == true;\n\n\t\t\tvar isRunningOnCloudWithGrpcEnabled = environmentType == Core.Util.Config.EnvironmentType.Cloud && isGrpcEnabled;\n\n\t\t\tif (isRunningOnCloudWithGrpcEnabled && InstanceStateChangedHelper.IsInstanceStateChanged(_instance.Uid, ActivityExecutionCount, CacheRepository, WorkflowSettingRepository))\n\t\t\t{\n\t\t\t\t_ForceReload();\n\t\t\t\tInstanceStateChangedHelper.RemoveInstanceStateChanged(_instance.Uid, CacheRepository);\n\t\t\t}\n\t\t}\n    }\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
      "content": "#if NET\n#nullable enable\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService\n{\n    private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore\n#endif\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/AbstractServicedComponent.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.HealthChecks;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.FeatureFlags;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.CqlCorePersistence;\nusing ADEXS.ElasticCore;\nusing ADEXS.FeatureFlags;\nusing ADEXS.HealthCheck;\nusing ADEXS.MQ;\nusing ADEXS.MqWorkers;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing log4net;\n\nusing Newtonsoft.Json;\n\nusing ApplicationInfo = ADEXS.Core.Domain.Utilities.ApplicationInfo;\n\nnamespace ADEXS.Core.ServiceFramework\n{\n\t/// <summary>\n\t/// Base class to subclass for services.  Handles the managing of worker processes,\n\t/// worker groups, and remotable objects via the Register* methods.\n\t/// </summary>\n\tpublic abstract class AbstractServicedComponent : ScmServicedComponent\n\t{\n\t\t// We query for this in our alerts, do not change this without updating alerts.\n\t\tprivate const string HealthCheckFailedPrefix = \"Health check failed\";\n\n\t\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\t\tprotected override List<IServiceRegistry> GetServiceRegistries()\n\t\t{\n\t\t\treturn new List<IServiceRegistry> {\n\t\t\t\tnew CoreServiceFrameworkRegistry(),\n\t\t\t\tnew CoreDomainRegistry(),\n\t\t\t\tnew MessageQueueRegistry(),\n\t\t\t\tnew ElasticCoreRegistry(),\n\t\t\t\tnew FeatureFlagRegistry()\n\t\t\t};\n\t\t}\n\n\t\tprotected override void OnBeforeRun()\n\t\t{\n\t\t\t// Use MSF specific env variable, fallback to app settings.\n\t\t\tvar application = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? ApplicationInfo.Name;\n\t\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? Configuration.GetStringAppSetting(\"Environment\", \"Unknown\");\n\t\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\t\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\n\t\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\t\tapplicationName: application,\n\t\t\t\tappVersion: GetType().Assembly.GetName().Version.ToString(),\n\t\t\t\tenvironmentName: environment,\n\t\t\t\tsiteName: site,\n\t\t\t\tpartitionName: partition,\n\t\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\t\tshouldEnableLogFileListener: () => ApplicationSettings.KazmonEnableLogFileListener);\n\n\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t\t{\n\t\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t\t{\n\t\t\t\t\t// Run synchronously.\n\t\t\t\t\t// For service framework, we are using service invocation to start process,\n\t\t\t\t\t// so Assembly.EntryAssembly is not represents correct service assembly. We are\n\t\t\t\t\t// using GetType().Assembly instead, which would provide correct release version.\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: this.GetType().Assembly))\n\t\t\t\t\t\t\t.GetAwaiter().GetResult();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add custom connection limit if defined.\n\t\t\tstring ServicePointConnectionLimitSettingName = $\"{application}_{Constants.ApplicationSettings.ServicePointConnectionLimit}\";\n\t\t\tint servicePointConnectionLimitSetting = Configuration.GetInt32AppSetting(ServicePointConnectionLimitSettingName, 0);\n\t\t\tif (0 < servicePointConnectionLimitSetting)\n\t\t\t{\n\t\t\t\tServicePointManager.DefaultConnectionLimit = servicePointConnectionLimitSetting;\n\t\t\t}\n\n\t\t\tbase.OnBeforeRun();\n\t\t}\n\n\t\tprotected override void OnStop()\n\t\t{\n\t\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t\t}\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t\t}\n\n\t\t\tKazmonMonitoring.ShutdownKazmon();\n\t\t}\n\n\t\tpublic override void RunHealthCheck()\n\t\t{\n\t\t\tif (!Configuration.GetBooleanAppSetting(\"HealthCheckEnabled\", true))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!IsService())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the CorrelationToken to make log tracing easier.\n\t\t\tMonitoringContext.CorrelationToken ??= Guid.NewGuid();\n\n\t\t\tHealthCheckResult result = RunSelfCheck();\n\n\t\t\tif (result.Pass)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"Health check passed.\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// App-specific override takes precedence over system-wide setting\n\t\t\t\tvar continueOnFailure = Configuration.GetOptionalBooleanAppSetting($\"HealthCheckContinueOnFailure_{ApplicationInfo.Name}\", null)\n\t\t\t\t\t\t\t\t\t\t?? Configuration.GetBooleanAppSetting(\"HealthCheckContinueOnFailure\", false);\n\n\t\t\t\tif (continueOnFailure)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"{HealthCheckFailedPrefix}, but will continue running.\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.FatalNoPII($\"{HealthCheckFailedPrefix}. Exiting.\");\n\t\t\t\t\tExit(EXIT_FAIL_HELTH_CHECK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic override void InitializeFeatureFlags()\n\t\t{\n\t\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t\t}\n\t\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// This method is to be used only as an entry point for an external\n\t\t/// tool to invoke a self health check on the service.\n\t\t/// </summary>\n\t\t/// <returns>Json health report</returns>\n\t\tpublic string ExternalRunServiceHealthCheck()\n\t\t{\n\t\t\tif (IsService())\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tif (ConfigWrapper.UseOneConfig)\n\t\t\t{\n\t\t\t\tBootstrapper.Bootstrap(GetServiceRegistries);\n\t\t\t}\n\n\t\t\t// Since this is called from an external process some things need initializing\n\n\t\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\t\tapplicationName: ApplicationInfo.Name,\n\t\t\t\tappVersion: GetType().Assembly.GetName().Version.ToString(),\n\t\t\t\tenvironmentName: Configuration.GetStringAppSetting(\"Environment\", \"Unknown\"),\n\t\t\t\tsiteName: ApplicationSettings.Site,\n\t\t\t\tshouldEnableKazmon: () => true,\n\t\t\t\tshouldEnableSmartMon: () => true\n\t\t\t\t);\n\n#if NETFRAMEWORK\n\t\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n#else\n\t\t\tFileInfo logConfigFileInfo = new FileInfo(System.Configuration.ConfigurationManager.OpenExeConfiguration(System.Configuration.ConfigurationUserLevel.None).FilePath);\n#endif\n\n\t\t\tlog4net.Config.XmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\t\tif (!ConfigWrapper.UseOneConfig)\n\t\t\t{\n\t\t\t\tBootstrapper.Bootstrap(GetServiceRegistries);\n\t\t\t}\n\n\t\t\tHealthCheckResult selfCheck = RunSelfCheck();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tLogManager.Shutdown();\n\t\t\t\tKazmonMonitoring.ShutdownKazmon();\n\t\t\t}\n\t\t\tcatch { }\n\n\t\t\treturn selfCheck.Report;\n\t\t}\n\n\t\tprivate HealthCheckResult RunSelfCheck()\n\t\t{\n\t\t\t_log.InfoNoPII(\"Running health check.\");\n\t\t\tIList<IHealthCheckItem> defaultChecks = new List<IHealthCheckItem>()\n\t\t\t{\n\t\t\t\tnew HealthCheckAuthDbAccess(),\n\t\t\t\tnew HealthCheckCassandraStorage(ServiceLocator.GetInstance<IAtlasCassandraCluster>(), new string[] { \"atlas\" }),\n\t\t\t\tnew HealthCheckTempStorage(),\n\t\t\t\tnew HealthCheckSwiftStorage(),\n\t\t\t\tnew HealthCheckRedis(), // Remove this check when the RedisWithWrite is no longer log-only\n\t\t\t\tnew HealthCheckRedis(doWriteCheck: true) { IsLogOnly = true },\n\t\t\t\tnew OptimizelyHealthCheck() { IsLogOnly = true },\n\t\t\t\tnew HealthCheckMessageQueue(Types.Constants.HealthCheckRMQPath, string.Empty),\n\t\t\t\tnew HealthCheckJIT(),\n\t\t\t\tnew HealthCheckEmailTemplates()\n\t\t\t};\n\n\t\t\tIList<IHealthCheckItem> healthChecks = GetHealthChecksChain(defaultChecks);\n\n\t\t\t// Wait some \"random\" time before running checks, so that we don't generate\n\t\t\t// too many requests at the same time for our load sensitive services\n#pragma warning disable CA5394, CA1307\n\t\t\tThread.Sleep(new Random(GetType().Name.GetHashCode() ^ (int)DateTime.UtcNow.Ticks).Next(70, 700));\n#pragma warning restore CA5394, CA1307\n\n\t\t\treturn HealthCheckRunner.RunHealthChecks(healthChecks);\n\t\t}\n\n\t\tpublic virtual IList<IHealthCheckItem> GetHealthChecksChain(IList<IHealthCheckItem> defaultChecks)\n\t\t{\n\t\t\treturn defaultChecks;\n\t\t}\n\n\t\tprivate static readonly IDiscreetLogger _healthReportLog = DiscreetLogger.GetLogger(\"HealthCheck\");\n\t\tpublic virtual string LogHealthReport(HealthReport hreport)\n\t\t{\n\t\t\tstring jsonReport = JsonConvert.SerializeObject(hreport, Formatting.Indented);\n\t\t\tif (hreport.Pass)\n\t\t\t\t_healthReportLog.InfoNoPII(jsonReport);\n\t\t\telse\n\t\t\t\t_healthReportLog.WarnNoPII(jsonReport);\n\n\t\t\treturn jsonReport;\n\t\t}\n\n\t}\n}\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Constants.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\nusing ADEXS.Core.Util.Core;\n\n// This is added for svn testing purposes.\n\nnamespace ADEXS.Core.Types\n{\n\t/// <summary>\n\t/// Constants not tied to any specific object.\n\t/// </summary>\n\tpublic partial class Constants\n\t{\n\t\t// Use this when dealing with documents or folders to bypass security checks, if possible.\n\t\tpublic const int AllAccounts = Int32.MinValue;\n\t\tpublic static readonly Guid SystemUser = new Guid(\"00000001-0001-0001-0001-000000000001\");\n\t\tpublic static readonly Guid WorkflowUser = new Guid(\"00000002-0002-0002-0002-000000000002\");\n\t\tpublic static readonly string WorkflowName = \"Workflow\";\n\t\tpublic static readonly Guid PublicUser = new Guid(\"00000D0E-0D0E-0D0E-0D0E-000000000D0E\");\n\t\tpublic static readonly Guid InvalidUser = new Guid(\"00000BAD-0BAD-0BAD-0BAD-000000000BAD\");\n\t\tpublic static readonly Guid UnitTestUser = new Guid(\"00000555-0555-0555-0555-000000000555\");\n\t\tpublic static readonly double RegexDefaultTimeoutMilliseconds = 500;\n\t\tpublic const Enums.UserRole ProvisioningAdminRole = Enums.UserRole.Primary;\n\n\t\t//Document Upload cloud storage settings\n\t\tpublic const int DefaultSharedStorageTTL = 604800; //7days\n\n\t\tpublic static readonly Regex InvalidDocumentNameRegex = new Regex(\"[\\\\x00-\\\\x1F\\\"*/:<>?\\\\\\\\|]\", RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds)); // proper regex without the C# escapes: [x00-x1F\"*/:<>?\\\\|]   \\\\ is needed regex escape for the \\\n\t\tpublic static readonly Regex InvalidMetadataNameRegex = new Regex(\"#[\\\\.\\\\|]#\", RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds)); // \"#.#\" and \"#|#\" are used as delimiters in the Data Review Workflow step. Regex without the C# escapes: #[\\.\\|]#\n\t\tpublic static readonly Regex ScriptInjectorRegex = new Regex(\"[<>]\", RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidFirstLastNameRegex = new Regex(FirstLastNameRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidAddressRegex = new Regex(AddressRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidCityRegex = new Regex(CityRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidEmailRegex = new Regex(EmailRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t// Email validator used by One Notification. https://github.docusignhq.com/Core/Core/blob/1c8f3b366e58135312fbfc84bde2612f3a19ad2c/NotificationPlatform/API.Notifications/src/API.Notifications.Email/EmailUtils.cs#L39\n\t\tpublic static readonly Regex ValidEmailRegexOneNotification = new Regex(@\"^(?(\"\")(\"\".+?(?<!\\\\)\"\"@)|(([0-9a-zA-Z]((\\.(?!\\.))|[-!#\\$%&'\\*\\+/=\\?\\^`\\{\\}\\|~\\w])*)(?<=[0-9a-zA-Z_])@))(?(\\[)(\\[(\\d{1,3}\\.){3}\\d{1,3}\\])|(([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]*\\.)+[a-z0-9A-Z][\\-a-z0-9A-Z]{0,22}[a-zA-Z0-9]))$\", RegexOptions.Compiled, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t// TODO: replace ValidEmailRegex with ValidEmailRegexOneNotification\n\t\tpublic static readonly Regex EmailInTextRegex = new Regex(EmailRegexPatternInText, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidFaxNumberRegex = new Regex(FaxNumberRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex AlphaNumericWhitespaceHyphens = new Regex(AlphaNumericWhitespaceHyphensRegex, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex LoginNameRegex = new Regex(LoginNameRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex FilePathRegex = new Regex(FilePathRegexPattern, RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(Constants.RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidHtmlRegex = new Regex(HtmlRegexPattern, RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(Constants.RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex LineBreaksRegex = new Regex(LineBreaksRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(Constants.RegexDefaultTimeoutMilliseconds));\n\n\t\tpublic static readonly DateTime EpochStartDateTime = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);\n\t\tpublic const string AlphaNumericWhitespaceHyphensRegex = @\"[^\\w\\-\\s]\";\n\t\tpublic const string InvalidDocumentNameChars = \"\\\" * / : < > ? \\\\ |\"; // for use in messages to the user. should match above\n\t\tpublic const string ScriptInjectorCharacters = \"< >\";\n\t\tpublic const int MaxFolderLength = 100;\n\t\tpublic const int MaxFolderPathLength = (4000 - 1);          // we use nvarchar(4000) in many path related sprocs and udf, until then keep this less than 4000\n\t\tpublic const int MaxFolderPathLevels = (100 - 1);           // we will have CTE issues when the depth reaches 100\n\n\t\tpublic const int FirstLastNameMaxLength = 128; // match database setting\n\t\t\t\t\t\t\t\t\t\t\t\t\t   //Any character up to 128 length, except <>\"\n\t\tpublic const string FirstLastNameRegexPattern = @\"^[^<>\"\"]{1,128}$\";\n\t\tpublic const string CityRegexPattern = @\"^[\\w\\'\\ \\.#&]{2,50}$\";\n\t\tpublic const string AddressRegexPattern = @\"[a-zA-Z0-9 .,#\\-&'/]+\";\n\t\t// This will match one or more of whatever EXCEPT <, >, space, or @, followed by a single @, followed by whatever and a . followed by whatever.\n\t\t// We are being very generous in our email validation intentionally.\n\t\t// We exclude < and > because the smtp server throws an error on them,\n\t\t// and require only a single @ in the whole string, and at least one . in the domain otherwise type whatever you want.\n\t\t// As long as it is ASCII only. SMTP is not there yet with non ASCII support.\n\t\t// The regex is emitted in JavaScript so it needs to work there as well.\n\t\tpublic const string EmailRegexPattern = @\"^[!-;=?A-~]+@[!-;=?A-~]+\\.[A-Za-z0-9]{2,}$\";\n\t\t// same as above but doesn't require the email to be the only thing in the text.\n\t\tpublic const string EmailRegexPatternInText = @\"[!-;=?A-~]+@[!-;=?A-~]+\\.[!-;=?A-~]+\";\n\n\t\tpublic const string EmailLocalPartRegexPattern = @\"^[0-9a-zA-Z!#$%&'*+\\-/=?\\^_`{|}~.]+$\";\n\t\t// same character set as an email without forcing the email patern.\n\t\tpublic const string LoginNameRegexPattern = @\"^[a-zA-Z0-9][!-;=?@-~]{1,99}$\";\n\n\t\tpublic const string EmailValidationRegex = @\"\\b[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}\\b\";\n\n\t\tpublic const string FaxNumberRegexPattern =\n\t\t\t@\"^(?:(?:[\\+]?([\\d]{1,3}(?:[ ]+|[\\-.])))?[(]?([\\d]{3})[\\-/)]?(?:[ ]+)?)?([2-9][0-9 \\-.]{6,})$\";\n\n\t\tpublic const string HexColorRegexPattern = \"^([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$|^([a-fA-F0-9]{1})([a-fA-F0-9]{1})([a-fA-F0-9]{1})$\";\n\n\t\tpublic const string SpecialDateTimeFormatCharactersRegexPattern = @\"\\s?'?[\u0433|\u00fd]\\.'?\";   // ie. see Bulgarian and Turkmen short date patterns\n\n\t\tpublic const string UrlSanitizerRegexPatern = @\"[^A-Za-z0-9 \\-_.]\"; // remove all special characters except space, minus, underscore and period.\n\n\t\tpublic const string PositiveIntegerRegexPattern = @\"^\\d+$\";\n\n\t\tpublic const string MisplacedTagsPattern = \"</head>(.*?)<body>\";\n\n\t\tpublic const string ScriptPattern = \"<script>(.*?)</script>\";\n\n\t\tpublic const string StylePattern = \"<style>(.*?)</style>\";\n\n\t\tpublic const string HtmlPattern = \"<html>(.*?)</html>\";\n\n\t\tpublic const string FilePathRegexPattern = \".*?([a-z]:\\\\\\\\(?:[-\\\\w\\\\.\\\\d]+\\\\\\\\)*(?:[-\\\\w\\\\.\\\\d]+)?)\";\n\n\t\tpublic const string InvalidXmlDataForMergeRegexPattern = @\"&#x([0-8BCEFbcef]|1[0-9A-Fa-f]);|[\\x01-\\x08\\x0B\\x0C\\x0E\\x0F\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]\";\n\n\t\tpublic const string HtmlRegexPattern = @\"<\\/?[a-z][\\s\\S]*>\";\n\n\t\tpublic const string LineBreaksRegexPattern = @\"(\\r\\n|\\r|\\n)+\";\n\n\t\tpublic const int KB = 1024;\n\t\tpublic const int MB = KB * KB;\n\t\tpublic const int GB = KB * KB * KB;\n\n\t\t/// <summary>\n\t\t/// This is ASCII #30, dubbed \"record separator\", it is a character that is not visible when printed out.\n\t\t/// </summary>\n\t\tpublic const char AsciiRecordSeparator = (char)30;\n\n\t\tpublic const decimal SpringMaxDecimalValue = 9999999999999999.99M;\n\n\t\tpublic const string SFLoginUrl = \"https://login.salesforce.com\";\n\t\tpublic const string SFTestLoginUrl = \"https://test.salesforce.com\";\n    \tpublic const string SalesforceGovCloudDomain = \"salesforce-gov.com\";\n\t\tpublic const string SALESFORCE = \"Salesforce\";\n\t\tpublic const string STUB = \"Stub\";\n\t\tpublic const string StubValueRegexPattern = STUB + \"(.*:.*){2}\";\n\t\tpublic const string SFProdSubdomain = \"login\";\n\t\tpublic const string SFSandboxSubdomain = \"test\";\n\t\tpublic const string ScopeEventsAggregationJobLastRunRedisKey = \"ScopeEventsAggregationJob\";\n\n\t\tpublic const string WIDGET = \"Widget\";\n\n\t\tpublic const int SpringStartYear = 2003;\n\n\t\tpublic const int DayInSeconds = 60 * 60 * 24;\n\n\t\tpublic const int WorkflowNameMaxLength = 100;\n\t\tpublic const int DocumentNameMaxLength = 255;\n\t\tpublic const int AgreementSummaryMaxLength = 65535;\n\t\tpublic const int AgreementSummaryMaxDefaultLength = 600;\n\t\tpublic const int FolderNameMaxLength = 100;\n\t\tpublic const char IllegalTrailingFolderNameCharacter = '.';\n\n\t\tpublic const int SqlTimeoutErrorCode = -2;\n\t\tpublic const int MaxTrashDaysToKeep = 365;\n\t\tpublic const int MinAutoRenewalUnit = 1;\n\t\tpublic const int MaxAutoRenewalUnit = 1000;\n\n\t\t//Page restrictions\n\t\tpublic const string NoRestriction = \"NoRestriction\";\n\n\t\tpublic const string HealthCheckRMQPath = \"healthcheck\";\n\n\t\tpublic const string EssentialsFieldLibraryName = \"System Field library\";\n\n\t\t// Skip Link\n\t\tpublic const string SkipLinkMainContentId = \"ContentContainerOuter\";\n\t\tpublic const string SkipLinkId = \"skipLink\";\n\n\t\t//DefaultImageFormat\n\t\tpublic const string DefaultPreviewOutputFormat = \"Png\";\n\n\t\tpublic class EMSPaths\n\t\t{\n\t\t\tpublic const string ModelsEsignV2BasePath = \"/models-esign/v2/private/accounts\";\n\t\t\tpublic const string DocumentsIngestPath = \"documents/clm/ingest\";\n\t\t\tpublic const string CustomAttributesPath = \"custom_attributes\";\n\t\t\tpublic const string CustomAttributesFinalizePath = \"custom_attributes_finalize\";\n\t\t\tpublic const string UpdateDocumentIdOfAgreementDocumentPath = \"documents/clm/{0}\";\n\t\t\tpublic const string HealthCheckV1Path = \"/models-esign/v1/health\";\n\t\t}\n\n\t\tpublic class DevXIamPaths\n\t\t{\n\t\t\tpublic const string ModelsIamV1BasePath = \"devx-iam/v1/accounts\";\n\t\t\tpublic const string QueryDocumentPath = \"agreements/query\";\n\t\t\tpublic const string DeleteDocumentPath = \"agreements/{1}\";\n\t\t}\n\n\t\tpublic class ABACContextKeys\n\t\t{\n\t\t\tpublic const string UserId = \"UserId\";\n\t\t\tpublic const string AccountId = \"AccountId\";\n\t\t\tpublic const string AgreementType = \"AgreementType\";\n\t\t\tpublic const string GroupMembership = \"GroupMembership\";\n\t\t\tpublic const string Role = \"Role\";\n\t\t\tpublic const string Type = \"Type\";\n\t\t\tpublic const string PartyUid = \"PartyUid\";\n\t\t\tpublic const string Region = \"Region\";\n\t\t\tpublic const string Status = \"Status\";\n\t\t\tpublic const string Uid = \"Uid\";\n\t\t\tpublic const string Name = \"Name\";\n\t\t\tpublic const string CreatedDate = \"CreatedDate\";\n\t\t\tpublic const string CreatorUid = \"CreatorUid\";\n\t\t\tpublic const string UpdatedDate = \"UpdatedDate\";\n\t\t\tpublic const string ParentUid = \"ParentUid\";\n\t\t\tpublic const string ParentType = \"ParentType\";\n\t\t\tpublic const string HasSecurityAttributes = \"HasSecurityAttributes\";\n\t\t}\n\n\t\tpublic class APIKeyProducts\n\t\t{\n\t\t\tpublic const string AtlasUploadService = \"Atlas Upload Service\";\n\t\t\tpublic const string MultipleUploadControl = \"Multiple Upload Control\";\n\t\t\tpublic const string RulesOnFolders = \"Rules On Folders\";\n\t\t\tpublic const string UnitTest = \"Unit Test\";\n\t\t\tpublic const string UnknownAPIClient = \"Unknown API Client\";\n\t\t}\n\n\t\tpublic static class ActSalesforceForClm\n\t\t{\n\t\t\tpublic static readonly Guid AppId = new Guid(\"2d576583-520a-41e2-886b-089fefe733a1\");\n\t\t\tpublic const string ChildRelationshipFieldType = \"CHILD_RELATIONSHIP\";\n\t\t\tpublic const string CurrencyFieldType = \"CURRENCY\";\n\t\t\tpublic const string CurrentDateFieldName = \"CurrentDate\";\n\t\t\tpublic const string CurrencyIsoCodeFieldName = \"CurrencyIsoCode\";\n\t\t\tpublic const string GenTemplateWorkflowMappingName = \"dfsle__ApplyCLMWorkflow__c\";\n\t\t\tpublic const string IdFieldName = \"Id\";\n\t\t\tpublic const string MalformedGenMessage = \"Malformed Gen Template. Its empty and has no children.\";\n\t\t\tpublic const string NameFieldName = \"Name\";\n\t\t\tpublic const string ObjectMappingsName = \"dfsle__ObjectMappings\";\n\t\t\tpublic const string PickListFieldType = \"PICKLIST\";\n\t\t\tpublic const string ReferenceFieldType = \"REFERENCE\";\n\t\t\tpublic const string SalesforceObjectType = \"dfsle__GenTemplate__c\";\n\t\t\tpublic static readonly string[] SalesforceFields = new string[] { \"dfsle__ObjectMappings__c\", \"dfsle__ObjectMappings2__c\", \"dfsle__ObjectMappings3__c\", \"dfsle__ObjectMappings4__c\" };\n\t\t\tpublic static readonly string SalesforceLoggingObjectName = \"dfsle__Log__c\";\n\t\t}\n#pragma warning disable CA1724 // type name conflict\n\t\tpublic class API\n#pragma warning restore // type name conflict\n\t\t{\n\t\t\tpublic const string AttributeTypePropertyName = \"AttributeType\";\n\t\t\tpublic const string AttributeRepeatingPropertyName = \"RepeatingAttribute\";\n\t\t\tpublic const string AtomContentType = \"application/atom+xml\";\n\t\t\tpublic const string AtomNamespace = \"http://www.w3.org/2005/Atom\";\n\t\t\tpublic const string JsonContentType = \"application/json\";\n\t\t\tpublic const string OpenSearchAtomRel = \"results\";\n\t\t\tpublic const string OpenSearchDescription = \"Search documents stored in SpringCM.\";\n\t\t\tpublic const string OpenSearchEncoding = \"UTF-8\";\n\t\t\tpublic const string OpenSearchShortName = \"SpringCM Search\";\n\t\t\tpublic const string OpenSearchNamespace = \"http://a9.com/-/spec/opensearch/1.1/\";\n\t\t\tpublic const string SalesforceNamespace = \"http://salesforce.com/2016/federatedsearch/1.0\";\n\t\t\tpublic const string XmlContentType = \"application/xml\";\n\t\t\tpublic const string SalesforceNamespacePrefix = \"sfdc\";\n\t\t\tpublic const string OpenSearchNamespacePrefix = \"opensearch\";\n\t\t\tpublic const string AuthenticationTime = \"authtime\";\n\t\t\tpublic const string DsAccountId = \"DsAccountId\";\n\t\t\tpublic const string RestApi = \"restapi\";\n\t\t\tpublic const string Version1 = \"1\";\n\t\t\tpublic const string SiteWarmupPingPath = \"sitewarmup/ping\";\n\t\t\tpublic const string AlivePath = \"alive\";\n\n\t\t\t//UrlPrefixes\n\t\t\tpublic const string APIUrlPrefix = \"api\";\n\t\t\tpublic const string APIDownloadUrlPrefix = \"apidownload\";\n\t\t\tpublic const string OfficeAddInPrefix = \"officeaddin\";\n\t\t\tpublic const string DsOfficeAddInPrefix = \"ds-officeaddin\";\n\t\t\tpublic const string APIUploadUrlPrefix = \"apiupload\";\n\t\t\tpublic const string OpenSearchUrlPrefix = \"opensearch\";\n\t\t\tpublic const string RestUrlPrefix = \"rest\";\n\t\t\tpublic const string RestContentUrlPrefix = \"restcontent\";\n\t\t\tpublic const string SFTPUrlPrefix = \"sftp\";\n\t\t\tpublic const string SoapUrlPrefix = \"soap\";\n\t\t\tpublic const string AllocationUrlPrefix = \"allocate\";\n\t\t\tpublic const string GatekeeperUrlPrefix = \"gatekeeper\";\n\t\t\tpublic const string ProvisioningUrlPrefix = \"provisioning\";\n\n\t\t\t//WorkflowScopes\n\t\t\tpublic const string CLMExpressionCompile = \"clm_expression_compile\";\n\t\t\tpublic const string CLMExpressionExecute = \"clm_expression_execute\";\n\n\t\t\t// OrchestrationScopes\n\t\t\tpublic const string AowManage = \"aow_manage\";\n\n\t\t\t// DocManagementService Scopes and Paths\n\t\t\tpublic const string DMSBasePath = \"/document-management-service/v1\";\n\t\t\tpublic const string DMSMetadataPath = \"accounts/{0}/documents/{1}/metadata\";\n\t\t\tpublic const string DMSInternalScopes = \"internal_api_dms\";\n\t\t\tpublic const string DMSHealthCheckPath = \"/document-management-service/v1/health\";\n\n\t\t\t//ObligationManagementService (OMS) Paths\n\t\t\tpublic const string OMSReadPath = \"/obg-mgmt-service/v2.0/workflows/accounts/{0}/document/{1}/obligations\";\n\t\t\tpublic const string OMSUpdatePath = \"/obg-mgmt-service/v2.0/workflows/accounts/{0}/document/{1}/obligations/{2}\";\n\t\t}\n\n\t\tpublic class ApplicationSettings\n\t\t{\n\t\t\t// Blob storage settings\n\t\t\tpublic const string BlobPhysicalStorageUrl = \"BlobPhysicalStorageUrl\";\n\t\t\tpublic const string EnableNgScmDeferForChooser = \"EnableNgScmDeferForChooser\";\n\t\t\tpublic const string EnableBlobSharedStorageFallback = \"EnableBlobSharedStorageFallback\";\n\t\t\tpublic const string BlobPhysicalStorageDataPlaneAppIdUri = \"BlobPhysicalStorageDataPlaneAppIdUri\";\n\t\t\tpublic const string BlobPhysicalStorageClientId = \"BlobPhysicalStorageClientId\";\n\t\t\tpublic const string BlobSharedStorageClientId = \"BlobSharedStorageClientId\";\n\t\t\tpublic const string BlobSharedStorageDataPlaneAppIdUri = \"BlobSharedStorageDataPlaneAppIdUri\";\n\t\t\tpublic const string BlobSharedStorageUrl = \"BlobSharedStorageUrl\";\n\t\t\tpublic const string BlobPhysicalStorageHttpClientTimeoutMs = \"BlobPhysicalStorageHttpClientTimeoutMs\";\n\t\t\tpublic const string BlobPhysicalStorageAuthenticationTimeoutMs = \"BlobPhysicalStorageAuthenticationTimeoutMs\";\n\t\t\tpublic const string BlobStorageBackoffFirstRetrySeconds = \"BlobStorageBackoffFirstRetrySeconds\";\n\t\t\tpublic const string BlobStorageBackoffMaxRetryCount = \"BlobStorageBackoffMaxRetryCount\";\n\t\t\t// Dms storage settings\n\t\t\tpublic const string DmsPhysicalStorageUrl = \"DmsPhysicalStorageUrl\";\n\t\t\tpublic const string DmsPhysicalStorageClientId = \"DmsPhysicalStorageClientId\";\n\t\t\tpublic const string DmsPhysicalStorageHttpClientTimeoutMs = \"DmsPhysicalStorageHttpClientTimeoutMs\";\n\t\t\tpublic const string DmsPhysicalStorageAuthenticationTimeoutMs = \"DmsPhysicalStorageAuthenticationTimeoutMs\";\n\n\t\t\t//Document Upload cloud storage settings\n\t\t\tpublic const string WriteToSharedStorageOnDocumentUpload = \"WriteToSharedStorageOnDocumentUpload\";\n\n\n\t\t\t// connection strings\n\t\t\tpublic const string ConnectionString = \"connectionString\";\n\t\t\tpublic const string AuthenticationConnectionString = \"AuthenticationConnectionString\";\n\t\t\tpublic const string AuthenticationTokenExpirationMinutes = \"AuthenticationTokenExpirationMinutes\";\n\t\t\tpublic const string AuthenticationDomainRootUrl = \"AuthenticationDomainRootUrl\";\n\t\t\tpublic const string AuthenticationApplicationRootFormat = \"AuthenticationApplicationRootFormat\";\n\t\t\tpublic const string GateKeeperUrlFormat = \"GateKeeperUrlFormat\";\n\t\t\tpublic const string GateKeeperRetryCount = \"GateKeeperRetryCount\";\n\t\t\tpublic const string GateKeeperRetryIntervalInMs = \"GateKeeperRetryIntervalInMs\";\n\t\t\tpublic const string EventForwardingRegistrationRetryCount = \"EventForwardingRegistrationRetryCount\";\n\t\t\tpublic const string EventForwardingRegistrationIntervalInMs = \"EventForwardingRegistrationIntervalInMs\";\n\t\t\tpublic const string RestAuthRootUrl = \"RestAuthRootUrl\";\n\t\t\tpublic const string RestAuthRootUrlFormatSiteSpecific = \"RestAuthRootUrlFormatSiteSpecific\";\n\t\t\tpublic const string NewAccountConnectionString = \"NewAccountConnectionString\";\n\t\t\tpublic const string NewTrialConnectionString = \"NewTrialConnectionString\";\n\t\t\tpublic const string ProfileDatabaseConnectionString = \"ProfileDatabaseConnectionString\";\n\n\t\t\t/// <summary>\n\t\t\t/// This is the database connection string used by a wins service to connect to its target DB.\n\t\t\t/// </summary>\n\t\t\tpublic const string WINSDatabaseConnectionString = \"WINSDatabaseConnectionString\";\n\n\t\t\t// This value is set only to provide a clear notification when db access is attempted,\n\t\t\t// unbeknown to a unit test writer. Even on local environment unit tests would fail if\n\t\t\t// they try to use the database.\n\t\t\t// Note that the server start with \"local\", so that site matching continues to work.\n\t\t\tpublic static string DEFAULT_CONNECTION_STRING => \"Integrated Security=SSPI;initial catalog=noDefaultDb4u;data source=localNoDefaultServer4u;\";\n\n\t\t\tpublic const string ABCpdfLicense = \"ABCpdfLicense\";\n\t\t\tpublic const string AcceptableFileExtensions = \"AcceptableFileExtensions\";\n\t\t\tpublic const string AccountStatisticOldNumDays = \"AccountStatisticOldNumDays\";\n\t\t\tpublic const string ActivePDFErrorsDirectory = \"activePDFErrorsDirectory\";\n\t\t\tpublic const string ActivePDFOutputDirectory = \"activePDFOutputDirectory\";\n\t\t\tpublic const string ActivePDFWorkDirectory = \"activePDFWorkDirectory\";\n\t\t\tpublic const string AllowInternetExplorer = \"AllowInternetExplorer\";\n\t\t\tpublic const string AllowOpenRedirect = \"AllowOpenRedirect\";\n\t\t\tpublic const string AllowedRequestSources = \"AllowedRequestSources\";\n\t\t\tpublic const string InternalEmailDomains = \"InternalEmailDomains\";\n\t\t\tpublic const string AllowUpdatingScimExternalId = \"AllowUpdatingScimExternalId\";\n\t\t\tpublic const string AllowDocuSignOrderProvisioningInPSOTool = \"AllowDocuSignOrderProvisioningInPSOTool\";\n\t\t\tpublic const string CustomerSupportEmail = \"CustomerSupportEmail\";\n\t\t\tpublic const string LegacyCustomerSupportEmail = \"LegacyCustomerSupportEmail\";\n\t\t\tpublic const string AllowTrainingAccounts = \"AllowTrainingAccounts\";\n\t\t\tpublic const string AsyncPasteThreshold = \"AsyncPasteThreshold\";\n\t\t\tpublic const string BouncebackSMTPUserNames = \"BouncebackSMTPUserNames\";\n\n\t\t\tpublic const string BrandName = \"BrandName\";\n\t\t\tpublic const string BrandStreet = \"BrandStreet\";\n\t\t\tpublic const string BrandCity = \"BrandCity\";\n\t\t\tpublic const string BrandState = \"BrandState\";\n\t\t\tpublic const string BrandZip = \"BrandZip\";\n\n\t\t\tpublic const string EnableDocLauncherAutomaticNumberFormatting = \"EnableDocLauncherAutomaticNumberFormatting\";\n\n\t\t\tpublic const string PIIHashingStrategy = \"PIIHashingStrategy\";\n\n\t\t\tpublic const string MaxItemsInFolderDisplayedInUI = \"MaxItemsInFolderDisplayedInUI\";\n\n\t\t\tpublic const string MessagingFrameworkBrandedHeaderImageUrl = \"MessagingFrameworkBrandedHeaderImageUrl\";\n\n\t\t\tpublic const string MessagingFrameworkFacebookUrl = \"MessagingFrameworkFacebookUrl\";\n\t\t\tpublic const string MessagingFrameworkLinkedinUrl = \"MessagingFrameworkLinkedinUrl\";\n\t\t\tpublic const string MessagingFrameworkTwitterUrl = \"MessagingFrameworkTwitterUrl\";\n\t\t\tpublic const string MessagingFrameworkYoutubeUrl = \"MessagingFrameworkYoutubeUrl\";\n\n\t\t\tpublic const string MessagingFrameworkFacebookImageUrl = \"MessagingFrameworkFacebookImageUrl\";\n\t\t\tpublic const string MessagingFrameworkLinkedinImageUrl = \"MessagingFrameworkLinkedinImageUrl\";\n\t\t\tpublic const string MessagingFrameworkTwitterImageUrl = \"MessagingFrameworkTwitterImageUrl\";\n\t\t\tpublic const string MessagingFrameworkYoutubeImageUrl = \"MessagingFrameworkYoutubeImageUrl\";\n\n\t\t\tpublic const string BrowseUploadTempLocation = \"BrowseUploadTempLocation\";\n\t\t\tpublic const string BuildMinorOffset = \"BuildMinorOffset\";\n\t\t\tpublic const string ChunkSize = \"chunkSize\";\n\t\t\tpublic const string LogInInfoMessage = \"LogInInfoMessage\";\n\t\t\tpublic const string UploadAuthenticationTokenTtl = \"UploadAuthenticationTokenTtl\";\n\n\t\t\t/* ABAC */\n\t\t\tpublic const string SecurityEvaluationServiceMemoryCacheEntryCountLimit = \"SecurityEvaluationServiceMemoryCacheEntryCountLimit\";\n\t\t\tpublic const string AllowAbacEnablementDuringAccountCreation = \"AllowAbacEnablementDuringAccountCreation\";\n\n\t\t\t/* Caching */\n\t\t\tpublic const string CacheName = \"CacheName\";\n\t\t\tpublic const string CacheDataItemExpirationMinutes = \"CacheDataItemExpirationMinutes\";\n\t\t\tpublic const string CacheClientElapsedMSThreshold = \"CacheClientElapsedMSThreshold\";\n\t\t\tpublic const string SignedRequestCacheSeconds = \"SignedRequestCacheSeconds\";\n\t\t\tpublic const string SfIdentityResponseCacheSeconds = \"SfIdentityResponseCacheSeconds\";\n\t\t\tpublic const string DSAccountEntitlementCacheTtlSeconds = \"DSAccountEntitlementCacheTtlSeconds\";\n\t\t\tpublic const string DSOrgUserProfileCacheTtlSeconds = \"DSOrgUserProfileCacheTtlSeconds\";\n\t\t\tpublic const string DSAccountServerAccessTokenCacheTimeout = \"DSAccountServerAccessTokenCacheTimeout\";\n\t\t\tpublic const string DSLimitedAccessTokenCacheKeyPrefix = \"DSLimitedAccessTokenCacheKeyPrefix\";\n\t\t\tpublic const string DSLimitedAccessTokenCacheLockKeyPrefix = \"DSLimitedAccessTokenCacheLockKeyPrefix\";\n\n\t\t\tpublic const string CaptchaPublicKey = \"CaptchaPublicKey\";\n\n\t\t\tpublic const string CaptchaPrivateKey = \"CaptchaPrivateKey\";\n\t\t\tpublic const string CaseCreateInProcessWaitTimeoutInSeconds = \"CaseCreateInProcessWaitTimeoutInSeconds\";\n\t\t\tpublic const string CaseCreateOutProcessWaitTimeoutInSeconds = \"CaseCreateInProcessWaitTimeoutInSeconds\";\n\n\t\t\tpublic const string BuildNumberSuffix = \"BuildNumberSuffix\";\n\n\t\t\tpublic const string MaxTransactionsPerBatch = \"MaxTransactionsPerBatch\";\n\n\t\t\t/* Cassandra */\n\t\t\tpublic const string CassandraConnectionString = \"CassandraConnectionString\";\n\t\t\tpublic const string CassandraConnectTimeoutMs = \"CassandraConnectTimeoutMs\";\n\t\t\tpublic const string CassandraDriverTraceLevel = \"CassandraDriverTraceLevel\";\n\t\t\tpublic const string CassandraEnableTracing = \"CassandraEnableTracing\";\n\t\t\tpublic const string CassandraHeartbeatInterval = \"CassandraHeartbeatInterval\";\n\t\t\tpublic const string CassandraKeyspaceName = \"CassandraKeyspaceName_\";\n\t\t\tpublic const string CassandraLocalDatacenter = \"CassandraLocalDatacenter\";\n\t\t\tpublic const string CassandraExecuteMaxAttempts = \"CassandraExecuteMaxAttempts\";\n\t\t\tpublic const string CassandraReconnectMaxMs = \"CassandraReconnectMaxMs\";\n\t\t\tpublic const string CassandraReadTimeOutMs = \"CassandraReadTimeOutMs\";\n\t\t\tpublic const string CassandraReconnectMinMs = \"CassandraReconnectMinMs\";\n\t\t\tpublic const string FolderHistoryItemsLimit = \"FolderHistoryItemsLimit\";\n\t\t\tpublic const string WriteFolderHistory = \"WriteFolderHistory\";\n\t\t\tpublic const string BucketedHistoryAlignSeconds = \"BucketedHistoryAlignSeconds\";\n\t\t\tpublic const string ObjectHistoryBucketedMaxBucketSize = \"ObjectHistoryBucketedMaxBucketSize\";\n\t\t\tpublic const string SentEmailBucketedAlignSeconds = \"SentEmailBucketedAlignSeconds\";\n\t\t\tpublic const string SentEmailBucketedMaxBucketSize = \"SentEmailBucketedMaxBucketSize\";\n\t\t\tpublic const string CassandraEnabledMaterializedViews = \"CassandraEnabledMaterializedViews\";\n\t\t\tpublic const string IsMultipleColumnsOrderBySupported = \"IsMultipleColumnsOrderBySupported\";\n\n\t\t\t/* Presto/Reporting/Analytics/ */\n\t\t\tpublic const string PrestoReportUIMaxRows = \"PrestoReportUIMaxRows\";\n\n\t\t\tpublic const string PrestoDocActivityReportMaxBuckets = \"PrestoDocActivityReportMaxBuckets\";\n\n\t\t\tpublic const string PrestoUiPreviewQueryMaxExecutionTimeSecs = \"PrestoUiPreviewQueryMaxExecutionTimeSecs\";\n\t\t\tpublic const string PrestoUiViewQueryMaxExecutionTimeSecs = \"PrestoUiViewQueryMaxExecutionTimeSecs\";\n\n\t\t\tpublic const string PrestoExportQueryMaxExecutionTimeHours = \"PrestoExportQueryMaxExecutionTimeHours\";\n\t\t\tpublic const string PrestoReportCacheTtlSecs = \"PrestoReportCacheTtlSecs\";\n\t\t\tpublic const string PrestoWorkflowOverviewReportMaxPartitions = \"PrestoWorkflowOverviewReportMaxPartitions\";\n\t\t\tpublic const string PrestoWorkflowStepReportMaxPartitions = \"PrestoWorkflowStepReportMaxPartitions\";\n\t\t\tpublic const string PrestoMaxScopeNamePartitions = \"PrestoMaxScopeNamePartitions\";\n\t\t\tpublic const string PrestoRestRequestLatencyMs = \"PrestoRestRequestLatencyMs\";\n\t\t\tpublic const string PrestoSQLHeaderEnabled = \"PrestoSQLHeaderEnabled\";\n\t\t\tpublic const string PrestoUrl = \"PrestoUrl\";\n\t\t\tpublic const string PrestoUrlFormat = \"PrestoUrlFormat\";\n\n\n\t\t\tpublic const string PrestoLogAllHttpRequests = \"PrestoLogAllHttpRequests\";\n\t\t\tpublic const string PrestoQueryLogTtlHours = \"PrestoQueryLogTtlHours\";\n\t\t\tpublic const string PrestoReportUIMaxGroups = \"PrestoReportUIMaxGroups\";\n\t\t\tpublic const string PrestoUseSeparateCassandraCatalogs = \"PrestoUseSeparateCassandraCatalogs\";\n\t\t\tpublic const string PrestoEnableAsUTC = \"PrestoEnableAsUTC\";\n\t\t\tpublic const string ReportBuilderLoadingStatusIntervalMs = \"ReportBuilderLoadingStatusIntervalMs\";\n\t\t\tpublic const string ReportBuilderLoadingStatusMaxRetries = \"ReportBuilderLoadingStatusMaxRetries\";\n\t\t\tpublic const string ReportingMaxCheckInDocumentRetryCount = \"ReportingMaxCheckInDocumentRetryCount\";\n\t\t\tpublic const string ReportingMaxSubscriberDeleteRetryCount = \"ReportingMaxSubscriberDeleteRetryCount\";\n\n\t\t\tpublic const string EnableDocumentReportAttributeFiltersPerformanceImprovement =\n\t\t\t\t\"EnableDocumentReportAttributeFiltersPerformanceImprovement\";\n\t\t\tpublic const string EnableStandardReportsSqlDynamicFiltering =\n\t\t\t\t\"EnableStandardReportsSqlDynamicFiltering\";\n\n\t\t\tpublic const string EnableDocumentReportAttributeColumnsPerformanceImprovement =\n\t\t\t\t\"EnableDocumentReportAttributeColumnsPerformanceImprovement\";\n\n\t\t\tpublic const string MaxRetryAttemptsPackageFolderMapping = \"MaxRetryAttemptsPackageFolderMapping\";\n\t\t\tpublic const string ReportingLoadingStatePollingIntervalMs = \"ReportingLoadingStatePollingIntervalMs\";\n\t\t\tpublic const string ReportingTempStoragePath = \"ReportingTempStoragePath\";\n\t\t\tpublic const string SearchFacadeBaseUrl = \"SearchFacadeBaseUrl\";\n\t\t\tpublic const string SearchIncBaseUrl = \"SearchIncBaseUrl\";\n\t\t\tpublic const string SearchUseExternalServiceOnly = \"SearchUseExternalServiceOnly\";\n\n\t\t\t/* Elastic indexing */\n\t\t\tpublic const string AzureRingShard = \"AzureRingShard\";\n\t\t\tpublic const string ElasticsearchMaxBatchSizeMBCLMClient = \"ElasticsearchMaxBatchSizeMBCLMClient\";\n\t\t\tpublic const string ElasticsearchMaxBatchSizeMBExternalClient = \"ElasticsearchMaxBatchSizeMBExternalClient\";\n\t\t\tpublic const string ElasticIndexingFolderLoadPageSize = \"ElasticIndexingFolderLoadPageSize\"; // The size of each page loaded from the database when the service is bulk indexing\n\t\t\tpublic const string ElasticIndexingDocumentLoadPageSize = \"ElasticIndexingDocumentLoadPageSize\"; // The size of each page loaded from the database when the service is bulk indexing\n\t\t\tpublic const string ElasticUseMatchPhraseForWithAllWords = \"ElasticUseMatchPhraseForWithAllWords\";\n\t\t\tpublic const string ElasticsearchMaxIndexedContentLen = \"ElasticsearchMaxIndexedContentLen\";\n\t\t\tpublic const string ElasticsearchMaxMessageSizeExternalService = \"ElasticsearchMaxMessageSizeExternalService\";\n\t\t\tpublic const string ElasticsearchScrollTtlSeconds = \"ElasticsearchScrollTtlSeconds\";\n\t\t\tpublic const string ElasticsearchHighlightFragmentSize = \"ElasticsearchHighlightFragmentSize\";\n\t\t\tpublic const string ElasticsearchHighlightPreTags = \"ElasticsearchHighlightPreTags\";\n\t\t\tpublic const string ElasticsearchHighlightPostTags = \"ElasticsearchHighlightPostTags\";\n\t\t\tpublic const string ElasticsearchIndexingBackoffFirstRetrySeconds =\n\t\t\t\t\"ElasticsearchIndexingBackoffFirstRetrySeconds\";\n\t\t\tpublic const string ElasticsearchIndexingBackoffMaxRetryCount = \"ElasticsearchIndexingBackoffMaxRetryCount\";\n\t\t\tpublic const string ElasticsearchSearchBackoffFirstRetrySeconds =\n\t\"ElasticsearchSearchBackoffFirstRetrySeconds\";\n\t\t\tpublic const string ElasticsearchSearchBackoffMaxRetryCount = \"ElasticsearchSearchBackoffMaxRetryCount\";\n\t\t\t/// <summary>\n\t\t\t/// Originally, this was BrowseUploadTempLocation, but since chunks may be\n\t\t\t/// uploaded to different web servers in a load balanced environment, the chunks\n\t\t\t/// need to be stored at some centrally accessible location.\n\t\t\t/// </summary>\n\t\t\tpublic const string ChunkUploadDirectory = \"chunkUploadDirectory\";\n\t\t\tpublic const string UiChunkUploadDirectory = \"UiChunkUploadDirectory\";\n\n\t\t\tpublic const string ApprovalReservedName = \"ApprovalReservedName\";\n\t\t\tpublic const string DocuSignDownloadsUrl = \"DocuSignDownloadsUrl\";\n\t\t\tpublic const string CommandCountWarning = \"commandCountWarning\";\n\t\t\tpublic const string CommandSecondsWarning = \"commandSecondsWarning\";\n\t\t\tpublic const string ContentRootUrl = \"ContentRootUrl\";\n\t\t\tpublic const string UxRootUrl = \"UxRootUrl\";\n\t\t\tpublic const string UxVersion = \"UxVersion\";\n\t\t\tpublic const string OAuthRefreshTokenExpirationMinutes = \"OAuthRefreshTokenExpirationMinutes\";\n\t\t\tpublic const string ApplicationOauthName = \"ApplicationOauthName\";\n\t\t\tpublic const string ObjectNameDisplayLength = \"objectNameDisplayLength\";\n\t\t\tpublic const int ObjectNameDisplayLengthDefault = 40;\n\n\t\t\tpublic const string ChunkUploadExpirationSeconds = \"ChunkUploadExpirationSeconds\";\n\t\t\tpublic const string AkamaiUploadTimeoutValue = \"AkamaiUploadTimeoutValue\";\n\t\t\tpublic const string CounterCacheSize = \"counterCacheSize\";\n\t\t\tpublic const string CustomLogoPath = \"CustomLogoPath\";\n\t\t\tpublic const string CustomLogoMaxWidth = \"CustomLogoMaxWidth\";\n\t\t\tpublic const string CustomIconMaxWidth = \"CustomIconMaxWidth\";\n\t\t\tpublic const string CustomLogoMaxHeight = \"CustomLogoMaxHeight\";\n\t\t\tpublic const string CustomIconMaxHeight = \"CustomIconMaxHeight\";\n\t\t\tpublic const string CustomLogoMaxFileSize = \"CustomLogoMaxFileSize\";\n\t\t\tpublic const string CustomLogoSupportedFileTypes = \"CustomLogoSupportedFileTypes\";\n\t\t\tpublic const string CustomChartPalette = \"CustomChartPalette\";\n\t\t\tpublic const string DBConnectInfoExpirationMinutes = \"DBConnectInfoExpirationMinutes\";\n\t\t\tpublic const string DeactivatedFaxEmailRecipients = \"DeactivatedFaxEmailRecipients\";\n\t\t\tpublic const string DeleteUnusedFileLocalStartTime = \"DeleteUnusedFileLocalStartTime\";\n\t\t\tpublic const string DefaultContractStorageGB = \"DefaultContractStorageGB\";\n\t\t\tpublic const string DefaultContractStorageGBFreeEdition = \"DefaultContractStorageGBFreeEdition\";\n\t\t\tpublic const string DefaultContractStorageGBTrialAccount = \"DefaultContractStorageGBTrialAccount\";\n\t\t\tpublic const string DefaultContractUserLimit = \"DefaultContractUserLimit\";\n\t\t\tpublic const string DefaultContractUserLimitFreeEdition = \"DefaultContractUserLimitFreeEdition\";\n\t\t\tpublic const string DefaultContractUserLimitTrialAccount = \"DefaultContractUserLimitTrialAccount\";\n\t\t\tpublic const string DefaultLogoutRedirectUrl = \"DefaultLogoutRedirectUrl\";\n\t\t\tpublic const string DefaultPremiumContractStorageGB = \"DefaultPremiumContractStorageGB\";\n\t\t\tpublic const string DefaultUserKeyExpirationMinutes = \"DefaultUserKeyExpirationMinutes\";\n\t\t\tpublic const string DebugOnStartup = \"DebugOnStartup\";\n\t\t\tpublic const string ServiceName = \"serviceName\";\n\t\t\tpublic const string AdexsServicedComponent = \"adexsServicedComponent\";\n\t\t\tpublic const string AdexsServicedComponentAssembly = \"adexsServicedComponentAssembly\";\n\t\t\tpublic const string MaxUserKeyExpirationMinutes = \"MaxUserKeyExpirationMinutes\";\n\t\t\tpublic const string DirectoryToClean = \"directoryToClean\";\n\t\t\tpublic const string DisableNotificationFramework = \"DisableNotificationFramework\";\n\t\t\tpublic const string DocumentLWDPPfailureImageBig = \"DocumentLWDPPfailureImageBig\";\n\t\t\tpublic const string DocumentLWDPPfailureImageSmall = \"DocumentLWDPPfailureImageSmall\";\n\t\t\tpublic const string DocumentLWDPRepositoryRootLegacyFallback = \"DocumentLWDPRepositoryRootLegacyFallback\";\n\t\t\tpublic const string DocumentRepositoryRootLegacyFallback = \"DocumentRepositoryRootLegacyFallback\";\n\t\t\tpublic const string DomainRootFormat = \"DomainRootFormat\";\n\t\t\tpublic const string IsFedRamp = \"IsFedRamp\";\n\t\t\tpublic const string SfGenApiRoot = \"SfGenApiRoot\";\n\t\t\tpublic const string SoapUrlFormat = \"SoapUrlFormat\";\n\t\t\tpublic const string RestUrlFormat = \"RestUrlFormat\";\n\t\t\tpublic const string RestContentUrlFormat = \"RestContentUrlFormat\";\n\t\t\tpublic const string APIBaseUrlFormat = \"APIBaseUrlFormat\";\n\t\t\tpublic const string APIBaseUploadUrlFormat = \"APIBaseUploadUrlFormat\";\n\t\t\tpublic const string APIBaseDownloadUrlFormat = \"APIBaseDownloadUrlFormat\";\n\t\t\tpublic const string OfficeAddInUrlFormat = \"OfficeAddInUrlFormat\";\n\t\t\tpublic const string DsOfficeAddInUrlFormat = \"DsOfficeAddInUrlFormat\";\n\t\t\tpublic const string SftpUrlFormat = \"SftpUrlFormat\";\n\t\t\tpublic const string OpenSearchBaseUrlFormat = \"OpenSearchBaseUrlFormat\";\n\t\t\tpublic const string SpringCMDomain = \"SpringCMDomain\";\n\t\t\tpublic const string DocusignDomain = \"DocusignDomain\";\n\t\t\tpublic const string DomainUploadRoot = \"DomainUploadRoot\";\n\t\t\tpublic const string PdfFieldExportTemporaryStoragePath = \"PdfFieldExportTemporaryStoragePath\";\n\t\t\tpublic const string ShareRootUrl = \"ShareRootUrl\";\n\t\t\tpublic const string TransientStorage = \"TransientStorage\";\n\t\t\tpublic const string TempTransientStorage = \"TempTransientStorage\";\n\t\t\tpublic const string OutboundHttpStorage = \"OutboundHttpStorage\";\n\t\t\tpublic const string DropdownMaxItems = \"DropdownMaxItems\";\n\t\t\tpublic const string GridSelectAllLimit = \"GridSelectAllLimit\";\n\t\t\tpublic const string SpringCMEditProhibitedExtensions = \"SpringCMEditProhibitedExtensions\";\n\t\t\tpublic const string SpringCMSalesEmail = \"SpringCMSalesEmail\";\n\t\t\tpublic const string SpringCMSalesPhoneNumber = \"SpringCMSalesPhoneNumber\";\n\t\t\tpublic const string EnableWorkItemNewsWorker = \"EnableWorkItemNewsWorker\";\n\t\t\tpublic const string EnableSignedRequestReplayPrevention = \"EnableSignedRequestReplayPrevention\";\n\t\t\tpublic const string AtlasEtlStorage = \"AtlasEtlStorage\";\n\t\t\tpublic const string DefaultBounceBackEmail = \"DefaultBounceBackEmail\";\n\t\t\tpublic const string DocLauncherFormsKnowledgeUrl = \"DocLauncherFormsKnowledgeUrl\";\n\t\t\tpublic const string DocLauncherOneClickKnowledgeUrl = \"DocLauncherOneClickKnowledgeUrl\";\n\t\t\tpublic const string DocLauncherOneClickKnowledgeUrlDS = \"DocLauncherOneClickKnowledgeUrlDS\";\n\t\t\tpublic const string AllowDocLauncherCanvasUrls = \"AllowDocLauncherCanvasUrls\";\n\t\t\tpublic const string UserOverageEmailIntervalInDays = \"UserOverageEmailIntervalInDays\";\n\t\t\tpublic const string EnableNewESignatureConfigurationPage = \"EnableNewESignatureConfigurationPage\";\n\t\t\tpublic const string SessionTimeoutOptions = \"SessionTimeoutOptions\";\n\t\t\tpublic const string PasswordExpirationOptions = \"PasswordExpirationOptions\";\n\t\t\tpublic const string PasswordReuseOptions = \"PasswordReuseOptions\";\n\t\t\tpublic const string FederatedSecurityPossibleCacheValuesMinutes = \"FederatedSecurityPossibleCacheValuesMinutes\";\n\t\t\tpublic const string AuthAppSessionTimeoutInSeconds = \"AuthAppSessionTimeoutInSeconds\";\n\n\t\t\t//Electronic Signatures\n\t\t\tpublic const string AdobeSignApiKey = \"AdobeSignApiKey\"; //This is the default (Application-wdie) stored value if the Account doesn't have a specifid API\n\t\t\tpublic const string EchoSignApiKey = \"EchoSignApiKey\"; //This is the default (Application-wdie) stored value if the Account doesn't have a specifid API\n\t\t\tpublic const string EchosignTestDocumentPath = \"EchosignTestDocumentPath\";\n\t\t\tpublic const string ESignatureTestRecipient = \"ESignatureTestRecipient\";\n\t\t\tpublic const string EchosignTestSignatureMessage = \"EchosignTestSignatureMessage\";\n\t\t\tpublic const string ElectronicSignatureWaitExpirationMinutes = \"ElectronicSignatureWaitExpirationMinutes\";\n\t\t\tpublic const string ElectronicSignatureMaxWaitExpirationDays = \"ElectronicSignatureMaxWaitExpirationDays\";\n\t\t\tpublic const string ESignMinPendingMinutes = \"ESignMinPendingMinutes\";\n\t\t\tpublic const string ESignMaxPendingMinutes = \"ESignMaxPendingMinutes\";\n\t\t\tpublic const string ElectronicSignatureMaxErrorCount = \"ElectronicSignatureMaxErrorCount\";\n\t\t\tpublic const string EchoSignWorkerCount = \"EchoSignWorkerCount\";\n\t\t\tpublic const string ESignPreviewWorkerCount = \"ESignPreviewWorkerCount\";\n\t\t\tpublic const string DocuSignWorkerCount = \"DocuSignWorkerCount\";\n\t\t\tpublic const string EchoSignWorkerSleepSeconds = \"EchoSignWorkerSleepSeconds\";\n\t\t\tpublic const string ESignPreviewWorkerSleepSeconds = \"ESignPreviewWorkerSleepSeconds\";\n\t\t\tpublic const string DocuSignWorkerSleepSeconds = \"DocuSignWorkerSleepSeconds\";\n\t\t\tpublic const string DocuSignMaxResponseContentBufferSize = \"DocuSignMaxResponseContentBufferSize\";\n\t\t\tpublic const string DocuSignMaxWaitExpirationDays = \"DocuSignMaxWaitExpirationDays\";\n\t\t\tpublic const string DocuSignAllowedDocExtensions = \"DocuSignAllowedDocExtensions\";\n\t\t\tpublic const string EchoSignWorkerMaxRowsPerRound = \"EchoSignWorkerMaxRowsPerRound\";\n\t\t\tpublic const string DocuSignWorkerMaxRowsPerRound = \"DocuSignWorkerMaxRowsPerRound\";\n\t\t\tpublic const string ESignRetryWorkerCount = \"ESignRetryWorkerCount\";\n\t\t\tpublic const string ESignRetryWorkerSleepSeconds = \"ESignRetryWorkerSleepSeconds\";\n\t\t\tpublic const string ESignatureRefreshActiveWorkerSleepSeconds = \"ESignatureRefreshActiveWorkerSleepSeconds\";\n\t\t\tpublic const string ESignatureRefreshActiveWorkerCount = \"ESignatureRefreshActiveWorkerCount\";\n\t\t\tpublic const string ESignatureRefreshRecordsUpdatedBeforeSeconds = \"ESignatureRefreshRecordsUpdatedBeforeSeconds\";\n\t\t\tpublic const string ESignatureRetryRefreshErrorWorkerCount = \"ESignatureRetryRefreshErrorWorkerCount\";\n\t\t\tpublic const string ESignatureRetryRefreshErrorWorkerSleepSeconds = \"ESignatureRetryRefreshErrorWorkerSleepSeconds\";\n\t\t\tpublic const string GenericCallbackPrefix = \"GenericCallbackPrefix\";\n\t\t\tpublic const string AuthCallbackPrefix = \"AuthCallbackPrefix\";\n\t\t\tpublic const string IncludeCallbackSuffixInVendorCallbackUrl = \"IncludeCallbackSuffixInVendorCallbackUrl\";\n\t\t\tpublic const string PollEchoSignStatusTimeoutInSeconds = \"PollEchoSignStatusTimeoutInSeconds\";\n\t\t\tpublic const string ElectronicSignatureLegalStatusKnowledgeUrl = \"ElectronicSignatureLegalStatusKnowledgeUrl\";\n\t\t\tpublic const string ElectronicSignatureCleanupWorkerCount = \"ElectronicSignatureCleanupWorkerCount\";\n\t\t\tpublic const string ElectronicSignatureCleanupWorkerSleepSeconds = \"ElectronicSignatureCleanupWorkerSleepSeconds\";\n\t\t\tpublic const string ElectronicSignatureCleanupWorkerMaxRetentionDays = \"ElectronicSignatureCleanupWorkerMaxRetentionDays\";\n\n\t\t\tpublic const string PlainTextExtractionMaxFileSize = \"PlainTextExtractionMaxFileSize\";\n\n\t\t\t//Document Reminders\n\t\t\tpublic const string DocumentReminderWorkerCount = \"DocumentReminderWorkerCount\";\n\t\t\tpublic const string DocumentReminderWorkerSleepSeconds = \"DocumentReminderWorkerSleepSeconds\";\n\t\t\tpublic const string DocumentReminderWorkerMaxRowsPerRound = \"DocumentReminderWorkerMaxRowsPerRound\";\n\t\t\tpublic const string DocumentReminderCleanupWorkerCount = \"DocumentReminderCleanupWorkerCount\";\n\t\t\tpublic const string DocumentReminderCleanupWorkerSleepSeconds = \"DocumentReminderCleanupWorkerSleepSeconds\";\n\t\t\tpublic const string DocumentReminderCleanupExpirationMinutes = \"DocumentReminderCleanupExpirationMinutes\";\n\n\t\t\t//SXTerms\n\t\t\tpublic const string TermMaxOptionLength = \"TermMaxOptionLength\";\n\t\t\tpublic const string TermMaxFileSize = \"TermMaxFileSize\";\n\t\t\tpublic const string Cached_Term_Key = \"CACHED_TERM_{0}_{1}\"; // CACHED_TERM_{accountId}_{termDocFileDataUid}\n\t\t\tpublic const int Cached_Term_ExpirationSeconds = 60 * 60 * 24 * 14; // 2 weeks\n\n\t\t\t//Email\n\t\t\tpublic const string AcceptedEmailDomain = \"AcceptedEmailDomain\";\n\t\t\tpublic const string OneNotificationEmailRetryCount = \"OneNotificationEmailRetryCount\";\n\t\t\tpublic const string OneNotificationEmailRetryIntervalInMs = \"OneNotificationEmailRetryIntervalInMs\";\n\t\t\tpublic const string OneNotificationCallbackUrlPath = \"OneNotificationCallbackUrlPath\";\n\t\t\tpublic const string OneNotificationIncludeCallbackUrl = \"OneNotificationIncludeCallbackUrl\";\n\t\t\tpublic const string OneNotificationCallbackUrl = \"OneNotificationCallbackUrl\";\n\t\t\tpublic const string OneNotificationEmailCacheTTLInSeconds = \"OneNotificationEmailCacheTTLInSeconds\";\n\t\t\tpublic const string OneNotificationLogErrorMessages = \"OneNotificationLogErrorMessages\";\n\t\t\tpublic const string OneNotificationEmailMaxRecipients = \"OneNotificationEmailMaxRecipients\";\n\t\t\tpublic const string OutboundEmailMaxRecipients = \"OutboundEmailMaxRecipients\";\n\t\t\tpublic const string MaxOutboundEmailsForAccountInSlidingWindow = \"MaxOutboundEmailsForAccountInSlidingWindow\";\n\t\t\tpublic const string EmailAccountIdCacheKeyPrefix = \"EmailAccountIdCacheKeyPrefix\";\n\n\t\t\t//External Review\n\t\t\tpublic const string ExternalReviewMaxPdfWaitTimeSeconds = \"ExternalReviewMaxPdfWaitTimeSeconds\";\n\t\t\tpublic const string ExternalReviewExpirationWorkerSleepSeconds = \"ExternalReviewExpirationWorkerSleepSeconds\";\n\t\t\tpublic const string EnableNewCompleteExternalReviewPage = \"EnableNewCompleteExternalReviewPage\";\n\t\t\tpublic const string ExternalReviewAttachmentCleanupTimeoutSeconds = \"ExternalReviewAttachmentCleanupTimeoutSeconds\";\n\t\t\tpublic const string ExternalReviewSafeToReplyEmailCleanupTimeoutSeconds = \"ExternalReviewSafeToReplyEmailCleanupTimeoutSeconds\";\n\t\t\tpublic const string EnableExternalReviewReplyToEmailUid = \"EnableExternalReviewReplyToEmailUid\";\n\t\t\tpublic const string ExternalReviewEmailProcessingUrl = \"ExternalReviewEmailProcessingUrl\";\n\t\t\tpublic const string ExternalReviewReplyToDomain = \"ExternalReviewReplyToDomain\";\n\t\t\tpublic const string ExternalReviewFromAddress = \"ExternalReviewFromAddress\";\n\t\t\tpublic const string EnableSetMaxTaskErrorCountWhenInvalidRecipients = \"EnableSetMaxTaskErrorCountWhenInvalidRecipients\";\n\t\t\tpublic const string ExternalReviewMaxExpirationDays = \"ExternalReviewMaxExpirationDays\";\n\t\t\tpublic const string ExternalReviewOnBehalfMaxConversionTimeInSecond = \"ExternalReviewOnBehalfMaxConversionTimeInSecond\";\n\t\t\tpublic const string EnableExternalReviewCompleteOnBehalf = \"EnableExternalReviewCompleteOnBehalf\";\n\t\t\tpublic const string EnableAssignmentInCompleteOnBehalf = \"EnableAssignmentInCompleteOnBehalf\";\n\t\t\tpublic const string ExternalReviewStatusViewList = \"ExternalReviewStatusViewList\";\n\t\t\tpublic const string UseExternalReviewDownloadableV2 = \"UseExternalReviewDownloadableV2\";\n\t\t\tpublic const string EformClientGuid = \"EformClientGuid\";\n\t\t\tpublic const string EmailFolderNotificationWaitTime = \"EmailFolderNotificationWaitTime\";\n\t\t\tpublic const string EmailSmtpServer = \"EmailSmtpServer\";\n\t\t\tpublic const string Environment = \"Environment\";\n\t\t\tpublic const string EnvironmentType = \"EnvironmentType\";\n\t\t\tpublic const string EnableRestTestClient = \"EnableRestTestClient\";\n\t\t\tpublic const string ErrorRetryMinutes = \"ErrorRetryMinutes\";\n\t\t\tpublic const string ErrorSleepMillis = \"ErrorSleepMillis\";\n\t\t\tpublic const string EventDispatcherEventQueuePath = \"EventDispatcherEventQueuePath\";\n\t\t\tpublic const string ExportSearchTTLSeconds = \"ExportSearchTTLSeconds\";\n\t\t\tpublic const string FileAgeMinutes = \"fileAgeMinutes\";\n\t\t\tpublic const string FolderCacheTimeoutSeconds = \"FolderCacheTimeoutSeconds\";\n\t\t\tpublic const string ImageOperationExtensions = \"ImageOperationExtensions\";\n\t\t\tpublic const string DocxOperationExtensions = \"DocxOperationExtensions\";\n\t\t\tpublic const string ImagePreviewExtensions = \"ImagePreviewExtensions\";\n\t\t\tpublic const string VideoExtensions = \"VideoExtensions\";\n\t\t\tpublic const string ExcelFileMaxPagesToConvert = \"ExcelFileMaxPagesToConvert\";\n\t\t\tpublic const string IPRestrictionsSpringRegex = \"IPRestrictionsSpringRegex\";\n\t\t\tpublic const string OutboundIPWhitelistRegex = \"OutboundIPWhitelistRegex\";\n\t\t\tpublic const string OutboundIPBlacklistRegex = \"OutboundIPBlacklistRegex\";\n\t\t\tpublic const string OutboundHostDenylistRegex = \"OutboundHostDenylistRegex\";\n\t\t\tpublic const string OutbountHostWarnlistRegex = \"OutboundHostWarnlistRegex\";\n\t\t\tpublic const string PDFStandInExtensions = \"PDFStandInExtensions\";\n\t\t\tpublic const string PdfOperationsConcatUseTempFile = \"PdfOperationsConcatUseTempFile\";\n\t\t\tpublic const string LWDPManipulationReservationSeconds = \"LWDPManipulationReservationSeconds\";\n\t\t\tpublic const string ImageWrapperGenerationQuality = \"ImageWrapperGenerationQuality\";\n\t\t\tpublic const string InboundEmailDomain = \"InboundEmailDomain\";\n\t\t\tpublic const string InterfaxOutboundPassword = \"InterfaxOutboundPassword\";\n\t\t\tpublic const string InterfaxOutboundUser = \"InterfaxOutboundUser\";\n\t\t\tpublic const string InterfaxInboundPassword = \"InterfaxInboundPassword\";\n\t\t\tpublic const string InterfaxInboundUser = \"InterfaxInboundUser\";\n\t\t\tpublic const string InvalidSalesforceCredentialEmailMaxFrequencySeconds = \"InvalidSalesforceCredentialEmailMaxFrequencySeconds\";\n\t\t\tpublic const string IsEchoSignEnabled = \"IsEchoSignEnabled\";\n\t\t\tpublic const string IsDocuSignEnabled = \"IsDocuSignEnabled\";\n\t\t\tpublic const string IsESignLiveEnabled = \"IsESignLiveEnabled\";\n\t\t\tpublic const string IsProntoSignEnabled = \"IsProntoSignEnabled\";\n\t\t\tpublic const string EchoSignCallbackUrlEnabled = \"EchoSignCallbackUrlEnabled\";\n\t\t\tpublic const string DocuSignCallbackUrlEnabled = \"DocuSignCallbackUrlEnabled\";\n\t\t\tpublic const string ESignLiveCallbackUrlEnabled = \"ESignLiveCallbackUrlEnabled\";\n\t\t\tpublic const string ProntoSignCallbackUrlEnabled = \"ProntoSignCallbackUrlEnabled\";\n\t\t\tpublic const string RegisterExternalReviewTokenWithAccountServer = \"RegisterExternalReviewTokenWithAccountServer\";\n\t\t\tpublic const string ExternalReviewApiBaseUrlFormat = \"ExternalReviewApiBaseUrlFormat\";\n\n\t\t\tpublic const string ShowServerStatus = \"showServerStatus\";\n\t\t\tpublic const string LogAllEvenIfCounted = \"LogAllEvenIfCounted\";\n\t\t\tpublic const string LogoPath = \"LogoPath\";\n\t\t\tpublic const string LongPollInterval = \"longPollInterval\";\n\t\t\tpublic const string LWDPThumbnailWidth = \"LWDPThumbnailWidth\";\n\t\t\tpublic const string MaxRetries = \"MaxRetries\";\n\t\t\tpublic const string MailFrom = \"mailFrom\";\n\t\t\tpublic const string MailFrom_Alternate = \"mailFrom_Alternate\";\n\t\t\tpublic const string MailFrom_OneNotification = \"MailFrom_OneNotification\";\n\t\t\tpublic const string MarketingUrlPrefix = \"MarketingUrl_\";\n\t\t\tpublic const string MarketoApiPrivateKey = \"MarketoApiPrivateKey\";\n\t\t\tpublic const string MaxBrowseDocumentBreadCrumbSize = \"maxBrowseDocumentBreadCrumbSize\";\n\t\t\tpublic const string MaxChunkUploadChunkSize = \"MaxChunkUploadChunkSize\";\n\t\t\tpublic const string MaximumAttachmentSize = \"maximumAttachmentSize\";\n\t\t\tpublic const string MaximumEmailSizeInBytes = \"maximumEmailSizeInBytes\";\n\t\t\tpublic const string UseBase64TotalEmailSize = \"useBase64TotalEmailSize\";\n\t\t\tpublic const string MaximumPaidFileSize = \"maximumPaidFileSize\";\n\t\t\tpublic const string MaximumTrialFileSize = \"maximumTrialFileSize\";\n\t\t\tpublic const string MaxDocumentsWhenAutoExpandingFolders = \"MaxDocumentsWhenAutoExpandingFolders\";\n\t\t\tpublic const string MaxloginAttempts = \"MaxloginAttempts\";\n\t\t\tpublic const string MaxSessionTimeoutMinutes = \"MaxSessionTimeoutMinutes\";\n\t\t\tpublic const string MaxUploadFailures = \"MaxUploadFailures\";\n\t\t\tpublic const string MergedDocumentViewMaxWaitMinutes = \"MergedDocumentViewMaxWaitMinutes\";\n\t\t\tpublic const string MergedDocumentViewRefreshSeconds = \"MergedDocumentViewRefreshSeconds\";\n\t\t\tpublic const string MobileUrlRoot = \"MobileUrlRoot\";\n\t\t\tpublic const string NotificationRefreshIntervalMs = \"NotificationRefreshIntervalMs\";\n\t\t\tpublic const string NDREmailBlockListLifespanInSeconds = \"NDREmailBlockListLifespanInSeconds\";\n\t\t\tpublic const string ProfileMQPathFormat = \"ProfileMQPathFormat\";\n\t\t\tpublic const string ProfileMQWorkers = \"ProfileMQWorkers\";\n\t\t\tpublic const string RestContentAllowDownload = \"RestContentAllowDownload\";\n\t\t\tpublic const string RestContentAllowUpload = \"RestContentAllowUpload\";\n\t\t\tpublic const string SFDCRowLimitForUserSync = \"SFDCRowLimitForUserSync\";\n\t\t\tpublic const string SiteTimeZoneId = \"SiteTimeZoneId\";\n\t\t\tpublic const string TabletDocumentUrlFormat = \"TabletDocumentUrlFormat\";\n\t\t\tpublic const string TabletFolderUrlFormat = \"TabletFolderUrlFormat\";\n\t\t\tpublic const string TabletHomeUrl = \"TabletHomeUrl\";\n\t\t\tpublic const string TabletLoginUrlFormat = \"TabletLoginUrlFormat\";\n\t\t\tpublic const string TabletSupportedUserAgentsRegex = \"TabletSupportedUserAgentsRegex\";\n\t\t\t/* MQ Settings */\n\t\t\tpublic const string MQAdminQueuePath = \"MQAdminQueuePath\";\n\t\t\tpublic const string MQReachQueueTimeout = \"MQReachQueueTimeout\";\n\t\t\tpublic const string MQReceiveTimeout = \"MQReceiveTimeout\";\n\t\t\tpublic const string MQReceiveWaitMS = \"MQReceiveWaitMS\";\n\t\t\tpublic const string MQResponseQueuePath = \"MQResponseQueuePath\";\n\t\t\tpublic const string MQSerializationType = \"MQSerializationType\";        // used in ScmMQ\n\t\t\tpublic const string ProfileMQ = \"ProfileMQ\";\n\t\t\tpublic const string ProfileMQEvents = \"ProfileMQEvents\";\n\t\t\tpublic const string MQUseDeadLetterQueue = \"MQUseDeadLetterQueue\";\n\t\t\tpublic const string TaskAttemptThreshold = \"_AttemptThreshold\";\n\t\t\tpublic const string TaskMaxErrorCount = \"_MaxErrorCount\";\n\t\t\tpublic const string TaskNotifyOnLastTryOnly = \"_NotifyOnLastTryOnly\";\n\t\t\t/* MQ Tasks */\n\t\t\tpublic const string ExtractOcrContentPerPageMaxThreshold = \"ExtractOcrContentPerPageMaxThreshold\";\n\t\t\tpublic const string MetadataDeleteBatchSize = \"MetadataDeleteBatchSize\";\n\t\t\tpublic const string AtlasEtl_EventMQPath = \"AtlasEtl_EventMQPath\";\n\t\t\tpublic const string CopyFolderActivity_EventMQPath = \"CopyFolderActivity_EventMQPath\";\n\t\t\tpublic const string EmailFailed_EventProcessorAQN = \"EmailFailed_EventProcessorAQN\";\n\t\t\tpublic const string ExecuteReportTask_AttemptThreshold = \"ExecuteReportTask_AttemptThreshold\";\n\t\t\tpublic const string ExecuteReportTask_MaxErrorCount = \"ExecuteReportTask_MaxErrorCount\";\n\t\t\tpublic const string LoadObjectsForReindexTask_MaxErrorCount = \"LoadObjectsForReindexTask_MaxErrorCount\";\n\t\t\tpublic const string UserAccountRemoveReferencesProcessorAutoUpdateLock = \"UserAccountRemoveReferencesProcessorAutoUpdateLock\";\n\t\t\tpublic const string UserAccountRemoveReferencesProcessorEnableLocking = \"UserAccountRemoveReferencesProcessorEnableLocking\";\n\t\t\tpublic const string UserAccountRemoveReferencesProcessorReservationTimeoutSeconds = \"UserAccountRemoveReferencesProcessorReservationTimeoutSeconds\";\n\n\t\t\t/* login throttling */\n\t\t\tpublic const string ResetPasswordRateLimitWindowDurationSeconds = \"ResetPasswordRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string ResetPasswordLimitWindowAllowedRequests = \"ResetPasswordLimitWindowAllowedRequests\";\n\t\t\tpublic const string TwoFactorRateLimitWindowDurationSeconds = \"TwoFactorRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string TwoFactorRateLimitAllowedRequests = \"TwoFactorRateLimitAllowedRequests\";\n\t\t\tpublic const string LoginReminderRateLimitWindowDurationSeconds = \"LoginRemidnerRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string LoginReminderLimitWindowAllowedRequests = \"LoginReminderLimitWindowAllowedRequests\";\n\n\t\t\t/* user email throttling */\n\t\t\tpublic const string EmailSendRateLimitWindowDurationSeconds = \"EmailSendRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string EmailSendRateLimitWindowAllowedRequests = \"EmailSendRateLimitWindowAllowedRequests\";\n\n\t\t\t/* Word Merge Settings */\n\t\t\tpublic const string MergeTempDir = \"MergeTempDir\";\n\t\t\tpublic const string CreateMergeTemplateHelpUrl = \"CreateMergeTemplateHelpUrl\";\n\n\t\t\tpublic const string NativeFaxableExtensions = \"NativeFaxableExtensions\";\n\t\t\tpublic const string OCRExtractorExtensions = \"OCRExtractorExtensions\";\n\t\t\tpublic const string TessnetOCRExtensions = \"TessnetOCRExtensions\";\n\t\t\tpublic const string PassiveEndPort = \"PassiveEndPort\";\n\t\t\tpublic const string PassiveStartPort = \"PassiveStartPort\";\n\t\t\tpublic const string PassiveTimeout = \"PassiveTimeout\";\n\t\t\tpublic const string PdfConversionMaxNativeFileSize = \"PdfConversionMaxNativeFileSize\";\n\t\t\tpublic const string PdfManipulationPassiveMode = \"PdfManipulationPassiveMode\";\n\t\t\tpublic const string PdfManipulationTempMergeLocation = \"PdfManipulationTempMergeLocation\";\n\t\t\tpublic const string PasteTaskResultTempStorage = \"PasteTaskResultTempStorage\";\n\t\t\tpublic const string PollInterval = \"pollInterval\";\n\t\t\tpublic const string PreviewImageBaseDpi = \"PreviewImageBaseDpi\";\n\t\t\tpublic const string PreviewOutputFormat = \"PreviewOutputFormat\";\n\t\t\tpublic const string PreviewReloadMaxTries = \"PreviewReloadMaxTries\";\n\t\t\tpublic const string PreviewReloadTimeout = \"PreviewReloadTimeout\";\n\t\t\tpublic const string PageCountOnDemandTimeoutMilliseconds = \"PageCountOnDemandTimeoutMilliseconds\";\n\t\t\tpublic const string Profile = \"profile\";\n\t\t\tpublic const string ProcessTimeoutMinutes = \"ProcessTimeoutMinutes\";\n\t\t\tpublic const string ProfileInsertCommandTimeout = \"ProfileInsertCommandTimeout\";\n\t\t\tpublic const string RemotePdfServiceMaxRows = \"RemotePdfServiceMaxRows\";\n\t\t\tpublic const string RemotePdfServiceNoWorkSleepInSeconds = \"RemotePdfServiceNoWorkSleepInSeconds\";\n\t\t\tpublic const string RemotePdfServiceNoAvaibleThreadsSleepInMilliSeconds = \"RemotePdfServiceNoAvaibleThreadsSleepInMilliSeconds\";\n\t\t\tpublic const string RemotePdfServiceNoAvaibleMemorySleepInMilliSeconds = \"RemotePdfServiceNoAvaibleMemorySleepInMilliSeconds\";\n\t\t\tpublic const string RemotePdfServiceMaxRuntimeFileSizeAllowed = \"RemotePdfServiceMaxRuntimeFileSizeAllowed\";\n\t\t\tpublic const string RemotePdfServicePdfSaveLocation = \"RemotePdfServicePdfSaveLocation\";\n\t\t\tpublic const string RemotePdfServicePdfTouchCount = \"RemotePdfServicePdfTouchCount\";\n\t\t\tpublic const string RemotePdfServiceThumbnailWidth = \"RemotePdfServiceThumbnailWidth\";\n\t\t\tpublic const string RegularOCREnabled = \"RegularOCREnabled\";\n\t\t\tpublic const string RelayEmail = \"RelayEmail\";\n\t\t\tpublic const string EmailPayloadSharedStorageTTLSeconds = \"EmailPayloadSharedStorageTTLSeconds\";\n\t\t\tpublic const string SaveEmailPayloadToSharedStorage = \"SaveEmailPayloadToSharedStorage\";\n\t\t\tpublic const string ReportExportDownloadDelayMs = \"ReportExportDownloadDelayMs\";\n\t\t\tpublic const string ReportingServicesCacheTimeout = \"ReportingServicesCacheTimeout\";\n\t\t\tpublic const string ReportingServicesUrl = \"ReportingServicesUrl\";\n\t\t\tpublic const string ReportingServicesExecutionUrl = \"ReportingServicesExecutionUrl\";\n\t\t\tpublic const string ReportingServicesExecutionTimeout = \"ReportingServicesExecutionTimeout\";\n\t\t\tpublic const string ReportingServicesViewerUrl = \"ReportingServicesViewerUrl\";\n\t\t\tpublic const string ReportingServicesBaseModelPath = \"ReportingServicesBaseModelPath\";\n\t\t\tpublic const string ReportingServicesMaxSet = \"ReportingServicesMaxSet\";\n\t\t\tpublic const string ReportingServicesQueryTimeout = \"ReportingServicesQueryTimeout\";\n\t\t\tpublic const string ReportingServicesScheduleID = \"ReportingServicesScheduleID\";\n\t\t\tpublic const string ResourceUrlRoot = \"ResourceUrlRoot\";\n\t\t\tpublic const string StaticResourceUrlFormat = \"StaticResourceUrlFormat\";\n\t\t\tpublic const string UseDeployedStaticResources = \"UseDeployedStaticResources\";\n\t\t\tpublic const string UseWebApplicationRootOverride = \"UseWebApplicationRootOverride\";\n\t\t\tpublic const string WebApplicationRootOverride = \"WebApplicationRootOverride\";\n\t\t\tpublic const string WebApplicationRedirectOverride = \"WebApplicationRedirectOverride\";\n\t\t\tpublic const string UseCookiePathOverride = \"UseCookiePathOverride\";\n\t\t\tpublic const string WebCookiePathOverride = \"WebCookiePathOverride\";\n\t\t\tpublic const string NonRelayDomainsRegex = \"NonRelayDomainsRegex\";\n\t\t\tpublic const string SplitEmailAddressRegex = \"SplitEmailAddressRegex\";\n\t\t\tpublic const string SplitDocumentTempLocation = \"SplitDocumentTempLocation\";\n\t\t\tpublic const string SearchStopWords = \"SearchStopWords\";\n\t\t\tpublic const string SearchQueryDefaultPageSize = \"SearchQueryDefaultPageSize\";\n\t\t\tpublic const string ShowLegacyReports = \"ShowLegacyReports\";\n\t\t\t//public const string Site = \"Site\"; //Using this with Configuration.GetStringAppSetting would return the full site name, instead use ApplicationSettings.Site for the correct short site name\n\t\t\tpublic const string SnippetsHighlightFormat = \"SnippetsHighlightFormat\";\n\t\t\tpublic const string SFBatchSize = \"SFBatchSize\";\n\t\t\tpublic const string SForceMetadataGroup = \"SForceMetadataGroup\";\n\t\t\tpublic const string SFAccountMetaDataField = \"SFAccountMetaDataField\";\n\t\t\tpublic const string SFChildIdMetadataField = \"SFChildIdMetadataField\";\n\t\t\tpublic const string SFClientId = \"SFClientId\";\n\t\t\tpublic const string SFProdApiUrl = \"SFProdApiUrl\";\n\t\t\tpublic const string SFApiUrlFormat = \"SFApiUrlFormat\";\n\t\t\tpublic const string SFAPIVersion = \"SFAPIVersion\";\n\t\t\tpublic const string SalesforceBatchSize = \"SalesforceBatchSize\";\n\t\t\tpublic const string SalesforceInstanceURITerminationString = \"SalesforceInstanceURITerminationString\";\n\t\t\tpublic const string SFIntegrationClientId = \"SFIntegrationClientId\";\n\t\t\tpublic const string SFIntegrationTokenRedirectUrlFormat = \"SFIntegrationTokenRedirectUrlFormat\";\n\t\t\tpublic const string SFManagedPackageIntegrationTokenRedirectUrlFormat = \"SFManagedPackageIntegrationTokenRedirectUrlFormat\";\n\t\t\tpublic const string SFDisplayForRefreshTokens = \"SFDisplayForRefreshTokens\";\n\t\t\tpublic const string SalesforceFileItPackageUrl = \"SalesforceFileItPackageUrl\";\n\t\t\tpublic const string SpringCMSalesforceConfigUrlPath = \"SpringCMSalesforceConfigUrlPath\";\n\t\t\tpublic const string SalesforceSpringCMConfigUrlPath = \"SalesforceSpringCMConfigUrlPath\";\n\t\t\tpublic const string SalesforceCLMConfigUrlPath = \"SalesforceCLMConfigUrlPath\";\n\t\t\tpublic const string SalesforceCLMGenTemplatesUrlPath = \"SalesforceCLMGenTemplatesUrlPath\";\n\t\t\tpublic const string SpringCMSalesforceViewerUrlPath = \"SpringCMSalesforceViewerUrlPath\";\n\t\t\tpublic const string FederatedSearchSalesforceViewerUrlPath = \"FederatedSearchSalesforceViewerUrlPath\";\n\t\t\tpublic const string SyncUseReportDb = \"SyncUseReportDb\";\n\t\t\tpublic const string SyncReportDbLatencySec = \"SyncReportDbLatencySec\";\n\t\t\tpublic const string SyncManifestTimeDriftSec = \"SyncManifestTimeDriftSec\";\n\t\t\tpublic const string SFFileItDevSecret = \"SFFileItDevSecret\";\n\t\t\tpublic const string SFFileItSecret = \"SFFileItSecret\";\n\t\t\tpublic const string SFOAuthRequestTokenURLFormat = \"SFOAuthRequestTokenURLFormat\";\n\t\t\tpublic const string SFRestAPIVersion = \"SFRestAPIVersion\";\n\t\t\tpublic const string SFOauthRedirectUrl = \"SFOauthRedirectUrl\";\n\t\t\tpublic const string GenSFOauthRedirectUrl = \"GenSFOauthRedirectUrl\";\n\t\t\tpublic const string SFFileItNamespace = \"SFFileItNamespace\";\n\t\t\tpublic const string SFPackageCNamespace = \"SFPackageCNamespace\";\n\t\t\tpublic const string SFDevFileItNamespace = \"SFDevFileItNamespace\";\n\t\t\tpublic const string SFFileItUrl = \"SFFileItUrl\";\n\t\t\tpublic const string SFFileItInstructions = \"SFFileItInstructions\";\n\t\t\tpublic const string SFCLMPackageInstructions = \"SFCLMPackageInstructions\";\n\t\t\tpublic const string SFDomains = \"SFDomains\";\n\t\t\tpublic const string SFValidateUrl = \"SFValidateUrl\";\n\n\n\t\t\tpublic const string ObsoleteCustomCustomReports = \"ObsoleteCustomCustomReports\";\n\n\t\t\tpublic const string InterFaxRequiresEndChunkEveryFile = \"InterFaxRequiresEndChunkEveryFile\";\n\t\t\tpublic const string InterFaxChunkUploadSize = \"InterFaxChunkUploadSize\";\n\t\t\tpublic const string InterFaxRetryCount = \"InterFaxRetryCount\";\n\n\t\t\tpublic const string MaxMemoryStreamSizeInBytes = \"MaxMemoryStreamSizeInBytes\";\n\t\t\tpublic const string StoreEnqueuedMergeTaskStringDataSourceInTempStorage = \"StoreEnqueuedMergeTaskStringDataSourceInTempStorage\";\n\t\t\tpublic const string MergeTaskDataSourceMaxLength = \"MergeTaskDataSourceMaxLength\";\n\t\t\tpublic const string SFAuthCacheTTLInSeconds = \"SFAuthCacheTTLInSeconds\";\n\n\t\t\t//For SAML SSO\n\t\t\tpublic const string SAMLAuthContexts = \"SAMLAuthContexts\";\n\t\t\tpublic const string SAMLEntityId = \"SAMLEntityId\";\n\t\t\tpublic const string SAMLOrgName = \"SAMLOrgName\";\n\t\t\tpublic const string SAMLLang = \"SAMLLang\";\n\t\t\tpublic const string SSOSignVerifyCert = \"SAMLSignVerifyCert\";\n\t\t\tpublic const string SSOSigningCert = \"SAMLSigningCert\";\n\t\t\tpublic const string SSOSigningCertPWD = \"SAMLSigningCertPWD\";\n\t\t\tpublic const string AuthenticationApplicationVerifyCert = \"AuthenticationApplicationVerifyCert\";\n\t\t\tpublic const string AuthenticationApplicationSigningCert = \"AuthenticationApplicationSigningCert\";\n\t\t\tpublic const string AuthenticationApplicationSigningCertPassword = \"AuthenticationApplicationSigningCertPassword\";\n\t\t\tpublic const string SAMLPublishedSpringPublicCertificate = \"SAMLPublishedSpringPublicCertificate\";\n\t\t\tpublic const string SAMLMetadataUrl = \"SAMLMetadataUrl\";\n\t\t\tpublic const string SamlEndointDomain = \"SamlEndointDomain\";\n\t\t\tpublic const string SfIssuerDomains = \"SfIssuerDomains\";\n\t\t\tpublic const string OktaIssuerDomains = \"OktaIssuerDomains\";\n\t\t\tpublic const string OneLoginIssuerDomains = \"OneLoginIssuerDomains\";\n\t\t\tpublic const string CustomSAMLNameIdentifier = \"CustomSAMLNameIdentifier\";\n\n\t\t\t/// <summary>\n\t\t\t/// For salesforce even though it doesn't allow for www.salesforce.com you\n\t\t\t/// can use na1.salesforce.com and it will redirect you on login to the correct\n\t\t\t/// subdomain.  If this ever breaks then it can no longer be an application setting\n\t\t\t/// </summary>\n\t\t\tpublic const string AppExchangeSpringCMUrl = \"AppExchangeSpringCMUrl\";\n\t\t\tpublic const string SFDocTabUrl = \"SFDocTabUrl\";\n\t\t\tpublic const string SFPackageUrl = \"SFPackageUrl\";\n\t\t\tpublic const string SFServiceUrl = \"SFServiceURL\";\n\t\t\tpublic const string SftpListenPort = \"SftpListenPort\";\n\t\t\tpublic const string DisposeSSHServer = \"DisposeSSHServer\";\n\t\t\tpublic const string DisposeSSHServerOnFinalize = \"DisposeSSHServerOnFinalize\";\n\t\t\tpublic const string SignUpPageURL = \"SignUpPageURL\";\n\t\t\tpublic const string SingleObjectCacheLifetimeSeconds = \"SingleObjectCacheLifetimeSeconds\";\n\t\t\tpublic const string SingleObjectCacheObjectLifetimeSeconds = \"SingleObjectCacheObjectLifetimeSeconds\";\n\t\t\tpublic const string SleepLong = \"SleepLong\";\n\t\t\tpublic const string SleepSeconds = \"sleepSeconds\";\n\t\t\tpublic const string SleepShort = \"SleepShort\";\n\t\t\tpublic const string SleepStandard = \"SleepStandard\";\n\t\t\tpublic const string SMTPServer = \"SMTPServer\";\n\t\t\tpublic const string SMTPServer_Alternate = \"SMTPServer_Alternate\";\n\t\t\tpublic const string SmtpServerPort = \"SmtpServerPort\";\n\t\t\tpublic const string SmtpServerPort_Alternate = \"SmtpServerPort_Alternate\";\n\t\t\tpublic const string SMTPListenPort = \"SmtpListenPort\";\n\t\t\tpublic const string SupportUrlPrefix = \"SupportUrl_\";\n\t\t\tpublic const string TemplateSourceDirectory = \"templateSourceDirectory\";\n\t\t\tpublic const string ThreadCount = \"ThreadCount\";\n\t\t\tpublic const string SFSetUpIntegrationUserRedirectUrl = \"SFSetUpIntegrationUserRedirectUrl\";\n\t\t\tpublic const string CLMSalesforcePackageUrl = \"CLMSalesforcePackageUrl\";\n\n\t\t\tpublic const string SSOIssueTimeout = \"SSOIssueTimeout\";\n\t\t\tpublic const string SSOBeforeOnOrAfterFuzzyMin = \"SSOBeforeOnOrAfterFuzzyMin\";\n\t\t\tpublic const string SSOCertificateFileName = \"SSOCertificateFileName\";\n\n\t\t\tpublic const string FolderPortalHelpUrl = \"FolderPortalHelpUrl\";\n\n\t\t\t// Feature Toggles\n\t\t\tpublic const string Toggle_DocumentReminderTemplates = \"Toggle_DocumentReminderTemplates\";\n\t\t\tpublic const string HideAlphaLanguageSettings = \"HideAlphaLanguageSettings\";\n\n\t\t\t// Number of thumbnails to get on the edit doc page per \"gulp\"\n\t\t\tpublic const string ThumbnailsPerPage = \"ThumbnailsPerPage\";\n\t\t\tpublic const int ThumbnailsPerPageDefault = 20;\n\t\t\tpublic const string TileViewPreviewRetryIntervals = \"TileViewPreviewRetryIntervals\";\n\n\n\t\t\tpublic const string UploadRootUrl = \"UploadRootUrl\";\n\t\t\tpublic const string FastUploadRootUrl = \"FastUploadRootUrl\";\n\t\t\t/* URLs in SpringCM Settings */\n\t\t\tpublic const string UrlMimeTypes = \"UrlMimeTypes\";\n\t\t\tpublic const string UrlAllowedProtocols = \"UrlAllowedProtocols\";\n\n\t\t\tpublic const string TotalSecondsWarning = \"totalSecondsWarning\";\n\t\t\tpublic const string TrashOldNumDays = \"TrashOldNumDays\";\n\t\t\tpublic const string TrialPeriod = \"TrialPeriod\";\n\t\t\tpublic const string UnlockUsersIntervalInMinutes = \"UnlockUsersIntervalInMinutes\";\n\t\t\tpublic const string UpgradeCallMeEmail = \"UpgradeCallMeEmail\";\n\t\t\tpublic const string UploadServiceNamespace = \"UploadServiceNamespace\";\n\t\t\tpublic const string UserSyncAddressBookTempStorage = \"UserSyncAddressBookTempStorage\";\n\t\t\tpublic const string UseABCpdfExtraChecks = \"UseABCpdfExtraChecks\";\n\t\t\tpublic const string ViewableFileExtensions = \"ViewableFileExtensions\";\n\t\t\tpublic const string VerifyUserExpirationIntervalDays = \"VerifyUserExpirationIntervalDays\";\n\t\t\tpublic const string ValidateEmailsBeforeSending = \"ValidateEmailsBeforeSending\";\n\n\t\t\tpublic const string PartySyncTempStorage = \"PartySyncTempStorage\";\n\t\t\tpublic const string MergeTaskTempStorage = \"MergeTaskTempStorage\";\n\t\t\tpublic const string TranslationImportTempStorage = \"TranslationImportTempStorage\";\n\t\t\tpublic const string WorkflowTaskTempStorage = \"WorkflowTaskTempStorage\";\n\n\t\t\tpublic const string WebServiceChunkSize = \"WebServiceChunkSize\";\n\t\t\tpublic const string WebServicesPathElement = \"WebServicesPathElement\";\n\t\t\tpublic const string WebServicesApiUrlFormat = \"WebServicesApiUrlFormat\";\n\t\t\tpublic const string WebServicesRestUrlFormat = \"WebServicesRestUrlFormat\";\n\t\t\tpublic const string WebServicesSyncUrlFormat = \"WebServicesSyncUrlFormat\";\n\t\t\tpublic const string WebServicesSoapUrlFormat = \"WebServicesSoapUrlFormat\";\n\t\t\tpublic const string WebServicesRestDownloadUrlFormat = \"WebServicesRestDownloadUrlFormat\";\n\t\t\tpublic const string WebServicesRestUploadUrlFormat = \"WebServicesRestUploadUrlFormat\";\n\t\t\tpublic const string WorkDirectory = \"workDirectory\";\n\n\t\t\tpublic const string WebServiceMaxObjectArrayLength = \"WebServiceMaxObjectArrayLength\";\n\n\t\t\tpublic const string WorkflowAnalyticsConfigCacheTtlSecs = \"WorkflowAnalyticsConfigCacheTtlSecs\";\n\n\t\t\tpublic const string WorkflowNotificationSupportAddress = \"WorkflowNotificationSupportAddress\";\n\t\t\tpublic const string MonitorWorkflowMaxVariableNodeCount = \"MonitorWorkflowMaxVariableNodeCount\";\n\t\t\tpublic const string WinsErrorRetrySeconds = \"WinsErrorRetrySeconds\";\n\t\t\tpublic const string WinsLockExpirationSeconds = \"WinsLockExpirationSeconds\";\n\t\t\tpublic const string WinsPurgeWorkerReservationSeconds = \"WinsPurgeWorkerReservationSeconds\";\n\t\t\tpublic const string WinsRemoteCallTimeoutMilliseconds = \"WinsRemoteCallTimeoutMilliseconds\";\n\t\t\tpublic const string WinsRemoteCallRetryDelayMilliseconds = \"WinsRemoteCallRetryDelayMilliseconds\";\n\t\t\tpublic const string WinsWaitForIdleTimeoutSeconds = \"WinsWaitForIdleTimeoutSeconds\";\n\t\t\tpublic const string WinsServiceUrl = \"WinsServiceUrl\";\n\t\t\tpublic const string WinsSlowServiceUrl = \"WinsSlowServiceUrl\";\n\t\t\tpublic const string ExplicitWinsUrlFormat = \"ExplicitWinsUrlFormat\";\n\t\t\tpublic const string EnableWorkflowSettingsCache = \"EnableWorkflowSettingsCache\";\n\t\t\tpublic const string WorkflowSettingsCacheTTLSeconds = \"WorkflowSettingsCacheTTLSeconds\";\n\n\t\t\tpublic const string EssentialsPlanDefaultWINSDatabaseConnectionString =\n\t\t\t\t\"EssentialsPlanDefaultWINSDatabaseConnectionString\";\n\n\t\t\tpublic const string EssentialsPlanDefaultRemoteWinsUrl = \"EssentialsPlanDefaultRemoteWinsUrl\";\n\n\t\t\tpublic const string ACEResourceUrlPattern = \"ACEResourceUrlPattern\";\n\n\t\t\tpublic const string VideoMaxWidth = \"VideoMaxWidth\";\n\t\t\tpublic const string VideoMaxHeight = \"VideoMaxHeight\";\n\n\t\t\t// It is expected each machine to have a local space for temporary storage.\n\t\t\t// It is expected to be the same across all machines (t:\\temp).\n\t\t\t// If not configured, the environment's TEMP location will be used.\n\t\t\tpublic const string MachineTempPath = \"MachineTempPath\";\n\n\t\t\tpublic const string GhostScriptTimeout = \"GhostScriptTimeout\";\n\t\t\tpublic const string GoogleTagManagerId = \"GoogleTagManagerId\";\n\n\t\t\t//Redis strings\n\t\t\tpublic const string RedisConnectionString = \"RedisConnectionString\";\n\t\t\tpublic const string RedisDbNum = \"RedisDbNum\";\n\t\t\tpublic const string RedisPhaseDurationThreshold = \"RedisPhaseDurationThreshold\";\n\n\t\t\tpublic const string DocuSignApiKey = \"DocuSignApiKey\";\n\t\t\tpublic const string DocuSignRestLoginUrl = \"DocuSignRestLoginUrl\";\n\t\t\tpublic const string DocuSignRestApiAccountsUrlFormat = \"DocuSignRestApiAccountsUrlFormat\";\n\t\t\tpublic const string DocuSignRestApiAccountsUrlFormatForProviderDocuments = \"DocuSignRestApiAccountsUrlFormatForProviderDocuments\";\n\n\t\t\tpublic const string DocuSignDeveloperUrl = \"DocuSignDeveloperUrl\";\n\t\t\tpublic const string DocuSignRestBaseUrl = \"DocuSignRestBaseUrl\";\n\n\t\t\tpublic const string ESignLivRestApiUrl = \"ESignLivRestApiUrl\";\n\t\t\tpublic const string ElectronicSignatureDocuSignEndpoints = \"ElectronicSignatureDocuSignEndpoints\";\n\t\t\tpublic const string ElectronicSignatureESignLiveEndpoints = \"ElectronicSignatureESignLiveEndpoints\";\n\t\t\tpublic const string AdobeSignRestApiUrl = \"AdobeSignRestApiUrl\";\n\t\t\tpublic const string ElectronicSignatureBulkRefreshProviders = \"ElectronicSignatureBulkRefreshProviders\";\n\n\t\t\t//REST API\n\t\t\tpublic const string RestApiBaseUrl = \"RestApiBaseUrl\";\n\t\t\tpublic const string RefreshTokenExpirationDays = \"RefreshTokenExpirationDays\";\n\t\t\tpublic const string RestApiPageSize = \"RestApiPageSize\";\n\t\t\tpublic const string RestApiMaxPageSize = \"RestApiMaxPageSize\";\n\t\t\tpublic const string IsWebApiTestingEnvironment = \"IsWebApiTestingEnvironment\";\n\t\t\tpublic const string RestApiErrorHandlingEnabled = \"RestApiErrorHandlingEnabled\";\n\t\t\tpublic const string ExcludeFromRateLimitClientIdsCacheDuration = \"ExcludeFromRateLimitClientIdsCacheDuration\";\n\t\t\tpublic const string RestApiLogRequests = \"RestApiLogRequests\";\n\t\t\tpublic const string EnableHttpResponseCompression = \"EnableHttpResponseCompression\";\n\t\t\tpublic const string RequestLoggingHandlerUrlContains = \"RequestLoggingHandlerUrlContains\";\n\t\t\tpublic const string ElectronicSignatureDocuSignRestApiVersion = \"ElectronicSignatureDocuSignRestApiVersion\";\n\n\t\t\tpublic const string ConcurrentRequestExpirationSeconds = \"ConcurrentRequestExpirationSeconds\";\n\n\t\t\tpublic const string SendUsingEmailRefactoring = \"SendUsingEmailRefactoring\";\n\n\t\t\tpublic const string SFUserSyncCacheTimeInSeconds = \"SFUserSyncCacheTimeInSeconds\";\n\t\t\tpublic const string SFUserSyncWorkerSleepSeconds = \"SFUserSyncWorkerSleepSeconds\";\n\t\t\tpublic const string SalesforceDowntimeStart = \"SalesforceDowntimeStart\";\n\t\t\tpublic const string SalesforceDowntimeEnd = \"SalesforceDowntimeEnd\";\n\n\t\t\tpublic const string WebApiErrorDetailPolicy = \"WebApiErrorDetailPolicy\";\n\n\t\t\tpublic const string InternalApiRootFormat = \"InternalApiRootFormat\";\n\t\t\tpublic const string EnableInternalApiSwagger = \"EnableInternalApiSwagger\";\n\t\t\tpublic const string InternalApiSwaggerScheme = \"InternalApiSwaggerScheme\";\n\t\t\tpublic const string EnableInternalApiRateLimit = \"EnableInternalApiRateLimit\";\n\t\t\tpublic const string InternalApiRateLimitWindowAllowedRequests = \"InternalApiRateLimitWindowAllowedRequests\";\n\t\t\tpublic const string InternalApiRateLimitWindowDurationSeconds = \"InternalApiRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string InternalApiRateLimitCounterSyncInterval = \"InternalApiRateLimitCounterSyncInterval\";\n\t\t\tpublic const string InternalApiAiCallbackMaxLength = \"InternalApiAiCallbackMaxLength\";\n\n\t\t\t//SOAP\n\t\t\tpublic const string SoapVersionEnabled = \"SoapVersionEnabled\";\n\n\t\t\t// Extract Service Extensions\n\t\t\tpublic const string WindowsExtractorExtensions = \"WindowsExtractorExtensions\";\n\t\t\tpublic const string PdfFallBackExtensions = \"PdfFallBackExtensions\";\n\t\t\tpublic const string ExtractFromPdfRenditionExtensions = \"ExtractFromPdfRenditionExtensions\";\n\n\t\t\t//External Fonts\n\t\t\tpublic const string ExternalFontUrl = \"ExternalFontUrl\";\n\n\t\t\t//Document Package Builder\n\t\t\tpublic const string DocumentLauncherStep1InstructionsMaxCharacters = \"DocumentLauncherStep1InstructionsMaxCharacters\";\n\t\t\tpublic const string DocumentLauncherStep2InstructionsMaxCharacters = \"DocumentLauncherStep2InstructionsMaxCharacters\";\n\t\t\tpublic const string DocumentLauncherSuccessMessageMaxCharacters = \"DocumentLauncherSuccessMessageMaxCharacters\";\n\t\t\tpublic const string DocumentLauncherDataMaxDataSizeInKB = \"DocumentLauncherDataMaxDataSizeInKB\";\n\t\t\tpublic const string DocumentLauncherConfigMetadataItemsPerPage = \"DocumentLauncherConfigMetadataItemsPerPage\";\n\t\t\tpublic const string LogInTextMaxCharacterLength = \"LogInTextMaxCharacterLength\";\n\n\t\t\t//Branding\n\t\t\tpublic const string BrandingPrimaryColor = \"BrandingPrimaryColor\";\n\t\t\tpublic const string BrandingSecondaryColor = \"BrandingSecondaryColor\";\n\t\t\tpublic const string BrandingPolarisPrimaryColor = \"BrandingPolarisPrimaryColor\";\n\t\t\tpublic const string BrandingPolarisSecondaryColor = \"BrandingPolarisSecondaryColor\";\n\n\t\t\t//Swift settings\n\t\t\tpublic const string SwiftAuthUrl = \"SwiftAuthUrl\";\n\t\t\tpublic const string Swift2AuthUrl = \"Swift2AuthUrl\";\n\t\t\tpublic const string SwiftTransientAuthUrl = \"SwiftTransientAuthUrl\";\n\t\t\tpublic const string SwiftSharedStorageTTLSeconds = \"SwiftSharedStorageTTLSeconds\";\n\t\t\tpublic const string EnableSwiftSharedStorageFallback = \"EnableSwiftSharedStorageFallback\";\n\n\t\t\t//Two Factor\n\t\t\tpublic const string TwoFactorBarcodeSize = \"TwoFactorBarcodeSize\";\n\t\t\tpublic const string TwoFactorTimeToleranceMinutes = \"TwoFactorTimeToleranceMinutes\";\n\t\t\tpublic const string TwoFactorAuthenticatorLinkAndroid = \"TwoFactorAuthenticatorLinkAndroid\";\n\t\t\tpublic const string TwoFactorAuthenticatorLinkIPhone = \"TwoFactorAuthenticatorLinkIPhone\";\n\t\t\tpublic const string TwoFactorAuthenticationGracePeriodDays = \"TwoFactorAuthenticationGracePeriodDays\";\n\t\t\tpublic const string TwoFactorIssuerFormat = \"TwoFactorIssuerFormat\";\n\t\t\tpublic const string FailedLogInAuthenticationSleepRandomLowerLimitMs = \"FailedLogInAuthenticationSleepRandomLowerLimitMs\";\n\t\t\tpublic const string FailedLogInAuthenticationSleepRandomUpperLimitMs = \"FailedLogInAuthenticationSleepRandomUpperLimitMs\";\n\n\t\t\t#region Office Web Apps\n\n\t\t\tpublic const string OfficeWebAppsDiscoveryUrl = \"OfficeWebAppsDiscoveryUrl\";\n\t\t\tpublic const string OfficeWebAppsApiRoot = \"OfficeWebAppsApiRoot\";\n\t\t\tpublic const string OfficeWebAppsClientGuid = \"OfficeWebAppsClientGuid\";\n\t\t\tpublic const string OfficeWebAppsConfigurationTTL = \"OfficeWebAppsConfigurationTTL\";\n\t\t\tpublic const string OfficeWebAppsSupportsWriteRelative = \"OfficeWebAppsSupportsWriteRelative\";\n\t\t\tpublic const string OfficeWebAppsInactiveDraftVersionMinutes = \"OfficeWebAppsInactiveDraftVersionMinutes\";\n\t\t\tpublic const string EnableOfficeWebAppsRequestLogging = \"EnableOfficeWebAppsRequestLogging\";\n\t\t\tpublic const string OfficeWebAppsDocumentReservationExpireSeconds = \"OfficeWebAppsDocumentReservationExpireSeconds\";\n\t\t\tpublic const string AllowUnsupportedBrowserClientIds = \"AllowUnsupportedBrowserClientIds\";\n\n\t\t\t#endregion\n\n\t\t\tpublic const string SpackageMaxDocumentsAddedCount = \"SpackageMaxDocumentsAddedCount\";\n\t\t\tpublic const string SpackageMaxDocumentsAddedBytes = \"SpackageMaxDocumentsAddedBytes\";\n\t\t\tpublic const string SpackageV2SigningKeyReferenceName = \"SpackageV2SigningKeyReferenceName\";\n\n\t\t\t//Allocation/Propagation\n\t\t\tpublic const string MasterSite = \"MasterSite\";\n\t\t\tpublic const string AllocationRootFormat = \"AllocationRootFormat\";\n\t\t\tpublic const string ManagedSites = \"ManagedSites\";\n\t\t\tpublic const string RequestTimeToleranceMinutes = \"RequestTimeToleranceMinutes\";\n\t\t\tpublic const string AuthenticationApplicationServedSites = \"AuthenticationApplicationServedSites\";\n\t\t\tpublic const string AuthenticationSites = \"AuthenticationSites\";\n\t\t\tpublic const string AuthenticationSite = \"AuthenticationSite\";\n\n\t\t\tpublic const string ProvisioningRootFormat = \"ProvisioningRootFormat\";\n\t\t\tpublic const string ProvisioningSiteByPlanIdFormat = \"ProvisioningSiteByPlanId_{0}\";\n\t\t\tpublic const string DeniedProvisioningSiteByModuleIdFormat = \"DeniedProvisioningSiteByModuleIdFormat_{0}\";\n\n\t\t\tpublic const string CrossDomainAntiforgeryTimeToleranceMinutes = \"CrossDomainAntiforgeryTimeToleranceMinutes\";\n\n\t\t\tpublic const string AuthContentSecurityPolicy = \"AuthContentSecurityPolicy\";\n\n\t\t\t// Walkthrough\n\t\t\tpublic const string Walkthrough_NewNavigation = \"Walkthrough_NewNavigation\";\n\n\t\t\tpublic const string DocxXmlMergeProcessor_MaxRecursionCount = \"DocxXmlMergeProcessor_MaxRecursionCount\";\n\t\t\tpublic const string EditDownloadTokenLength = \"EditDownloadTokenLength\";\n\t\t\tpublic const string EditDownloadTokenTTLSeconds = \"EditDownloadTokenTTLSeconds\";\n\n\t\t\t// DocuSign\n\t\t\tpublic const string DSProvisioningApiEndpoint = \"DSProvisioningApiEndpoint\";\n\t\t\tpublic const string DSProvisioningApiVersion = \"DSProvisioningApiVersion\";\n\t\t\tpublic const string DocuSignAccountServerProtocol = \"DocuSignAccountServerProtocol\";\n\t\t\tpublic const string DocuSignAccountServerDomain = \"DocuSignAccountServerDomain\";\n\t\t\tpublic const string EnableDSLogin = \"EnableDSLogin\";\n\t\t\tpublic const string SfDSSessionKeyExpirationSeconds = \"SfDSSessionKeyExpirationSeconds\";\n\t\t\tpublic const string DocusignMagnumPageSize = \"DocusignMagnumPageSize\";\n\t\t\tpublic const string SfAutoProvisionUser_QueryFieldName = \"SfAutoProvisionUser_QueryFieldName\";\n\t\t\tpublic const string EnableProvisioningAccountAsyncProcessing = \"EnableProvisioningAccountAsyncProcessing\";\n\t\t\tpublic const string DSOrganizationApiVersion = \"DSOrganizationApiVersion\";\n\n\t\t\t// NPS Survey\n\t\t\tpublic const string AllowNpsSurvey = \"AllowNpsSurvey\";\n\t\t\tpublic const string NpsSurveyLoadDelay = \"NpsSurveyLoadDelay\";\n\t\t\tpublic const string TimesToLoginBeforeNpsSurvey = \"TimesToLoginBeforeNpsSurvey\";\n\t\t\tpublic const string AllowTargetSamplingNpsSurvey = \"AllowTargetSamplingNpsSurvey\";\n\t\t\tpublic const string DaysToCheckForUniqueActionForNpsSurvey = \"DaysToCheckForUniqueActionForNpsSurvey\";\n\t\t\tpublic const string NpsSurveyToUse = \"NpsSurveyToUse\";\n\t\t\tpublic const string WootricSdkUrl = \"WootricSdkUrl\";\n\t\t\tpublic const string WootricNpsSurveyAppToken = \"WootricNpsSurveyAppToken\";\n\t\t\tpublic const string WootricEnvironmentProperty = \"WootricEnvironmentProperty\";\n\n\t\t\tpublic const string GenSfDocusignAccountCustomField = \"GenSfDocusignAccountCustomField\";\n\t\t\tpublic const string GenSfSetupDataCustomField = \"GenSfSetupDataCustomField\";\n\t\t\tpublic const string GenInviteCallbackRoute = \"GenInviteCallbackRoute\";\n\t\t\tpublic const string GenInviteEmailBody = \"GenInviteEmailBody\";\n\t\t\tpublic const string GenInviteEmailSubject = \"GenInviteEmailSubject\";\n\t\t\tpublic static string GenInviteRedirect = \"GenInviteRedirect\";\n\t\t\tpublic const string GetAccountRolesRoute = \"GetAccountRolesRoute\";\n\n\n\t\t\t// Docusign Urls\n\t\t\tpublic const string DocuSignAccountAdminRootUrl = \"DocuSignAccountAdminRootUrl\";\n\t\t\tpublic const string DocuSignAccountProvisioningUrl = \"DocuSignAccountProvisioningUrl\";\n\t\t\tpublic const string DocusignSyncRoute = \"DocusignSyncRoute\";\n\t\t\tpublic const string DocusignNdnsSyncRoute = \"DocusignNdnsSyncRoute\";\n\t\t\tpublic const string DocusignProfileNotificationSyncRoute = \"DocusignProfileNotificationSyncRoute\";\n\t\t\tpublic const string DocusignLoginPageUrl = \"DocusignLoginPageUrl\";\n\t\t\tpublic const string DocuSignNotificationApiBaseUrl = \"DocuSignNotificationApiBaseUrl\";\n\t\t\tpublic const string DocusignInternalApiCallbackUrl = \"DocusignInternalApiCallbackUrl\";\n\n\t\t\t//Javelin\n\t\t\tpublic const string JavelinBaseUrl = \"JavelinBaseUrl\";\n\n\t\t\t//AIRE\n\t\t\tpublic const string AIREApiBaseUrl = \"AIREApiBaseUrl\";\n\n\t\t\t//APR\n\t\t\tpublic const string APRBridgeApiRootUrl = \"APRBridgeApiRootUrl\";\n\t\t\tpublic const string EnableAPRHealthCheck = \"EnableAPRHealthCheck\";\n\t\t\tpublic const string MaxAllowedDocumentsInSingleBulkCreateTransaction = \"MaxAllowedDocumentsInSingleBulkCreateTransaction\";\n\n\t\t\t//MSF\n\t\t\tpublic const string MSFInternalBaseUrl = \"MSFInternalBaseUrl_{0}\";\n\t\t\tpublic const string MSFInternalRootUrl = \"MSFInternalRootUrl\";\n\t\t\tpublic const string MSFPublicApiBaseUrl = \"MSFPublicApiBaseUrl\";\n\n\t\t\t//VendorCallback\n\t\t\tpublic const string VendorCallBackEnableTracing = \"VendorCallBackEnableTracing\";\n\n\t\t\t// Workflow\n\t\t\tpublic const string ExpressionServiceEndpointUri = \"ExpressionServiceEndpointUri\";\n\t\t\tpublic const string WorkflowDesignApiEndpointUri = \"WorkflowDesignApiEndpointUri\";\n\t\t\tpublic const int WorkflowPurgeDaysOnSuccessDefault = 30;\n\t\t\tpublic const int WorkflowPurgeDaysOnFailureDefault = 30;\n\t\t\tpublic const string MaxWorkflowNextStepWaitTime = \"MaxWorkflowNextStepWaitTime\";\n\t\t\tpublic const bool AutomaticWorkflowAbortDefault = true;\n\t\t\tpublic const bool WaitForNextStepAfterCompletionDefault = false;\n\t\t\tpublic const bool EnablePurgeOnScopeDefault = false;\n\t\t\tpublic const bool EnableWorkflowSettingsCacheDefault = true;\n\t\t\tpublic const long WorkflowSettingsCacheTTLSecondsDefault = 600;\n\t\t\tpublic const string EnableMonitorActivityCountChanges = \"EnableMonitorActivityCountChanges\";\n\t\t\tpublic const string NextWorkItemPollingIntervalInMilliSeconds = \"NextWorkItemPollingIntervalInMilliSeconds\";\n\t\t\tpublic const string WorkflowRevisionsBatchProcessingSize = \"WorkflowRevisionsBatchProcessingSize\";\n\t\t\tpublic const string EnableWorkflowRmqEventSubscribers = \"EnableWorkflowRmqEventSubscribers\";\n\t\t\tpublic const bool EnableWorkflowLimitNotificationsDefault = true;\n\n\t\t\t// BulkJob\n\t\t\tpublic const string EnableBulkJobWorkflows = \"EnableBulkJobWorkflows\";\n\t\t\tpublic const string BulkJobApiUri = \"BulkJobApiUri\";\n\t\t\tpublic const string BulkJobUseQuorumQueues = \"BulkJobUseQuorumQueues\";\n\t\t\tpublic const string BulkJobExchangeType = \"BulkJobExchangeType\";\n\t\t\tpublic const string BulkJobItemDoneQueue = \"BulkJobItemDoneQueue\";\n\t\t\tpublic const string BulkJobVirtualHost = \"BulkJobVirtualHost\";\n\n\t\t\t// Analytics\n\t\t\tpublic const string EnableMixpanel = \"EnableMixpanel\";\n\t\t\tpublic const string MixpanelToken = \"MixpanelToken\";\n\t\t\tpublic const string AnalyticsSecret = \"analyticssecret\";\n\n\t\t\t// Agreement Analyzer\n\t\t\tpublic const string CachedAnalysisProcessingStatus_Key = \"Agreement_Analysis:Extractions_Processing_Status:{0}:{1}\";  //Agreement_Analysis:Extractions_Processing_Status:{accountId}:{docFileDataUid}\n\t\t\tpublic const long CachedAnalysisProcessingStatus_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedAnalysisScorecardProcessingStatus_Key = \"Agreement_Analysis:Scorecard_Processing_Status:{0}:{1}:{2}\";  //Agreement_Analysis:Scorecard_Processing_Status:{accountId}:{docFileDataUid}:{digitalAppId}\n\t\t\tpublic const long CachedAnalysisScorecardProcessingStatus_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedClauseSmartContractProcessingStatus_Key = \"Agreement_Analysis:ClauseSmartContract_Processing_Status:{0}:{1}\";  //Agreement_Analysis:ClauseSmartContract_Processing_Status:{accountId}:{docUid}\n\t\t\tpublic const long CachedClauseSmartContractProcessingStatus_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedClauseSmartContractResponse_Key = \"Agreement_Analysis:ClauseSmartContract_Response:{0}:{1}\";  //Agreement_Analysis:ClauseSmartContract_Response:{accountId}:{docUid}\n\t\t\tpublic const long CachedClauseSmartContractResponse_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedClauseFlowResponse_Key = \"Agreement_Analysis:ClauseFlow_Response:{0}:{1}\";  //Agreement_Analysis:ClauseFlow_Response:{accountId}:{docUid}\n\t\t\tpublic const long CachedClauseFlowResponse_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedClauseSignContractResponse_Key = \"Agreement_Analysis:ClauseSignContract_Response:{0}:{1}\";  //Agreement_Analysis:ClauseSignContract_Response:{accountId}:{docUid}\n\t\t\tpublic const long CachedClauseSignContractResponse_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedSealLabelsErrorStatus_Key = \"Agreement_Analysis:SealLabels_Error_Status:{0}:{1}\";  //Agreement_Analysis:SealLabels_Error_Status:{accountId}:{fileDataUid}\n\t\t\tpublic const string ClauseMetadataGroupName = \"Clause Integration\";\n\t\t\tpublic const string AdvancedInsightsEventQueueHost = \"AdvancedInsightsEventQueueHost\";\n\t\t\tpublic const string EnableAdvancedInsightsRegisterForEvents = \"EnableAdvancedInsightsRegisterForEvents\";\n\n\t\t\tpublic const string KickStartSecurityUILockWaitTimeoutMs = \"KickStartSecurityUILockWaitTimeoutMs\";\n\t\t\tpublic const string KickStartSecurityLockWaitTimeoutMs = \"KickStartSecurityLockWaitTimeoutMs\";\n\t\t\tpublic const string KickStartSecurityTimeoutSeconds = \"KickStartSecurityTimeoutSeconds\";\n\t\t\tpublic const string KickStartSecurityUITimeoutSeconds = \"KickStartSecurityUITimeoutSeconds\";\n\t\t\tpublic const string AccountsToSkipSecurityCalculateByUser = \"AccountsToSkipSecurityCalculateByUser\";\n\t\t\tpublic const string SecurityCalcTaskInQueueTTLSeconds = \"SecurityCalcTaskInQueueTTLSeconds\";\n\n\t\t\tpublic const string DefaultMaintenanceWorkerReservationTimeout = \"DefaultMaintenanceWorkerReservationTimeout\";\n\n\t\t\tpublic const string TempFileSwiftContainerName = \"TempFileSwiftContainerName\";\n\n\t\t\tpublic const string DocumentTypesNotAllowedToBeDisplayedInline = \"DocumentTypesNotAllowedToBeDisplayedInline\";\n\n\t\t\tpublic const string ClauseIntegrationClientId = \"ClauseIntegrationClientId\";\n\t\t\tpublic const string ClauseLoginUrl = \"ClauseLoginUrl\";\n\n\t\t\tpublic const string GlyphExtractionTTLHours = \"GlyphExtractionTTLHours\";\n\t\t\tpublic const string GlyphReconciliationReservationExpireSeconds = \"GlyphReconciliationReservationExpireSeconds\";\n\t\t\tpublic const string ShouldOptimizeBrushInfoUse = \"ShouldOptimizeBrushInfoUse\";\n\t\t\tpublic const string TrackedTermsXmlTTLSeconds = \"TrackedTermsXmlTTLSeconds\";\n\t\t\tpublic const string SealDigitalAppsCacheExpirationSeconds = \"SealDigitalAppsCacheExpirationSeconds\";\n\t\t\tpublic const string SealModelListCacheExpirationSeconds = \"SealModelListCacheExpirationSeconds\";\n\t\t\tpublic const string SealUserViewsCacheExpirationSeconds = \"SealUserViewsCacheExpirationSeconds\";\n\n\t\t\tpublic const string IntellegoModelListExpirationSeconds = \"IntellegoModelListExpirationSeconds\";\n\n\t\t\tpublic const string EnableQueueSeparationForBulkBackgroundTasks = \"{0}_EnableQueueSeparationForBulkBackgroundTasks\";\n\n\t\t\tpublic const int SealClauseSyncMaxFolderTreeLevel = 10;\n\n\t\t\tpublic const string KazmonEnableSealExtractionCompleted = \"Kazmon_EnableScmTaskProcessor_SealExtraction\";\n\t\t\tpublic const string KazmonEnableSealScorecardCompleted = \"Kazmon_EnableScmTaskProcessor_SealScorecard\";\n\t\t\tpublic const string KazmonEnableAITransactionCheckStatus = \"Kazmon_EnableScmTaskProcessor_AITransactionCheckStatus\";\n\t\t\tpublic const string KazmonEnableAITransactionTelemetry = \"Kazmon_EnableAITransactionTelemetry\";\n\t\t\tpublic const string KazmonEnableAIAgreementSummaryTelemetry = \"Kazmon_EnableAIAgreementSummaryTelemetry\";\n\t\t\tpublic const string KazmonEnableAIBatchTelemetry = \"Kazmon_EnableAIBatchTelemetry\";\n\t\t\tpublic const string KazmonEnableCommentsReconcileWorkload = \"Kazmon_EnableWorkload_CommentsReconcile\";\n\t\t\tpublic const string KazmonEnableGetSearchablePdfWorkload = \"Kazmon_EnableScmTaskProcessor_GetSearchablePdf\";\n\t\t\tpublic const string AITransactionCheckStatusWorkerSleepSeconds = \"AITransactionCheckStatusWorkerSleepSeconds\";\n\t\t\tpublic const string AITransactionCheckStatusWorkflowWorkerSleepSeconds = \"AITransactionCheckStatuWorkflowWorkerSleepSeconds\";\n\t\t\tpublic const string AITransactionCheckStatusWorkerBucketInDays = \"AITransactionCheckStatusWorkerBucketInDays\";\n\t\t\tpublic const string AITransactionCheckStatusWorkflowWorkerBucketInDays = \"AITransactionCheckStatusWorkflowWorkerBucketInDays\";\n\t\t\tpublic const string AITransactionCheckStatusWorkerReservationInSecs = \"AITransactionCheckStatusWorkerReservationInSecs\";\n\t\t\tpublic const string AITransactionExtractionsCompletionBufferTimeInHours = \"AITransactionExtractionsCompletionBufferTimeInHours\";\n\t\t\tpublic const string AITransactionExtractionsCompletionWorkflowBufferTimeInHours = \"AITransactionExtractionsCompletionWorkflowBufferTimeInHours\";\n\t\t\tpublic const string AITransactionCheckStatusWorkerEnabled = \"AITransactionCheckStatusWorkerEnabled\";\n\t\t\tpublic const string AITransactionCheckStatusWorkflowWorkerEnabled = \"AITransactionCheckStatusWorkflowWorkerEnabled\";\n\t\t\tpublic const string LogicAppProgressStatusCheckedMaxCount = \"LogicAppProgressStatusCheckedMaxCount\";\n\t\t\tpublic const string AprRetryableErrorCodes = \"AprRetryableErrorCodes\";\n\n\t\t\tpublic const string AiAutofillSealExtractionContextLength = \"AiAutofillSealExtractionContextLength\";\n\t\t\tpublic const string AttributeDetailsPageNumberCacheExpirationSeconds = \"AttributeDetailsPageNumberCacheExpirationSeconds\";\n\t\t\tpublic const string CancelBatchMaxNumberOfTransactionToLoadInSingleCall = \"CancelBatchMaxNumberOfTransactionToLoadInSingleCall\";\n\n\t\t\tpublic const string AiAutofillBatchReportSharedStorageTTLSeconds = \"AiAutofillBatchReportSharedStorageTTLSeconds\";\n\t\t\tpublic const string AiAutofillBatchReportFilePathCacheTTLSeconds = \"AiAutofillBatchReportFilePathCacheTTLSeconds\";\n\n\t\t\tpublic const string DocLauncherMergePackageTTLInSeconds = \"DocLauncherMergePackageTTLInSeconds\";\n\n\t\t\tpublic const string EnableSessionProviderTelemetry = \"EnableSessionProviderTelemetry\";\n\n\t\t\tpublic const string SaveQueueStateToCache = \"SaveQueueStateToCache\";\n\n\t\t\t// Intellego integration\n\t\t\tpublic const string IntellegoAIFrontendApiBaseUrl = \"IntellegoAIFrontendApiBaseUrl\";\n\t\t\tpublic const string IntellegoLabelDisplayNames = \"IntellegoLabelDisplayNames\";\n\t\t\tpublic const string IntellegoContractValueModelName = \"IntellegoContractValueModelName\";\n\t\t\tpublic const string ProvideFeedbackForMissedExtractions = \"ProvideFeedbackForMissedExtractions\";\n\n\t\t\tpublic const string ZipConstructionTempDir = \"ZipConstructionTempDir\";\n\t\t\tpublic const string MaxZipFileBytes = \"MaxZipFileBytes\";\n\n\t\t\t//Agreement Object Model and Counterparties\n\t\t\tpublic const string AOMRestApiUrl = \"AOMRestApiUrl\";\n\t\t\tpublic const string AgreementRelationshipMaxHierarchyLevel = \"AgreementRelationshipMaxHierarchyLevel\";\n\n\t\t\t//Agreement Document Model\n\t\t\tpublic const string ADMRestApiUrl = \"ADMRestApiUrl\";\n\n\t\t\tpublic const string AdmDocumentTypeEnumId = \"AdmDocumentTypeEnumId\";\n\t\t\tpublic const string DocumentTypesSupportPageUrl = \"DocumentTypesSupportPageUrl\";\n\n\t\t\tpublic const string DocuSignNegotiationApiBaseUrl = \"DocuSignNegotiationApiBaseUrl\";\n\n\t\t\tpublic const string ABACRootFormat = \"ABACRootFormat\";\n\t\t\tpublic const string MaxSecurityAttributeCount = \"MaxSecurityAttributeCount\";\n\t\t\tpublic const string JITRepostRootFormat = \"JITRepostRootFormat\";\n\t\t\tpublic const string JITRootFormat = \"JITRootFormat\";\n\n\t\t\tpublic const string ABACRetrySleepSecondsSchedule = \"ABACRetrySleepSecondsSchedule\";\n\t\t\tpublic const string SecurityEvaluationRequestTimeoutMs = \"SecurityEvaluationRequestTimeoutMs\";\n\t\t\tpublic const string AdmSecretHeaderValue = \"AdmSecretHeaderValue\";\n\t\t\tpublic const string AdmSecretHeaderKey = \"AdmSecretHeaderKey\";\n\n\t\t\tpublic const string SearchReadDataFromSearchInc = \"SearchReadDataFromSearchInc\";\n\t\t\tpublic const string SearchSendDataToFacadeService = \"SearchSendDataToFacadeService\";\n\t\t\t// ACT Integration\n\t\t\tpublic const string DocuSignActUIBaseUrl = \"DocuSignActUIBaseUrl\";\n\t\t\tpublic const string DocuSignActAppsBaseUrl = \"DocuSignActAppsBaseUrl\";\n\t\t\tpublic const string DocusignActClientApplicationId = \"DocusignActClientApplicationId\";\n\t\t\tpublic const string DocuSignActClientTimeOutInSeconds = \"DocuSignActClientTimeOutInSeconds\";\n\t\t\tpublic const string DocuSignActRequestUseAppToken = \"DocuSignActRequestUseAppToken\";\n\n\t\t\t// Agreement List\n\t\t\tpublic const string ElasticAgreementRepositoryLoadRecentDocumentOffsetInMonths = \"ElasticAgreementRepositoryLoadRecentDocumentOffsetInMonths\";\n\t\t\tpublic const string ElasticAgreementSearchDelayMs = \"ElasticAgreementSearchDelayMs\";\n\n\t\t\t//Support URL\n\t\t\tpublic const string SlackHelpUrl = \"SlackHelpUrl\";\n\t\t\tpublic const string AdminConversionInfoUrl = \"AdminConversionInfoUrl\";\n\t\t\tpublic const string UserConversionInfoUrl = \"UserConversionInfoUrl\";\n\t\t\tpublic const string SfdcConversionInfoUrl = \"SfdcConversionInfoUrl\";\n\t\t\tpublic const string SfdcDalAppLink = \"SfdcDalAppLink\";\n\t\t\tpublic const string TranslationHelpUrl = \"TranslationHelpUrl\";\n\t\t\tpublic const string FederatedSecuritySandboxUrl = \"FederatedSecuritySandboxUrl\";\n\t\t\tpublic const string FederatedSecuritySandboxUrlDS = \"FederatedSecuritySandboxUrlDS\";\n\t\t\tpublic const string FederatedSecurityUrlDS = \"FederatedSecurityUrlDS\";\n\t\t\tpublic const string FederatedSecurityUrl = \"FederatedSecurityUrl\";\n\t\t\tpublic const string FederatedSecurityAccessMapping = \"FederatedSecurityAccessMapping\";\n\t\t\tpublic const string FederatedSecurityAccessMappingDS = \"FederatedSecurityAccessMappingDS\";\n\t\t\tpublic const string OrgCreationGuideUrl = \"OrgCreationGuideUrl\";\n\t\t\tpublic const string AdminIntroUrl = \"AdminIntroUrl\";\n\t\t\tpublic const string ClmKickoffGuideForAdmins = \"ClmKickoffGuideForAdmins\";\n\t\t\tpublic const string WorkflowCreate = \"WorkflowCreate\";\n\t\t\tpublic const string Upload = \"Upload\";\n\t\t\tpublic const string SupportedBrowsers = \"SupportedBrowsers\";\n\t\t\tpublic const string SendDocuments = \"SendDocuments\";\n\t\t\tpublic const string SAMLSSO = \"SAMLSSO\";\n\t\t\tpublic const string Reports = \"Reports\";\n\t\t\tpublic const string NodeSecurity = \"NodeSecurity\";\n\t\t\tpublic const string MetadataImportMappings = \"MetadataImportMappings\";\n\t\t\tpublic const string ManageAttributes = \"ManageAttributes\";\n\t\t\tpublic const string ImportUsers = \"ImportUsers\";\n\t\t\tpublic const string Forms = \"Forms\";\n\t\t\tpublic const string FolderSettings = \"FolderSettings\";\n\t\t\tpublic const string DocuSignCommunityScmTopic = \"DocuSignCommunityScmTopic\";\n\t\t\tpublic const string DocuSignCommunity = \"DocuSignCommunity\";\n\t\t\tpublic const string DocuSignSupportCenter = \"DocuSignSupportCenter\";\n\t\t\tpublic const string DocumentReviewer = \"DocumentReviewer\";\n\t\t\tpublic const string DocumentRules = \"DocumentRules\";\n\t\t\tpublic const string DeviceManagement = \"DeviceManagement\";\n\t\t\tpublic const string NewDashboard = \"NewDashboard\";\n\t\t\tpublic const string Developer = \"Developer\";\n\t\t\tpublic const string CutCopyPaste = \"CutCopyPaste\";\n\t\t\tpublic const string CustomizeMenu = \"CustomizeMenu\";\n\t\t\tpublic const string CreateUser = \"CreateUser\";\n\t\t\tpublic const string CreateContact = \"CreateContact\";\n\t\t\tpublic const string BrowseDocuments = \"BrowseDocuments\";\n\t\t\tpublic const string AdvancedSearch = \"AdvancedSearch\";\n\t\t\tpublic const string AddressBook = \"AddressBook\";\n\t\t\tpublic const string Index = \"Index\";\n\t\t\tpublic const string IndexDS = \"IndexDS\";\n\t\t\tpublic const string EnableNewDelegateAccess = \"EnableNewDelegateAccess\";\n\t\t\tpublic const string HideDelegateAccess = \"HideDelegateAccess\";\n\t\t\tpublic const string HideExternalReviewCompletionByEmailSetting = \"HideExternalReviewCompletionByEmailSetting\";\n\t\t\tpublic const string SecurityEvaluationApiMaxNodes = \"SecurityEvaluationApiMaxNodes\";\n\t\t\tpublic const string UpdatableSupportUserProperties = \"UpdatableSupportUserProperties\";\n\t\t\tpublic const string ABACPDPServerList = \"ABACPDPServerList\";\n\n\t\t\tpublic const string DocuSignCollaborationApiBaseUrl = \"DocuSignCollaborationApiBaseUrl\";\n\t\t\tpublic const string AssignmentsApiBaseUrl = \"AssignmentsApiBaseUrl\";\n\t\t\tpublic const string AssignmentsApiPageSize = \"AssignmentsApiPageSize\";\n\t\t\tpublic const string EnableCommentsInPreview = \"EnableCommentsInPreview\";\n\t\t\tpublic const string EnableCommentAssignmentsInPreview = \"EnableCommentAssignmentsInPreview\";\n\t\t\tpublic const string EnableCommentsTaskGroups = \"EnableCommentsTaskGroups\";\n\t\t\tpublic const string EnableGraphQLGzipCompression = \"EnableGraphQLGzipCompression\";\n\t\t\tpublic const string EnableCommentsReconciliation = \"EnableCommentsReconciliation\";\n\t\t\tpublic const string CommentsReconcilePreAndPostCharLimit = \"CommentsReconcilePreAndPostCharLimit\";\n\t\t\tpublic const string ExternalMapCacheTimeout = \"ExternalMapCacheTimeout\";\n\t\t\tpublic const string EnableContextMenuInTasks = \"EnableContextMenuInTasks\";\n\n\t\t\tpublic const string InsightsAllowedProtocols = \"InsightsAllowedProtocols\";\n\t\t\tpublic const string InsightsAllowedDomains = \"InsightsAllowedDomains\";\n\n\t\t\tpublic const string EnableAdvancedPreview = \"EnableAdvancedPreview\";\n\t\t\tpublic const string CollapseStandardAttributePanelByDefault = \"CollapseStandardAttributePanelByDefault\";\n\t\t\tpublic const string EnableReactDocLauncherPreview = \"EnableReactDocLauncherPreview\";\n\t\t\tpublic const string EnableChatNotifications = \"EnableChatNotifications\";\n\t\t\tpublic const string EnableInteractiveChatNotificationPayloads = \"EnableInteractiveChatNotificationPayloads\";\n\t\t\tpublic const string DisableExternalMapCaching = \"DisableExternalMapCaching\";\n\t\t\tpublic const string CLMUIBaseUrl = \"CLMUIBaseUrl\";\n\t\t\tpublic const string OliveImagesCdnUrl = \"OliveImagesCdnUrl\";\n\t\t\tpublic const string OliveImagesCdnVersion = \"OliveImagesCdnVersion\";\n\t\t\tpublic const string CLMUIVersion = \"CLMUIVersion\";\n\n\t\t\tpublic const string EnableDesiredWorkerCountFromFeatureFlags = \"EnableDesiredWorkerCountFromFeatureFlags\";\n\n\t\t\tpublic const string EnableCommentsWordIngestion = \"EnableCommentsWordIngestion\";\n\t\t\tpublic const string EnableRebrand2024 = \"EnableRebrand2024\";\n\n\t\t\tpublic const string EnableCLMSitemap = \"EnableCLMSiteMap\";\n\n\t\t\tpublic const string DisableDsUserIdCaching = \"DisableDsUserIdCaching\";\n\t\t\tpublic const string DsUserIdCacheExpirationSeconds = \"DsUserIdCacheExpirationSeconds\";\n\n\t\t\t//Data review\n\t\t\tpublic const string DataReviewCustomAttributesAllowedAttributeTypes = \"DataReviewCustomAttributesAllowedAttributeTypes\";\n\t\t\tpublic const string DataReviewCustomAttributesEnableRepeatable = \"DataReviewCustomAttributesEnableRepeatable\";\n\t\t\tpublic const string KazmonEnableDataReviewTelemetry = \"Kazmon_EnableDataReviewTelemetry\";\n\t\t\tpublic const string DataReviewFuzzyMatchMinScore = \"DataReviewFuzzyMatchMinScore\";\n\n\t\t\t// Account Conversion\n\t\t\tpublic const string EnableCLMAccountConversion = \"EnableCLMAccountConversion\";\n\t\t\tpublic const string EnableCLMAccountMigrationForm = \"EnableCLMAccountMigrationForm\";\n\t\t\tpublic const string EnableRollbackAllSettings = \"EnableRollbackAllSettings\";\n\t\t\tpublic const string EnableConversionMixedMode = \"EnableConversionMixedMode\";\n\t\t\tpublic const string ConversionMixedModeSettings = \"ConversionMixedModeSettings\";\n\t\t\tpublic const string EnableCLMBeginAccountConversion = \"EnableCLMBeginAccountConversion\";\n\t\t\tpublic const string AddUpdateUserTimeout = \"AddUpdateUserTimeout\";\n\n\t\t\tpublic const string EnableCertificateValidator = \"EnableCertificateValidator\";\n\n\t\t\tpublic const string EnableHasSecurityChangeEvaluationWorkflow = \"EnableHasSecurityChangeEvaluationWorkflow\";\n\n\t\t\tpublic const string DocumentDeletedMaxRetries = \"DocumentDeletedMaxRetries\";\n\t\t\tpublic const string FolderDeletedMaxRetries = \"FolderDeletedMaxRetries\";\n\t\t\tpublic const string EnableAssignmentDelete = \"EnableAssignmentDelete\";\n\t\t\tpublic const string NotificationEmailRegex = \"NotificationEmailRegex\";\n\t\t\tpublic const string TaskGroupDeletedEventMaxRetries = \"TaskGroupDeletedEventMaxRetries\";\n\n\t\t\tpublic const string EnableProfileNotificationMessageHandling = \"EnableProfileNotificationMessageHandling\";\n\t\t\tpublic const string AllowedClientIds_ProfileNotification = \"AllowedClientIds_ProfileNotification\";\n\t\t\tpublic const string EnableSFDCPermissionSetAssignment = \"EnableSFDCPermissionSetAssignment\";\n\t\t\tpublic const string EnableSFDCStopUserSyncForConvertedAccounts = \"EnableSFDCStopUserSyncForConvertedAccounts\";\n\t\t\tpublic const string EnableSFDCApisForSalesforceLedConversion = \"EnableSFDCApisForSalesforceLedConversion\";\n\n\t\t\t//DotVVM\n\t\t\tpublic const string DotVVMEnablePages = \"DotVVMEnablePages\";\n\n\t\t\t// CLM Max\n\t\t\tpublic const string APRIntegratorKeyWhitelist = \"APRIntegratorKeyWhitelist\";\n\t\t\tpublic const string BatchManagementIntegratorKeyWhitelist = \"BatchManagementIntegratorKeyWhitelist\";\n\n\t\t\t//ServiceProtection\n\t\t\tpublic const string ServProtEnableRequestFiltering = \"ServProtEnableRequestFiltering\";\n\t\t\tpublic const string ServProtEnableExternalActionRulesUpdater = \"ServProtEnableExternalActionRulesUpdater\";\n\t\t\tpublic const string ServProtLoadSecretsFromVault = \"ServProtLoadSecretsFromVault\";\n\t\t\tpublic const string ServProtEnableVNextSmartSetFetching = \"ServProtEnableVNextSmartSetFetching\";\n\t\t\tpublic const string ServProtAccountHost = \"ServProtAccountHost\";\n\t\t\tpublic const string ServProtClientId = \"ServProtClientId\";\n\t\t\tpublic const string ServProtContextTypes = \"ServProtContextTypes\";\n\t\t\tpublic const string ServProtInstanceName = \"ServProtInstanceName\";\n\t\t\tpublic const string ServProtJwtBearerAudience = \"ServProtJwtBearerAudience\";\n\t\t\tpublic const string ServProtPrivateKey = \"ServProtPrivateKey\";\n\t\t\tpublic const string ServProtProtectUri = \"ServProtProtectUri\";\n\t\t\tpublic const string ServProtRuleRefreshSeconds = \"ServProtRuleRefreshSeconds\";\n\t\t\tpublic const string ServProtRuleRefreshWrapperSeconds = \"ServProtRuleRefreshWrapperSeconds\";\n\t\t\tpublic const string ServProtTimeoutMs = \"ServProtTimeoutMs\";\n\t\t\tpublic const string ServProtEnableClientLogging = \"ServProtEnableClientLogging\";\n\t\t\tpublic const string ServProtEnableDynamicThrottling = \"ServProtEnableDynamicThrottling\";\n\t\t\tpublic const string ServProtDynamicThrottlingRefreshRateSeconds = \"ServProtDynamicThrottlingRefreshRateSeconds\";\n\n\n\t\t\t// Atlas Context Provider settings\n\t\t\tpublic const string UseAsyncAtlasContextProvider = \"UseAsyncAtlasContextProvider\";\n\n\t\t\tpublic const string DocLauncherMaxUserConversionTaskQueueTimeInSeconds = \"DocLauncherMaxUserConversionTaskQueueTimeInSeconds\";\n\t\t\tpublic const string SfMergeProcessorMaxTimeWaitingForPdfInSeconds = \"SfMergeProcessor_MaxTimeWaitingForPdfInSeconds\";\n\t\t\tpublic const string OneConfigIniPath = \"OneConfigIniPath\";\n\n\t\t\t// Bulk Review\n\t\t\tpublic const string UploadCenterUrl = \"UploadCenterUrl\";\n\n\t\t\t// Rate limit counting\n\t\t\tpublic const string UseSlidingWindowForRateLimitAcrossAccounts = \"UseSlidingWindowForRateLimitAcrossAccounts\";\n\n\t\t\t// API Content Integrator Key Rate Limit\n\t\t\tpublic const string ApiContentIntegratorKeyRateLimitAllowedRequests = \"ApiContentIntegratorKeyRateLimitAllowedRequests_{0}\";\n\t\t\tpublic const string ApiContentIntegratorKeyRateLimitDurationSeconds = \"ApiContentIntegratorKeyRateLimitDurationSeconds_{0}\";\n\t\t\tpublic const string ApiContentIntegratorKeyRateLimitSyncStep = \"ApiContentIntegratorKeyRateLimitSyncStep_{0}\";\n\t\t\tpublic const string ApiContentIntegratorKeyRateLimitEnabledKeys = \"ApiContentIntegratorKeyRateLimitEnabledKeys\";\n\n\t\t\t// Orchestration Workflow Integration\n\t\t\tpublic const string OrchestrationWorkflowStartTaskTempStorage = \"OrchestrationWorkflowStartTaskTempStorage\";\n\t\t\tpublic const string OrchestrationIntegrationRetryCount = \"OrchestrationIntegrationRetryCount\";\n\t\t\tpublic const string OrchestrationIntegrationRetryIntervalInMs = \"OrchestrationIntegrationRetryIntervalInMs\";\n\t\t\tpublic const string OrchestrationManageApiEndpoint = \"OrchestrationManageApiEndpoint\";\n\n\t\t\t// Obligation Management Integration\n\t\t\tpublic const string ObligationManagementIntegrationRetryCount = \"ObligationManagementIntegrationRetryCount\";\n\t\t\tpublic const string ObligationManagementIntegrationRetryIntervalInMs = \"ObligationManagementIntegrationRetryIntervalInMs\";\n\n\t\t\t// AI Agreement Summary\n\t\t\tpublic const string AIAgreementSummaryMaxFailures = \"AIAgreementSummaryMaxFailures\";\n\t\t\tpublic const string AIAgreementSummaryMaxFileSizeBytes = \"AIAgreementSummaryMaxFileSizeBytes\";\n\t\t\tpublic const string AIAgreementSummaryProcessingThresholdInSeconds = \"AIAgreementSummaryProcessingThresholdInSeconds\";\n\n\t\t\t// New Tasks list performance improvements\n\t\t\tpublic const string WorkItemLoadByWorkerPoolUidsMaxCount = \"WorkItemLoadByWorkerPoolUidsMaxCount\";\n\t\t\tpublic const string WorkItemLoadByAssignedUserUidsMaxCount = \"WorkItemLoadByAssignedUserUidsMaxCount\";\n\n\t\t\t// Account behavior\n\t\t\tpublic const string UseSiteColumnForSiteName = \"UseSiteColumnForSiteName\";\n\t\t\tpublic const string UseDbNameColumnForDbName = \"UseDbNameColumnForDbName\";\n\n\t\t\tpublic const string WatermarkEventTimeoutMinutes = \"WatermarkEventTimeoutMinutes\";\n\n\t\t\t// Unified Repository\n\t\t\tpublic const string UnifiedRepositoryUrl = \"UnifiedRepositoryUrl\";\n\t\t\tpublic const string PermissionServiceMaxEventsAllowedPerRequest = \"PermissionServiceMaxEventsAllowedPerRequest\";\n\t\t\tpublic const string UnifiedRepositoryHistoricalLoadNextMaxRows = \"UnifiedRepositoryHistoricalLoadNextMaxRows\";\n\t\t\tpublic const string DocumentExtensionsSupportedForIAMIngestion = \"DocumentExtensionsSupportedForIAMIngestion\";\n\t\t\tpublic const string CachedAttributeMappingsExistsStatusKey = \"AttributeMappingsExists_Status_{0}\";  //AttributeMappingExists_Status_{accountId}\n\t\t\tpublic const string CachedAttributeMappingsExistsStatusExpirationSecond = \"CachedAttributeMappingsExistsStatusExpirationSecond\";\n\t\t\tpublic const string UnifiedRepositoryPartiesUrl = \"UnifiedRepositoryPartiesUrl\";\n\n\t\t\t// Audit Service API\n\t\t\tpublic const string AuditServiceMaxEventsAllowedPerRequest = \"AuditServiceMaxEventsAllowedPerRequest\";\n\t\t\tpublic const string KazmonEnableAuditServiceTelemetry = \"Kazmon_EnableAuditServiceTelemetry\";\n\t\t\tpublic const string AuditServiceMaxNumberOfRetries = \"AuditServiceMaxNumberOfRetries\";\n\t\t\tpublic const string AuditServiceWaitTimeInMsBeforeNextAttempt = \"AuditServiceWaitTimeInMsBeforeNextAttempt\";\n\n\t\t\t// UR Permission Service\n\t\t\tpublic const string KazmonEnablePermissionServiceTelemetry = \"Kazmon_EnablePermissionServiceTelemetry\";\n\n\t\t\t//WebContent\n\t\t\tpublic const string EnableSessionForWebContent = \"EnableSessionForWebContent\";\n\n\t\t\tpublic const string SiteSpecificDomainRoot = \"DomainRoot_{0}\";\n\t\t\tpublic const string CrossPlatformSites = \"CrossPlatformSites\";\n\t\t\tpublic const string CrossPlatformAppUrlFormat = \"CrossPlatformAppUrlFormat_{0}\";\n\t\t\tpublic const string StandardCrossPlatformAppUrlFormat = \"StandardCrossPlatformAppUrlFormat\";\n\t\t\tpublic const string AppUrlFormat = \"AppUrlFormat\";\n\t\t\tpublic const string AuthAppFormat = \"AuthAppFormat\";\n\n\t\t\t//API Request Headers\n\t\t\tpublic const string EnableCheckXForwardedFor = \"EnableCheckXForwardedFor\";\n\t\t\tpublic const string EnableCheckXForwardedForBehindProxy = \"EnableCheckXForwardedForBehindProxy\";\n\t\t\tpublic const string EnableTrueClientIp = \"EnableTrueClientIP\";\n\t\t\tpublic const string DefaultEnableCheckXForwardedForForwardLimit = \"DefaultEnableCheckXForwardedForForwardLimit\";\n\t\t\tpublic const string DefaultEnableCheckXForwardedForForwardLimitBehindProxy = \"DefaultEnableCheckXForwardedForForwardLimitBehindProxy\";\n\t\t\tpublic const string UseTrueClientIp = \"UseTrueClientIP\";\n\t\t\tpublic const string UseXForwardedFor = \"UseXForwardedFor\";\n\t\t\tpublic const string UseXForwardedForBehindProxy = \"UseXForwardedForBehindProxy\";\n\n\t\t\t//MaintenanceService AccessReservation\n\t\t\tpublic const string EnableAccessReservationForMaintenanceWorkers = \"EnableAccessReservationForMaintenanceWorkers\";\n\t\t\tpublic const string EnableWorkerLevelLocksDocumentNamingService = \"EnableWorkerLevelLocksDocumentNamingService\";\n\n\t\t\tpublic const string MaxNumberOfAIExtractionResults = \"MaxNumberOfAIExtractionResults\";\n\n\t\t\t// All Applications\n\t\t\tpublic const string ServicePointConnectionLimit = \"ServicePointConnectionLimit\";\n\n\t\t\t// SetResponseHeadersAttribute\n\t\t\tpublic const string DSSessionControllerEnterEndpointEnableCors = \"DSSessionControllerEnterEndpointEnableCors\";\n\t\t\tpublic const string DSSessionControllerEnterEndpointEnableUserId = \"DSSessionControllerEnterEndpointEnableUserId\";\n\n\t\t\t// UserTokenAuth\n\t\t\tpublic const string EnableSingleUseUserToken = \"EnableSingleUseUserToken\";\n\t\t\tpublic const string SessionCookiesSameSiteMode = \"SessionCookiesSameSiteMode\";\n\n\t\t\t// Lexion\n\t\t\tpublic const string LexionAppVersion = \"LexionAppVersion\";\n\t\t\tpublic const string LexionAppSourceId = \"LexionAppSourceId\";\n\n\t\t\t// DMS Migration\n\t\t\tpublic const string DmsMigrationIntegratorKeyWhitelist = \"DmsMigrationIntegratorKeyWhitelist\";\n\n\t\t\tpublic const string DSEditProhibitedFileTypes = \"DSEditProhibitedFileTypes\";\n\n\t\t\t//  Maximum file size in MB for Tracked Content Extractions & Content Replacement Tasks\n\t\t\tpublic const string TrackedContentExtractionsTaskMaxFileSizeMB = \"TrackedContentExtractionsTaskMaxFileSizeMB\";\n\t\t\tpublic const string ContentReplacementTaskMaxFileSizeMB = \"ContentReplacementTaskMaxFileSizeMB\";\n\n\t\t\t// User handler\n\t\t\tpublic const string UserHandlerUseContextAccessor = \"UserHandlerUseContextAccessor\";\n\n\t\t\tpublic const string DeleteFoldersWithEmptyParent = \"DeleteFoldersWithEmptyParent\";\n\t\t}\n\n\t\tpublic class AutoNumber\n\t\t{\n\t\t\tpublic const int NUM_WIDTH_MAX_VALUE = 19;\n\t\t}\n\n\t\tpublic class Cassandra\n\t\t{\n\t\t\tpublic const string HistoryKeyspace = \"history\";\n\t\t\tpublic const string DefaultKeyspace = \"atlas\";\n\t\t\tpublic const string AnalyticsKeyspace = \"analytics\";\n\t\t\tpublic const string EventsKeyspace = \"events\";\n\t\t\tpublic const string DefaultCatalog = \"cassandra\";\n\t\t\tpublic const string AnalyticsCatalog = \"cassandra_analytics\";\n\t\t\tpublic const string HistoryCatalog = \"cassandra_history\";\n\t\t}\n\n\n\t\tpublic class ClientScriptBlock\n\t\t{\n\t\t\tpublic const string AutoRefresh = \"auto-refresh\";\n\t\t\tpublic const string CloseWindoid = \"CloseWindoid\";\n\t\t\tpublic const string CloseWindow = \"CloseWindow\";\n\t\t\tpublic const string ClosePopupWindow = \"ClosePopupWindow\";\n\t\t\tpublic const string CollaborationStartupVariables = \"CollaborationStartupVariables\";\n\t\t\tpublic const string ColorPickerCss = \"ColorPickerCss\";\n\t\t\tpublic const string dirtyflag = \"dirtyflag\";\n\t\t\tpublic const string ForceLogger = \"ForceScriptLogger\";\n\t\t\tpublic const string InitiallyCollapseLeftNavigation = \"InitiallyCollapseLeftNavigation\";\n\t\t\tpublic const string logicaldocumentblock = \"logicaldocumentblock\";\n\t\t\tpublic const string NoPreviewAvaliable = \"NoPreviewAvaliable\";\n\t\t\tpublic const string NoDisplayWhenReadOnly = \"NoDisplayWhenReadOnly\";\n\t\t\tpublic const string OnKeyDownBody = \"OnKeyDownBody\";\n\t\t\tpublic const string RadGridColumnWidthFix = \"RadGridColumnWidthFix\";\n\t\t\tpublic const string RefreshOpener = \"RefreshOpener\";\n\t\t\tpublic const string RequiredPrepend = \"RequiredPrepend\";\n\t\t\tpublic const string RequiredPrependAndHideSections = \"RequiredPrependAndHideSections\";\n\t\t\tpublic const string SalesForceContainerCssOverride = \"SalesForceContainerCssOverride\";\n\t\t\tpublic const string SalesForceJavascriptlet = \"SalesForceJavascriptlet\";\n\t\t\tpublic const string SelectNodesJSVariables = \"SelectNodesJSVariables\";\n\t\t\tpublic const string SFReport = \"SFReport\";\n\t\t\tpublic const string toggleWexExSettings = \"toggleWexExSettings\";\n\t\t\tpublic const string ToolbarScript = \"toolbarScript\";\n\t\t\tpublic const string WizardPricingTableHook = \"WizardPricingTableHook\";\n\t\t\tpublic const string WorkflowConfigurationStepInitialization = \"WorkflowConfigurationStepInitialization\";\n\t\t}\n\n\t\tpublic class CustomHeaders\n\t\t{\n\t\t\tpublic const string RateLimitAllowed = \"X-RateLimit-Allowed\";\n\t\t\tpublic const string RateLimitRemaining = \"X-RateLimit-Remaining\";\n\t\t\tpublic const string RateLimitReset = \"X-RateLimit-Reset\";\n\t\t}\n\n\t\tpublic class DateFormatString\n\t\t{\n\t\t\tprivate static readonly object DateFormatListLocker = new object();\n\t\t\tprivate static volatile IReadOnlyList<string> _dateFormats;\n\n\t\t\tpublic static IReadOnlyList<string> DateFormats\n\t\t\t{\n\t\t\t\tget\n\t\t\t\t{\n\t\t\t\t\tif (_dateFormats != null) return _dateFormats;\n\n\t\t\t\t\tlock (DateFormatListLocker)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (_dateFormats != null) return _dateFormats;\n\n\t\t\t\t\t\tvar tempDateFormats = new List<string>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"MMMM dd, yyyy\",\n\t\t\t\t\t\t\t\"MMMM d, yyyy\",\n\t\t\t\t\t\t\t\"MMMM-dd\",\n\t\t\t\t\t\t\t\"MMMM-yy\",\n\t\t\t\t\t\t\t\"MMMM yyyy\",\n\t\t\t\t\t\t\t\"MMMM\",\n\t\t\t\t\t\t\t\"MMM-dd\",\n\t\t\t\t\t\t\t\"MMM-yy\",\n\t\t\t\t\t\t\t\"MM-dd\",\n\t\t\t\t\t\t\t\"MM/dd/yyyy\",\n\t\t\t\t\t\t\t\"MM/dd/yy\",\n\t\t\t\t\t\t\t\"MM\",\n\t\t\t\t\t\t\t\"dd\",\n\t\t\t\t\t\t\t\"dd/MM/yy\",\n\t\t\t\t\t\t\t\"dd/MM/yyyy\",\n\t\t\t\t\t\t\t\"dd.MM.yyyy\",\n\t\t\t\t\t\t\t\"dd MMMM yyyy\",\n\t\t\t\t\t\t\t\"dd 'day of' MMMM yyyy\",\n\t\t\t\t\t\t\t\"yyyy-MM-dd\",\n\t\t\t\t\t\t\t\"yyyy\",\n\t\t\t\t\t\t\t\"yy-MMM\",\n\t\t\t\t\t\t\t\"yy-MMM-dd\"\n\t\t\t\t\t\t}.AsReadOnly();\n\n\t\t\t\t\t\t_dateFormats = tempDateFormats;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn _dateFormats;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic class DocuSignAgreementStatus\n\t\t{\n\t\t\tpublic const string AgreementStatus = \"Agreement Status\";\n\t\t\tpublic const string StatusChangedDate = \"Agreement Status Timestamp\";\n\t\t}\n\n\t\tpublic class DocuSignAuthenticationScopes\n\t\t{\n\t\t\tpublic const string Signature = \"signature\";\n\t\t\tpublic const string Impersonation = \"impersonation\";\n\t\t\tpublic const string AccountProductRead = \"account_product_read\";\n\t\t\tpublic const string ProvisionRead = \"provision_read\";\n\t\t\tpublic const string CreateManagedToken = \"create_managed_token\";\n\t\t\tpublic const string ProvisionWrite = \"provision_write\";\n\t\t\tpublic const string ProvisionPendingOrders = \"provision_order_pending_orders\";\n\t\t\tpublic const string UserRead = \"user_read\";\n\t\t\tpublic const string UserWrite = \"user_write\";\n\t\t\tpublic const string AccountSyncWrite = \"accountsync_write\";\n\t\t\tpublic const string PublicKeyApi = \"public_key_api\";\n\t\t\tpublic const string GroupManagementRead = \"group_management_read\";\n\t\t\tpublic const string GroupManagementWrite = \"group_management_write\";\n\t\t\tpublic const string MeProfile = \"me_profile\";\n\t\t\tpublic const string InviteCallback = \"invite_callback\";\n\t\t\tpublic const string ClmAppRestrictedScope = \"clm_app_restricted\";\n\t\t\tpublic const string NegotiationReview = \"negotiation_review\";\n\t\t\tpublic const string ActRead = \"act_read\";\n\t\t\tpublic const string ActWrite = \"act_write\";\n\t\t\tpublic const string ActExecute = \"act_execute\";\n\t\t\tpublic const string ActFirstParty = \"act_first_party\";\n\t\t\tpublic const string AnalyzerCallback = \"analyzer_callback\";\n\t\t\tpublic const string AisAnalyze = \"ais_analyze\";\n\t\t\tpublic const string AprRead = \"apr_read\";\n\t\t\tpublic const string AprWrite = \"apr_write\";\n\t\t\tpublic const string DcfWrite = \"dcf_write\";\n\t\t\tpublic const string RealTimeApiCreateToken = \"rtm_token_create\";\n\t\t\tpublic const string SearchRead = \"search_read\";\n\t\t\tpublic const string SearchWrite = \"search_write\";\n\t\t\tpublic const string RealTimeApiChannelAccess = \"rtm_channel_access\";\n\t\t\tpublic const string CollaborationApi = \"collaboration\";\n\t\t\tpublic const string TasksApi = \"task_api\";\n\t\t\tpublic const string ProfileNotificationClm = \"profile_notification_CLM\";\n\t\t\tpublic const string ProfileNotificationGen = \"profile_notification_Gen\";\n\t\t\tpublic const string ProfileNotificationNegotiate = \"profile_notification_Negotiate\";\n\t\t\tpublic const string ProvisionAccountRead = \"provision_account_read\";\n\t\t\tpublic const string ClmAiBatchWrite = \"clm_ai_batch_write\";\n\t\t\tpublic const string ClmCallback = \"clm_processing_status_callback\";\n\t\t\tpublic const string NotificationService = \"notification_service\";\n\t\t\tpublic const string DocGenWrite = \"docgen_write\";\n\t\t\tpublic const string SpringWriteScope = \"spring_write\";\n\t\t\tpublic const string SpringReadScope = \"spring_read\";\n\t\t\tpublic const string SpringContentScope = \"spring_content\";\n\t\t\tpublic const string ClmUI = \"clm_ui\";\n\t\t\tpublic const string ClmCommunityUserAccess = \"clm_community_user_access\";\n\t\t\tpublic const string AomRead = \"agreement_object_model_read\";\n\t\t\tpublic const string AomWrite = \"agreement_object_model_write\";\n\t\t\tpublic const string AIRulesEngineExecuteScope = \"ai_rules_engine_execute\";\n\t\t\tpublic const string AIRulesEngineReadScope = \"ai_rules_engine_read\";\n\t\t\tpublic const string AIRulesEngineWriteScope = \"ai_rules_engine_write\";\n\t\t\tpublic const string EmailProcessing = \"email_processing\";\n\t\t\tpublic const string AuditServer = \"audit_server\";\n\t\t\tpublic const string ModelsESignManage = \"models_esign_manage\";\n\t\t\tpublic const string ModelsRead = \"models_read\";\n\t\t\tpublic const string ModelsWrite = \"models_write\";\n\t\t\tpublic const string AdmStoreUnifiedRepoRead = \"adm_store_unified_repo_read\";\n\t\t\tpublic const string AdmStoreUnifiedRepoWrite = \"adm_store_unified_repo_write\";\n\t\t\tpublic const string AccessRead = \"access_read\";\n\t\t\tpublic const string AccessWrite = \"access_write\";\n\t\t\tpublic const string Doc2PdfClient = \"msf_doc2pdf\";\n\t\t\tpublic const string AdmDotRead = \"adm_dot_read\";\n\t\t\tpublic const string AdmDotWrite = \"adm_dot_write\";\n\t\t\tpublic const string ClmActivitiesExecute = \"clm_activities_execute\";\n\t\t\tpublic const string ObligationManagementRead = \"obligation_management_read\";\n\t\t\tpublic const string ObligationManagementWrite = \"obligation_management_write\";\n\t\t\tpublic const string ClmIngestion = \"clm_ingestion\";\n\t\t    public const string IntegrationsExtensionRead = \"ie_sf_read\";\n\t\t\tpublic const string IntegrationsExtensionWrite = \"ie_sf_write\";\n\t\t}\n\n\t\tpublic class DocuSignCustomHeaders\n\t\t{\n\t\t\tpublic const string CorrelationToken = \"X-DocuSign-CorrelationToken\";\n\t\t\tpublic const string ClmAccountId = \"X-Clm-Account-Id\";\n\t\t\tpublic const string ClmSiteName = \"X-Clm-SiteName\";\n\t\t\tpublic const string ClmAccountGuid = \"X-Clm-Account-Guid\";\n\t\t\tpublic const string ClmUserId = \"X-Clm-User-Id\";\n\t\t\tpublic const string ClmAccountType = \"X-Clm-Account-Type\";\n\t\t\tpublic const string SourceContext = \"X-Source-Context\";\n\t\t\tpublic const string TraceToken = \"X-DocuSign-TraceToken\";\n\t\t\tpublic const string TraceParent = \"traceparent\";\n\t\t\tpublic const string IsRepost = \"X-DocuSign-Repost\";\n\t\t\tpublic const string AppId = \"X-Act-App-Id\";\n\t\t\tpublic const string ClientTransactionId = \"X-DocuSign-ClientTransactionId\";\n\t\t\tpublic const string DocuSignAccountId = \"X-DocuSign-AccountId\";\n\t\t\tpublic const string DocuSignUserId = \"X-DocuSign-UserId\";\n\t\t\tpublic const string WorkflowActivityId = \"X-DocuSign-WorkflowActivityId\";\n\t\t\tpublic const string WorkflowInstanceId = \"X-DocuSign-WorkflowInstanceId\";\n\t\t\tpublic const string DocusignShardId = \"Docusign-Shard-Id\";\n\t\t}\n\n\t\tpublic class ActCustomHeaders\n\t\t{\n\t\t\tpublic const string DocuSignAccountIdGuid = \"X-DS-Account-Id-Guid\";\n\t\t\tpublic const string DocuSignAccountIdNumber = \"X-DS-Account-Id\";\n\t\t\tpublic const string DocuSignSiteName = \"X-DS-Site-Name\";\n\t\t\tpublic const string DocuSignUserId = \"X-DS-User-Id\";\n\t\t}\n\n\t\tpublic class Entitlements\n\t\t{\n\t\t\tpublic const string Gen = \"gen\";\n\t\t\tpublic const string Clm = \"clm\";\n\t\t\tpublic const string Negotiate = \"negotiate\";\n\t\t}\n\n\t\tpublic class ExternalReview\n\t\t{\n\t\t\tpublic const int CommentMaxCharLength = 750;\n\t\t\tpublic const string ReplyToEmail = \"review-clm\";\n\t\t\tpublic const int ReplyToEmailParts = 3;\n\t\t\tpublic const string EmbeddedDocumentPropertyId = \"DocId\";\n\t\t\tpublic static readonly string ReplyToEmailAddressFormat = $\"{ReplyToEmail}+{{0}}@{{1}}\";\n\t\t}\n\n\t\t// TODO: The human workflow activities method LegacyElementName() should use these constants, also HumanActivityHelper should use these as well.\n\t\tpublic class HumanActivity\n\t\t{\n\t\t\tpublic const string ApproveDocumentsActivity = \"Approve Documents\";\n\t\t\tpublic const string ChoiceActivity = \"Choice\";\n\t\t\tpublic const string RoutingActivity = \"Routing\";\n\t\t\tpublic const string ChooseDocumentsActivity = \"Choose Documents\";\n\t\t\tpublic const string ChooseUsersActivity = \"Choose Users\";\n\t\t\tpublic const string CreateDocumentActivity = \"Create or Upload Doc\";\n\t\t\tpublic const string EditDocumentsActivity = \"Edit Documents\";\n\t\t\tpublic const string FillFormActivity = \"Fill Form\";\n\t\t\tpublic const string FullPageFillFormActivity = \"Full Page Fill Form\";\n\t\t\tpublic const string EditFormActivity = \"Edit Form\";\n\t\t\tpublic const string FullPageEditFormActivity = \"Full Page Edit Form\";\n\t\t\tpublic const string ReviewAndSendForExternalReviewActivity = \"Review and Send for External Review\";\n\t\t\tpublic const string ReviewAndSendForSignatureActivity = \"Review and Send for Signature\";\n\t\t\tpublic const string DataReview = \"Data Review\";\n\t\t\tpublic const string DataReconciliationActivity = \"Data Reconciliation\";\n\t\t\tpublic const string ReviewData = \"Review Data\";\n\t\t}\n\n\t\tpublic class HelpKeys\n\t\t{\n\t\t\t// Total char length of MainKey plus any individual key's string should not exceed 50 chars.\n\t\t\tpublic const string MainKey = \"HelpMessageDismissed_\"; //Length=21\n\n\t\t\tpublic const string AccountClone = MainKey + \"AccountClone\";\n\t\t\tpublic const string AccountContact = MainKey + \"AccountContact\";\n\t\t\tpublic const string AddressBook = MainKey + \"AddressBook\";\n\t\t\tpublic const string APIUsers = MainKey + \"APIUsers\";\n\t\t\tpublic const string AutoNumbers = MainKey + \"AutoNumbers\";\n\t\t\tpublic const string BPMEditDocuments = MainKey + \"BPMEditDocuments\";\n\t\t\tpublic const string BPMWorkList = MainKey + \"BPMWorkList\";\n\t\t\tpublic const string BrowseDocuments = MainKey + \"BrowseDocuments\";\n\t\t\tpublic const string BrowseForms = MainKey + \"BrowseForms\";\n\t\t\tpublic const string CaseViewer = MainKey + \"CaseViewer\";\n\t\t\tpublic const string CheckIn = MainKey + \"CheckIn\";\n\t\t\tpublic const string ConfigureToolbars = MainKey + \"ConfigureToolbars\";\n\t\t\tpublic const string ConfigureMenus = MainKey + \"ConfigureMenus\";\n\t\t\tpublic const string ConfigureMetadata = MainKey + \"ConfigureMetadata\";\n\t\t\tpublic const string ConfigureMetadataRelation = MainKey + \"ConfigureMetadataRelation\";\n\t\t\tpublic const string CreateContact = MainKey + \"CreateContact\";\n\t\t\tpublic const string CreateFolder = MainKey + \"CreateFolder\";\n\t\t\tpublic const string CreateFolderEditMode = MainKey + \"CreateFolderEditMode\";\n\t\t\tpublic const string CreateFolderLink = MainKey + \"CreateFolderLink\";\n\t\t\tpublic const string CreateFolderLinkEditMode = MainKey + \"CreateFolderLinkEditMode\";\n\t\t\tpublic const string CreateUser = MainKey + \"CreateUser\";\n\t\t\tpublic const string Dashboard = MainKey + \"Dashboard\";\n\t\t\tpublic const string DeviceManagement = MainKey + \"DeviceManagement\";\n\t\t\tpublic const string DocumentHistory = MainKey + \"DocumentHistory\";\n\t\t\tpublic const string DocumentRules = MainKey + \"DocumentRules\";\n\t\t\tpublic static string ElectronicSignature = MainKey + \"ElectronicSignature\";\n\t\t\tpublic const string Forms = MainKey + \"Forms\";\n\t\t\tpublic const string HelpMenu = MainKey + \"HelpMenu\";\n\t\t\tpublic const string ImportAddressBook = MainKey + \"ImportAddressBook\";\n\t\t\tpublic const string ImportGuests = MainKey + \"ImportGuests\";\n\t\t\tpublic const string ManageInboundEmail = MainKey + \"ManageInboundEmail\";\n\t\t\tpublic const string ManageKeywords = MainKey + \"ManageKeywords\";\n\t\t\tpublic const string MergedDocumentView = MainKey + \"MergedDocumentView\";\n\t\t\tpublic const string MetadataImportMappings = MainKey + \"MetadataImportMappings\";\n\t\t\tpublic const string MoveDocuments = MainKey + \"MoveDocuments\";\n\t\t\tpublic const string Packaging = MainKey + \"Packaging\";\n\t\t\tpublic const string PdfDelete = MainKey + \"PdfDelete\";\n\t\t\tpublic const string PdfRotate = MainKey + \"PdfRotate\";\n\t\t\tpublic const string PdfSplit = MainKey + \"PdfSplit\";\n\t\t\tpublic const string Preview = MainKey + \"Preview\";\n\t\t\tpublic const string QueryDesigner = MainKey + \"QueryDesigner\";\n\t\t\tpublic const string ReminderTemplates = MainKey + \"ReminderTemplates\";\n\t\t\tpublic const string ReportViewer = MainKey + \"ReportViewer\";\n\t\t\tpublic const string ReportCriteria = MainKey + \"ReportCriteria\";\n\t\t\tpublic const string Schedules = MainKey + \"Schedules\";\n\t\t\tpublic const string Search = MainKey + \"Search\";\n\t\t\tpublic const string Security = MainKey + \"Security\";\n\t\t\tpublic const string SecurityProgress = MainKey + \"SecurityProgress\";\n\t\t\tpublic const string SendDocuments = MainKey + \"SendDocuments\";\n\t\t\tpublic const string SendDocumentLinks = MainKey + \"SendDocumentLinks\";\n\t\t\tpublic const string SAMLSSOLinks = MainKey + \"SAMLSSOLinks\";\n\t\t\tpublic const string UploadContent = MainKey + \"UploadContent\";\n\t\t\tpublic const string VarAccountsManagement = MainKey + \"VarAccountsManagement\";\n\t\t\tpublic const string WorkflowConfirmSetup = MainKey + \"WorkflowConfirmSetup\";\n\t\t\tpublic const string WorkflowCreate = MainKey + \"WorkflowCreate\";\n\t\t\tpublic const string WorkflowConfiguration = MainKey + \"WorkflowConfiguration\";\n\t\t\tpublic const string WorkflowStart = MainKey + \"WorkflowStart\";\n\t\t\tpublic const string WorkflowWorklist = MainKey + \"WorkflowWorklist\";\n\t\t\tpublic const string WorkflowTemplates = MainKey + \"WorkflowTemplates\";\n\t\t}\n\n\t\tpublic class HttpContextCache\n\t\t{\n\t\t\tpublic const string ReportingServicesModel = \"ReportingServicesModel\";\n\t\t\tpublic const string RouteTemplate = \"RouteTemplate\";\n\t\t\tpublic const string RouteDictionary = \"RouteDictionary\";\n\t\t}\n\n\t\tpublic class HttpContextCookie\n\t\t{\n\t\t\tpublic const string COOKIE_NAME = \"SpringCMAtlas\";\n\t\t\tpublic const string AccountId = \"aid\";\n\t\t\tpublic const string UserId = \"uid\";\n\t\t\tpublic const string AlertPreference = \"AlertPreference\";\n\t\t\tpublic const string NewDocumentsReceivedPreference = \"NewDocumentsReceivedPreference\";\n\t\t\tpublic const string NavigationSplitter = \"Splitter\";\n\t\t\tpublic const string NavigationSplitterWidth = \"SplitterWidth\";\n\t\t\tpublic const string NavigationSplitterCollapsed = \"SplitterCollapsed\";\n\t\t\tpublic const string SESSION_ID = \"random\";\n\t\t\tpublic const string SESSION_IDPartitioned = \"randomPartitioned\";\n\t\t\tpublic const string LogoutToken = \"LogoutToken\";\n\t\t\tpublic const string FederatedAccountID = \"FederatedAccountID\";\n\t\t\tpublic const string UserAgeInHours = \"UserAge\";\n\t\t\tpublic const string AccountType = \"AccountType\";\n\t\t\tpublic const string SFDC = \"SFDC\";\n\t\t\tpublic const string Trial = \"Trial\";\n\t\t\tpublic const string SCMUser = \"SCM\";\n\t\t\tpublic const string AspNetSessionId = \"ASP.NET_SessionId\";\n\t\t\tpublic const string Language = \"_language\";\n\t\t\tpublic const string BTCookie = \"bt\";\n\t\t\tpublic const string SamlCookie = \"SamlCookie\";\n\t\t\tpublic const string SamlCookiePartitioned = \"SamlCookiePartitioned\";\n\t\t\tpublic const string IE11DeprecationOAuthClient = \"IE11DeprecationOAuthClient\";\n\t\t\tpublic const string IE11DeprecationOAuthClientPartitioned = \"IE11DeprecationOAuthClientPartitioned\";\n\t\t}\n\n\t\tpublic class IntellegoIntegration\n\t\t{\n\t\t\tpublic const string DocumentReferenceFormat = \"{0}_{1}_{2}\"; // {AccountId}_{DocumentUid}_{FileDataUid}\n\t\t}\n\n\t\tpublic class JavaScriptVars\n\t\t{\n\t\t\tpublic const string TempFileName = \"TempFileName\";\n\t\t\tpublic const string MimeType = \"mimeType\";\n\t\t\tpublic const string FileName = \"name\";\n\t\t\tpublic const string Size = \"size\";\n\t\t\tpublic const string Chunked = \"chunked\";\n\t\t\tpublic const string Error = \"error\";\n\t\t\tpublic const string JsonMimeType = \"application/json\";\n\t\t\tpublic const string LegacyHistoryPropertyName = \"__legacyMessage\";\n\t\t\tpublic const string LegacyHistoryRelatedDocumentUid = \"__legacyRelatedDocumentUid\";\n\t\t\tpublic const string LegacyHistoryRelatedDocumentVersion = \"__legacyReatedDocumentVersion\";\n\t\t\tpublic const string LegacyHistoryWorkflowInstanceUid = \"__legacyHistoryWorkflowInstanceUid\";\n\t\t\tpublic const string DocumentHistoryFolderPath = \"FolderPath\";\n\t\t\tpublic const string HistoryJsonData = \"__jsonData\";\n\t\t}\n\n\t\tpublic class SalesforceIntegration\n\t\t{\n\t\t\tpublic const string DefaultSFSubDomain = \"login\";\n\t\t}\n\n\t\tpublic class SparkJobVars\n\t\t{\n\t\t\tpublic const string Cassandra = \"cassandra\";\n\t\t\tpublic const string KespaceNames = \"keyspaceNames\";\n\t\t\tpublic const string History = \"history\";\n\t\t\tpublic const string AccountId = \"accountId\";\n\t\t\tpublic const string AllUsers = \"allUsers\";\n\t\t\tpublic const string UserAccountUid = \"userAccountUid\";\n\t\t\tpublic const string Email = \"email\";\n\t\t\tpublic const string StartDate = \"startDate\";\n\t\t\tpublic const string EndDate = \"endDate\";\n\t\t\tpublic const string BucketType = \"bucketType\";\n\t\t\tpublic const string SaveType = \"saveType\";\n\t\t\tpublic const string SqlConnectionString = \"sqlConnectionString\";\n\t\t\tpublic const string ReportUid = \"reportUid\";\n\t\t\tpublic const string UploadActionTypes = \"uploadActionTypes\";\n\t\t\tpublic const string Columns = \"columns\";\n\t\t\tpublic const string Filters = \"filters\";\n\t\t\tpublic const string Threshold = \"threshold\";\n\t\t\tpublic const string TimeZone = \"timezoneid\";\n\t\t\tpublic const string Limit = \"limit\";\n\t\t\tpublic const string userName = \"spark.cassandra.auth.username\";\n\t\t\tpublic const string password = \"spark.cassandra.auth.password\";\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Values here must be public const strings. These are read using reflection in MetadataGroupRepository.cs\n\t\t/// </summary>\n\t\tpublic class SystemMetadataGroupNames\n\t\t{\n\t\t\tpublic const string EMAIL = \"Email\";\n\t\t\tpublic const string FAX = \"Fax\";\n\t\t\tpublic const string SFORCE = \"SForce\";\n\t\t\tpublic const string METAGROUP_ATTACHMENT = \"Document Attachment Set\";\n\t\t\tpublic const string XOBJECT = \"Spring External Object Reference\";\n\t\t\tpublic const string VIDEO_INFO = \"SpringCM-VideoInfo\";\n\t\t\tpublic const string OCR_SPLIT = \"SpringOCRSplitStatus\";\n\t\t\tpublic const string TERM_SYNC = \"SpringCM Term Sync\";\n\t\t\tpublic const string DOCUSIGN_AGREEMENT_STATUS = \"DocuSign Agreement Group\";\n\t\t\tpublic const string CLM_AGREEMENT_DETAILS = \"CLM Agreement Details\";\n\t\t\tpublic const string CLM_PARTY = \"CLM Party\";\n\t\t}\n\n\t\t//TODO combine w/PostVariables as RequestParameters\n\t\t//TODO refactor multiple different things into same one (eg. AccountIdAbbreviated, AccountId)-> AccountId\n\t\tpublic class QueryStringParameters\n\t\t{\n\t\t\tpublic const string AccessKey = \"ak\";\n\t\t\tpublic const string AccountId_LEGACY_DONT_USE = \"accountId\";\n\t\t\tpublic const string AccountIdAbbreviated = \"aid\";\n\t\t\tpublic const string AccountIdToClone = \"accountIdToClone\";\n\t\t\tpublic const string Action = \"action\";\n\t\t\tpublic const string ActionType = \"actionType\";\n\t\t\tpublic const string AdvancedSearchQuery = \"asq\";\n\t\t\tpublic const string AdvanceStyle = \"AdvanceStyle\";\n\t\t\tpublic const string AgreementAnalyzer = \"AgreementAnalyzer\";\n\t\t\tpublic const string ApiKey = \"apikey\";\n\t\t\tpublic const string ApiServerUrl = \"apiServerURL\";\n\t\t\tpublic const string ApprovalWorkflowUid = \"approvalWorkflowUid\";\n\t\t\tpublic const string Attributes = \"attributes\";\n\t\t\tpublic const string AuthorizationToken = \"authz\";\n\t\t\tpublic const string BPMExecutionId = \"wid\";\n\t\t\tpublic const string BPMMultipleWorkflows = \"multiple\";\n\t\t\tpublic const string BPMWorkItemId = \"wiid\";\n\t\t\tpublic const string BPMWorkflowName = \"bpmwn\";\n\t\t\tpublic const string BPMWorkflowVersion = \"bpmwv\";\n\t\t\tpublic const string CancelRename = \"cancelRename\";\n\t\t\tpublic const string CancelTransaction = \"CancelTransaction\";\n\t\t\tpublic const string CancelUrl = \"cu\";\n\t\t\tpublic const string CanSelectFolders = \"CanSelectFolders\";\n\t\t\tpublic const string CanSelectUrls = \"CanSelectUrls\";\n\t\t\tpublic const string CaseUid = \"caseUid\";\n\t\t\tpublic const string ClientId = \"client_id\";\n\t\t\tpublic const string code = \"code\";\n\t\t\tpublic const string CollaborationId = \"collaborationId\";\n\t\t\tpublic const string CollaborationUid = \"collaborationUid\";\n\t\t\tpublic const string Columns = \"columns\";\n\t\t\tpublic const string ColumnWrap = \"ColumnWrap\";\n\t\t\tpublic const string Comments = \"comments\";\n\t\t\tpublic const string CompleteExternalReview = \"CompleteExternalReview\";\n\t\t\tpublic const string ConfigUid = \"configUid\";\n\t\t\tpublic const string Confirmation = \"confirmation\";\n\t\t\tpublic const string ConfirmationType = \"type\";\n\t\t\tpublic const string ContactUid = \"contactUid\";\n\t\t\tpublic const string CorrelationId = \"correlationId\";\n\t\t\tpublic const string Cid = \"cid\";\n\t\t\tpublic const string Culture = \"cul\";\n\t\t\tpublic const string CurrentTab = \"CurrentTab\";\n\t\t\tpublic const string CurrentUrl = \"CurrentUrl\";\n\t\t\tpublic const string CustomReportUid = \"customReportUid\";\n\t\t\tpublic const string CustomRuleUid = \"RuleUid\";\n\t\t\tpublic const string CustomRuleKind = \"RuleKind\";\n\t\t\tpublic const string Default = \"default\";\n\t\t\tpublic const string Degrees = \"degrees\";\n\t\t\tpublic const string Dev = \"dev\";\n\t\t\tpublic const string DocumentAttributeTypeId = \"LDTID\";\n\t\t\tpublic const string DocumentIdAbbreviated = \"ldid\";\n\t\t\tpublic const string DocumentId = \"documentId\";\n\t\t\tpublic const string SelectedDocumentIds = \"documentIds\";\n\t\t\tpublic const string DocumentUid = \"ldUid\";\n\t\t\tpublic const string DocumentUidExpanded = \"documentUid\";\n\t\t\tpublic const string DocumentUids = \"DocumentUids\";\n\t\t\tpublic const string Download = \"download\";\n\t\t\tpublic const string DocumentTitle = \"title\";\n\t\t\tpublic const string DocumentHistoryFilter = \"historyfilter\";\n\t\t\tpublic const string DPBUid = \"dpbuid\";\n\t\t\tpublic const string Ds = \"ds\";\n\t\t\tpublic const string DocuSignAccountId = \"accountId\";\n\t\t\tpublic const string DocuSignAccountIdAbbreviated = \"dsaid\";\n\t\t\tpublic const string DocuSignGroupId = \"dsgroupId\";\n\t\t\tpublic const string DocuSignUserId = \"dsuserId\";\n\t\t\tpublic const string ElectronicSignature = \"ElectronicSignature\";\n\t\t\tpublic const string DocumentExtract = \"DocumentExtract\";\n\t\t\tpublic const string DocumentDeletePages = \"DocumentDeletePages\";\n\t\t\tpublic const string DocumentRotate = \"DocumentRotate\";\n\t\t\tpublic const string EnableGuests = \"enableGuests\";\n\t\t\tpublic const string EnableMultiselection = \"EnableMultiselection\";\n\t\t\tpublic const string EosParamsToken = \"eostoken\";\n\t\t\tpublic const string DPI = \"DPI\";\n\t\t\tpublic const string Draft = \"draft\";\n\t\t\tpublic const string EditMode = \"EditMode\";\n\t\t\tpublic const string Email = \"email\";\n\t\t\tpublic const string EnableContacts = \"enableContacts\";\n\t\t\tpublic const string EnableDistributionGroups = \"enableDistGroups\";\n\t\t\tpublic const string EnableFullSubscribers = \"enableFS\";\n\t\t\tpublic const string EnableLimitedSubscribers = \"enableLS\";\n\t\t\tpublic const string EnableSecurityGroups = \"enableSecurityGroups\";\n\t\t\tpublic const string EnableQueue = \"enableQueue\";\n\t\t\tpublic const string EnableSuperAdministrators = \"enableSuperAdminis\";\n\t\t\tpublic const string EnableUserAdministrators = \"enableUserAdmins\";\n\t\t\tpublic const string EnableUsers = \"enableUsers\";\n\t\t\tpublic const string EndDate = \"enddate\";\n\t\t\tpublic const string EosPath = \"eosPath\";\n\t\t\tpublic const string ESignatureUid = \"ESignatureUid\";\n\t\t\tpublic const string DocuSignEvent = \"event\";\n\t\t\tpublic const string ExpandedValues = \"ExpandedValues\";\n\t\t\tpublic const string Expired = \"expired\";\n\t\t\tpublic const string ExternalReviewUid = \"ERUid\";\n\t\t\tpublic const string ExternalReview = \"ExternalReview\";\n\t\t\tpublic const string ExternalReviewAttachmentUid = \"XrAttachmentUid\";\n\t\t\tpublic const string CompleteInternally = \"CompleteInternally\";\n\t\t\tpublic const string DlcName = \"dlcname\";\n\t\t\tpublic const string Fax = \"fax\";\n\t\t\tpublic const string FeelLucky = \"FeelLucky\";\n\t\t\tpublic const string Filetype = \"Filetype\";\n\t\t\tpublic const string Forms = \"forms\";\n\t\t\tpublic const string SingleResultShowPreview = \"SingleResultShowPreview\";\n\t\t\tpublic const string FileDataUid = \"fdUid\";\n\t\t\tpublic const string FileMoveStyle = \"FileMoveStyle\";\n\t\t\tpublic const string FindLargerThan = \"largerThan\";\n\t\t\tpublic const string FolderId = \"fid\";\n\t\t\tpublic const string FolderLinkUid = \"flUid\";\n\t\t\tpublic const string FolderPath = \"folderPath\";\n\t\t\tpublic const string FolderUid = \"fUid\";\n\t\t\tpublic const string ForceReturn = \"forceReturn\";\n\t\t\tpublic const string RootFolderUid = \"rootFolderUid\";\n\t\t\tpublic const string ForAdvancedWorkflowUse = \"ForAdvancedWorkflowUse\";\n\t\t\tpublic const string ForceNewSearch = \"forceNewSearch\";\n\t\t\tpublic const string ForceScriptLogger = \"scriptlog\";\n\t\t\tpublic const string FormContainer = \"FormContainer\";\n\t\t\tpublic const string FormUid = \"FormUid\";\n\t\t\tpublic const string Format = \"Format\";\n\t\t\tpublic const string Forwarded = \"forwarded\";\n\t\t\tpublic const string GroupUid = \"groupUid\";\n\t\t\tpublic const string GroupDataUids = \"groupDataUids\";\n\t\t\tpublic const string HideAddressBookFilters = \"hideAddressBookFilters\";\n\t\t\tpublic const string ShowContinueButton = \"scb\";\n\t\t\tpublic const string HideInboxes = \"HideInboxes\";\n\t\t\tpublic const string HideTrash = \"HideTrash\";\n\t\t\tpublic const string HidePdfToolbar = \"hideToolbar\";\n\t\t\tpublic const string Id = \"Id\";\n\t\t\tpublic const string Ids = \"Ids\";\n\t\t\tpublic const string Uid = \"Uid\";\n\t\t\tpublic const string SetUid = \"SetUid\";\n\t\t\tpublic const string IncludeComments = \"IncludeComments\";\n\t\t\tpublic const string IncludeLexionMetadata = \"IncludeLexionMetadata\";\n\t\t\tpublic const string IncludeDocuments = \"IncludeDocuments\";\n\t\t\tpublic const string IncludeFolders = \"IncludeFolders\";\n\t\t\tpublic const string IncludeChildren = \"IncludeChildren\";\n\t\t\tpublic const string IncludeFolderPath = \"IncludeFolderPath\";\n\t\t\tpublic const string IncludeSource = \"IncludeSource\";\n\t\t\tpublic const string IncludeTrashed = \"IncludeTrashed\";\n\t\t\tpublic const string Inline = \"inline\";\n\t\t\tpublic const string InSubFolders = \"inSubfolders\";\n\t\t\tpublic const string IsApproved = \"isApproved\";\n\t\t\tpublic const string IsAggregate = \"isAggregate\";\n\t\t\tpublic const string IsMobile = \"ismobile\";\n\t\t\tpublic const string IsPassiveSearch = \"isPassiveSearch\";\n\t\t\tpublic const string IsProcessInsights = \"isProcessInsights\";\n\t\t\tpublic const string IsSavedSearch = \"isSavedSearch\";\n\t\t\tpublic const string ItemActionXml = \"iax\";\n\t\t\tpublic const string Iterator = \"iter\";\n\t\t\tpublic const string IsPopup = \"popup\";\n\t\t\tpublic const string Key = \"Key\";\n\t\t\tpublic const string Keyword = \"Keyword\";\n\t\t\tpublic const string Language = \"ln\";\n\t\t\tpublic const string Libraries = \"libraries\";\n\t\t\tpublic const string LimitToGroups = \"limitToGroupUids\";\n\t\t\tpublic const string LimitToTaskGroups = \"limitToTaskGroupUids\";\n\t\t\tpublic const string LoadingRoot = \"loadingRoot\";\n\t\t\tpublic const string LoadExisting = \"LoadExisting\";\n\t\t\tpublic const string LoadWriteAccessOnly = \"LoadWriteAccessOnly\";\n\t\t\tpublic const string LogHistory = \"lh\";\n\t\t\tpublic const string LoginDelegationId = \"delid\";\n\t\t\tpublic const string LoginClear = \"lc\";\n\t\t\tpublic const string LoginUid = \"LoginUid\";\n\t\t\tpublic const string LogOut = \"LogOut\";\n\t\t\tpublic const string MemberOf = \"MemberOf\";\n\t\t\tpublic const string MenuId = \"menuId\";\n\t\t\tpublic const string MergeUid = \"mergeuid\";\n\t\t\tpublic const string MetadataGroupUid = \"MetadataGroupUid\";\n\t\t\tpublic const string MetadataGroupUids = \"MetadataGroupUids\";\n\t\t\tpublic const string MergeSuccess = \"MergeSuccess\";\n\t\t\tpublic const string MergeError = \"MergeError\";\n\t\t\tpublic const string MergeInfo = \"MergeInfo\";\n\t\t\tpublic const string MessageRef = \"MessageRef\";\n\t\t\tpublic const string Mode = \"mode\";\n\t\t\tpublic const string ModifiedBy = \"modifiedBy\";\n\t\t\tpublic const string ModifiedDateStart = \"modifiedDateStart\";\n\t\t\tpublic const string ModifiedDateEnd = \"modifiedDateEnd\";\n\t\t\tpublic const string Name = \"Name\";\n\t\t\tpublic const string Nav = \"nav\";\n\t\t\tpublic const string NewAccount = \"newaccount\";\n\t\t\tpublic const string NewTrial = \"newtrial\";\n\t\t\tpublic const string NewReport = \"newReport\";\n\t\t\tpublic const string NotComplete = \"nc\";\n\t\t\tpublic const string NoCopy = \"NoCopy\";\n\t\t\tpublic const string NotifyFrequency = \"nf\";\n\t\t\tpublic const string ObjectUid = \"oUid\";\n\t\t\tpublic const string ObjectType = \"oType\";\n\t\t\tpublic const string ObligationId = \"obligationId\";\n\t\t\tpublic const string OneClickDocGen = \"oneclickdocgen\";\n\t\t\tpublic const string OnlyAPIUsers = \"onlyAPIUsers\";\n\t\t\tpublic const string OnlyWorkflow = \"onlyWF\";\n\t\t\tpublic const string OrgId = \"orgid\";\n\t\t\tpublic const string OwnedByUser = \"OwnedByUser\";\n\t\t\tpublic const string Page = \"page\";\n\t\t\tpublic const string PageNumber = \"PageNumber\";\n\t\t\tpublic const string PageSize = \"PageSize\";\n\t\t\tpublic const string PartyId = \"partyId\";\n\t\t\tpublic const string PasswordStrengthInvalid = \"psInvalid\";\n\t\t\tpublic const string Pdf = \"pdf\";\n\t\t\tpublic const string PDFView = \"PDFView\";\n\t\t\tpublic const string PreviousDocumentUid = \"prevldUid\";\n\t\t\tpublic const string PreviousObjectUid = \"prevoUid\";\n\t\t\tpublic const string PreviousObjectType = \"prevotype\";\n\t\t\tpublic const string ProcessUid = \"processUid\";\n\t\t\tpublic const string Prompt = \"prompt\";\n\t\t\tpublic const string PublicShareLinkUid = \"pslUid\";\n\t\t\tpublic const string QA = \"qa\"; // Query-Attributes for search...\n\t\t\tpublic const string Q = \"q\";\n\t\t\tpublic const string Query = \"query\";\n\t\t\tpublic const string QueryExclude = \"queryExclude\";\n\t\t\tpublic const string QueryAny = \"queryAny\";\n\t\t\tpublic const string QueryPhase = \"queryPhrase\";\n\t\t\tpublic const string QueueId = \"qid\";\n\t\t\tpublic const string ReadOnly = \"readonly\";\n\t\t\tpublic const string Reload = \"reload\";\n\t\t\tpublic const string RenderPartial = \"renderPartial\";\n\t\t\tpublic const string ReminderUid = \"ReminderUid\";\n\t\t\tpublic const string ReportExportFormat = \"reportExportFormat\";\n\t\t\tpublic const string ReportName = \"reportName\";\n\t\t\tpublic const string ReportKey = \"reportKey\";\n\t\t\tpublic const string ReportPath = \"ReportPath\";\n\t\t\tpublic const string ReportSortInfo = \"reportSortInfo\";\n\t\t\tpublic const string ReportSearchQuery = \"reportSearchQuery\";\n\t\t\tpublic const string ReportViewType = \"reportViewType\";\n\t\t\tpublic const string ReportType = \"reportType\";\n\t\t\tpublic const string ReportUid = \"reportUid\";\n\t\t\tpublic const string ReportContext = \"rptctx\";\n\t\t\tpublic const string RequestMode = \"requestMode\";\n\t\t\tpublic const string Required = \"required\";\n\t\t\tpublic const string Resume = \"resume\";\n\t\t\tpublic const string ResxRef = \"resxref\";\n\t\t\tpublic const string ReturnUrl = \"ru\";\n\t\t\tpublic const string relayState = \"relayState\";\n\t\t\tpublic const string Role = \"role\";\n\t\t\tpublic const string RuleId = \"ruleId\";\n\t\t\tpublic const string SavedSearchUid = \"ssUid\";\n\t\t\tpublic const string SavedSearchId = \"savedSearchId\";\n\t\t\tpublic const string ScmEosPath = \"ScmPath\";\n\t\t\tpublic const string ScheduleUid = \"schedUid\";\n\t\t\tpublic const string SearchAllAttributes = \"searchAllAttributes\";\n\t\t\tpublic const string SearchId = \"searchId\";\n\t\t\tpublic const string SearchContent = \"searchContent\";\n\t\t\tpublic const string SearchDescription = \"searchDescription\";\n\t\t\tpublic const string SearchMode = \"SearchMode\";\n\t\t\tpublic const string SearchName = \"searchName\";\n\t\t\tpublic const string SearchSource = \"searchSource\";\n\t\t\tpublic const string SearchType = \"SearchType\";\n\t\t\tpublic const string Secure = \"secure\";\n\t\t\tpublic const string SelectedAccountId = \"said\";\n\t\t\tpublic const string SelectedNamespace = \"SelectedNamespace\";\n\t\t\tpublic const string SelectedNavTab = \"SelectedNavTab\";\n\t\t\tpublic const string Selection = \"Selection\";\n\t\t\tpublic const string SendForApproval = \"SendForApproval\";\n\t\t\tpublic const string ServerIP = \"ServerIP\";\n\t\t\tpublic const string SFAccountId = \"sfaid\";\n\t\t\tpublic const string SFAccountName = \"sfaname\";\n\t\t\tpublic const string SFAPIUrl = \"sfapiurl\";\n\t\t\tpublic const string SFChildId = \"sfchildid\";\n\t\t\tpublic const string SFObjectId = \"sfoid\";\n\t\t\tpublic const string SFObjectName = \"sfon\";\n\t\t\tpublic const string SFObjectType = \"sfot\";\n\t\t\tpublic const string SFRetURL = \"sfreturl\";\n\t\t\tpublic const string SFSessionId = \"sfsid\";\n\t\t\tpublic const string SFSpringView = \"springview\";\n\t\t\tpublic const string ShareType = \"ShareType\";\n\t\t\tpublic const string ShowDisabledUsers = \"ShowDisabledUsers\";\n\t\t\tpublic const string ShowSuccessOnSave = \"ShowSuccessOnSave\";\n\t\t\tpublic const string SignedRequest = \"signed_request\";\n\t\t\tpublic const string SAMLResponse = \"SAMLResponse\";\n\t\t\tpublic const string SAMLRequest = \"SAMLRequest\";\n\t\t\tpublic const string SAMLMetadata = \"SAMLMetadata\";\n\t\t\tpublic const string TargetRestriction = \"TargetRestriction\";\n\t\t\tpublic const string Size = \"size\";\n\t\t\tpublic const string Sort = \"sort\";\n\t\t\tpublic const string StartDate = \"startdate\";\n\t\t\tpublic const string SSOMode = \"SSOMode\";\n\t\t\tpublic const string StartMigration = \"startMigration\";\n\t\t\tpublic const string State = \"state\";\n\t\t\tpublic const string SuppressNavigation = \"SuppressNavigation\";\n\t\t\tpublic const string SUri = \"suri\";\n\t\t\tpublic const string SwitchToAccountId = \"switchaid\";\n\t\t\tpublic const string SwitchFromSiteName = \"switchfromsitename\";\n\t\t\tpublic const string Tab = \"tab\";\n\t\t\tpublic const string TabWas = \"TabWas\";\n\t\t\tpublic const string Target = \"Target\";\n\t\t\tpublic const string TargetFolderUid = \"tfUid\";\n\t\t\tpublic const string TaskUid = \"taskUid\";\n\t\t\tpublic const string TermSync = \"termSync\";\n\t\t\tpublic const string TimeStamp = \"ts\"; //generic time stamp\n\t\t\tpublic const string Token = \"token\";\n\t\t\tpublic const string Tour = \"tour\";\n\t\t\tpublic const string TransDocUid = \"transDocUid\";\n\t\t\tpublic const string TransReportName = \"transReportName\";\n\t\t\tpublic const string TransUid = \"transUid\";\n\t\t\tpublic const string TransType = \"transtype\";\n\t\t\tpublic const string TreeViewType = \"TreeViewType\";\n\t\t\tpublic const string TreeViewVisible = \"TreeViewVisible\";\n\t\t\tpublic const string Type = \"Type\";\n\t\t\tpublic const string UniqueKey = \"uk\";\n\t\t\tpublic const string Upgrade = \"upgrade\";\n\t\t\tpublic const string UploadToken = \"uploadToken\";\n\t\t\tpublic const string Url = \"url\";\n\t\t\tpublic const string UserId = \"userId\";\n\t\t\tpublic const string UserAccountUid = \"userAccountUid\";\n\t\t\tpublic const string UseInternalSSOCert = \"useInternalSSOCert\";\n\t\t\tpublic const string UserIds = \"UserIds\";\n\t\t\tpublic const string UserKey = \"userkey\";\n\t\t\tpublic const string UserLoginEmail = \"uEmail\";\n\t\t\tpublic const string UserName = \"username\";\n\t\t\tpublic const string UserPassword = \"uPwd\";\n\t\t\tpublic const string Viewer = \"view\";\n\t\t\tpublic const string VisibleColumns = \"visibleColumns\";\n\t\t\tpublic const string WaitForNextStep = \"wait\";\n\t\t\tpublic const string WidgetUid = \"widgetUid\";\n\t\t\tpublic const string WorkflowInbox = \"workflowinbox\";\n\t\t\tpublic const string WorkflowItemId = \"wfid\";\n\t\t\tpublic const string WorkflowInstanceUid = \"workflowinstanceuid\";\n\t\t\tpublic const string WorkFlowStepUid = \"WorkFlowStepUid\";\n\t\t\tpublic const string WorkFlowParams = \"params\";\n\t\t\tpublic const string WorkflowName = \"workflowname\";\n\t\t\tpublic const string WorkflowDefinition = \"workflowdefinition\";\n\t\t\tpublic const string WorkflowVersion = \"workflowversion\";\n\t\t\tpublic const string WorkflowRevision = \"workflowrevision\";\n\t\t\tpublic const string WorkflowTemplateId = \"templateId\";\n\t\t\tpublic const string Zoom = \"Zoom\";\n\t\t\tpublic const string SearchPayloadId = \"searchPayloadId\";\n\t\t\tpublic const string ForceReauth = \"force_reauth\";\n\n\t\t\tpublic class OAuth2\n\t\t\t{\n\t\t\t\tpublic const string Code = \"code\";\n\t\t\t\tpublic const string State = \"state\";\n\t\t\t\tpublic const string AccessToken = \"access_token\";\n\t\t\t\tpublic const string TokenType = \"token_type\";\n\t\t\t\tpublic const string ExpiresIn = \"expires_in\";\n\t\t\t}\n\t\t}\n\n\t\t//TODO combine w/QueryStringParameters as RequestParameters\n\t\tpublic class PostVariables\n\t\t{\n\t\t\tpublic const string EventTarget = \"__EVENTTARGET\";\n\t\t\tpublic const string iRole = \"iRole\";\n\t\t\tpublic const string BasicSearchSide = \"BasicSearchSide\";\n\t\t\tpublic const string BasicSearchMain = \"BasicSearchMain\";\n\t\t\tpublic const string txtCompany = \"txtCompany\";\n\t\t\tpublic const string txtContent = \"txtContent\";\n\t\t\tpublic const string txtEmail = \"txtEmail\";\n\t\t\tpublic const string txtFirstName = \"txtFirstName\";\n\t\t\tpublic const string txtFromDate = \"txtFromDate\";\n\t\t\tpublic const string txtKeywords = \"txtKeywords\";\n\t\t\tpublic const string txtLastName = \"txtLastName\";\n\t\t\tpublic const string txtSentFrom = \"txtSentFrom\";\n\t\t\tpublic const string txtTitle = \"txtTitle\";\n\t\t\tpublic const string txtToDate = \"txtToDate\";\n\t\t\tpublic const string RenameText = \"RenameText\";\n\t\t\tpublic const string tbxDocumentName = \"tbxDocumentName\";\n\t\t\tpublic const string ckbExpDate = \"ckbExpDate\";\n\t\t\tpublic const string tbxExpDate = \"tbxExpDate\";\n\t\t\tpublic const string ckbReminderDate = \"ckbReminderDate\";\n\t\t\tpublic const string tbxReminderDate = \"tbxReminderDate\";\n\t\t\tpublic const string tbxDocumentKeywords = \"tbxDocumentKeywords\";\n\t\t\tpublic const string Pages = \"pages\";\n\t\t\tpublic const string SFObjectXml = \"ObjectXml\";\n\t\t}\n\n\t\tpublic class ReportRegexStrings\n\t\t{\n\t\t\tpublic const string RegexDateOffsetsBegin = \"^[+-]{0,1}[0-9]+\";\n\t\t\tpublic const string RegexDateOffsetsEnd = \"[dmywq]\";\n\t\t\tpublic const string RegexDateOffsets = RegexDateOffsetsBegin + RegexDateOffsetsEnd;\n\t\t}\n\n\n\t\tpublic class ExtractService\n\t\t{\n\t\t\tpublic const string TextExtractorExtensions = \"TextExtractorExtensions\";\n\t\t\tpublic const string OCRExtractorExtensions = \"OCRExtractorExtensions\";\n\n\t\t\tpublic const string ExtractMaxRetries = \"ExtractMaxRetries\";\n\t\t\tpublic const string ExtractSleepSeconds = \"ExtractSleepSeconds\";\n\t\t\tpublic const string MaxFileSize = \"MaxFileSize\";\n\t\t\tpublic const string ExtractOcrPdfImageThresholdPercentHeight = \"ExtractOcrPdfImageThresholdPercentHeight\";\n\t\t\tpublic const string ExtractOcrPdfImageThresholdPercentWidth = \"ExtractOcrPdfImageThresholdPercentWidth\";\n\t\t\tpublic const string ExtractOcrContentPerPageThreshold = \"ExtractOcrContentPerPageThreshold\";\n\t\t\tpublic const string ExtractOcrContentPerPageMaxThreshold = \"ExtractOcrContentPerPageMaxThreshold\";\n\t\t\tpublic const string MinPriority = \"MinPriority\";\n\t\t\tpublic const string ExtractOcrPdfContentThreshold = \"ExtractOcrPdfContentThreshold\";\n\t\t\tpublic const string PdfFallBackFileSizeThreshold = \"PdfFallBackFileSizeThreshold\";\n\t\t\tpublic const string PdfFallBackMinutesThreshold = \"PdfFallBackMinutesThreshold\";\n\n\t\t\tpublic const string OCRDefaultEngineProfile = \"OCRDefaultEngineProfile\";\n\t\t\tpublic const string OCRAccurateEngineProfile = \"OCRAccurateEngineProfile\";\n\t\t\tpublic const string LicenseNumberFlexiCapture = \"LicenseNumberFlexiCapture\";\n\t\t\tpublic const string LicenseNumber = \"LicenseNumber\";\n\t\t\tpublic const string SerialNumber = \"SerialNumber\";\n\t\t\tpublic const string OCREnginePath = \"OCREnginePath\";\n\t\t\tpublic const string OCRConfigLocation = \"OCRConfigLocation\";\n\t\t\tpublic const string OCREngineProfileLoadAttempts = \"OCREngineProfileLoadAttempts\";\n\n\t\t\tpublic const string ExtractTaskTempStorageLocation = \"ExtractTaskTempStorageLocation\";\n\t\t}\n\n\t\tpublic class DocumentCompare\n\t\t{\n\t\t\tpublic const string RequestNamePrefix = \"DocumentCompareRequest_\";\n\t\t\tpublic const string CompareResultDeafultFilename = \"Compare-\";\n\t\t}\n\n\t\tpublic class OliveImageAssetNames\n\t\t{\n\t\t\tpublic const string docusignLogoDefault = \"ds-logo-default.svg\";\n\t\t\tpublic const string docusignFaviconDefault = \"ds-icons-favicon-default-64x64.svg\";\n\t\t\tpublic const string docusignEmailLogoDefault = \"email-templates/email-logo.png\";\n\t\t}\n\n\t\tpublic static class DocGen\n\t\t{\n\t\t\tpublic const string AllPagesExpression = \"all\";\n\t\t\tpublic const string DocxExtension = \"docx\";\n\t\t\tpublic const string PdfExtension = \"pdf\";\n\t\t\tpublic const string XmlExtension = \"xml\";\n\n\t\t\t// field names\n\t\t\tpublic const string SectionFieldName = \"Section\";\n\t\t\tpublic const string TextFieldFieldName = \"Text Field\";\n\t\t\tpublic const string TextBoxFieldName = \"Text Box\";\n\t\t\tpublic const string RichTextFieldName = \"Rich Text Box\";\n\t\t\tpublic const string DateFieldName = \"Date Field\";\n\t\t\tpublic const string AttachmentFieldName = \"Attachment\";\n\t\t\tpublic const string CheckboxFieldName = \"Check Box\";\n\t\t\tpublic const string NumberFieldName = \"Number\";\n\t\t\tpublic const string CurrencyFieldName = \"Currency\";\n\t\t\tpublic const string RadioButtonsFieldName = \"Radio Buttons\";\n\t\t\tpublic const string DropdownFieldName = \"Dropdown\";\n\n\t\t\tpublic const string DateFormatProperty = \"DateFormat\";\n\t\t\tpublic const string NumberFormatProperty = \"NumberFormat\";\n\t\t\tpublic const string CurrencyFormatProperty = \"CurrencyFormat\";\n\t\t\tpublic const string FormatProperty = \"Format\";\n\t\t\tpublic const string TargetIdentifierProperty = \"TargetIdentifier\";\n\n\t\t\t// API data source/target property keys\n\t\t\tpublic const string SalesforceRootObjectKey = \"SalesforceRootObject\";\n\n\t\t\t//field configuration transformers\n\t\t\tpublic const string TypeConvertToDecimal = \"TypeConvertToDecimal\";\n\t\t\tpublic const string NumericFormatTransformer = \"NumericFormatTransformer\";\n\n\t\t\t//field configuration default value\n\t\t\tpublic const string ExactNumberOfDigitsDefaultValue = \"6\";\n\t\t\tpublic const string DecimalPlacesDefaultValue = \"2\";\n\t\t\tpublic const string ThousandSeparatorDefaultValue = \",\";\n\t\t\tpublic const string DecimalSeparatorDefaultValue = \".\";\n\t\t\tpublic const string DigitGroupingIndexDefaultValue = \"0\";\n\n\t\t\t//validation parameters\n\t\t\tpublic const string Percent = \"percent\";\n\t\t\tpublic const string Decimal = \"decimal\";\n\t\t\tpublic const string Number = \"number\";\n\t\t\tpublic const string Dollar = \"dollar\";\n\n\t\t\t//Field Format Properties\n\t\t\tpublic const string DecimalSeparator = \"DecimalSeparator\";\n\t\t\tpublic const string ThousandSeparator = \"ThousandSeparator\";\n\t\t\tpublic const string ExactNumberOfDigits = \"ExactNumberOfDigits\";\n\t\t\tpublic const string DecimalPlaces = \"DecimalPlaces\";\n\n\t\t\t//field configuration format min max values\n\t\t\tpublic const int MinimumNumberOfDecimals = 0;\n\t\t\tpublic const int MaximumNumberOfDecimals = 15;\n\t\t\tpublic const int MaximumNumberOfDigits = 15;\n\n\t\t\t// radio buttons constants\n\t\t\tpublic const string OptionsRegexPattern = \"[a-zA-Z0-9]\";\n\t\t\tpublic const int OptionsLimit = 50;\n\n\t\t\t//Merge tag types\n\t\t\tpublic const string MergeTagTypeContent = \"Content\";\n\t\t\tpublic const string MergeTagTypeRichText = \"RichText\";\n\n\t\t\t/// <summary>\n\t\t\t/// See <a href=\"http://www.websupergoo.com/helppdf6net/source/3-concepts/2-objectinfo.htm\">here</a>.\n\t\t\t/// </summary>\n\t\t\tpublic const string ROTATE_INFO_TYPE = \"/Rotate\";\n\n\t\t\tpublic const string MERGE_ENGINE_OVERRIDE_GROUP_NAME = \"springcm merge engine\";\n\t\t\tpublic const string MERGE_ENGINE_OVERRIDE_FIELD_NAME_CURRENT = \"use current\";\n\t\t\tpublic const string MERGE_ENGINE_OVERRIDE_FIELD_NAME_LEGACY = \"use legacy\";\n\t\t}\n\n\t\tpublic static class FieldConfigTemplateIds\n\t\t{\n\t\t\tpublic const string Textfield = \"textfield\";\n\t\t\tpublic const string Numberfield = \"numberfield\";\n\t\t\tpublic const string Currencyfield = \"currencyfield\";\n\t\t\tpublic const string Textbox = \"textbox\";\n\t\t\tpublic const string Checkbox = \"checkbox\";\n\t\t\tpublic const string Sxterm = \"sxterm\";\n\t\t\tpublic const string Dropdown = \"dropdown\";\n\t\t\tpublic const string MultiSelectDropdown = \"multi-select-dropdown\";\n\t\t\tpublic const string RadioButton = \"radio-button\";\n\t\t\tpublic const string DateField = \"date-field\";\n\t\t\tpublic const string Section = \"section\";\n\t\t\tpublic const string Heading = \"heading\";\n\t\t\tpublic const string Table = \"table\";\n\t\t\tpublic const string CustomTable = \"custom-table\";\n\t\t\tpublic const string Column = \"column\";\n\t\t\tpublic const string AdvancedMode = \"advanced-mode\";\n\t\t\tpublic const string TableRecord = \"table-record\";\n\t\t\tpublic const string Record = \"record\";\n\t\t\tpublic const string LibraryFile = \"library-file\";\n\t\t\tpublic const string CsvRowChooser = \"csv-row-chooser\";\n\t\t\tpublic const string CsvField = \"csv-field\";\n\t\t\tpublic const string Attachment = \"attachment\";\n\t\t\tpublic const string Actor = \"actor\";\n\t\t\tpublic const string CustomTableColumn = \"custom-table-column\";\n\t\t}\n\n\t\tpublic class AgreementCloudEditor\n\t\t{\n\t\t\tpublic const string AdftExtension = \".adft\";\n\t\t\tpublic const string HtmlExtension = \".html\";\n\t\t}\n\n\t\tpublic static class FieldConfigLibraryFields\n\t\t{\n\t\t\tpublic const string LibraryField = \"Library Field\";\n\t\t\tpublic const string External = \"External\";\n\t\t}\n\n\t\tpublic class SmartSuggestions\n\t\t{\n\t\t\tpublic const string SuggestionKeyword = \"SmartSuggestions\";\n\t\t\tpublic const string Wildcard = \"*\";\n\t\t\tpublic const string JsonPath = \"JSONPATH:\";\n\t\t}\n\n\t\tpublic class Delimiters\n\t\t{\n\t\t\tpublic const string ArraySplit = \"|\";\n\t\t}\n\t\tpublic class DataBase\n\t\t{\n\t\t\t//Used to not overflow the ids being sent to an sp.\n\t\t\tpublic const int MaxTextLengthForBuildingArraySplit = 900;\n\t\t}\n\n\t\tpublic class HtmlAttributes\n\t\t{\n\t\t\tpublic const string GuestView = \"GuestView\";\n\t\t\tpublic const string Class = \"class\";\n\t\t}\n\n\t\tpublic class Allocation\n\t\t{\n\t\t\tpublic const string DateName = \"RequestDate\";\n\t\t\tpublic const string AuthSchema = \"SCMSignature\";\n\t\t\tpublic const string ForwardingType = \"ForwardingType\";\n\t\t}\n\n\t\tpublic class ABAC\n\t\t{\n\t\t\tpublic const string DateName = \"RequestDate\";\n\t\t\tpublic const string AuthSchema = \"SCMSignature\";\n\t\t\tpublic const string MaxNodesCustomHeader = \"X-Security-Evaluation-Max-Nodes\";\n\t\t}\n\n\t\tpublic static class PagingAndFiltering\n\t\t{\n\t\t\tpublic const string OrderBy = \"OrderBy\";\n\t\t\tpublic const string OrderByDescending = \"OrderByDescending\";\n\t\t\tpublic const string ThenBy = \"ThenBy\";\n\t\t\tpublic const string ThenByDescending = \"ThenByDescending\";\n\t\t\tpublic const string Descending = \"Descending\";\n\t\t}\n\n\t\tpublic class VaultKeyNames\n\t\t{\n\t\t\tpublic const string Audience = \"audience\";\n\t\t\tpublic const string ClientId = \"clientid\";\n\t\t\tpublic const string Host = \"host\";\n\t\t\tpublic const string Instance = \"instance\";\n\t\t\tpublic const string License = \"license\";\n\t\t\tpublic const string Password = \"password\";\n\t\t\tpublic const string PrivateKey = \"privatekey\";\n\t\t\tpublic const string SecureBlackBox = \"blackbox16\";\n\t\t\tpublic const string ServiceProtectionClient = \"serviceprotectionclient\";\n\t\t\tpublic const string SFTPSSHKeys = \"sftp_sshkeys\";\n\t\t\tpublic const string SwiftAuth = \"swiftauth\";\n\t\t\tpublic const string SwiftTransientAuth = \"swifttransientauth\";\n\t\t\tpublic const string Username = \"username\";\n\t\t}\n\n\t\tpublic class WorkflowDesignApi\n\t\t{\n\t\t\tpublic const string AuthSchema = \"Basic\";\n\t\t}\n\n\t\tpublic class WorkflowActivitiesApi\n\t\t{\n\t\t\tpublic const string ScopePolicyName = \"RequireScope\";\n\t\t\t// Why is it a URL? Ref here https://learn.microsoft.com/en-us/dotnet/api/microsoft.identity.web.claimconstants?view=msal-model-dotnet-latest\n\t\t\tpublic const string ScopeClaimKey = \"http://schemas.microsoft.com/identity/claims/scope\";\n\t\t\tpublic const string AllowAllPolicyName = \"AllowAll\";\n\t\t\tpublic const string AllowAnonymousSchemeName = \"AllowAnonymous\";\n\t\t}\n\n\t\t[Serializable]\n\t\tpublic class FileDataSource\n\t\t{\n\t\t\tprivate string _srcDbLabel = \"\";\n\t\t\tprivate static readonly Dictionary<string, FileDataSource> _srcMap = new Dictionary<string, FileDataSource>();\n\n\t\t\t// use only predefined statics\n\t\t\tprivate FileDataSource(string srcDbLabel, bool isSourceInteractive)\n\t\t\t{\n\t\t\t\t_srcDbLabel = srcDbLabel;\n\t\t\t\t_srcMap[srcDbLabel] = this;\n\t\t\t\tIsSourceInteractive = Configuration.GetBooleanAppSetting($\"{srcDbLabel}_IsSourceInteractive\", isSourceInteractive);\n\t\t\t}\n\n\t\t\tprivate FileDataSource()\n\t\t\t{\n\t\t\t}\n\n\t\t\t// these are to be used in code\n\t\t\tpublic static implicit operator string(FileDataSource src)\n\t\t\t{\n\t\t\t\treturn src._srcDbLabel;\n\t\t\t}\n\n\t\t\t// mostly for the benefit of Core.Domain.Command class\n\t\t\t// it means you can assign a plain string to a variable of this type\n\t\t\tpublic static implicit operator FileDataSource(string dbLabel)\n\t\t\t{\n\t\t\t\treturn Get(dbLabel);\n\t\t\t}\n\n\t\t\tpublic static FileDataSource Get(string dbLabel)\n\t\t\t{\n\t\t\t\tif (String.IsNullOrEmpty(dbLabel))\n\t\t\t\t\treturn Unset;\n\t\t\t\tif (!_srcMap.ContainsKey(dbLabel))\n\t\t\t\t\treturn new FileDataSource { _srcDbLabel = dbLabel }; // on the fly - not put in dictionary\n\t\t\t\treturn _srcMap[dbLabel];\n\t\t\t}\n\n\t\t\tpublic override bool Equals(object o)\n\t\t\t{\n\t\t\t\tif (null == o || !(o is FileDataSource))\n\t\t\t\t\treturn false;\n\t\t\t\treturn _srcDbLabel == ((FileDataSource)o)._srcDbLabel;\n\t\t\t}\n\n\t\t\tpublic override int GetHashCode()\n\t\t\t{\n\t\t\t\treturn _srcDbLabel.GetHashCode();\n\t\t\t}\n\n\t\t\tpublic bool IsSourceInteractive { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// Returns a friendly and localized name for the end user's benefit\n\t\t\t/// </summary>\n\t\t\tpublic string Name\n\t\t\t{\n\t\t\t\tget\n\t\t\t\t{\n\t\t\t\t\tstring loc = Resources.CoreTypes.ResourceManager.GetString(String.Format(\"documentsource_{0}\", _srcDbLabel));\n\t\t\t\t\tif (!String.IsNullOrEmpty(loc))\n\t\t\t\t\t\treturn loc;\n\n\t\t\t\t\treturn _srcDbLabel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]\n\t\t\tpublic class UploadSourceAttribute : Attribute\n\t\t\t{\n\t\t\t\tpublic int Order = 0;\n\t\t\t\tpublic UploadSourceAttribute(int order)\n\t\t\t\t{\n\t\t\t\t\tOrder = order;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Important: Do not modify the string value for the source if it has already been deployed to production. Doing so will cause\n\t\t\t// failures in loading a Document or FileData object.\n\n\t\t\tpublic static FileDataSource AccountCloning { get; } = new FileDataSource(\"AccountCloning\", false);\n\t\t\t[UploadSource(18)]\n\t\t\tpublic static FileDataSource AdvancedWorkflow { get; } = new FileDataSource(\"AdvancedWorkflow\", false);\n\t\t\tpublic static FileDataSource AdvancedWorkflowMerge { get; } = new FileDataSource(\"AdvancedWorkflowMerge\", true);\n\t\t\t[UploadSource(2)]\n\t\t\tpublic static FileDataSource AtlasInboundEmail { get; } = new FileDataSource(\"AtlasInboundEmail\", false);\n\t\t\t[UploadSource(7)]\n\t\t\tpublic static FileDataSource AtlasUploadService { get; } = new FileDataSource(\"AtlasUploadService\", false);\n\t\t\t[UploadSource(11)]\n\t\t\tpublic static FileDataSource AutoSplit { get; } = new FileDataSource(\"AutoSplit\", false);  // ocr bar code processing\n\t\t\t[UploadSource(1)]\n\t\t\tpublic static FileDataSource BrowseUpload { get; } = new FileDataSource(\"BrowseUpload\", true);\n\t\t\tpublic static FileDataSource CheckIn { get; } = new FileDataSource(\"CheckIn\", true);\n\t\t\tpublic static FileDataSource CheckInFile { get; } = new FileDataSource(\"CheckInFile\", true);\n\t\t\tpublic static FileDataSource CollaborationCheckIn { get; } = new FileDataSource(\"CollaborationCheckIn\", true);\n\t\t\tpublic static FileDataSource CollaborationSave { get; } = new FileDataSource(\"CollaborationSave\", true);\n\t\t\tpublic static FileDataSource CollaborationSetup { get; } = new FileDataSource(\"CollaborationSetup\", true);\n\t\t\tpublic static FileDataSource ContentReplacement { get; } = new FileDataSource(\"ContentReplacement\", true);\n\t\t\tpublic static FileDataSource Copy { get; } = new FileDataSource(\"Copy\", true);\n\t\t\tpublic static FileDataSource DocumentCompare { get; } = new FileDataSource(\"DocumentCompare\", true);\n\t\t\tpublic static FileDataSource DocumentPackageBuilder { get; } = new FileDataSource(\"DocumentPackageBuilder\", true);\n\t\t\tpublic static FileDataSource DocLauncherAttachment { get; } = new FileDataSource(\"DocLauncherAttachment\", true);\n\t\t\tpublic static FileDataSource DraftDocument { get; } = new FileDataSource(\"DraftDocument\", false);\n\t\t\t[UploadSource(15)]\n\t\t\tpublic static FileDataSource ESignature { get; } = new FileDataSource(\"ESignature\", false);\n\t\t\t[UploadSource(12)]\n\t\t\tpublic static FileDataSource FormPublicSubmit { get; } = new FileDataSource(\"FormPublicSubmit\", false);\n\t\t\t[UploadSource(13)]\n\t\t\tpublic static FileDataSource FormSubmit { get; } = new FileDataSource(\"FormSubmit\", true);\n\t\t\t[UploadSource(14)]\n\t\t\tpublic static FileDataSource FormUpdate { get; } = new FileDataSource(\"FormUpdate\", false);\n\t\t\t[UploadSource(3)]\n\t\t\tpublic static FileDataSource InboundFax { get; } = new FileDataSource(\"InboundFax\", false);\n\t\t\tpublic static FileDataSource Merge { get; } = new FileDataSource(\"Merge\", false);\n\t\t\tpublic static FileDataSource DocxMerge { get; } = new FileDataSource(\"DocxMerge\", false);\n\t\t\tpublic static FileDataSource OfficeUploaderEditInline { get; } = new FileDataSource(\"OfficeUploaderEditInline\", true);\n\t\t\tpublic static FileDataSource GoogleUploaderEditInline { get; } = new FileDataSource(\"GoogleUploaderEditInline\", true);\n\t\t\tpublic static FileDataSource ProofOfDelivery { get; } = new FileDataSource(\"ProofOfDelivery\", false);\n\t\t\tpublic static FileDataSource Packaging { get; } = new FileDataSource(\"Packaging\", false);\n\t\t\t[UploadSource(17)]\n\t\t\tpublic static FileDataSource PdfMerge { get; } = new FileDataSource(\"PdfMerge\", true);\n\t\t\tpublic static FileDataSource Received { get; } = new FileDataSource(\"Received\", false);\n\t\t\tpublic static FileDataSource RestContentService { get; } = new FileDataSource(\"RestContentService\", false);\n\t\t\tpublic static FileDataSource SFTPProxyService { get; } = new FileDataSource(\"SFTPProxyService\", false); // the SouthOaks \"stop gap\" solution with OpenSSH and SpringFolderWatchService\n\t\t\t[UploadSource(5)]\n\t\t\tpublic static FileDataSource SFTPServer { get; } = new FileDataSource(\"SFTPServer\", false);\n\t\t\t[UploadSource(6)]\n\t\t\tpublic static FileDataSource SpringCMService { get; } = new FileDataSource(\"SpringCMService\", false);\n\t\t\tpublic static FileDataSource Support { get; } = new FileDataSource(\"Support\", false);\n\t\t\tpublic static FileDataSource TermUpdate { get; } = new FileDataSource(\"TermUpdate\", false);\n\t\t\tpublic static FileDataSource Test { get; } = new FileDataSource(\"Test\", true);      // considered an interactive source since integrations tests will wait for a result\n\t\t\tpublic static FileDataSource Unset { get; } = new FileDataSource(\"Unset\", false);\n\t\t\tpublic static FileDataSource UpdateDocument { get; } = new FileDataSource(\"UpdateDocument\", true);\n\t\t\t[UploadSource(10)]\n\t\t\tpublic static FileDataSource UserSplit { get; } = new FileDataSource(\"UserSplit\", true);  // pdf manipulations\n\t\t\tpublic static FileDataSource DocumentRuleCopy { get; } = new FileDataSource(\"DocumentRuleCopy\", false);\n\t\t\t[UploadSource(16)]\n\t\t\tpublic static FileDataSource XmlMerge { get; } = new FileDataSource(\"XMLMerge\", false);\n\t\t\tpublic static FileDataSource BusinessSync { get; } = new FileDataSource(\"DesktopSync\", false);\n\t\t\tpublic static FileDataSource Mobile { get; } = new FileDataSource(\"Mobile\", false);\n\t\t\tpublic static FileDataSource ScanToSpring { get; } = new FileDataSource(\"ScanToSpring\", false);\n\t\t\t[UploadSource(8)]\n\t\t\tpublic static FileDataSource SalesforceMigration { get; } = new FileDataSource(\"SalesforceMigration\", false);\n\t\t\t[UploadSource(9)]\n\t\t\tpublic static FileDataSource ApiContent { get; } = new FileDataSource(\"ApiContent\", false);\n\t\t\tpublic static FileDataSource ExportSearch { get; } = new FileDataSource(\"ExportSearch\", false);\n\t\t\tpublic static FileDataSource ExternalReview { get; } = new FileDataSource(\"ExternalReview\", false);\n\t\t\tpublic static FileDataSource ReportJob { get; } = new FileDataSource(\"ReportJob\", false);\n\t\t\tpublic static FileDataSource ProcessBuilderHtmlToDocxRendition { get; } = new FileDataSource(\"ProcessBuilderHtmlToDocxRendition\", false);\n\t\t\tpublic static FileDataSource ProcessBuilderUpdateACEAdfHtmlFiles { get; } = new FileDataSource(\"ProcessBuilderUpdateACEAdfHtmlFiles\", false);\n\n\t\t}\n\n\n\t\tpublic class MetadataHtmlAttributes\n\t\t{\n\t\t\tpublic const string CNTR_ATTR_FIELD_ID = \"metadatafieldid\";\n\t\t\tpublic const string CNTR_ATTR_SET_ID = \"metadatasetid\";\n\t\t\tpublic const string CNTR_ATTR_GROUP_ID = \"metadatagroupid\";\n\t\t\tpublic const string CNTR_ATTR_FIELD_NAME = \"fieldname\";\n\t\t\tpublic const string CNTR_ATTR_GROUP_NAME = \"groupname\";\n\t\t\tpublic const string CNTR_ATTR_DATA_TYPE = \"datatype\";\n\t\t\tpublic const string CNTR_ATTR_REQUIRED = \"required\";\n\t\t\tpublic const string CNTR_ATTR_TAB_INDEX = \"tabindex\";\n\t\t\tpublic const string CNTR_ATTR_CHECK_NUMBER = \"checknumber\";\n\t\t\tpublic const string CNTR_ATTR_CHECK_DECIMAL = \"checkdecimal\";\n\t\t\tpublic const string CNTR_ATTR_CHECK_DATE = \"checkdate\";\n\t\t\tpublic const string CNTR_ATTR_FIELDSET_NUMBER = \"fieldsetnumber\";\n\t\t\tpublic const string CNTR_ATTR_UX_ATTRS = \"attrs\";\n\t\t\t/// <summary>\n\t\t\t/// Used as JS selector to disable automatic validation of UX components and process using components' built-in validate methods\n\t\t\t/// </summary>\n\t\t\tpublic const string CNTR_ATTR_UX_VALIDATE_CUSTOM = \"data-validator-custom\";\n\t\t\tpublic const string CNTR_ATTR_DATA_DEFINITION = \"ChooserDataDefinition\";\n\t\t\tpublic const string CNTR_ATTR_ACTOR_METADATA_FIELD_ID = \"ActorMetadataFiledId\";\n\t\t\tpublic const string CNTR_ATTR_ACTOR_CHOOSER_PLACEHOLDER = \"actor-chooser-placeholder\";\n\t\t}\n\n\t\t// aka \"CLM Agreement Details\"\n\t\tpublic static class AomMetadata\n\t\t{\n\t\t\tpublic const string NAME = \"Name\";\n\t\t\tpublic const string AGREEMENT_ID = \"Agreement ID\";\n\t\t\tpublic const string AUTOMATIC_RENEWAL = \"Automatic Renewal\";\n\t\t\tpublic const string PARTY_NAME = \"Party Name\";\n\t\t\tpublic const string PARTY_ID = \"Party ID\";\n\t\t\tpublic const string TYPE = \"Type\";\n\t\t\tpublic const string VALUE = \"Value\";\n\t\t\tpublic const string REQUESTOR = \"Requestor\";\n\t\t\tpublic const string EFFECTIVE_DATE = \"Effective Date\";\n\t\t\tpublic const string EXPIRATION_DATE = \"Expiration Date\";\n\t\t\tpublic const string RENEWAL_TERM = \"Renewal Term\";\n\t\t\tpublic const string RENEWAL_TERM_UNIT = \"Renewal Term Unit\";\n\t\t\tpublic const string SIGNED = \"Signed\";\n\t\t\tpublic const string TERMINATION_NOTICE = \"Termination Notice\";\n\t\t\tpublic const string TERMINATION_NOTICE_UNIT = \"Termination Notice Unit\";\n\t\t\tpublic const string TERMINATION_NOTICE_DATE = \"Termination Notice Date\";\n\t\t\tpublic const string PAYMENT_TERMS = \"Payment Terms\";\n\t\t\tpublic const string PAYMENT_LATE_FEES = \"Payment Late Fees\";\n\t\t\tpublic const string TERMINATION_CONVENIENCE = \"Termination Convenience\";\n\t\t\tpublic const string LIMITATION_OF_LIABILITY = \"Limitation of Liability\";\n\t\t\tpublic const string TERMINATION_CAUSE = \"Termination Cause\";\n\t\t\tpublic const string ASSIGNABLE = \"Assignable\";\n\t\t\tpublic const string INDEMNITY = \"Indemnity\";\n\t\t\tpublic const string RENEWAL_NOTICE_PERIOD = \"Renewal Notice Period\";\n\t\t\tpublic const string RENEWAL_NOTICE_PERIOD_UNIT = \"Renewal Notice Period Unit\";\n\t\t\tpublic const string PAYMENT_DURATION = \"Payment Duration\";\n\t\t\tpublic const string PAYMENT_DURATION_UNIT = \"Payment Duration Unit\";\n\t\t\tpublic const string DESCRIPTION = \"Description\";\n\t\t\tpublic const string CHANGE_OF_CONTROL = \"Change of Control\";\n\t\t\tpublic const string PAYMENT_EARLY_DISCOUNT = \"Payment Early Discount\";\n\t\t\tpublic const string FORCE_MAJEURE = \"Force Majeure\";\n\t\t}\n\n\t\t// these fields have no underlying field / values, there are implied via the existence of another field\n\t\t// eg. \"Automatic Renewal\" is implied via the existence of the \"Renewal Term\" field\n\t\t// we need to keep track of their guids so that we know how to filter on these\n\t\tpublic static class AgreementDetailsImpliedMetadataGuids\n\t\t{\n\t\t\tpublic static readonly Guid AUTOMATIC_RENEWAL = new Guid(\"81c76ed8-d9be-4091-b32e-96193033b5cd\");\n\t\t}\n\n\t\tpublic static class DurationUnits\n\t\t{\n\t\t\tpublic const string DAYS = \"Days\";\n\t\t\tpublic const string WEEKS = \"Weeks\";\n\t\t\tpublic const string MONTHS = \"Months\";\n\t\t\tpublic const string YEARS = \"Years\";\n\t\t}\n\n\t\tpublic static class NonTranslatedFields\n\t\t{\n\t\t\tpublic const string PARTY_NAME = \"Party Name\";\n\t\t\tpublic const string TYPE = \"Type\";\n\t\t\tpublic const string CONTRACT_VALUE = \"Contract Value\";\n\t\t}\n\n\t\tpublic static class AomApi\n\t\t{\n\t\t\tpublic static string PartiesObjectTypeName = \"Parties\";\n\t\t\tpublic static string AgreementsObjectTypeName = \"Agreements\";\n\t\t\tpublic static string AgreementRelationshipsObjectTypeName = \"AgreementRelationships\";\n\t\t\tpublic static string ObligationsObjectTypeName = \"Obligations\";\n\t\t\tpublic static string ExternalId = \"ExternalId\";\n\t\t\tpublic static string ExternalIds = \"ExternalIds\";\n\t\t}\n\n\t\tpublic static class AdmApi\n\t\t{\n\t\t\tpublic const string PartiesObjectTypeName = \"parties\";\n\t\t\tpublic const string AgreementsObjectTypeName = \"agreements\";\n\t\t\tpublic const string AgreementEnumsObjectTypeName = \"agreements/enums\";\n\t\t\tpublic const string AgreementEnumsSubObjectTypeName = \"values\";\n\t\t\tpublic const string ObligationsObjectTypeName = \"obligations\";\n\t\t\tpublic const string AgreementRelationshipsObjectTypeName = \"AgreementRelationships\";\n\t\t\tpublic const string ContactsObjectTypeName = \"contacts\";\n\t\t\tpublic const string DocumentsObjectTypeName = \"documents\";\n\t\t\tpublic const string SubObjectName_Filter = \"filter\";\n\t\t}\n\n\t\tpublic class TranslationExportField\n\t\t{\n\t\t\tpublic const string ATTR_NAME = \"Name\";\n\t\t\tpublic const string ATTR_NAMING_TEMPLATE = \"NamingTemplate\";\n\t\t\tpublic const string ATTR_VALIDATION_MESSAGE = \"ValidationMessage\";\n\t\t\tpublic const string ATTR_VALIDATION_REGEX = \"ValidationRegex\";\n\t\t\tpublic const string ATTR_VALUE = \"Value\";\n\t\t\tpublic const string DOCGEN_NAME = ATTR_NAME;\n\t\t\tpublic const string DOCGEN_DESCRIPTION = \"Description\";\n\t\t\tpublic const string DOCGEN_HELP_TEXT = \"HelpText\";\n\t\t\tpublic const string DOCGEN_VALUE = ATTR_VALUE;\n\t\t\tpublic const string DOCGEN_DEFAULT_VALUE = \"DefaultValue\";\n\t\t\tpublic const string DOCGEN_VALIDATION_MESSAGE = \"ValidationMessage\";\n\t\t\tpublic const string DOCGEN_CSV_OPTIONS = \"CsvOption\";\n\t\t\tpublic const string DOCGEN_STEP1INSTRUCTIONS = \"Step1Instructions\";\n\t\t\tpublic const string DOCGEN_STEP2INSTRUCTIONS = \"Step2Instructions\";\n\t\t\tpublic const string DOCGEN_SUCCESSMESSAGE = \"SuccessMessage\";\n\t\t}\n\n\t\t// form related stuff\n\t\tpublic class Forms\n\t\t{\n\t\t\t// custom form tag generation and parsing\n\t\t\tpublic const string SPRING_TAG_METAGROUP_LABEL = \"springcm:MetaGroupLabel\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_LABEL = \"springcm:MetaFieldLabel\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_INPUT = \"springcm:MetaFieldInput\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_UX_COMPONENT = \"springcm:MetaFieldUxComponent\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_UX_CUSTOM = \"springcm:MetaFieldUxCustom\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_UX_DROPDOWN = \"springcm:MetaFieldUxDropdown\";\n\t\t\tpublic const string SPRING_TAG_FILEATTACH_INPUT = \"springcm:FileAttachmentInput\";\n\t\t\tpublic const string SPRING_TAG_NAMED_PROPERTY = \"springcm:property\";\n\n\t\t\t//Internal values\n\t\t\tpublic const string SPRING_TAG_INTERNAL_PREFIX = \"springcm:internal_\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL = \"InternalDataCode\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_UID = \"uid\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_DOCUMENTNAME = \"documentname\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_CREATEDBY = \"createdby\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_CREATEDDATE = \"createddate\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_UPDATEDBY = \"updatedby\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_UDPATEDDATE = \"updateddate\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_USERKEY = \"userkey\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_USEREMAIL = \"useremail\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_RAWCUSTOMDATA = \"rawcustomdata\";\n\n\t\t\tpublic const string LINK_STYLE = \"pseudoLink\";\n\t\t\tpublic const string SET_STYLE = \"set\";\n\t\t\tpublic const string REPEATINGROW_STYLE = \"repeatingRow\";\n\n\t\t\tpublic const string SXFORM_ATTR_RPT_ROW = \"repeatingrow\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_CONTAINER = \"repeatingcontainer\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_ADD_ANCHOR = \"addanchorelement\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_ADD_HANDLER = \"addrepeatinghandlerelement\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_DEL_ANCHOR = \"removeanchorelement\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_DEL_HANDELER = \"removerepeatinghandlerelement\";\n\n\n\t\t\tpublic const string SPRING_TAG_INITATTACH_COUNT = \"InitialAttachmentCount\";\n\t\t\tpublic const string BOOL_REGEX = @\"[true|false]+\";\n\t\t\tpublic const string GUID_REGEX = @\"[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}\";\n\t\t\tpublic const string NAME_REGEX = @\"[a-z0-9_-]{1,}\";\n\n\t\t\t// Two named groups are used. id tags where the id for the attribute field or group is. cstyle tags where an optional custom styling should be.\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_ID = \"id\";\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_NAME = \"name\";\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_REPEATING = \"repeating\";      // used for repeating custom UX fields\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_CUSTOMSTYLE = \"cstyle\";\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_INITATTACH = \"initAttach\";\n\n\t\t\tpublic static readonly Regex springMetafieldInputElementRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{5})\\\"(?<{4}>{1}+.+)?{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_INPUT, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, SPRING_TAG_REGEXGROUP_ID, SPRING_TAG_REGEXGROUP_CUSTOMSTYLE, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\tpublic static readonly Regex springFileAttachElementRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>[0-9-]+)\\\"(?<{4}>{1}+.+)?{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_FILEATTACH_INPUT, \"\\\\s\", SPRING_TAG_INITATTACH_COUNT, SPRING_TAG_REGEXGROUP_INITATTACH, SPRING_TAG_REGEXGROUP_CUSTOMSTYLE), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\t// these don't need to accept custom styling\n\t\t\tpublic static readonly Regex springMetagroupLabelElementRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAGROUP_LABEL, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_GROUP_ID, SPRING_TAG_REGEXGROUP_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\tpublic static readonly Regex springMetafieldLabelElementRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_LABEL, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, SPRING_TAG_REGEXGROUP_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\t// matches only the attribute for input - \"springcm:MetaFieldInput MetaDataFieldId = 4\"\n\t\t\tpublic static readonly Regex springMetafieldInputAttributeRx = new Regex(String.Format(\"{0}{1}+{2}{1}*={1}*\\\"{3}\\\"\", SPRING_TAG_METAFIELD_INPUT, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\n\t\t\tpublic static readonly Regex springMetafieldUxComponentRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_UX_COMPONENT, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, SPRING_TAG_REGEXGROUP_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\tpublic static readonly Regex springMetafieldUxCustomRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"({1}+{5}{1}*={1}*\\\"(?<{5}>{6})\\\")?{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_UX_CUSTOM, \"\\\\s\", SPRING_TAG_REGEXGROUP_NAME, SPRING_TAG_REGEXGROUP_NAME, NAME_REGEX, SPRING_TAG_REGEXGROUP_REPEATING, BOOL_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\tpublic static readonly Regex springMetafieldUxDropdownRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_UX_DROPDOWN, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, SPRING_TAG_REGEXGROUP_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\n\t\t\tpublic static string EmitMetafieldLabelElement(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"<{0} {2}=\\\"{1}\\\"/>\", SPRING_TAG_METAFIELD_LABEL, uid, MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID);\n\t\t\t}\n\n\t\t\tpublic static string EmitMetafieldInputAttribute(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"{0} {2}=\\\"{1}\\\"\", SPRING_TAG_METAFIELD_INPUT, uid, MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID);\n\t\t\t}\n\n\t\t\tpublic static string EmitMetafieldUxComponent(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"{0} {2}=\\\"{1}\\\"\", SPRING_TAG_METAFIELD_UX_COMPONENT, uid, MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID);\n\t\t\t}\n\t\t\tpublic static string EmitMetafieldUxDropdownComponent(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"{0} {2}=\\\"{1}\\\"\", SPRING_TAG_METAFIELD_UX_DROPDOWN, uid, MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID);\n\t\t\t}\n\n\t\t\tpublic static string EmitMetafieldInputElement(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"<{0}/>\", EmitMetafieldInputAttribute(uid));\n\t\t\t}\n\n\t\t\tpublic static string EmitAttachmentInputElement()\n\t\t\t{\n\t\t\t\treturn String.Format(\"<{0} {1}=\\\"1\\\"/>\", SPRING_TAG_FILEATTACH_INPUT, SPRING_TAG_INITATTACH_COUNT);\n\t\t\t}\n\n\t\t\tpublic static string EmitMetagroupLabelElement(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"<{0} {2}=\\\"{1}\\\"/>\", SPRING_TAG_METAGROUP_LABEL, uid, MetadataHtmlAttributes.CNTR_ATTR_GROUP_ID);\n\t\t\t}\n\t\t}\n\n\t\tpublic static class ItemTables\n\t\t{\n\t\t\tpublic const string CustomReport = \"CustomReport\";\n\t\t\tpublic const string CustomReportToLower = \"customreport\";\n\t\t}\n\n\t\tpublic static class DocLauncher\n\t\t{\n\t\t\tpublic const int ConfigNameMaxLength = 100;\n\t\t\tpublic const string RecordType = \"RecordType\";\n\t\t\tpublic const string CustomEosRedirectAuthorization = \"CustomEosRedirectAuthorization\";\n\t\t\tpublic static readonly string[] Clm360AllowedSfObjects = { SalesforceObjectType.Account, SalesforceObjectType.Opportunity };\n\t\t\tpublic const string FieldType = \"FieldType\";\n\t\t\tpublic const string CustomTable = \"CustomTable\";\n\t\t}\n\n\t\tpublic static class SalesforceObjectType\n\t\t{\n\t\t\tpublic const string Account = \"Account\";\n\t\t\tpublic const string Opportunity = \"Opportunity\";\n\t\t\tpublic const string User = \"User\";\n\t\t}\n\n\t\tpublic static class UI\n\t\t{\n\t\t\tpublic static class UIWorkflowConstants\n\t\t\t{\n\t\t\t\tpublic const string TYPE_INBOX = \"i\";\n\t\t\t}\n\n\t\t\tpublic const string Days = \"d\";\n\t\t\tpublic const string Hours = \"h\";\n\t\t}\n\n\t\tpublic static class OAuth\n\t\t{\n\t\t\tpublic const int TOKEN_LENGTH = 128;\n\t\t\tpublic const int ACCESS_TOKEN_EXPIRATION_MINUTES = 60;\n\t\t\tpublic const int AUTHORIZATION_TOKEN_EXPIRATION_MINUTES = 1;\n\t\t\tpublic const string AUTHORIZATION_HEADER_NAME = \"Authorization\";\n\t\t\tpublic const string API_APPNAME = \"api\";\n\t\t\tpublic const string ACCESS_TOKEN_SERVICE = \"AccessTokenService\";\n\t\t}\n\n\t\tpublic static class Authentication\n\t\t{\n\t\t\tpublic const string AUTHENTICATION_APPLICATION_ISSUER = \"Atlas.AuthenticationApplication\";\n\t\t\tpublic const string SHOW_ANNOUNCEMENT_KEY = \"ShowAnnouncement\";\n\t\t\tpublic const int SALT_CHARLENGTH = 32;          // should always be an even number greater than or equal to 16 (8 bytes of salt)\n\t\t\tpublic const int PW_ITERATIONS = 77436;\n\t\t\tpublic const string ACCOUNT_ID_USER_ID_CACHE_KEY_PREFIX = \"AccountIdUserIdForSession\";\n\t\t\tpublic const string AUTH_APP_CROSS_PLATFORM_FETCH = \"authapp\";\n\t\t\tpublic const string RESTAUTH_APP_CROSS_PLATFORM_FETCH = \"auth\";\n\t\t}\n\n\t\tpublic static class GridConfigKey\n\t\t{\n\t\t\tpublic const string FOLDER_PORTAL_KO = \"resultsGridKo\";\n\t\t\tpublic const string DYNAMIC_SEARCH_KO = \"dynamicSearchKo\";\n\t\t}\n\n\t\tpublic class PageNames\n\t\t{\n\t\t\tpublic const string BROWSE_DOCUMENTS = \"BrowseDocuments.aspx\";\n\t\t\tpublic const string BROWSE_DOCUMENTS_WITHOUT_EXTENSION = \"BrowseDocuments\";\n\t\t\tpublic const string PREVIEW = \"Preview.aspx\";\n\t\t\tpublic const string DOC_EXPLORER = \"DocExplorer\";\n\t\t}\n\n\t\tpublic class VideoInfo\n\t\t{\n\t\t\tpublic const string METADATA_FIELD_NAME_HEIGHT = \"Height\";\n\t\t\tpublic const string METADATA_FIELD_NAME_WIDTH = \"Width\";\n\t\t\tpublic const string METADATA_FIELD_NAME_CODEC = \"Codec\";\n\t\t\tpublic const string METADATA_FIELD_NAME_DURATION = \"Duration\";\n\t\t}\n\n\t\tpublic class WorkerPool\n\t\t{\n\t\t\tpublic const string UserOwnerDefaultAccessRightsXml = \"<accessrights><queuerights><queueelements name=\\\"View Queue?\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Put Back in Same Queue\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Plan Queue Item\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can View Dispatched Item\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Ad Hoc Pick Task\\\" checked=\\\"True\\\" /><queueelements name=\\\"Queue Owner\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Put Back in Diff Queue\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Change Priority level\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Do Pattern Based Allocation\\\" checked=\\\"True\\\" /><queueelements name=\\\"Disable Participant\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Recall Allocated Items\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Do User Based Allocation\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Do Time Based Allocation\\\" checked=\\\"True\\\" /><queueelements name=\\\"Consider Queue Owner as Participant for Automatic Dispatch\\\" checked=\\\"False\\\" /></queuerights><queuepagerights><queueelements name=\\\"Participants\\\" checked=\\\"True\\\" /><queueelements name=\\\"Fields\\\" checked=\\\"True\\\" /><queueelements name=\\\"Dispatch Patterns\\\" checked=\\\"True\\\" /><queueelements name=\\\"Access Rights\\\" checked=\\\"True\\\" /><queueelements name=\\\"Settings\\\" checked=\\\"True\\\" /><queueelements name=\\\"Escalation\\\" checked=\\\"True\\\" /></queuepagerights></accessrights>\";\n\t\t}\n\n\t\tpublic const string BulkUserImportDelimitedExtractionSourceName = \"UserSyncCsv\";\n\n\t\tpublic class MenuAction\n\t\t{\n\t\t\t// menu keys\n\t\t\tpublic const string ACCOUNT_DEFAULT_KEY = \"AccountDefault\";\n\t\t\tpublic const string DEFAULT_BROWSE_KEY = \"Browse\";\n\t\t\tpublic const string BROWSE_KEY = \"BrowseDocumentActions\";\n\t\t\tpublic const string DOCEXPLORER_KEY = \"DocExplorerActions\";\n\t\t\tpublic const string DOCEXPLORER_MOBILE_KEY = \"DocExplorerMobileActions\";\n\t\t\tpublic const string DOCEXPLORER_KEY_OLD = \"DocExplorerToolbar\";\n\t\t\tpublic const string DOCUMENTTASK_KEY = \"DocumentTaskActions\";\n\t\t\tpublic const string FILE_IT_KEY = \"NodeActionsGridPortal\";\n\t\t\tpublic const string DOCUMENT_ACTIONS_KEY = \"StandardDocumentActions\";\n\t\t\tpublic const string DOCUMENT_ACTIONS_MOBILE_KEY = \"StandardDocumentActions_Mobile\";\n\t\t\tpublic const string DOCUMENT_ACTIONS_KEY_OLD = \"FolderAndDocumentToolbar\";\n\t\t\tpublic const string FILEWIDGET_ACTIONS_KEY = \"FileWidgetActions\";\n\t\t\tpublic const string NAVIGATION_KEY = \"Navigation\";\n\t\t\tpublic const string NAVIGATIONACTIONS_KEY = \"NavigationActions\";\n\t\t\tpublic const string NAVIGATIONHELP_KEY = \"NavigationHelp\";\n\t\t\tpublic const string DEFAULT_PREVIEW_KEY = \"Preview\";\n\t\t\tpublic const string PREVIEW_KEY = \"PreviewActions\";\n\t\t\tpublic const string DOCUMENTMANAGEMENTACTIONS_KEY = \"DocumentManagementActions\";\n\t\t\tpublic const string DOCUMENTMANAGEMENTCUSTOMACTIONS_KEY = \"DocumentManagementCustomActions\";\n\t\t\tpublic const string CLMFILESACTIONS_KEY = \"ClmFilesActions\";\n\t\t\tpublic const string CLMFILESCUSTOMACTIONS_KEY = \"ClmFilesCustomActions\";\n\t\t\tpublic const string NEW_PERSONA = \"NewPersona\";\n\t\t\tpublic const string REPORT_LANDING = \"ReportLanding\";\n\t\t\tpublic const string RECENTDOCUMENTSWIDGET_ACTIONS_KEY = \"RecentDocumentsWidgetActions\";\n\t\t\tpublic const string RECENTDOCUMENTSWIDGET_ACTIONS_MOBILE_KEY = \"RecentDocumentsWidgetActions_Mobile\";\n\t\t\tpublic const string SEARCH_ACTIONS_KEY = \"SearchActions\";\n\t\t\tpublic const string WORKFLOWINBOXWIDGET_ACTIONS_KEY = \"WorkflowInboxWidgetToolbar\";\n\t\t\tpublic const string WORKFLOWTASK_ACTIONS_KEY = \"WorkflowTaskToolbarMultiLevel\";\n\t\t\tpublic const string FILE_IT_FOLDER_WIDGET_CUSTOM_ACTIONS_KEY = \"FileItFolderWidgetCustomActions\";\n\n\t\t\t// action keys\n\t\t\tpublic const string DOCUMENT_EDIT_KEY = \"DocumentEdit\";\n\t\t\tpublic const string DOCUMENT_EDIT_REDLINES_KEY = \"DocumentEditWithRedlines\";\n\t\t\tpublic const string DOCUSIGN_DOCUMENT_EDIT_KEY = \"DocuSignDocumentEdit\";\n\t\t\tpublic const string DOCUSIGN_DOCUMENT_EDIT_REDLINES_KEY = \"DocuSignDocumentEditWithRedlines\";\n\n\t\t\t//Custom Menu Action\n\t\t\tpublic const string CUSTOM_ACTION_LANGUAGE_PREFIX = \"language:\";\n\t\t\tpublic const string CUSTOM_ACTION_LANGUAGE_DEFAULT = \"any\";\n\n\t\t\t// Context menu keys\n\t\t\tpublic const string NODE_CONTEXT_MENU_KEY = \"NodeContextMenu\";\n\t\t\tpublic const string NODE_CONTEXT_MENU_EXTENDED_KEY = \"NodeContextMenuExtended\";\n\t\t}\n\n\t\tpublic class HistoryData\n\t\t{\n\t\t\tpublic const string HISTORYCREATEDDATE = \"HistoryCreatedDate\";\n\t\t\tpublic const string HISTORYUSEREMAIL = \"HistoryUserEmail\";\n\t\t\tpublic const string HISTORYUSERFIRSTNAME = \"HistoryUserFirstName\";\n\t\t\tpublic const string HISTORYUSERLASTNAME = \"HistoryUserLastName\";\n\t\t\tpublic const string HISTORYUSERNAME = \"HistoryUserName\";\n\t\t\tpublic const string HISTORYNAME = \"HistoryName\";\n\t\t\tpublic const string HISTORYUID = \"HistoryUid\";\n\t\t\tpublic const string USER = \"User\";\n\t\t\tpublic const string EMAIL = \"Email\";\n\t\t\tpublic const string FIRSTNAME = \"FirstName\";\n\t\t\tpublic const string LASTNAME = \"LastName\";\n\t\t\tpublic const string USERNAME = \"UserName\";\n\t\t\tpublic const string FRIENDLYNAME = \"FriendlyName\";\n\t\t\tpublic const string UID = \"Uid\";\n\t\t\tpublic const string DATETIME = \"DateTime\";\n\t\t\tpublic const string ACTION_NAME = \"actionName\";\n\t\t\tpublic const string APPROVERS = \"Approvers\";\n\t\t\tpublic const string COMMENTS = \"Comments\";\n\t\t\tpublic const string COMMENTLIST = \"CommentList\";\n\t\t\tpublic const string CONTENTVERSIONID = \"ContentVersionId\";\n\t\t\tpublic const string DESTINATIONOBJECTID = \"DestinationObjectId\";\n\t\t\tpublic const string DOCUMENT = \"Document\";\n\t\t\tpublic const string DOCUMENTUID = \"DocumentUid\";\n\t\t\tpublic const string DOCUMENTNAME = \"DocumentName\";\n\t\t\tpublic const string DOCUMENTOLDNAME = \"DocumentOldName\";\n\t\t\tpublic const string DUEDATE = \"DueDate\";\n\t\t\tpublic const string EMAILADDRESS = \"EmailAddress\";\n\t\t\tpublic const string EMAILMESSAGE = \"EmailMessage\";\n\t\t\tpublic const string EMAILSUBJECT = \"EmailSubject\";\n\t\t\tpublic const string IPADDRESS = \"IpAddress\";\n\t\t\tpublic const string REFID = \"RefId\";\n\t\t\tpublic const string REVIEWER = \"Reviewer\";\n\t\t\tpublic const string VERSIONNUMBER = \"VersionNumber\";\n\t\t\tpublic const string ACTOR = \"Actor\";\n\t\t\tpublic const string FULLNAME = \"FullName\";\n\t\t\tpublic const string SENDER = \"Sender\";\n\t\t\tpublic const string METADATA = \"Metadata\";\n\t\t\tpublic const string GROUPS = \"Groups\";\n\t\t\tpublic const string VALUE = \"Value\";\n\t\t\tpublic const string OLDDESCRIPTION = \"OldDescription\";\n\t\t\tpublic const string NEWDESCRIPTION = \"NewDescription\";\n\t\t\tpublic const string TO_EMAILADDRESS = \"toAddress\";\n\t\t\tpublic const string RECIPIENTS = \"Recipients\";\n\t\t\tpublic const string ISONBEHALFOF = \"IsOnBehalfOf\";\n\t\t\tpublic const string ONBEHALFOFUSER = \"OnBehalfOfUser\";\n\t\t\tpublic const string ATTACHMENTS = \"Attachments\";\n\t\t\tpublic const string ORIGINALDOCUMENT = \"OriginalDocument\";\n\t\t\tpublic const string ORIGINALDOCUMENTUID = \"originalDocumentUid\";\n\t\t\tpublic const string ORIGINALDOCUMENTNAME = \"originalDocumentName\";\n\t\t\tpublic const string ORIGINALFOLDERUID = \"originalFolderUid\";\n\t\t\tpublic const string ORIGINALFOLDERNAME = \"originalFolderName\";\n\t\t\tpublic const string NEWDOCUMENTUID = \"newDocumentUid\";\n\t\t\tpublic const string NEWDOCUMENTNAME = \"newDocumentName\";\n\t\t\tpublic const string NEWFOLDERUID = \"newFolderUid\";\n\t\t\tpublic const string NEWFOLDERNAME = \"newFolderName\";\n\t\t\tpublic const string CURRENTVERSION = \"CurrentVersion\";\n\t\t\tpublic const string PREVIOUSVERSION = \"PreviousVersion\";\n\t\t\tpublic const string PREVIOUSDOCUMENTUID = \"PreviousDocumentUid\";\n\t\t\tpublic const string CHECKEDINDOCUMENT = \"checkedInDocument\";\n\t\t\tpublic const string EDITORS = \"editors\";\n\t\t\tpublic const string UPLOADEDFILENAME = \"uploadedFileName\";\n\t\t\tpublic const string SOURCE = \"source\";\n\t\t\tpublic const string METADATAFIELD_ = \"MetadataField_\";\n\t\t\tpublic const string METADATAGROUP_ = \"MetadataGroup_\";\n\t\t\tpublic const string MULTILINESETTING = \"MultilineSetting\";\n\t\t\tpublic const string FIELDCOUNT = \"FieldCount\";\n\t\t\tpublic const string NOTFIELDCOUNT = \"NotFieldCount\";\n\t\t\tpublic const string FIELDNAME = \"FieldName\";\n\t\t\tpublic const string GROUPCOUNT = \"GroupCount\";\n\t\t\tpublic const string RULE = \"Rule\";\n\t\t\tpublic const string DOCXPATH = \"DocXPath\";\n\t\t\tpublic const string MANIFEST = \"Manifest\";\n\t\t\tpublic const string ROWNUMBER = \"RowNumber\";\n\t\t\tpublic const string CANDOWNLOADPDF = \"CanDownloadPdf\";\n\t\t\tpublic const string CANDOWNLOADNATIVE = \"CanDownloadNative\";\n\t\t\tpublic const string PREVIEWBEHAVIOR = \"PreviewBehavior\";\n\t\t\tpublic const string FAXNUMBER = \"FaxNumber\";\n\t\t\tpublic const string FAXCOUNT = \"FaxCount\";\n\t\t\tpublic const string COMMENT_IDENTIFIER = \"CommentIdentifier\";\n\t\t\tpublic const string EFORM_DESIGN_NAME = \"eformDesignName\";\n\t\t\tpublic const string EXTERNAL_REVIEW = \"ExternalReview\";\n\t\t\tpublic const string EXTERNAL_REVIEW_DOCUMENT = \"ExternalReviewDocument\";\n\t\t\tpublic const string REMINDERNAME = \"ReminderName\";\n\t\t\tpublic const string WATCHERS = \"Watchers\";\n\t\t\tpublic const string CC = \"cc\";\n\t\t\tpublic const string WORKFLOW = \"Workflow\";\n\t\t\tpublic const string WORKFLOW_ACTION = \"WorkflowAction\";\n\t\t\tpublic const string WORKFLOW_ACTIVITY_NAME = \"WorkflowActivityName\";\n\t\t\tpublic const string WORKFLOW_NAME = \"workflowName\";\n\t\t\tpublic const string WORKITEM_DISPLAYNAME = \"workitemDisplayName\";\n\t\t\tpublic const string WORKFLOW_UID = \"WorkflowUid\";\n\t\t\tpublic const string WORKFLOWINSTANCEUID = \"WorkflowInstanceUid\";\n\t\t\tpublic const string WORKFLOWACTIVITYUID = \"WorkflowActivityUid\";\n\t\t\tpublic const string RESULT = \"Result\";\n\t\t\tpublic const string CLIENT_APP_NAME = \"ClientAppName\";\n\t\t\tpublic const string CHATTER_GROUPS = \"ChatterGroups\";\n\t\t\tpublic const string CHATTER_MESSAGE = \"ChatterMessage\";\n\t\t\tpublic const string CHATTER_SFOBJECTID = \"ChatterSfObjectId\";\n\t\t\tpublic const string URL = \"Url\";\n\t\t\tpublic const string RULEUID = \"RuleUid\";\n\t\t\tpublic const string OLD_RULEUID = \"OldRuleUid\";\n\t\t\tpublic const string OLD_FILTER_ID = \"OldFilterId\";\n\t\t\tpublic const string NEW_FILTER_ID = \"NewFilterId\";\n\t\t\tpublic const string OLD_FILTER_VAL = \"OldFilterValue\";\n\t\t\tpublic const string NEW_FILTER_VAL = \"NewFilterValue\";\n\t\t\tpublic const string REMOVED_CONDITIONS = \"RemovedConditions\";\n\t\t\tpublic const string ADDED_CONDITIONS = \"AddedConditions\";\n\t\t\tpublic const string REMOVED_STATUS_SECURITY = \"RemovedStatusSecurity\";\n\t\t\tpublic const string ADDED_STATUS_SECURITY = \"AddedStatusSecurity\";\n\t\t\tpublic const string REMOVED_SECURITY_GROUPS = \"RemovedSecurityGroups\";\n\t\t\tpublic const string ADDED_SECURITY_GROUPS = \"AddedSecurityGroups\";\n\t\t\tpublic const string OLD_ACCESS_LEVEL = \"OldAccessLevel\";\n\t\t\tpublic const string NEW_ACCESS_LEVEL = \"NewAccessLevel\";\n\t\t\tpublic const string OLD_RULE_NAME = \"OldRuleName\";\n\t\t\tpublic const string NEW_RULE_NAME = \"NewRuleName\";\n\t\t\tpublic const string ALL_USERS = \"All Users\";\n\t\t\tpublic const string EMAIL_BOUNCE = \"EmailBounce\";\n\t\t\tpublic const string EMAIL_BOUNCE_DETAILS = \"EmailBounceDetails\";\n\t\t\tpublic const string FROMEMAIL = \"FromEmail\"; // From Email address from email ingestion\n\t\t\tpublic const string OLD_SUMMARY = \"OldSummary\";\n\t\t}\n\n\t\tpublic class ResourceTokenResources\n\t\t{\n\t\t\tpublic const string RESOURCEID = \"resource_id\";\n\t\t\tpublic const string RESOURCETYPE = \"resource_type\";\n\t\t\tpublic const string RESOURCEREQUESTTYPE = \"resource_request_type\";\n\t\t\tpublic const string CONTENTTYPE = \"content_type\";\n\t\t}\n\n\t\tpublic class SCIM\n\t\t{\n\t\t\tpublic const int RetryIntervalSeconds = 5;\n\t\t\tpublic const int RetryAttempts = 5;\n\t\t}\n\n\t\tpublic class SupportIndicators\n\t\t{\n\t\t\tpublic const string CLMIndicator = \"CLM\";\n\t\t\tpublic const string LegacyIndicator = \"CLM.CM\";\n\t\t\tpublic const string CLMEssentialsIndicator = \"CLM Essentials\";\n\t\t}\n\n\t\tpublic class SharedStorageOperations\n\t\t{\n\t\t\tpublic const string SaveFileFromStream = \"SaveFileFromStream\";\n\t\t\tpublic const string GetFileStream = \"GetFileStream\";\n\t\t\tpublic const string GetPartialStream = \"GetPartialStream\";\n\t\t\tpublic const string GetChunk = \"GetChunk\";\n\t\t\tpublic const string GetContentLength = \"GetContentLength\";\n\t\t\tpublic const string DeleteFile = \"DeleteFile\";\n\t\t\tpublic const string GetObject = \"GetObject\";\n\t\t\tpublic const string FileExists = \"FileExists\";\n\t\t}\n\n\t\tpublic class Status\n\t\t{\n\t\t\tpublic const string Success = \"Success\";\n\t\t\tpublic const string Failure = \"Failure\";\n\t\t}\n\n\t\tpublic static class ActGoogleForClm\n\t\t{\n\t\t\tpublic const string AppId = \"059ab90c-2cc6-4055-8361-49b1c0c8b4fe\";\n\t\t\tpublic const string DeleteActionId = \"daa5d01d-e053-41ce-84fb-736006902732\";\n\t\t\tpublic const string DownloadActionId = \"314f1fc7-9e68-4d0b-89a4-8c5353aa6854\";\n\t\t\tpublic const string UploadActionId = \"f34dd178-66af-44ea-8fa8-502c8f4c6be9\";\n\t\t\tpublic const string PermissionSetActionId = \"74b97b0d-bc7c-4999-a5ca-e0c78c857798\";\n\t\t}\n\n\t\tpublic static class ActAribaForClm\n\t\t{\n\t\t\tpublic const string ContractWorkspaceAppId = \"d00d0679-1fc3-45fc-b870-f6bb05caee81\";\n\t\t\tpublic const string SPMAppId = \"01a1b779-8dac-402f-afc4-178582760580\";\n\t\t\tpublic const string ACTv1ConnectionsDefaultResponse = \"{\\\"result\\\":\\\"SUCCESS\\\",\\\"error\\\":null,\\\"data\\\":[]}\";\n\t\t\tpublic const string AvailableActionsPropertyKey = \"crud\";\n\t\t\tpublic static readonly string[] LegacyActionNames = new string[] { \"get-contract-line-items\", \"get-contract-workspace\", \"get-contract-documents-metadata\", \"update-contract-workspace\", };\n\t\t}\n\n\t\tpublic static class DataIOV6ActionNames\n\t\t{\n\t\t\tpublic const string SearchRecords = \"search-records\";\n\t\t\tpublic const string GetTypeNames = \"get-type-names\";\n\t\t\tpublic const string GetTypeDefinitions = \"get-type-definitions\";\n\t\t\tpublic const string PatchRecord = \"patch-record\";\n\t\t\tpublic const string CreateRecord = \"create-record\";\n\t\t\tpublic const string GetSfOrgData = \"get-org-data\";\n\n\t\t\tpublic const string READABLE = \"Readable\";\n\t\t\tpublic const string CREATEABLE = \"Createable\";\n\t\t\tpublic const string UPDATEABLE = \"Updateable\";\n\t\t}\n\n\t\tpublic enum DataIOV6Action\n\t\t{\n\t\t\tSearchRecords,\n\t\t\tGetTypeNames,\n\t\t\tGetTypeDefinitions,\n\t\t\tPatchRecord,\n\t\t\tCreateRecord,\n\t\t\tGetSfOrgData\n\t\t}\n\n\t\tpublic static class ActIntegrationProviders\n\t\t{\n\t\t\tpublic const string NetSuite = \"netsuite\";\n\t\t\tpublic const string Workday = \"workday\";\n\t\t\tpublic const string Ariba = \"ariba\";\n\t\t\tpublic const string AribaSCW = \"aribascw\";\n\t\t\tpublic const string AribaSPM = \"aribaspm\";\n\t\t\tpublic const string AribaMDS = \"aribamds\";\n\t\t\tpublic const string AribaEMA = \"aribaema\";\n\t\t\tpublic const string AribaRMA = \"aribarma\";\n\t\t\tpublic const string AribaSCA = \"aribasca\";\n\t\t\tpublic const string AribaDMA = \"aribadma\";\n\t\t\tpublic const string AribaSDA = \"aribasda\";\n\t\t\tpublic const string Coupa = \"coupa\"; //ACT V1 app\n\t\t\tpublic const string CoupaCore = \"coupacore\"; //ACT V2 app\n\t\t\tpublic const string WorkdayFinancials = \"workdayfinancials\";\n\t\t\tpublic readonly static Dictionary<string, Guid> ProviderToAppId = new Dictionary<string, Guid>\n\t\t\t{\n\t\t\t\t{ AribaSCW, Guid.Parse(\"d00d0679-1fc3-45fc-b870-f6bb05caee81\") },\n\t\t\t\t{ AribaSPM, Guid.Parse(\"01a1b779-8dac-402f-afc4-178582760580\") },\n\t\t\t\t{ AribaMDS, Guid.Parse(\"44a96013-5326-4f09-bf2e-e3da77a67eda\") },\n\t\t\t\t{ AribaEMA, Guid.Parse(\"3eb4175e-10de-4baa-ae99-247bff678e36\") },\n\t\t\t\t{ AribaRMA, Guid.Parse(\"42a450bd-0b01-44bb-9606-a515fee248e9\") },\n\t\t\t\t{ AribaSCA, Guid.Parse(\"d86801cf-c318-4ac0-9ebd-427ac5a3c41d\") },\n\t\t\t\t{ AribaDMA, Guid.Parse(\"ee1e604c-55ae-4310-a467-e49c799be5d7\") },\n\t\t\t\t{ AribaSDA, Guid.Parse(\"db352637-e09e-40cb-a274-2ca2c1c44565\") },\n\t\t\t\t{ CoupaCore, Guid.Parse(\"4d4b08e6-f9bd-4f82-97df-6804aea2ee58\")},\n\t\t\t\t{ WorkdayFinancials, Guid.Parse(\"0260e028-8554-4f13-a314-27dca49a0a01\")}\n\t\t\t};\n\t\t}\n\n\t\tpublic enum ActExecutionStatus\n\t\t{\n\t\t\tEXECUTION_STATUS_UNSPECIFIED,\n\t\t\tEXECUTION_STATUS_CREATED,\n\t\t\tEXECUTION_STATUS_EXECUTING,\n\t\t\tEXECUTION_STATUS_FAILED,\n\t\t\tEXECUTION_STATUS_SUCCEEDED\n\t\t}\n\n\t\tpublic static class ActIntegrationPaths\n\t\t{\n\t\t\tpublic const string ProviderConfigPath = \"api/v2/providerConfig\";\n\t\t\tpublic const string ProviderPath = \"api/v2/providers\";\n\t\t\tpublic const string AppPath = \"api/v2/apps\";\n\t\t\tpublic const string AllProvidersAppsPath = \"api/v2/providersAndApps\";\n\t\t\tpublic const string ConnectedAppsPath = \"api/v2/connectedApps\";\n\t\t\tpublic const string IntegrationsPath = \"api/v2/integrations\";\n\t\t\tpublic const string ChatNotificationPath = \"api/v2/notifications/slack/message\";\n\t\t}\n\n\t\tpublic static class ActPlatformPaths\n\t\t{\n\t\t\tpublic const string AppsPath = \"apps\";\n\t\t\tpublic const string AccountAppsPath = \"accounts/{0}/apps\";\n\t\t\tpublic const string AccountAppsAppIdPath = \"accounts/{0}/apps/{1}\";\n\t\t\tpublic const string AccountExecutionsPath = \"accounts/{0}/executions\";\n\t\t\tpublic const string GetExecutionPath = \"accounts/{0}/executions/{1}\";\n\t\t}\n\n\t\tpublic static class AgreementAnalyzerConstants\n\t\t{\n\t\t\tpublic struct CustomMetadtaItemNames\n\t\t\t{\n\t\t\t\tpublic const string LogicAppNames = \"dsclm_LogicAppNames\";\n\t\t\t}\n\n\t\t\tpublic struct MetadataValueAttributeNames\n\t\t\t{\n\t\t\t\tpublic const string ConfidenceScore = \"score\";\n\t\t\t\tpublic const string DateIso8601Format = \"ISO_8601\";\n\t\t\t\tpublic const string DateOriginalValue = \"originalValue\";\n\t\t\t}\n\n\t\t\tpublic struct MetadataValueTypes\n\t\t\t{\n\t\t\t\tpublic const string Date = \"Date\";\n\t\t\t\tpublic const string String = \"String\";\n\t\t\t\tpublic const string Text = \"Text\";\n\t\t\t\tpublic const string Integer = \"Integer\";\n\t\t\t\tpublic const string Boolean = \"Boolean\";\n\t\t\t}\n\n\t\t\tpublic struct OriginApps\n\t\t\t{\n\t\t\t\tpublic const string PreExecution = \"dsclm_analyzer\";\n\t\t\t\tpublic const string PostExecution = \"dsclm_insight\";\n\t\t\t}\n\n\t\t\tpublic const double SealAttributeDefaultConfidenceScore = 100;\n\t\t}\n\n\t\tpublic static class AiAutofillConstants\n\t\t{\n\t\t\tpublic const int MaximumUserDefinedLabelNameLength = 5000;\n\n\t\t\tpublic const string AiAufofillBatchReportFilePath_Key = \"AiAutofill:BatchReport_FilePath:{0}:{1}\"; // AiAutofill:BatchReport_FilePath:{accountId}:{requestToken}\n\t\t}\n\n\t\tpublic static class NpsSurveyConstants\n\t\t{\n\t\t\tpublic static class Grouping\n\t\t\t{\n\t\t\t\tpublic const string DocumentGeneration = \"Document Generation\";\n\t\t\t\tpublic const string Report = \"Report\";\n\t\t\t\tpublic const string Task = \"Task\";\n\t\t\t\tpublic const string Workflow = \"Workflow\";\n\t\t\t}\n\t\t}\n\n\t\tpublic static class AdHocTask\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// This is a unique id to identify ad-hoc tasks in elastic work item index.\n\t\t\t/// It is a UUID v5 guid [ns:OID with name 'API.Assignments.Tasks.v1'].\n\t\t\t/// </summary>\n\t\t\tpublic static readonly Guid TypeId = new Guid(\"509c9a1a-e82a-5beb-950f-c4772fbb7645\");\n\t\t}\n\n\t\tpublic static class CacheKeys\n\t\t{\n\t\t\tpublic const string ForwardEventRegistrations = \"ForwardEventRegistrations\";\n\t\t}\n\n\t\tpublic static class SiteNames\n\t\t{\n\t\t\tpublic const string loca = \"loca\";\n\t\t\tpublic const string us11 = \"us11\";\n\t\t\tpublic const string us12 = \"us12\";\n\t\t\tpublic const string us13 = \"us13\";\n\t\t}\n\n\t\tpublic static class OfficeWebApps\n\t\t{\n\t\t\tpublic const string DocumentReservationKeyFormat = \"OwaDocument_{0}_{1}\"; // OwaDocument_{AccountId}_{DocumentUid}\n\t\t}\n\n\t\tpublic struct AisPropertyNames\n\t\t{\n\t\t\tpublic const string ContractType = \"ContractType\";\n\t\t\tpublic const string ContractingParties = \"ContractingParties\";\n\t\t\tpublic const string ContractValue = \"ContractValue\";\n\t\t\tpublic const string StartDate = \"StartDate\";\n\t\t\tpublic const string TerminationDate = \"TerminationDate\";\n\t\t\tpublic const string AutoRenewal = \"AutoRenewal\";\n\t\t\tpublic const string RenewalTerm = \"RenewalTerm\";\n\t\t\tpublic const string TerminationNoticePeriod = \"TerminationNoticePeriod\";\n\t\t\tpublic const string RenewalNotice = \"RenewalNotice\";\n\t\t\tpublic const string PaymentTerms = \"PaymentTerms\";\n\t\t\tpublic const string PaymentDuration = \"PaymentTermsDue\";\n\t\t\tpublic const string PaymentLateFees = \"PaymentLateFeeSent\";\n\t\t\tpublic const string LimitationOfLiability = \"LimitationOfLiability\";\n\t\t\tpublic const string Assignable = \"Assignable\";\n\t\t\tpublic const string Indemnity = \"Indemnity\";\n\t\t\tpublic const string TerminationCause = \"TerminationCause\";\n\t\t\tpublic const string TerminationConvenience = \"TerminationConvenience\";\n\t\t\tpublic const string ChangeOfControl = \"ChangeOfControl\";\n\t\t\tpublic const string PaymentEarlyDiscount = \"PaymentEarlyDiscount\";\n\t\t\tpublic const string ForceMajeure = \"ForceMajeure\";\n\t\t}\n\n\n\t}\n}\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap/WebServices/v7/SpringCMService.asmx.cs",
      "content": "\ufeffusing System;\nusing System.IO;\nusing System.Net.Mime;\nusing System.Web.Script.Services;\nusing System.Web.Services;\nusing System.Linq;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.FileOperations.PDF;\nusing ADEXS.Core.Domain.Lookup;\nusing ADEXS.Core.Domain.LWDP;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Base;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Repository;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.LWDP;\nusing ADEXS.Core.Domain.Repository.MetadataRepository;\nusing ADEXS.Core.Domain.Repository.ObjectHistory;\nusing ADEXS.Core.Domain.Repository.Security;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Domain.SharedStorage;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Cache;\nusing ADEXS.Core.Util.Conversions;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.FileIO;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.Helpers;\nusing ADEXS.WebServices.v7.Common;\nusing ADEXS.WebSoap;\nusing System.Collections;\nusing System.Text;\nusing Microsoft.Data.SqlClient;\nusing System.Collections.Generic;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.AccountRepository;\n\nusing Error = ADEXS.WebServices.v7.Common.Error;\nusing ADEXS.WebServices.v7.Services.Interfaces;\nusing System.Xml.Serialization;\nusing ADEXS.Core.Domain.Repository.Share;\nusing ADEXS.SForce.Core;\nusing DeleteResult = ADEXS.WebServices.v7.Common.DeleteResult;\nusing SaveResult = ADEXS.WebServices.v7.Common.SaveResult;\nusing ADEXS.WebSoap.WebServices;\nusing NameValuePair = ADEXS.Core.Util.Core.NameValuePair;\nusing ADEXS.Core.Domain.DocumentCreation;\nusing ADEXS.Core.Domain.Repository.Reporting;\n\nusing DocuSign.CLM.ContentStorage;\nusing DocuSign.CLM.ContentStorage.Shared;\n\n\n//WARNING: Web services must maintain backwards compatability.\n//WARNING: Renaming/removing methods/properties or arguments will break backwards compatibility\n//WARNING: Adding properties/methods or arguments (in an overload) is ok\n\nnamespace ADEXS.WebServices.v7 {\n\t/// <summary>\n\t/// Summary description for SpringCMService\n\t/// </summary>\n\t/// Since we have a load balancer in front of our servers with port remapping, the address the\n\t/// user sends the request to may not match the address that receives it (eg, sent to\n\t/// https://qa.springcm.com/..., received by https://66.77.43.93:444/...\n\t/// The SoapActor allows us to define an address independant name; on the client, we send to\n\t/// this name, but use a Via to specify an address.\n\t/// SoapActor name must be unique.\n\t[WebService(Namespace = \"http://www.springcm.com/atlas/webservices/v7/scm/\")]\n\t[ScriptService]\n    [SoapInclude(typeof(SCMCase))]\n    [SoapInclude(typeof(SCMContact))]\n    [XmlInclude(typeof(SCMCase))]\n    [XmlInclude(typeof(SCMContact))]\n\tpublic class SpringCMService : SCMBase, ICaseManagementService\n    {\n        private UserAccountRepository uar = new UserAccountRepository();\n        private ContactRepository cr = new ContactRepository();\n        private GroupRepository gr = new GroupRepository();\n\n        #region Private Properties\n\t\tprivate const int _defaultChunkSize = (50 * 1024);\n        private ADEXS.WebSoap.CacheData _cache;\n        private ADEXS.WebSoap.CacheData ApplicationCache\n        {\n            get\n            {\n                if (_cache == null)\n                {\n                    _cache = new ADEXS.WebSoap.CacheData(Context);\n                }\n                return _cache;\n            }\n        }\n        #endregion\n\n\t\t#region Object agnostic methods\n\n\t\t/// <summary>\n\t\t/// Copy a folder or a document to another new location. Returns a map of the new document ids to the old document ids, and their respective folder ids.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"type\">The type of object to copy.</param>\n\t\t/// <param name=\"id\">The id of the object to copy.</param>\n\t\t/// <param name=\"destinationFolderId\">Folder the object will be copied to.</param>\n\t\t/// <returns>The result is simply to be able to check and know if it was truely copied.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Copy']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Copy']/soap\" />\n        /// <seealso cref=\"Move\">Move</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Copy a folder or a document to another new location. Returns a map of the new document ids to the old document ids, and their respective folder ids.\")]\n        public SCMCopyResults Copy(string token, SCMObjectType type, string id, string destinationFolderId)\n        {\n\t\t\tSCMCopyResults result = new SCMCopyResults();\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                object source = LoadObject(user, type, id, Enums.Security.Read);\n                // Note: This is *not* checking if an object of the same name already exists at the destination\n\t\t\t\tFolder destination = LoadFolder(user, destinationFolderId, Enums.Security.Create);\n\t\t\t\tGuid destinationFolderUid = (destination == null ? Guid.Empty : destination.Uid);\n\t\t\t\tCopyResults copyResults = null;\n                if (source is Folder)\n                {\n                \tFolder folder = (Folder) source;\n\t\t\t\t\tif (folder.ParentFolderUid == destinationFolderUid) return null;\n                \tFolders folders = new Folders {folder};\n                \t// NOTE: This returns the document information only for backwards compatibility.\n                \t// We now have folder information from a copy; that is not currently being\n                \t// returned here, but probably should, considering that we are copying folders...\n                \tcopyResults = DocumentRepository.CopyMultipleToFolder(user, folders, new Documents(), destinationFolderUid);\n                }\n                else if (source is Document)\n                {\n                    Document ld = (Document)source;\n                    if (destination == null) Fail(PublicException.FailReason.ReadOnlyObject, \"Root folder cannot hold documents\");\n\t\t\t\t\tif (ld.FolderUid == destinationFolderUid) return null;\n                    Documents lds = new Documents {ld};\n                \t// NOTE: This returns the document information only for backwards compatibility.\n                    // Since this chunk of code should never copy folders, that's probably just fine.\n                    copyResults = DocumentRepository.CopyMultipleToFolder(user, new Folders(), lds, destinationFolderUid);\n                }\n                else\n                {\n                    FailInvalidObjectType(type);\n                }\n\n\t\t\t\t// If anything copied, report the result and log the copy action to document history\n                if (copyResults != null)\n                {\n                    result = new SCMCopyResults(copyResults);\n                }\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n\n\t\t\treturn result;\n        }\n\n\t\t/// <summary>\n\t\t/// Delete a document or folder from the repository\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"type\">The type of object to delete.</param>\n\t\t/// <param name=\"id\">The id of the object to delete.</param>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Delete']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Delete']/soap\" />\n        /// <seealso cref=\"Move\">Move</seealso>\n        /// <seealso cref=\"Copy\">Copy</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Delete a document or folder from the repository\")]\n        public void Delete(string token, SCMObjectType type, string id)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                switch (type)\n                {\n                    case SCMObjectType.Document:\n\t\t\t\t\t\tDocumentRepository.DeleteDocument(user, Conversions.TryParseGuid(id), WebServiceResource.ViaWebService);\n                        break;\n                    case SCMObjectType.Folder:\n                        DocumentRepository.DeleteFolder(user, Conversions.TryParseGuid(id));\n                        break;\n                    case SCMObjectType.Contact:\n                    case SCMObjectType.Group:\n                    case SCMObjectType.User:\n                        SCMContact contact = new SCMContact();\n                        contact.ObjectType = type;\n                        contact.Id = id;\n                        DeleteContactInfo(contact, user);\n                        break;\n                    case SCMObjectType.Case:\n                        string errorMsg = SCMCase.DeleteStatic(user, id);\n                        if (!string.IsNullOrEmpty(errorMsg))\n                        {\n                            throw new PublicException(PublicException.FailReason.InternalError, errorMsg);\n                        }\n                        break;\n                    case SCMObjectType.Account: //Can't delete accounts right now\n                    default:\n                        FailInvalidObjectType(type);\n                        break;\n                }\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Resulting object from a call to MoveMultiple.\n\t\t/// </summary>\n\t\tpublic class MoveObjectError\n\t\t{\n\t\t\tprivate string _errMsg = string.Empty;\n\t\t\tprivate SCMObject _obj;\n\n\t\t\t/// <summary>\n\t\t\t/// This is a text description of why the move failed on the object supplied.\n\t\t\t/// </summary>\n\t\t\tpublic string ErrorMessage\n\t\t\t{\n\t\t\t\tget { return _errMsg; }\n\t\t\t\tset { _errMsg = value; }\n\t\t\t}\n\t\t\t/// <summary>\n\t\t\t/// The object passed in that errored.\n\t\t\t/// </summary>\n\t\t\tpublic SCMObject SCMObject\n\t\t\t{\n\t\t\t\tget { return _obj; }\n\t\t\t\tset { _obj = value; }\n\t\t\t}\n\t\t}\n\n        /// <summary>\n        /// Move multiple folders or documents to a new destination folder. Will return any errors.\n        /// </summary>\n        /// <param name=\"token\"></param>\n        /// <param name=\"MovingObjects\"></param>\n        /// <param name=\"destinationFolderId\"></param>\n        /// <returns>MoveObjectError[]</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='MoveMultiple']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='MoveMultiple']/soap\" />\n        ///  <seealso cref=\"Move\">Move</seealso>\n        [SOAPLogExtension]\n        [WebMethod(Description = \"Move multiple folders or documents to a new destination folder. Will return any errors.\")]\n        public MoveObjectError[] MoveMultiple(string token, SCMObject[] MovingObjects, string destinationFolderId)\n        {\n\n\n            MoveObjectError[] ObjErrorArray = null;\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                ValidateArray(MovingObjects, \"MovingObjects\");\n\n                // Note: This is *not* checking if an object of the same name already exists at the destination\n                Folder destination = LoadFolder(user, destinationFolderId, Enums.Security.Create);\n\n                //This actually won't happen because LoadFolder throws a NonExistentObject Exception.\n                //But if that changes; bases covered.\n\t\t\t\tif (destination == null)\n                {\n                    Fail(PublicException.FailReason.PermissionDenied, string.Format(WebServiceResource.NoPermissionToDestinationFolderFormat, user.Uid, destinationFolderId));\n                }\n                else\n                {\n                    ArrayList Errors = new ArrayList();\n                    StringBuilder folderIds = new StringBuilder();\n                \tint numDocs = 0;\n                \tIList<Guid> badIds;\n\n\t\t\t\t\tIFolderRepository folderRepository = ServiceLocator.GetInstance<IFolderRepository>();\n\n\t\t\t\t\tforeach (SCMObject obj in MovingObjects)\n                    {\n\t\t\t\t\t\tif (obj.ObjectType == SCMObjectType.Folder && obj.ParentFolderId != destinationFolderId)\n                        {\n                            //Keep adding to the stringbuilder until it reaches the max capacity\n                            if (folderIds.Length != 0)\n                            {\n                                folderIds.Append(Constants.Delimiters.ArraySplit);\n                            }\n                            folderIds.Append(obj.Id);\n\n                            if (folderIds.Length > Constants.DataBase.MaxTextLengthForBuildingArraySplit)\n                            {\n\t\t\t\t\t\t\t\tbadIds = folderRepository.MoveMultipleToFolder(user, folderIds.ToString(), destination.Uid, string.Empty);\n                                ExtractMoveErrors(badIds, Errors, MovingObjects, SCMObjectType.Folder);\n                                folderIds = new StringBuilder();\n                                folderIds.Append(obj.Id);\n                            }\n                        }\n\t\t\t\t\t\telse if (obj.ObjectType == SCMObjectType.Document && obj.ParentFolderId != destinationFolderId)\n                        {\n                        \tnumDocs++;\n                        }\n                    }\n\n                    // At this point we only need to move the leftover ids\n                    if (folderIds.Length > 0)\n                    {\n\t\t\t\t\t\tbadIds = folderRepository.MoveMultipleToFolder(user, folderIds.ToString(), destination.Uid, string.Empty);\n\t\t\t\t\t\tExtractMoveErrors(badIds, Errors, MovingObjects, SCMObjectType.Folder);\n                    }\n\t\t\t\t\tif (numDocs > 0)\n                    {\n                    \tint i = 0;\n\t\t\t\t\t\tSCMDocument[] scmDocuments = new SCMDocument[numDocs];\n\t\t\t\t\t\tforeach (SCMObject obj in MovingObjects)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (obj.ObjectType == SCMObjectType.Document && obj.ParentFolderId != destinationFolderId)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tscmDocuments[i++] = (SCMDocument) obj;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tDocuments docs = SCMDocument.Convert(user, scmDocuments);\n                    \tbadIds = DocumentRepository.MoveMultipleToFolder(user, docs, destination, string.Empty);\n                        ExtractMoveErrors(badIds, Errors, MovingObjects, SCMObjectType.Document);\n                     }\n\n                    //Take all of the errors and put it in the returning array\n                    ObjErrorArray = (MoveObjectError[])Errors.ToArray(typeof(MoveObjectError));\n                }\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n            return ObjErrorArray;\n        }\n\n\t\t/// <summary>\n\t\t/// Utility method used strictly for MoveMultiple\n\t\t/// to build all of the error results.\n\t\t/// </summary>\n\t\t/// <param name=\"badIds\"></param>\n\t\t/// <param name=\"Errors\"></param>\n\t\t/// <param name=\"MovingObjects\"></param>\n\t\t/// <param name=\"sCMObjectType\"></param>\n\t\tprivate void ExtractMoveErrors(IEnumerable<Guid> badIds, IList Errors, SCMObject[] MovingObjects, SCMObjectType sCMObjectType)\n\t\t{\n\t\t\tMoveObjectError moe;\n\t\t\tforeach (Guid objectUid in badIds)\n\t\t\t{\n\t\t\t\tstring objectId = Conversions.GuidToApiStringId(objectUid);\n\t\t\t\tSCMObject obj = FindObject(MovingObjects, sCMObjectType, objectId);\n\t\t\t\tif (obj != null)\n\t\t\t\t{\n\t\t\t\t\tmoe = new MoveObjectError();\n\t\t\t\t\tmoe.SCMObject = obj;\n\t\t\t\t\t//Currently the only thing that will fail is if you do not have move permission\n\t\t\t\t\t//to the dest or the object itself.\n\t\t\t\t\tmoe.ErrorMessage = WebServiceResource.MovePermissionDenied;\n\t\t\t\t\tErrors.Add(moe);\n\t\t\t\t}\n\t\t\t\telse // probably not possible but logging doesn't hurt.\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Could not find SCMObject to extract the error for {objectId}.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Iterates through the array of objects to get the matching\n\t\t/// object by id and type.\n\t\t/// </summary>\n\t\t/// <param name=\"Objects\"></param>\n\t\t/// <param name=\"sCMObjectType\"></param>\n\t\t/// <param name=\"Id\"></param>\n\t\t/// <returns></returns>\n\t\tprivate SCMObject FindObject(SCMObject[] Objects, SCMObjectType sCMObjectType, string Id)\n\t\t{\n\t\t\tif (Objects == null) return null;\n\t\t\tforeach (SCMObject obj in Objects)\n\t\t\t{\n\t\t\t\tif (obj.ObjectType == sCMObjectType && obj.Id == Id)\n\t\t\t\t\treturn obj;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\n\n\t\t/// <summary>\n\t\t/// Move a folder or a document to a new location\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"type\">The type of object to move.</param>\n\t\t/// <param name=\"id\">The id of the object to move.</param>\n\t\t/// <param name=\"destinationFolderId\">Folder to move the object to</param>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Move']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Move']/soap\" />\n        /// <seealso cref=\"Copy\">Copy</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Move a folder or a document to a new location\")]\n        public void Move(string token, SCMObjectType type, string id, string destinationFolderId)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tobject source = LoadObject(user, type, id, Enums.Security.Move);\n                // Note: This is *not* checking if an object of the same name already exists at the destination\n\t\t\t\tFolder destination = LoadFolder(user, destinationFolderId, Enums.Security.Create);\n\t\t\t\tGuid destinationFolderUid = (destination == null ? Guid.Empty : destination.Uid);\n                if (source is Folder)\n                {\n                    Folder folder = (Folder)source;\n\t\t\t\t\tif (folder.ParentFolderUid == destinationFolderUid) return;\n                    Folders folders = new Folders {folder};\n\t\t\t\t\tServiceLocator.GetInstance<IFolderRepository>().MoveMultipleToFolder(user, folders, destinationFolderUid, null);\n\t\t\t\t}\n                else if (source is Document)\n                {\n                    Document ld = (Document)source;\n                    if (destination == null) Fail(PublicException.FailReason.ReadOnlyObject, \"Root folder cannot hold documents\");\n\t\t\t\t\tif (ld.FolderUid == destinationFolderUid) return;\n                    Documents lds = new Documents {ld};\n                \tDocumentRepository.MoveMultipleToFolder(user, lds, destination, WebServiceResource.ViaWebService);\n                }\n                else\n                {\n                    FailInvalidObjectType(type);\n                }\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Parse the path into one or more objects\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"currentFolderId\">Starting folder for the path</param>\n\t\t/// <param name=\"path\">Ex: mdoe@selectron.com.Z/Test Folder</param>\n\t\t/// <param name=\"loadExtendedMetadata\">If true it will load the metadata for the SCMObjects that are returned.</param>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='ParsePath']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='ParsePath']/soap\" />\n\t\t/// <returns>The result is an SCMPath which contains information about the path.</returns>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Parse the path into one or more objects\")]\n        public SCMPath ParsePath(string token, string currentFolderId, string path, bool loadExtendedMetadata)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n            \tGuid currentFolderUid = Conversions.TryParseGuid(currentFolderId);\n\n\t\t\t\tif(path == null)\n\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidArgument, WebServiceResource.error_PathCannotBeNull);\n\n\t\t\t\treturn new SCMPath(user, new LogicalFileSystemParseResultFactory().Parse(user, currentFolderUid, path), loadExtendedMetadata);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n        #endregion\n\n        #region Document specific methods\n\n\t\t/// <summary>\n\t\t/// Mark a given document as having been checked out.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">The id of the document to check out.</param>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCheckout']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCheckout']/soap\" />\n        /// <seealso cref=\"DocumentCheckoutCancel\">DocumentCheckoutCancel</seealso>\n        /// <seealso cref=\"DocumentCheckin\">DocumentCheckin</seealso>\n        [SOAPLogExtension]\n        [WebMethod(Description = \"Mark a given document as having been checked out.\")]\n        public void DocumentCheckout(string token, string documentId)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument ld = LoadDocument(user, documentId, Enums.Security.Create);\n                DocumentRepository.CheckoutDocument(user, ld);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Check a document back into the repository using a document in the repository as the new version\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">The document to checkin.</param>\n\t\t/// <param name=\"revisionDocumentId\">The document to checkin with. Will replace the document with id=documentId</param>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCheckin']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCheckin']/soap\" />\n        /// <seealso cref=\"DocumentCheckout\">DocumentCheckout</seealso>\n        /// <seealso cref=\"DocumentCheckoutCancel\">DocumentCheckoutCancel</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Check a document back into the repository using a document in the repository as the new version\")]\n        public void DocumentCheckin(string token, string documentId, string revisionDocumentId)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument document = LoadDocument(user, documentId, Enums.Security.Create);\n\t\t\t\tDocument revisionDocument = LoadDocument(user, revisionDocumentId, Enums.Security.Move);\n                DocumentRepository.CheckinDocumentExisting(user, document, revisionDocument, new DocumentRepository.InsertDocumentOptions());\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// This method will simply undo the checkout of a document.\n\t\t/// If this document was drafted say be edit in browser the draft will\n\t\t/// not be checked in.\n\t\t/// </summary>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCheckoutCancel']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCheckoutCancel']/soap\" />\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">The document to under the checkout.</param>\n        /// <seealso cref=\"DocumentCheckin\">DocumentCheckin</seealso>\n        /// <seealso cref=\"DocumentCheckout\">DocumentCheckout</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Cancel a checkout of a document\")]\n        public void DocumentCheckoutCancel(string token, string documentId)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument ld = LoadDocument(user, documentId, Enums.Security.Write);\n                DocumentRepository.UndoCheckoutDocument(user, ld, \"\", false);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Resulting object from a call to DocumentCreateBegin.\n\t\t/// Holds the fileid as a string and the size of the chunks to send.\n\t\t/// </summary>\n        public class DocumentCreateBeginResult\n        {\n\t\t\tpublic string FileIdentifier;\n\t\t\tpublic string PDFFileIdentifier;\n\t\t\tpublic string ContentFileIdentifier;\n\t\t\tpublic int ChunkSize;\n\n            public DocumentCreateBeginResult() { }\n            public DocumentCreateBeginResult(string fileIdentifier, int chunkSize, string pdfFileIdentifier, string contentFileIdentifier)\n            {\n                FileIdentifier = fileIdentifier;\n\t\t\t\tPDFFileIdentifier = pdfFileIdentifier;\n            \tContentFileIdentifier = contentFileIdentifier;\n                ChunkSize = chunkSize;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Step 1 of 3 for upload.  Begins an upload.  Returns a FileIdentifier and ChunkSize on success to be used with future calls.  folderId is optional, and can be used to upload a file to a specific folder.  MD5 hash of the file is optional, and may be null or 0 length.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"document\">SCMDocument object to use as the creating document.  Must have the Name and FileSize properties set.  Id can be left blank if creating a new document.  If using this for a checkin fill out the CheckoutUserid should be filled, but is not required.</param>\n\t\t/// <param name=\"md5Hash\">Nullable md5 hash for this document</param>\n\t\t/// <param name=\"pdfFileSize\">optional - Size of the pdf conversion that will be uploaded.</param>\n\t\t/// <param name=\"pdfMd5Hash\">optional - Nullable md5 hash for this document</param>\n\t\t/// <param name=\"contentFileSize\">optional - Size of the text content that will be uploaded.</param>\n\t\t/// <param name=\"contentMd5Hash\">optional - Nullable md5 hash for the content of document</param>\n\t\t/// <returns>DocumentCreateBeginResult</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateBeginWithFolder']/example\" />\n\t\t/// <seealso cref=\"DocumentCreateUploadChunk\">DocumentCreateUploadChunk</seealso>\n\t\t/// <seealso cref=\"DocumentCreateCancel\">DocumentCreateCancel</seealso>\n\t\t/// <seealso cref=\"DocumentCreateCommit\">DocumentCreateCommit</seealso>\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Step 1 of 3 for upload.  Begins an upload.  Returns a FileIdentifier and ChunkSize on success to be used with future calls.  folderId is optional, and can be used to upload a file to a specific folder.  MD5 hash of the file is optional, and may be null or 0 length.\")]\n\t\tpublic DocumentCreateBeginResult DocumentCreateFilesBegin(string token, SCMDocument document, byte[] md5Hash, long? pdfFileSize, byte[] pdfMd5Hash, long? contentFileSize, byte[] contentMd5Hash)\n\t\t{\n\t\t\tDocumentCreateBeginResult result = null;\n\t\t\t_log.InfoNoPII(\"DocumentCreateFilesBegin begin\");\n\t\t\ttry\n\t\t\t{\n\t\t\t\tGuid docUid = Conversions.TryParseGuid(document.Id);\n\t\t\t\t//Vaildate file name\n\t\t\t\tif (string.IsNullOrEmpty(document.Name) && docUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t// if there is no name, and this is not a check in of existing doc\n\t\t\t\t\tFail(PublicException.FailReason.InvalidArgument, \"No name provided\");\n\t\t\t\t}\n\t\t\t\tif (document.Name != null && DocumentUtilities.ValidateDocumentName(document.Name))\n\t\t\t\t{\n\t\t\t\t\tFail(PublicException.FailReason.InvalidArgument, \"Invalid Characters: \" + document.Name);\n\t\t\t\t}\n\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\t_log.InfoNoPII($\"DocumentCreateFilesBegin User {user.Uid} is beginning an upload\");\n\t\t\t\tDocumentRepository.InsertType insertType = DocumentRepository.InsertType.NewDocument;\n\t\t\t\tDocument d = null;\n\t\t\t\tif (docUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\td = (Document)LoadObject(user, document);\n\t\t\t\t\tif (d == null) Fail(PublicException.FailReason.NonexistentObject,\n\t\t\t\t\t\t$\"DocumentId {document.Id} does not exist\");\n\t\t\t\t\tif (!string.IsNullOrEmpty(document.Name)) d.Name = document.Name;\n\t\t\t\t\tif (d.IsCheckedOut()) insertType = DocumentRepository.InsertType.CheckIn;\n\t\t\t\t}\n\t\t\t\telse if (!string.IsNullOrEmpty(document.ParentFolderId) && LoadFolder(user, document.ParentFolderId, Enums.Security.See) == null)\n\t\t\t\t{\n\t\t\t\t\tFail(PublicException.FailReason.NonexistentObject,\n\t\t\t\t\t\t$\"FolderUid {document.ParentFolderId ?? string.Empty} does not exist\");\n\t\t\t\t}\n\t\t\t\tif (d == null) d = new Document(user, Conversions.TryParseGuid(document.ParentFolderId), document.Name);\n\t\t\t\td.NativeFileSize = document.FileSize;\n\n                // Not verifying duplicate handeling as it will be handled by the commit.\n                DocumentRepository.VerifyInsertDocument(user, insertType, d, null, new DocumentRepository.InsertDocumentOptions().SetVerifySourceFile(false), Enums.DuplicateHandling.Allow);\n\t\t\t\tint chunkSize = Configuration.GetInt32AppSetting(Constants.ApplicationSettings.WebServiceChunkSize, _defaultChunkSize);\n\t\t\t\tUploadInfo info = new UploadInfo(user, document.Name, document.FileSize, chunkSize, document.ParentFolderId, md5Hash, document.MIMEType);\n\t\t\t\tServiceLocator.GetInstance<IUploadPersistence>().Save(info);\n\t\t\t\t_log.InfoWithPII(\n\t\t\t\t\t$\"User {user.Uid} is beginning an upload of file {{0}} with identifier {info.UploadToken}\", document.Name);\n\t\t\t\tUploadInfo pdfInfo = null;\n\t\t\t\tif (pdfFileSize != null && pdfFileSize > 0)\n\t\t\t\t{\n\t\t\t\t\tstring tmpName = Path.GetFileNameWithoutExtension(document.Name) + FileUtil.Extensions.PDF;\n\t\t\t\t\tpdfInfo = new UploadInfo(user, tmpName, pdfFileSize ?? 0, chunkSize, string.Empty, pdfMd5Hash, MediaTypeNames.Application.Pdf);\n\t\t\t\t\tServiceLocator.GetInstance<IUploadPersistence>().Save(pdfInfo);\n\t\t\t\t\t_log.InfoWithPII(\n\t\t\t\t\t\t$\"User {user.Uid} is beginning an upload of file {{0}} PDF conversion with identifier {pdfInfo.UploadToken}\", document.Name);\n\t\t\t\t}\n\t\t\t\tUploadInfo contentInfo = null;\n\t\t\t\tif (contentFileSize != null && contentFileSize > 0)\n\t\t\t\t{\n\t\t\t\t\tstring tmpName = Path.GetFileNameWithoutExtension(document.Name) + FileUtil.Extensions.CONTENT;\n\t\t\t\t\tcontentInfo = new UploadInfo(user, tmpName, contentFileSize ?? 0, chunkSize, string.Empty, contentMd5Hash, MediaTypeNames.Text.Plain);\n\t\t\t\t\tServiceLocator.GetInstance<IUploadPersistence>().Save(contentInfo);\n\t\t\t\t\t_log.InfoWithPII(\n\t\t\t\t\t\t$\"User {user.Uid} is beginning an upload of file {{0}} text content with identifier {contentInfo.UploadToken}\", document.Name);\n\t\t\t\t}\n\t\t\t\tresult = new DocumentCreateBeginResult(info.UploadToken,\n\t\t\t\t\t\t\t\tchunkSize,\n\t\t\t\t\t\t\t\t(pdfInfo == null) ? string.Empty : pdfInfo.UploadToken,\n\t\t\t\t\t\t\t\t(contentInfo == null) ? string.Empty : contentInfo.UploadToken);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n        /// <summary>\n        /// Step 1 of 3 for upload.  Begins an upload.  Returns a FileIdentifier and ChunkSize on success to be used with future calls.  folderId is optional, and can be used to upload a file to a specific folder.  MD5 hash of the file is optional, and may be null or 0 length.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"document\">SCMDocument object to use as the creating document.  Must have the Name and FileSize properties set.  Id can be left blank if creating a new document.  If using this for a checkin fill out the CheckoutUserid should be filled, but is not required.</param>\n        /// <param name=\"md5Hash\">Nullable md5 hash for this document</param>\n\t\t/// <returns>DocumentCreateBeginResult</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateBeginWithFolder']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateBeginWithFolder']/soap\" />\n        /// <seealso cref=\"DocumentCreateUploadChunk\">DocumentCreateUploadChunk</seealso>\n        /// <seealso cref=\"DocumentCreateCancel\">DocumentCreateCancel</seealso>\n        /// <seealso cref=\"DocumentCreateCommit\">DocumentCreateCommit</seealso>\n        [SOAPLogExtension]\n        [WebMethod(Description = \"Step 1 of 3 for upload.  Begins an upload.  Returns a FileIdentifier and ChunkSize on success to be used with future calls.  folderId is optional, and can be used to upload a file to a specific folder.  MD5 hash of the file is optional, and may be null or 0 length.\")]\n\t\tpublic DocumentCreateBeginResult DocumentCreateBeginWithFolder(string token, SCMDocument document, byte[] md5Hash)\n        {\n        \treturn DocumentCreateFilesBegin(token, document, md5Hash, null, null, null, null);\n        }\n\n\n\t\t/// <summary>\n\t\t/// Cancels an upload in progress.  Should be called if, for any reason, the upload cannot be completed.  Releases server resources.\n\t\t/// </summary>\n\t\t/// <!-- Note this is the same example as DocumentCreateBeginWithFolder -->\n        /// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateBeginWithFolder']/example\" />\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"fileIdentifier\">Identifier located on the DocumentCreateBeginResult</param>\n\t\t/// <seealso cref=\"DocumentCreateBeginWithFolder\">DocumentCreateBeginWithFolder</seealso>\n        /// <seealso cref=\"DocumentCreateUploadChunk\">DocumentCreateUploadChunk</seealso>\n        /// <seealso cref=\"DocumentCreateCommit\">DocumentCreateCommit</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Cancels an upload in progress.  Should be called if, for any reason, the upload cannot be completed.  Releases server resources.\")]\n        public void DocumentCreateCancel(string token, string fileIdentifier)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                UploadInfo info = ServiceLocator.GetInstance<IUploadPersistence>().Load(fileIdentifier);\n                if (info != null && info.UserAccountUid != user.Uid) throw new PublicException(PublicException.FailReason.PermissionDenied, \"FileIdentifier is for a different user\",\n\t                $\"Token is for user {user.Uid}, fileIdentifier is for user {info.UserAccountUid}\");\n                // At this point, it's either for this user, or it's nonexistent.\n                if (info != null)\n                {\n                \tinfo.Delete();\n                    _log.InfoNoPII($\"File upload identifier {fileIdentifier} cancelled\");\n                }\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Step 3 of 3 for upload (option 1).  Commits a completed upload.  Should be called after all files are uploaded.  May return ResendFileFailure, in which case BeginUpload, etc, should be called again.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"identifiers\">Identifiers located in the DocumentCreateBeginResult</param>\n\t\t/// <param name=\"scmDocument\">The document information to create with the uploaded file.</param>\n\t\t/// <returns>The document that was created. Will now have the id of the document.</returns>\n        /// <!-- Note this is the same example as DocumentCreateBegin -->\n        /// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateBeginWithFolder']/example\" />\n\t\t/// <seealso cref=\"DocumentCreateFilesBegin\">DocumentCreateFilesBegin</seealso>\n\t\t/// <seealso cref=\"DocumentCreateBeginWithFolder\">DocumentCreateBeginWithFolder</seealso>\n\t\t/// <seealso cref=\"DocumentCreateUploadChunk\">DocumentCreateUploadChunk</seealso>\n        /// <seealso cref=\"DocumentCreateCancel\">DocumentCreateCancel</seealso>\n        /// <seealso cref=\"DocumentCreateCheckin\">DocumentCreateCheckin</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Step 3 of 3 for upload (option 1).  Commits a completed upload.  Should be called after the entire file is uploaded.  May return ResendFileFailure, in which case BeginUpload, etc, should be called again.\")]\n\t\tpublic SCMDocument DocumentCreateFilesCommit(string token, DocumentCreateBeginResult identifiers, SCMDocument scmDocument)\n        {\n\t\t\tDocument ld = null;\n\t\t\tUploadInfo info = null;\n\t\t\tUploadInfo pdfInfo = null;\n\t\t\tUploadInfo contentInfo = null;\n            UserAccount user = null;\n\t\t\ttry\n            {\n\t\t\t\tuser = AuthenticateFromToken(token).UserAccount;\n\t\t\t\t_log.InfoNoPII(\n\t\t\t\t\t$\"DocumentCreateFilesCommit -- User {user.Uid} uploaded fileIdentifier {identifiers.FileIdentifier}, pdf {identifiers.PDFFileIdentifier ?? string.Empty}, content {identifiers.ContentFileIdentifier ?? string.Empty}\");\n\t\t\t\tIUploadPersistence uploadPersister = ServiceLocator.GetInstance<IUploadPersistence>();\n                info = uploadPersister.Load(identifiers.FileIdentifier);\n\t\t\t\tif (info == null) throw new PublicException(PublicException.FailReason.InvalidArgument, \"The fileIdentifier does not exist.  The server may have terminated the upload unexpectedly.\",\n\t\t\t\t\t$\"fileIdentifier {identifiers.FileIdentifier} is null or not an UploadFileInfo object.\");\n                info.VerifyCompleteFile(user);\n\n\t\t\t\tstring extractContent = null;\n\t\t\t\tif (!string.IsNullOrEmpty(identifiers.PDFFileIdentifier))\n\t\t\t\t{\n                    pdfInfo = uploadPersister.Load(identifiers.PDFFileIdentifier);\n\t\t\t\t\tif (pdfInfo == null) throw new PublicException(PublicException.FailReason.InvalidArgument, \"The fileIdentifier does not exist.  The server may have terminated the upload unexpectedly.\",\n\t\t\t\t\t\t$\"fileIdentifier {identifiers.PDFFileIdentifier} for PDF is null or not an UploadFileInfo object.\");\n\t\t\t\t\tpdfInfo.VerifyCompleteFile(user);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(identifiers.ContentFileIdentifier))\n\t\t\t\t{\n                    contentInfo = uploadPersister.Load(identifiers.ContentFileIdentifier);\n\t\t\t\t\tif (contentInfo == null) throw new PublicException(PublicException.FailReason.InvalidArgument, \"The fileIdentifier does not exist.  The server may have terminated the upload unexpectedly.\",\n\t\t\t\t\t\t$\"fileIdentifier {identifiers.ContentFileIdentifier} for PDF is null or not an UploadFileInfo object.\");\n\t\t\t\t\tcontentInfo.VerifyCompleteFile(user);\n\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\t\tusing (FileStream strm = new FileStream(contentInfo.FullFileName, FileMode.Open, FileAccess.Read, FileShare.Read))\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (StreamReader extractData = new StreamReader(strm))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsb.Append(extractData.ReadToEnd());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\textractContent = sb.ToString();\n\t\t\t\t}\n\n\t\t\t\tld = scmDocument.SaveNewPlus(user, info.FullFileName, (pdfInfo == null) ? null : pdfInfo.FullFileName, extractContent, info.MIMEType);\n                _log.InfoWithPII(\n\t                $\"User {user.Uid} uploaded file {{0}} as documentId {ld.Uid} to folderId {scmDocument.ParentFolderId}{((pdfInfo != null) ? @\" with PDF conversion\" : string.Empty)}{((contentInfo != null) ? @\" with text content\" : string.Empty)}\", Path.GetFileName(info.FileName));\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n\t\t\tfinally\n            {\n\t\t\t\tif (info != null) info.Delete();\n\t\t\t\tif (pdfInfo != null) pdfInfo.Delete();\n\t\t\t\tif (contentInfo != null) contentInfo.Delete();\n\t\t\t}\n\n\t\t\treturn new SCMDocument(user, ld, true);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Step 3 of 3 for upload (option 1).  Commits a completed upload.  Should be called after all files are uploaded.  May return ResendFileFailure, in which case BeginUpload, etc, should be called again.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"fileIdentifier\">Identifier located on the DocumentCreateBeginResult</param>\n\t\t/// <param name=\"scmDocument\">The document information to create with the uploaded file.</param>\n\t\t/// <returns>The document that was created. Will now have the id of the document.</returns>\n\t\t/// <!-- Note this is the same example as DocumentCreateBegin -->\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateBeginWithFolder']/example\" />\n\t\t/// <seealso cref=\"DocumentCreateBeginWithFolder\">DocumentCreateBeginWithFolder</seealso>\n\t\t/// <seealso cref=\"DocumentCreateUploadChunk\">DocumentCreateUploadChunk</seealso>\n\t\t/// <seealso cref=\"DocumentCreateCancel\">DocumentCreateCancel</seealso>\n\t\t/// <seealso cref=\"DocumentCreateCheckin\">DocumentCreateCheckin</seealso>\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Step 3 of 3 for upload (option 1).  Commits a completed upload.  Should be called after the entire file is uploaded.  May return ResendFileFailure, in which case BeginUpload, etc, should be called again.\")]\n\t\tpublic SCMDocument DocumentCreateCommit(string token, string fileIdentifier, SCMDocument scmDocument)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\t_log.InfoNoPII($\"DocumentCreateCommit -- User {user.Uid} uploaded fileIdentifier {fileIdentifier}\");\n\t\t\t\tUploadInfo info = ServiceLocator.GetInstance<IUploadPersistence>().Load(fileIdentifier);\n\t\t\t\tif (info == null) throw new PublicException(PublicException.FailReason.InvalidArgument, \"The fileIdentifier does not exist.  The server may have terminated the upload unexpectedly.\",\n\t\t\t\t\t$\"fileIdentifier {fileIdentifier} is null or not an UploadFileInfo object.\");\n\t\t\t\t_log.InfoNoPII($\"DocumentCreateCommit -- User {user.Uid} fileIdentifier {fileIdentifier} before verify\");\n\t\t\t\tinfo.VerifyCompleteFile(user);\n\t\t\t\t_log.InfoNoPII($\"DocumentCreateCommit -- User {user.Uid} fileIdentifier {fileIdentifier} after verify\");\n\t\t\t\tDocument ld = scmDocument.SaveNew(user, info.FullFileName, info.MIMEType);\n\t\t\t\t_log.InfoWithPII(\n\t\t\t\t\t$\"User {user.Uid} uploaded file {{0}} as documentId {ld.Uid} to folderId {scmDocument.ParentFolderId}\", Path.GetFileName(info.FileName));\n\t\t\t\tinfo.Delete();\n\t\t\t\treturn new SCMDocument(user, ld, true);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Step 3 for 3 upload (option 2).  Commits a completed upload.  Should be called after the entire file is uploaded.  May return ResendFileFailure, in which case BeginUpload, etc, should be called again.  This function will also check in and check out the given file for the collaboration specified.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"fileIdentifier\">Identifier located on the DocumentCreateBeginResult</param>\n\t\t/// <param name=\"checkedOutDocumentId\">Id of the document to checkin the uploaded file to.</param>\n\t\t/// <param name=\"keepCheckedOut\">If true the uploaded file will be a draft of the checked out document.</param>\n\t\t/// <returns>The updated document that was checked in.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateCheckin']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateCheckin']/soap\" />\n        /// <seealso cref=\"DocumentCreateBeginWithFolder\">DocumentCreateBeginWithFolder</seealso>\n        /// <seealso cref=\"DocumentCreateUploadChunk\">DocumentCreateUploadChunk</seealso>\n        /// <seealso cref=\"DocumentCreateCancel\">DocumentCreateCancel</seealso>\n        /// <seealso cref=\"DocumentCreateCheckin\">DocumentCreateCommit</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Step 3 of 3 upload (option 2).  Commits a completed upload.  Called after the entire file is uploaded.  May return ResendFileFailure, in which case BeginUpload, etc, should be called again.  This function will also check in and check out the given file for the collaboration specified\")]\n        public SCMDocument DocumentCreateCheckin(string token, string fileIdentifier, string checkedOutDocumentId, bool keepCheckedOut)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument document = LoadDocument(user, checkedOutDocumentId, Enums.Security.Create);\n                Document newLd;\n\t\t\t\tUploadInfo info = ServiceLocator.GetInstance<IUploadPersistence>().Load(fileIdentifier);\n\t\t\t\tif (info == null) throw new PublicException(PublicException.FailReason.InvalidArgument, \"The fileIdentifier does not exist.  The server may have terminated the upload unexpectedly.\",\n\t\t\t\t\t$\"fileIdentifier {fileIdentifier} is null or not an UploadFileInfo object.\");\n\t\t\t\tinfo.VerifyCompleteFile(user);\n\t\t\t\t// It's good - send it to the processor.\n                if (keepCheckedOut)\n                { // instead of checking it in now we will draft it\n\t\t\t\t\tnewLd = DocumentRepository.DraftDocument(user, document, document.Name, info.FullFileName, CommonRepository.GetSourceFromUserAgent(Context.Request.UserAgent), info.MIMEType);\n                }\n                else\n                {\n                    DocumentRepository.InsertDocumentOptions insertOptions = new DocumentRepository.InsertDocumentOptions();\n                    insertOptions.SetHistoryText($\"Via web service upload of {document.Name}\");\n                    newLd = DocumentRepository.CheckinDocument(user, document, info.FileName, info.FullFileName, CommonRepository.GetSourceFromUserAgent(Context.Request.UserAgent), insertOptions);\n                }\n\t\t\t\t_log.InfoWithPII(\n\t\t\t\t\t$\"User {user.Uid} uploaded file {{0}} as documentId {newLd.Uid}, fileDataId {newLd.FileDataUid}, replacing checked out documentId {checkedOutDocumentId}\", Path.GetFileName(info.FileName));\n            \tinfo.Delete();\n                return new SCMDocument(user, newLd, true);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Step 2 of 3 for upload.  Uploads a chunk of data via a byte array.  May return ResendChunkFailure, in which case it should be called again, or ResendFileFailure, in which case the process should start back at chunk 1.  MD5 hash of the chunk is optional, and may be null or 0 length.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"fileIdentifier\">Identifier located on the DocumentCreateBeginResult</param>\n\t\t/// <param name=\"index\">Current chunk being uploaded for the file.</param>\n\t\t/// <param name=\"bufferLength\">The chunks size.</param>\n\t\t/// <param name=\"buffer\">The actual chunk</param>\n\t\t/// <param name=\"md5Hash\">This is a hash of the chunk itself.</param>\n        /// <!-- Note this is the same example as DocumentCreateBegin -->\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateBeginWithFolder']/example\" />\n        /// <seealso cref=\"DocumentCreateBeginWithFolder\">DocumentCreateBeginWithFolder</seealso>\n        /// <seealso cref=\"DocumentCreateCancel\">DocumentCreateCancel</seealso>\n        /// <seealso cref=\"DocumentCreateCommit\">DocumentCreateCommit</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Step 2 of 3 for upload.  Uploads a chunk of data via a byte array.  May return ResendChunkFailure, in which case it should be called again, or ResendFileFailure, in which case the process should start back at chunk 1.  MD5 hash of the chunk is optional, and may be null or 0 length.\")]\n        public void DocumentCreateUploadChunk(string token, string fileIdentifier, int index, int bufferLength, byte[] buffer, byte[] md5Hash)\n        {\n            try\n            {\n\t\t\t\t_log.InfoNoPII(\n\t\t\t\t\t$\"DocumentCreateUploadChunk begin {fileIdentifier}, chunk {index} - {bufferLength} bytes\");\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tUploadInfo info = ServiceLocator.GetInstance<IUploadPersistence>().Load(fileIdentifier);\n\t\t\t\tif (info == null) throw new PublicException(PublicException.FailReason.InvalidArgument, \"The fileIdentifier does not exist.  The server has terminated the upload unexpectedly.\",\n\t\t\t\t\t$\"fileIdentifier {fileIdentifier} is null or not an UploadFileInfo object.\");\n\t\t\t\tinfo.UploadChunk(index, bufferLength, buffer, md5Hash);\n\t\t\t\t_log.InfoNoPII($\"DocumentCreateUploadChunk end {fileIdentifier}, chunk {index} - {bufferLength} bytes\");\n\t\t\t}\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n        }\n\n\n\t\t/// <summary>\n\t\t/// DISCONTINUED. Uploads a chunk of data via DIME attachments.  May return ResendChunkFailure, in which case it should be called again, or ResendFileFailure, in which case the process should start back at chunk 1.  'data' attachment is required.  'hash' attachment (md5 hash of the chunk) is optional and may be missing, null, or 0 length.\n\t\t/// In order to send the chunk in an attachment it must be done with a web service extension in .net.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"fileIdentifier\">Identifier located on the DocumentCreateBeginResult</param>\n\t\t/// <param name=\"index\">The sequence index of the chunk being sent.</param>\n\t\t/// <param name=\"length\">The chunk size.</param>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateUploadChunkAttachment']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentCreateUploadChunkAttachment']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"DISCONTINUED. Uploads a chunk of data via DIME attachments.  May return ResendChunkFailure, in which case it should be called again, or ResendFileFailure, in which case the process should start back at chunk 1.  'data' attachment is required.  'hash' attachment (md5 hash of the chunk) is optional and may be missing, null, or 0 length.\")]\n        public void DocumentCreateUploadChunkAttachment(string token, string fileIdentifier, int index, int length)\n        {\n\t\t\tFail(new PublicException(PublicException.FailReason.InternalError, \"DocumentCreateUploadChunkAttachment method has been discontinued.\"));\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Download a given document by the document's object id.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">Id of the document to download.</param>\n\t\t/// <param name=\"start\">Index of the stream to start downloading.</param>\n\t\t/// <param name=\"length\">Length of bytes to get.</param>\n\t\t/// <param name=\"format\">Format of the document to download.</param>\n\t\t/// <returns>bytes of data represented in the document.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentDownload']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentDownload']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Retrieve the document content by the document's object id.\")]\n\t\tpublic byte[] DocumentDownload(string token, string documentId, long start, long length, SCMDocument.DownloadFormat format)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// TODO: Implement a flavor that does via a DIME attachment\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument ld = LoadDocument(user, documentId, Enums.Security.Read);\n\n\t\t\t\tint allowedChunkSize = Configuration.GetInt32AppSetting(Constants.ApplicationSettings.WebServiceChunkSize, _defaultChunkSize);\n\t\t\t\tif ((length <= 0) || (length > allowedChunkSize)) Fail(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t$\"Illegal Length = {length}, maximum allowed chunk size = {allowedChunkSize}.\");\n\n\t\t\t\tif (!Enum.IsDefined(typeof(SCMDocument.DownloadFormat), format)) Fail(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t$\"Unrecognized download format {format}\");\n\t\t\t\tDocumentReader rdr = new DocumentReader(user, ld);\n\t\t\t\tStorageConstants.StorageFormat docFormat = (StorageConstants.StorageFormat)format;\n\t\t\t\tlong contentLength = rdr.GetContentLength(docFormat);\n\t\t\t\tif (start >= contentLength) Fail(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t$\"Start {start} is beyond length of file {contentLength}\");\n\n\t\t\t\tusing (Stream str = rdr.OpenPartialStream(docFormat, start, (start + length - 1)))\n\t\t\t\t{\n\t\t\t\t\tbyte[] buffer = FileUtil.CopyStreamToByteArray(str);\n\t\t\t\t\tif (start == 0) DocumentRepository.LogDocumentDownload(user, ld, docFormat, false, string.Empty, WebServiceResource.WebService);\n\t\t\t\t\t_log.InfoNoPII($\"DocumentDownload end {ld.Uid}, start {start} - {buffer.LongLength} bytes\");\n\t\t\t\t\treturn buffer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Download a given document preview image (GIF) by the document's object id and page number.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">Id of the document.</param>\n\t\t/// <param name=\"start\">Index of the stream to start downloading.</param>\n\t\t/// <param name=\"length\">Lenght of bytes to get. A negative length value will attempt to send back the full size.</param>\n\t\t/// <param name=\"pageNumber\">The page number to download.</param>\n\t\t/// <param name=\"imageZoom\">Zoom level of image.</param>\n\t\t/// <returns>bytes of data represented in the document page image.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentDownloadPreviewImage']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentDownloadPreviewImage']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Retrieve document preview page image for a given document by the document's object id and page number.\")]\n\t\tpublic byte[] DocumentDownloadPreviewImage(string token, string documentId, int start, int length, int pageNumber, SCMPreviewImageZoom imageZoom)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// TODO: Implement a flavor that does via a DIME attachment\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tISharedStorage sharedStorage = ServiceLocator.GetInstance<IAtlasSharedStorageFactory>()\n\t\t\t\t\t.GetSharedFileStorage(user.AccountId, Enums.SharedStorageUseCase.DocPreview);\n\n\t\t\t\tImageScale imageScale = ImageScale.GetAllowedFromZoom(imageZoom == SCMPreviewImageZoom.Thumbnail ? (int) imageZoom : ((int) imageZoom)/100.0);\n\t\t\t\tDocument ld = LoadDocument(user, documentId, Enums.Security.Read);\n\t\t\t\tif (ld == null) Fail(PublicException.FailReason.InvalidArgument, $\"Invalid document ID {documentId}\");\n\t\t\t\tServiceLocator.GetInstance<IPageCountOnDemand>().EnsureDocumentPageCountIfEnabledForWebServices(ld, user.Account); // Used to not break our customers that might use page count - this will eventually be removed\n\t\t\t\tif ((pageNumber <= 0) || (pageNumber > ld.PageCount)) Fail(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t$\"Invalid page number {pageNumber}\");\n\n\t\t\t\tstring directory = LWDPRepository.GetLWDPDocumentPath(ld.AccountId, ld.FileName, imageScale);\n\t\t\t\t//PDFToDo: Move this junk to a common place so it isn't copied in DocumentDownloadImage\n\t\t\t\tstring fileGif = $\"page_{pageNumber.ToString(new string('0', ld.PageCount.ToString().Length))}.gif\";\n\t\t\t\tstring pathGif = Path.Combine(directory, fileGif);\n\t\t\t\tstring fileOther =\n\t\t\t\t\t$\"page_{pageNumber.ToString(ADEXS.Core.Domain.FileOperations.OperationFactory.OUTPUT_PAGENUM_FORMAT)}.{ApplicationSettings.PreviewOutputFormat}\";\n\t\t\t\tstring pathOther = Path.Combine(directory, fileOther);\n\t\t\t\tstring path = sharedStorage.FileExists(user.AccountId, pathGif) ? pathGif :  sharedStorage.FileExists(user.AccountId, pathOther) ? pathOther : null;\n\n\t\t\t\tif (string.IsNullOrEmpty(path))\n\t\t\t\t{\n\t\t\t\t\tLWDPRepository.GeneratePreviewImages(ld, imageScale, new int[] {}, user);\n\t\t\t\t\tFail(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t\tstring.Format(\"Document preview image unavailable.\"));\n\t\t\t\t}\n\n\t\t\t\tDocumentReader rdr = new DocumentReader(user, ld);\n\t\t\t\tusing(Stream fs = sharedStorage.GetFileStream(user.AccountId, path))\t\t\t\t{\n\t\t\t\t\tif (start >= fs.Length) Fail(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t\t$\"Start {start} is beyond length of file {fs.Length}\");\n\t\t\t\t\tint maxLength = (int) fs.Length - (start > 0 ? start : 0);\n\t\t\t\t\tif (length > maxLength || length <= 0) length = maxLength;\n\t\t\t\t\tif (start > 0) fs.Seek(start, SeekOrigin.Begin);\n\t\t\t\t\tbyte[] buffer = new byte[length];\n\t\t\t\t\tint readLength = fs.Read(buffer, 0, buffer.Length);\n\t\t\t\t\t// This shouldn't happen\n\t\t\t\t\tif (readLength < buffer.Length) Fail(PublicException.FailReason.InternalError,\n\t\t\t\t\t\t$\"Expected to read {buffer.Length} bytes, read {readLength}\");\n\t\t\t\t\treturn buffer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Retrieve detailed document info for a given document by the document's object id.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">Id of the document to load.</param>\n\t\t/// <param name=\"loadExtendedMetadata\">If true it will load the metadata for the document.</param>\n\t\t/// <returns>The document related to that id.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentGetById']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentGetById']/soap\" />\n        /// <seealso cref=\"FolderGetById\">FolderGetById</seealso>\n        /// <seealso cref=\"DocumentSave\">DocumentSave</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Retrieve detailed document info for a given document by the document's object id.\")]\n        public SCMDocument DocumentGetById(string token, string documentId, bool loadExtendedMetadata)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n            \tDocument d = LoadDocument(user, documentId, loadExtendedMetadata ? Enums.Security.Read : Enums.Security.See);\n\t\t\t\tif (d == null) Fail(PublicException.FailReason.InvalidArgument, WebServiceResource.InvalidDocumentId);\n\t\t\t\treturn new SCMDocument(user, d, loadExtendedMetadata);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Retrieve detailed document history for a given document by the document's object id.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">Id of the document to load.</param>\n\t\t/// <returns>An array of SCMDocumentHistory</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentHistoryGetById']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Retrieve document history for a give document by the document's object id.\")]\n\t\tpublic SCMDocumentHistory[] DocumentHistoryGetById(string token, string documentId)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tList<SCMDocumentHistory> result = new List<SCMDocumentHistory>();\n\n\t\t\t\tGuid documentUid = Conversions.TryParseGuid(documentId);\n\n\t\t\t\tvar objectHistoryRepository = ServiceLocator.GetInstance<IObjectHistoryRepository>();\n\t\t\t\tList<ObjectHistory> objectHistories = objectHistoryRepository.LoadByObjectIdentifier(user, Enums.HistoryObjectType.Document, documentUid.ToString());\n\n\t\t\t\tforeach (ObjectHistory objectHistory in objectHistories)\n\t\t\t\t{\n\t\t\t\t\tGuid relatedDocumentUid = Guid.Empty;\n\t\t\t\t\tif (objectHistory.Data.Property(Constants.JavaScriptVars.LegacyHistoryRelatedDocumentUid) != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid.TryParse(\n\t\t\t\t\t\t\tobjectHistory.Data.Property(Constants.JavaScriptVars.LegacyHistoryRelatedDocumentUid).Value.ToString(),\n\t\t\t\t\t\t\tout relatedDocumentUid);\n\t\t\t\t\t}\n\t\t\t\t\tstring relatedVersion = string.Empty;\n\t\t\t\t\tif (objectHistory.Data.Property(Constants.JavaScriptVars.LegacyHistoryRelatedDocumentVersion) != null)\n\t\t\t\t\t{\n\t\t\t\t\t\trelatedVersion = objectHistory.Data.Property(Constants.JavaScriptVars.LegacyHistoryRelatedDocumentUid).Value.ToString();\n\t\t\t\t\t}\n\t\t\t\t\tvar documentHistory = new SCMDocumentHistory()\n\t\t\t\t\t{\n\t\t\t\t\t\tActionType = Enums.GetName(objectHistory.ActionType),\n\t\t\t\t\t\tComment = objectHistory.Comment,\n\t\t\t\t\t\tCreatedDate = objectHistory.CreatedDate,\n\t\t\t\t\t\tDocumentId = objectHistory.ObjectIdentifier,\n\t\t\t\t\t\tDocumentName = objectHistory.Name,\n\t\t\t\t\t\tRelatedData = ServiceLocator.GetInstance<IObjectHistoryMessageRenderingRepository>().GetMessage(objectHistory, AtlasContext.Current.UserAccount, false),\n\t\t\t\t\t\tRelatedDocumentId = relatedDocumentUid.ToString(),\n\t\t\t\t\t\tUserEmail = objectHistory.Email,\n\t\t\t\t\t\tUserFirstName = objectHistory.FirstName,\n\t\t\t\t\t\tUserLastName = objectHistory.LastName,\n\t\t\t\t\t\tRelatedVersion = relatedVersion\n\t\t\t\t\t};\n\t\t\t\t\tresult.Add(documentHistory);\n\t\t\t\t}\n\n\t\t\t\treturn result.ToArray();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an array of documents that match the subject document's metadata fields (which are specified as MustMatch or PartialMatch metadata fields).\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">Id of the document to match metadata. </param>\n\t\t/// <param name=\"folderId\">Folder id to look for a match. Can be the same folder.</param>\n\t\t/// <param name=\"MustMatchMetadata\">Metadata field names that must match between the documents. Example: \"field1|field2\"</param>\n\t\t/// <param name=\"PartialMatchMetadata\">These metadata fields are optional.  If they are passed then you can get partial matches of a documents metadata.  Example: \"field1|field2\"</param>\n\t\t/// <param name=\"ReturnAll\">If true it will return multiple document matches. Otherwise it will pick the most logical match.</param>\n\t\t/// <param name=\"loadExtendedMetadata\">If true will load the metadata with the document.</param>\n\t\t/// <returns>Documents that match on this metadata.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentGetMatchByIdAndMetadata']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentGetMatchByIdAndMetadata']/soap\" />\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Retrieve detailed document info for a given document by the document's object id.\")]\n        public SCMDocument[] DocumentGetMatchByIdAndMetadata(string token, string documentId, string folderId, string MustMatchMetadata, string PartialMatchMetadata, bool ReturnAll, bool loadExtendedMetadata)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tGuid documentUid = Conversions.TryParseGuid(documentId);\n\t\t\t\tGuid folderUid = Conversions.TryParseGuid(folderId);\n\n                int Match = -1; // not used here.\n\t\t\t\tDocuments docs = ServiceLocator.GetInstance<IDocumentRepository>().LoadMatchByUidAndMetadata(user, documentUid, folderUid, MustMatchMetadata, PartialMatchMetadata, ref Match, ReturnAll);\n                //if (docs == null || docs.Count < 1) Fail(PublicException.FailReason.NonexistentObject, string.Format(\"Document {0} does not have a match\", documentId));\n\n                SCMDocument[] returnDocs = new SCMDocument[docs.Count];\n\n                for (int i = 0; i < docs.Count; i++)\n                {\n                    returnDocs[i] = new SCMDocument(user,docs[i], loadExtendedMetadata);\n                }\n\n                return returnDocs;\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Gets the extracted text associated with the document.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">Id of the document to retrieve a path for.</param>\n\t\t/// <returns>A string containing the full path to a document</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentGetExtractedText']/example\" />\n\t\t[WebMethod(Description = \"Returns a string of the document's extracted text specified by documentId\")]\n\t\tpublic string DocumentGetExtractedText(string token, string documentId)\n\t\t{\n\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\tDocument d = LoadDocument(user, documentId, Enums.Security.Read);\n\t\t\tif (d == null)\n\t\t\t{\n\t\t\t\tFail(new PublicException(PublicException.FailReason.InvalidArgument, \"The requested document does not exist.\"));\n\t\t\t}\n\n\t\t\treturn DocumentRepository.LoadContent(d);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Gets the full path to a document.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"documentId\">Id of the document to retrieve a path for.</param>\n\t\t/// <returns>A string containing the full path to a document</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentGetPath']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Returns the full path to a document\")]\n\t\tpublic string DocumentGetPath(string token, string documentId)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument ld = LoadDocument(user, documentId, Enums.Security.Read);\n\n\t\t\t\treturn ld.GetLogicalPath();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Publish the current version of a document and return a public URL.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"scmDocument\">Document to publish.</param>\n\t\t/// <param name=\"publishName\">DEPRECATED. The document will be downloaded with a filename matching its currently defined name.</param>\n\t\t/// <param name=\"expirationDateUTC\">Date published document will expire.</param>\n\t\t/// <param name=\"publishPDF\">Publish the PDF conversion, if available.</param>\n\t\t/// <returns>The URL to the publication.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentPublish']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Publish the current version of a document\")]\n\t\tpublic string DocumentPublish(string token, SCMDocument scmDocument, string publishName,\n\t\t\t\t\t\t\t\t\t  DateTime expirationDateUTC, bool publishPDF)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tif (expirationDateUTC <= DateTime.UtcNow)\n\t\t\t\t\tFail(PublicException.FailReason.InvalidArgument, WebServiceResource.ExpirationDateIsInThePast);\n\t\t\t\tDocument ld = LoadDocument(user, scmDocument.Id, Enums.Security.Read);\n\t\t\t\tif (ld == null) Fail(PublicException.FailReason.NonexistentObject, WebServiceResource.InvalidDocument);\n\t\t\t\tIShareRepository shareRepository = ServiceLocator.GetInstance<IShareRepository>();\n\t\t\t\tPublicShareLink publicShareLink = new PublicShareLink\n\t\t\t\t{\n\t\t\t\t\tAccountId = user.AccountId,\n\t\t\t\t\tUserAccountUid = user.Uid,\n\t\t\t\t\tObjectType = Enums.ObjectType.Document,\n\t\t\t\t\tObjectUid = ld.Uid,\n\t\t\t\t\tCanDownloadNative = !publishPDF,\n\t\t\t\t\tCanDownloadPdf = publishPDF,\n\t\t\t\t\tPreviewBehavior = publishPDF ? Enums.PreviewBehavior.DownloadPdf : Enums.PreviewBehavior.DownloadNative,\n\t\t\t\t\tExpirationDate = expirationDateUTC,\n\t\t\t\t\tCreatedBy = user.EmailAddress,\n\t\t\t\t\tUpdatedBy = user.EmailAddress\n\t\t\t\t};\n\t\t\t\tif (!shareRepository.CanShare(user, publicShareLink))\n\t\t\t\t{\n\t\t\t\t\tFail(PublicException.FailReason.PermissionDenied, WebServiceResource.NoPublishPrivileges);\n\t\t\t\t}\n\t\t\t\tshareRepository.SavePublicShareLink(user, publicShareLink);\n\n\t\t\t\treturn user.Account.Urls.Share.GetPublicObjectLink(publicShareLink.AccountId, publicShareLink.ObjectType, publicShareLink.ObjectUid, publicShareLink.Uid);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Update the metadata for a given document.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"scmDocument\">Document to save.</param>\n\t\t/// <returns>The document that was saved with the new values.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentSave']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentSave']/soap\" />\n\t\t/// <seealso cref=\"DocumentGetById\">DocumentGetById</seealso>\n\t\t/// <seealso cref=\"FolderSave\">FolderSave</seealso>\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Update the metadata for a given document\")]\n\t\tpublic SCMDocument DocumentSave(string token, SCMDocument scmDocument)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument ld = LoadDocument(user, scmDocument.Id, Enums.Security.Write);\n\t\t\t\tGuid newFolderUid = Conversions.TryParseGuid(scmDocument.ParentFolderId);\n\t\t\t\t//The folder will be checked in the sp\n\t\t\t\tif (newFolderUid != ld.FolderUid && (ld.SecurityFlags & Enums.Security.Move) != Enums.Security.Move)\n\t\t\t\t{\n\t\t\t\t\tFail(PublicException.FailReason.PermissionDenied, \"Do not have security to move document\");\n\t\t\t\t}\n\t\t\t\tld = scmDocument.Save(user, ld);\n\t\t\t\treturn new SCMDocument(user, ld, true);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\t// return scmDocument;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Saves the custom form data of the specified document. The data in the repository\n\t\t/// will be completely overwritten with what is passed in. Repeating custom fields\n\t\t/// must not change the set name and number and leave it as it was retreived from a\n\t\t/// pervious call. Adding new repeating entries through this\n\t\t/// method is not allowed. First a new repeating metadata set should be added and then\n\t\t/// custom fields data may be associated with it. The method will error if:\n\t\t/// <list type=\"bullet\">\n\t\t/// <item><description>The document is not a form document.</description></item>\n\t\t/// <item><description>Invalid or nonexisting set number and name are used for repeating custom fields.</description></item>\n\t\t/// <item><description>Only the set number or the set name has a value and the other one is blank.</description></item>\n\t\t/// <item><description>Insufficient permissions, including readonly form.</description></item>\n\t\t/// </list>\n\t\t/// This method will not update any other properties of the document, but the custom form data.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"scmDocument\">Form document whose custom form data is to be saved.</param>\n\t\t/// <returns>The document that was saved with the new values.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='SaveCustomFormData']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Update the custom form data for the given document.\")]\n\t\tpublic SCMDocument SaveCustomFormData(string token, SCMDocument scmDocument)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument ld = LoadDocument(user, scmDocument.Id, Enums.Security.Write);\n\t\t\t\tif ((ld.SecurityFlags & Enums.Security.Write) == 0)\n\t\t\t\t\tFail(PublicException.FailReason.PermissionDenied, \"Do not have security to update document\");\n\t\t\t\tld = scmDocument.UpdateCustomFormData(user, ld);\n\t\t\t\treturn new SCMDocument(user, ld, true);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\t// return scmDocument;\n\t\t}\n\t\t/// <summary>\n\t\t/// Search for documents in the repository.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"search\">This is an object describing the search.</param>\n\t\t/// <param name=\"loadExtendedMetadata\">If true will load the document metada.</param>\n\t\t/// <returns>Documents returned from the search.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentSearch']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentSearch']/soap\" />\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Search for documents in the repository\")]\n        public SCMDocument[] DocumentSearch(string token, SCMSearchDocument search, bool loadExtendedMetadata)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                return search.SearchDocument(user, loadExtendedMetadata);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Send a document out for electronic signature. The document will be checked out until all signatures have been approved or declined.\n\t\t///\n\t\t/// DocumentSendForSignatureStatus can be used to check on the status of the signature.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication taken from an Authenticate method call</param>\n\t\t/// <param name=\"doc\">Document to be signed</param>\n\t\t/// <param name=\"message\">A message to go with the signature request e-mail</param>\n\t\t/// <param name=\"emails\">Pipe delimited e-mail addresses, a signature request will be sent to each</param>\n\t\t/// <param name=\"writtenRequired\">Written signature required</param>\n\t\t/// <param name=\"senderSignsToo\">Sender will also sign the document</param>\n\t\t/// <seealso cref=\"DocumentSendForSignatureStatus\">DocumentSendForSignatureStatus</seealso>\n\t\t/// <seealso cref=\"DocumentSendForSignatureCancel\">DocumentSendForSignatureCancel</seealso>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentSendForSignature']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Send a document out for electronic signature\")]\n\t\tpublic void DocumentSendForSignature(string token, SCMDocument doc, string message, string emails, bool writtenRequired, bool senderSignsToo)\n\t\t{\n\t    \ttry\n\t    \t{\n\t    \t\tUserAccount sender = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tif (!sender.Privileges.CanSendDocuments || !sender.Privileges.CanCheckInOut ||\n\t\t\t\t\t!sender.Account.Settings.IsElectronicSignatureEnabled)\n\t\t\t\t\tFail(new PublicException(PublicException.FailReason.PermissionDenied,\n\t\t\t\t\t                         WebServiceResource.error_ElectronicSignaturePermissionDenied));\n\n                if (string.IsNullOrWhiteSpace(emails))\n                {\n                    Fail(new PublicException(PublicException.FailReason.InvalidArgument, WebServiceResource.EmailsRequired));\n                    return;\n                }\n\n                var toEmailAddresses = emails.Split(new char[] { '|' }, StringSplitOptions.RemoveEmptyEntries);\n                var maxNumberOfSigners = senderSignsToo ? ADEXS.ElectronicSignature.DomainModel.Constants.MaximumNumberOfSigners - 1 : ADEXS.ElectronicSignature.DomainModel.Constants.MaximumNumberOfSigners;\n                if (toEmailAddresses.Length > maxNumberOfSigners)\n                {\n                    Fail(new PublicException(PublicException.FailReason.InvalidArgument, string.Format(WebServiceResource.SignersLimitExceded0, ADEXS.ElectronicSignature.DomainModel.Constants.MaximumNumberOfSigners)));\n                    return;\n                }\n\n\t    \t\tDocument document = LoadDocument(sender, doc.Id, Enums.Security.Write);\n\n\t    \t\tif(document.CheckoutStatus != Enums.CheckoutStatus.NotCheckedOut)\n\t    \t\t{\n\t    \t\t\tFail(new PublicException(PublicException.FailReason.InvalidArgument, WebServiceResource.error_DocumentIsAlreadyCheckedOut));\n\t    \t\t\treturn;\n\t    \t\t}\n\n\t\t\t\tif ((document.PDFStatus != Enums.PdfConvertStatus.Success) && !DocumentRepository.SendForSignatureAllowedExtensions(document.Extension))\n\t\t\t\t{\n\t\t\t\t\tFail(new PublicException(PublicException.FailReason.InvalidArgument, WebServiceResource.error_DocumentCannotBeSentForSignature));\n\t\t\t\t}\n\n                ESignatureHelper.SendESignature(sender, document, message, toEmailAddresses, false, writtenRequired, senderSignsToo);\n\t\t\t}\n\t    \tcatch (Exception e)\n\t    \t{\n\t    \t\tFail(e);\n\t    \t\tthrow;\n\t    \t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Check status of a send for signature workflow.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication taken from an Authenticate method call</param>\n\t\t/// <param name=\"doc\">Document in a send for signature workflow.</param>\n\t\t/// <returns>Current status of the workflow.\n\t\t///\n\t\t/// Success indicates the document has been signed by everyone.\n\t\t///\n\t\t/// Failure indicates the workflow was cancelled or has failed.\n\t\t///\n\t\t/// Waiting indicates the workflow is still in progress.\n\t\t/// </returns>\n\t\t/// <seealso cref=\"DocumentSendForSignature\">DocumentSendForSignature</seealso>\n\t\t/// <seealso cref=\"DocumentSendForSignatureCancel\">DocumentSendForSignatureCancel</seealso>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentSendForSignatureStatus']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description=\"Check status of send for signature\")]\n\t\tpublic SCMQueueStatus DocumentSendForSignatureStatus(string token, SCMDocument doc)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tif (!user.Privileges.CanSendDocuments || !user.Privileges.CanCheckInOut ||\n\t\t\t\t\t!user.Account.Settings.IsElectronicSignatureEnabled)\n\t\t\t\t\tFail(new PublicException(PublicException.FailReason.PermissionDenied,\n\t\t\t\t\t\t\t\t\t\t\t WebServiceResource.error_ElectronicSignaturePermissionDenied));\n\n\t\t\t\tDocument document = LoadDocument(user, doc.Id, Enums.Security.Read);\n\t\t\t\treturn (SCMQueueStatus)ESignatureHelper.CheckStatus(user, document.Uid);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Cancel the Send for Signature workflow for a document.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication taken from an Authenticate method call</param>\n\t\t/// <param name=\"doc\">The document in a Send for Signature workflow</param>\n\t\t/// <seealso cref=\"DocumentSendForSignature\">DocumentSendForSignature</seealso>\n\t\t/// <seealso cref=\"DocumentSendForSignatureStatus\">DocumentSendForSignatureStatus</seealso>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentSendForSignatureCancel']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description=\"Cancel a send for signature\")]\n\t\tpublic void DocumentSendForSignatureCancel(string token, SCMDocument doc)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tif (!user.Privileges.CanSendDocuments || !user.Privileges.CanCheckInOut ||\n\t\t\t\t\t!user.Account.Settings.IsElectronicSignatureEnabled)\n\t\t\t\t\tFail(new PublicException(PublicException.FailReason.PermissionDenied,\n\t\t\t\t\t\t\t\t\t\t\t WebServiceResource.error_ElectronicSignaturePermissionDenied));\n\n\t\t\t\tDocument document = LoadDocument(user, doc.Id, Enums.Security.Write);\n\n\t\t\t\tif (document.CheckoutStatus != Enums.CheckoutStatus.SystemForSignature)\n\t\t\t\t{\n\t\t\t\t\tFail(new PublicException(PublicException.FailReason.InvalidArgument, WebServiceResource.error_DocumentIsAlreadyCheckedOut));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tESignatureHelper.Cancel(user, document.Uid);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Takes a document id, a list of page numbers, and a new file name. The\n\t\t/// resulting document will consist of the pages specified from the original\n\t\t/// document, and will be in the same folder with the specified name.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call</param>\n\t\t/// <param name=\"docId\">Id of the document to copy pages from</param>\n\t\t/// <param name=\"pages\">List of page numbers</param>\n\t\t/// <param name=\"newFileName\">Name of the new document</param>\n\t\t/// <returns>Id of the new document on success. Empty string on failure.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentSplit']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Split a document\")]\n\t\tpublic string DocumentSplit(string token, string docId, int[] pages, string newFileName)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tDocument doc = LoadDocument(user, docId, Enums.Security.Write);\n\t\t\t\tList<int> listPages = new List<int>(pages);\n\n\t\t\t\tDocument newDoc = DocumentRepository.Split(user, doc, Guid.Empty, listPages, newFileName);\n\t\t\t\treturn newDoc != null ? Conversions.GuidToApiStringId(newDoc.Uid) : string.Empty;\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n        /// <summary>\n        /// Allows the setting of permissions on specified objects based on role or username.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"permissions\">A maximum length of 200 is set on this array of permissions.</param>\n        /// <returns>SetPermissionResult[] (Resultset of errors from permissions)</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='SetPermission']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='SetPermission']/soap\" />\n        [SOAPLogExtension]\n        [WebMethod(Description=\"Allows the setting of permissions on specified objects based on role or username.\")]\n\t\tpublic SetPermissionResult[] SetPermission(string token, Permission[] permissions)\n\t\t{\n\n\n\t\t\tSetPermissionResult[] results = null;\n\t\t\ttry\n\t\t\t{\n\n\t\t\t\tUserAccount ua = AuthenticateFromToken(token).UserAccount;\n                ValidateArray(permissions, \"permissions\");\n\n\t\t\t\tList<SetPermissionResult> listResults = new List<SetPermissionResult>();\n\t\t\t\tforeach (Permission p in permissions)\n\t\t\t\t{\n\t\t\t\t\tGuid userAccountUid = Conversions.TryParseGuid(p.ApplyToUserId);\n\t\t\t\t\t//This allows for the client to only know the username...\n\t\t\t\t\tif (userAccountUid == Guid.Empty && !string.IsNullOrEmpty(p.ApplyToUserName))\n\t\t\t\t\t{\n\t\t\t\t\t\tUserAccount u = UserAccountPersistence.GetInstance(ua).LoadByAccountIdAndEmail(ua.AccountId, p.ApplyToUserName);\n\t\t\t\t\t\tif (u != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tuserAccountUid = u.Uid;\n\t\t\t\t\t\t\tp.ApplyToUserId = Conversions.GuidToApiStringId(u.Uid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidArgument, \"User does not exist.\");\n\t\t\t\t\t}\n\n\t\t\t\t\tGuid groupUid = Conversions.TryParseGuid(p.ApplyToGroupId);\n\t\t\t\t\t//This allows for the client to only know the group name...\n\t\t\t\t\tif (groupUid == Guid.Empty && !string.IsNullOrEmpty(p.ApplyToGroupName))\n\t\t\t\t\t{\n\t\t\t\t\t\tGroup g =\n\t\t\t\t\t\t\tGroupPersistence.GetInstance(ua).LoadByNameAndType(ua,\n\t\t\t\t\t\t\t                                   p.ApplyToGroupName, Enums.GroupType.Security);\n\t\t\t\t\t\tif (g != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgroupUid = g.Uid;\n\t\t\t\t\t\t\tp.ApplyToGroupId = Conversions.GuidToApiStringId(g.Uid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidArgument, \"Security group does not exist.\");\n\t\t\t\t\t}\n\n\t\t\t\t\t//Hydrate the Explicit Security\n\t\t\t\t\tExplicitSecurity es = new ExplicitSecurity();\n\t\t\t\t\tes.AccountId = ua.AccountId;\n\t\t\t\t\tes.RequiredRole = (Enums.UserRole)p.ApplyToRole;\n\t\t\t\t\tes.SecurityGroupUid = groupUid;\n\t\t\t\t\tes.ObjectUid = Conversions.TryParseGuid(p.ObjectId);\n\t\t\t\t\tes.ObjectType = (p.ObjectType == SCMObjectType.Document) ? Enums.ObjectType.Document : Enums.ObjectType.Folder;\n\t\t\t\t\tes.UserAccountUid = userAccountUid;\n\t\t\t\t\tes.WriteSecurity = (Enums.SecurityLevel)p.Write;\n\t\t\t\t\tes.CreateSecurity = (Enums.SecurityLevel)p.Create;\n\t\t\t\t\tes.MoveSecurity = (Enums.SecurityLevel)p.Move;\n\t\t\t\t\tes.ReadSecurity = (Enums.SecurityLevel)p.Read;\n\t\t\t\t\tes.SetAccessSecurity = (Enums.SecurityLevel)p.SetAccess;\n\n\t\t\t\t\t//If we error on permissions I don't want to stop moving through the array.\n\t\t\t\t\ttry\n                    {\n                        ServiceLocator.GetInstance<ISecurityRepository>().Save(es, ua, true);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (SqlException sqle)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (sqle.Message.Contains(ua.Uid.ToString()))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlistResults.Add(new SetPermissionResult(p, WebServiceResource.CanNotAdministerObject));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresults = listResults.ToArray();\n\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create a new document by merging XML data with a template.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"template\">A template document. Must be a docx with Content Controls.</param>\n\t\t/// <param name=\"dataSource\">An SCMXMLDataSource describing the XML to be merged.</param>\n\t\t/// <param name=\"destination\">Folder where the resulting document will be created.</param>\n\t\t/// <param name=\"destinationName\">Name for the resulting document.</param>\n\t\t/// <returns>A token that can be used to track the status of the merge.</returns>\n\t\t/// <seealso cref=\"DocumentXMLMergeStatus\">DocumentXMLMergeStatus</seealso>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentXMLMerge']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Merge a Word document template and XML data.\")]\n\t\tpublic string DocumentXMLMerge(string token, SCMDocument template, SCMXMLDataSource dataSource, SCMFolder destination, string destinationName)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\treturn ServiceLocator.GetInstance<IMerge>().Request(user, new MergeTask\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tAccountId = user.AccountId,\n\t\t\t\t\t\t\t\t\t\t\tUserAccountUid = user.Uid,\n\t\t\t\t\t\t\t\t\t\t\tTemplateDocumentId = template.Id,\n\t\t\t\t\t\t\t\t\t\t\tDataSourceType = (Enums.XMLDataSource) dataSource.SourceType,\n\t\t\t\t\t\t\t\t\t\t\tDataSource = dataSource.SourceType == SCMXMLSourceType.String ? dataSource.String : dataSource.Object.Id,\n\t\t\t\t\t\t\t\t\t\t\tDestinationFolderId = destination.Id,\n\t\t\t\t\t\t\t\t\t\t\tDestinationFileName = destinationName\n\t\t\t\t\t\t\t\t\t\t}).ToString();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tFail(ex);\n\t\t\t}\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Check on the status of a merged document.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"requestToken\">Merge request token from a DocumentXMLMerge method call.</param>\n\t\t/// <returns>An SCMXMLMergeResult describing the state of the merge request.</returns>\n\t\t/// <seealso cref=\"DocumentXMLMerge\">DocumentXMLMerge</seealso>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentXMLMerge']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Check on the status of a DocumentXMLMerge\")]\n\t\tpublic SCMXMLMergeResult DocumentXMLMergeStatus(string token, string requestToken)\n\t\t{\n\t\t\tSCMXMLMergeResult result = new SCMXMLMergeResult();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tstring message;\n\n\t\t\t\tresult.Status = (SCMQueueStatus)QueueItemStateRepository.Status(user,\n\t\t\t\t\trequestToken,\n\t\t\t\t\tout message);\n\n\t\t\t\tif (result.Status == SCMQueueStatus.Success)\n\t\t\t\t\tresult.DocumentId = message;\n\t\t\t\telse\n\t\t\t\t\tresult.Message = message;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tFail(ex);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/// <summary>\n        /// Part 1 of the document merge sequence. This queues up the documents to be merged and will return a result that will be used to gather the data later.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"documentIds\">long Ids for documents max of 200 can be sent.</param>\n        /// <returns>DocumentMergeResult that will carry data on the merge process state.</returns>\n\t\t/// <seealso cref=\"DocumentMergeCheck\">DocumentMergeCheck</seealso>\n\t\t/// <seealso cref=\"DocumentMergeDownload\">DocumentMergeDownload</seealso>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentMerge']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentMerge']/soap\" />\n        [WebMethod(Description=\"(PDFs Only) Part 1 of the document merge sequence. This queues up the documents to be merged and will return a result that will be used to gather the data later.\")]\n        [SOAPLogExtension]\n        public DocumentMergeResult DocumentMerge(string token, string[] documentIds)\n        {\n\t\t\tDocumentMergeResult result = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tValidateArray(documentIds, \"documentIds\");\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tStringBuilder list = new StringBuilder();\n\t\t\t\tDocuments nodeDocs = new Documents();\n\t\t\t\tIDocumentRepository docRepository = ServiceLocator.GetInstance<IDocumentRepository>();\n\t\t\t\tfor (int i = 0; i < documentIds.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tDocument d = docRepository.LoadByUid(user.AccountId, user.Uid, Conversions.TryParseGuid(documentIds[i]));\n\t\t\t\t\tif (d != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// treat the incoming list as sorted in the order that they want the document assembled.\n\t\t\t\t\t\tnodeDocs.Add(d);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tList<DocumentMergeWarning> warnings = new List<DocumentMergeWarning>();\n\t\t\t\tDocuments noViewDocs = new Documents\n                {\n\t                nodeDocs.Where(d => !d.HasSecurity(Enums.Security.Read))\n                };\n\n\t\t\t\tforeach (var node in noViewDocs)\n\t\t\t\t{\n\t\t\t\t\twarnings.Add(new DocumentMergeWarning(Conversions.GuidToApiStringId(node.Uid), DocumentMergeWarningReason.PermissionDenied));\n\t\t\t\t}\n\n\t\t\t\tnodeDocs.RemoveAllWhere(d => !d.HasSecurity(Enums.Security.Read));\n\n\t\t\t\tresult = new DocumentMergeResult();\n\t\t\t\tresult.IsReady = false;\n\t\t\t\tresult.Warnings = warnings.ToArray();\n\n\t\t\t\tIDocumentRepository documentRepository = ServiceLocator.GetInstance<IDocumentRepository>();\n\t\t\t\tvar mergeResult = documentRepository.MergeDocuments(user, nodeDocs);\n\t\t\t\tif (mergeResult.Success)\n\t\t\t\t{\n\t\t\t\t\tif (mergeResult.Warnings.Any())\n\t\t\t\t\t{\n\t\t\t\t\t\t//Convert them to warning objects\n\t\t\t\t\t\tforeach (var resultWarning in mergeResult.Warnings)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar warning = new DocumentMergeWarning()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDocumentId = resultWarning.Document.Uid.ToString()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tDocumentMergeWarningReason reason = DocumentMergeWarningReason.Unknown;\n\t\t\t\t\t\t\tswitch (resultWarning.ProcessingResult)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase PdfMergeTask.ProcessingResult.OperationNotSupported:\n\t\t\t\t\t\t\t\tcase PdfMergeTask.ProcessingResult.SingleItem:\n\t\t\t\t\t\t\t\t\treason = DocumentMergeWarningReason.Unknown;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase PdfMergeTask.ProcessingResult.NoPdfRendition:\n\t\t\t\t\t\t\t\t\treason = DocumentMergeWarningReason.NoPDF;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\treason = (DocumentMergeWarningReason)resultWarning.ProcessingResult;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\twarning.Reason = reason;\n\t\t\t\t\t\t\twarnings.Add(warning);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult.MergeId = mergeResult.MergeId;\n\t\t\t\t\tresult.Warnings = warnings.ToArray();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tFail(ex);\n\t\t\t}\n\t\t\treturn result;\n        }\n\n\n        /// <summary>\n        /// Part 2 of the document merge sequence. When given a DocumentMergeResult you then need to call this method until the result is valid meaning that the merge process has completed.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"merges\">A set of DocumentMergeResults to check the status of.</param>\n        /// <returns>DocumentMergeResult[] if one is ready the IsReady boolean will be set to true.</returns>\n\t\t/// <seealso cref=\"DocumentMerge\">DocumentMerge</seealso>\n\t\t/// <seealso cref=\"DocumentMergeDownload\">DocumentMergeDownload</seealso>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentMerge']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentMergeCheck']/soap\" />\n        [WebMethod(Description = \"(PDFs Only) Part 2 of the document merge sequence. When given a DocumentMergeResult you then need to call this method until the result is valid meaning that the merge process has completed.\")]\n        [SOAPLogExtension]\n        public DocumentMergeResult[] DocumentMergeCheck(string token, DocumentMergeResult[] merges)\n        {\n\n            try\n            {\n                ValidateArray(merges, \"merges\");\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n                foreach(DocumentMergeResult merger in merges)\n                {\n\t\t\t\t\tstring message;\n\t\t\t\t\tEnums.QueueStatus setResult = QueueItemStateRepository.Status(user, merger.MergeId,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   out message);\n\t\t\t\t\tif ((setResult != Enums.QueueStatus.Waiting) && (setResult != Enums.QueueStatus.Processing))\n                    {\n                        switch(setResult)\n                        {\n                            default:\n                                merger.IsReady = false;\n                                merger.StoppedProcessing = true;\n                                merger.StopReason = DocumentMergeStopProcessingReason.Unknown;\n\t\t\t\t\t\t\t\tint pdfStatus;\n\t\t\t\t\t\t\t\tif (int.TryParse(message, out pdfStatus))\n\t\t\t\t\t\t\t\t\tmerger.StopReason = (DocumentMergeStopProcessingReason)pdfStatus;\n                                break;\n\t\t\t\t\t\t\tcase Enums.QueueStatus.Success:\n\t\t\t\t\t\t\t\tint maxIndex = 0;\n\t\t\t\t\t\t\t\tif (DocumentMergeHelper.TryGetDocumentMergeResultMaxIndex(DocumentRepository.GetMergedPDFPath(user, merger.MergeId), user.AccountId, _defaultChunkSize, out maxIndex))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmerger.IsReady = true;\n\t\t\t\t\t\t\t\t\tmerger.MaxIndex = maxIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n                                {\n                                    merger.StoppedProcessing = true;\n                                    merger.StopReason = DocumentMergeStopProcessingReason.Unknown;\n                                }\n                                break;\n                        }\n                        merger.Warnings = null;\n                    }\n                }\n\n            }\n            catch (Exception ex)\n            {\n                Fail(ex);\n            }\n            return merges;\n        }\n\n        /// <summary>\n        /// Part 3 of the document merge sequence. When the DocumentMergeResult is validated then call this method to begin downloading the merged documents.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"merger\">DocumentMergeResult to download.</param>\n        /// <param name=\"index\">Index offset of the bytes to download.</param>\n        /// <returns>byte array of the merged pdf.</returns>\n\t\t/// <seealso cref=\"DocumentMerge\">DocumentMerge</seealso>\n\t\t/// <seealso cref=\"DocumentMerge\">DocumentMergeCheck</seealso>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentMerge']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DocumentMergeDownload']/soap\" />\n        [WebMethod(Description = \"(PDFs Only) Part 3 of the document merge sequence. When the DocumentMergeResult is validated then call this method to begin downloading the merged documents.\")]\n        [SOAPLogExtension]\n        public byte[] DocumentMergeDownload(string token, DocumentMergeResult merger, int index)\n        {\n\t\t\tbyte[] bytes = null;\n            try\n            {\n                UserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tstring path = DocumentRepository.GetMergedPDFPath(user, merger.MergeId);\n                if (string.IsNullOrEmpty(path)) Fail(PublicException.FailReason.NonexistentObject, WebServiceResource.error_DocumentMergeDownload);\n\n\t\t\t\tbytes = DocumentMergeHelper.GetMergedDocumentBytes(index, _defaultChunkSize, user.AccountId, path, (indexRange =>\n\t\t\t\t{\n\t\t\t\t\tFail(PublicException.FailReason.InvalidArgument, string.Format(WebServiceResource.error_DocumentMergeIndexOutOfRange, indexRange));\n\t\t\t\t}));\n\t\t\t}\n            catch (Exception ex)\n            {\n                Fail(ex);\n            }\n            return bytes;\n        }\n\n        #endregion\n\n        #region Document Type Methods\n\n\t\t/// <summary>\n\t\t/// Retrieves all available document types, and the attribute set for each.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <returns>A string array containing all of the metadata group names.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='GetMetadataGroups']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='GetMetadataGroups']/soap\" />\n        /// <seealso cref=\"GetMetadataFields\">GetMetadataFields</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Retrieves all available document types, and the attribute set for each\")]\n        public string[] GetMetadataGroups(string token)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                MetadataGroups types = MetadataGroupPersistence.GetInstance(user).LoadByAccountId(user.AccountId);\n                string[] names = new string[types.Count];\n                for (int ii = 0; ii < types.Count; ii++)\n                {\n                    names[ii] = types[ii].Name;\n                }\n                return names;\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Retrieves all attributes for the specified document type.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"name\">Name of the MetadataGroup to load fields.</param>\n\t\t/// <returns>Metadata field objects related to the MetadataGroup.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='GetMetadataFields']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='GetMetadataFields']/soap\" />\n        /// <seealso cref=\"GetMetadataGroups\">GetMetadataGroups</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Retrieves all attributes for the specified document type\")]\n        public SCMMetadataField[] GetMetadataFields(string token, string name)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                MetadataGroup type = MetadataGroupPersistence.GetInstance(user).LoadByAccountIdAndName(user.AccountId, name);\n                if (type == null) throw new PublicException(PublicException.FailReason.NonexistentObject,\n\t                $\"Invalid document type {name}\");\n\t\t\t\tMetadataFields fields = MetadataFieldPersistence.GetInstance(user).LoadByMetadataGroupUid(type.Uid);\n\t\t\t\tSCMMetadataField[] scmField = new SCMMetadataField[fields.Count];\n                for (int ii = 0; ii < fields.Count; ii++)\n                {\n\t\t\t\t\tscmField[ii] = new SCMMetadataField(fields[ii]);\n                }\n\t\t\t\treturn scmField;\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n        #endregion\n\n        #region Folder specific methods\n\n\t\t/// <summary>\n\t\t/// Create a new folder in the repository.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"scmFolder\">The folder object to create.</param>\n\t\t/// <returns>The folder object with the created id and updated info.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderCreate']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderCreate']/soap\" />\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Create a new folder in the repository\")]\n        public SCMFolder FolderCreate(string token, SCMFolder scmFolder)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                // This line is here for verification that they have create security to the parent folder\n\t\t\t\tLoadFolder(user, scmFolder.ParentFolderId, Enums.Security.Create);\n                Folder folder = scmFolder.SaveNew(user);\n                // Reload from db, just to make sure all calculated fields are set correctly.  Maybe overkill.\n\t\t\t\treturn new SCMFolder(user, LoadFolder(user, Conversions.GuidToApiStringId(folder.Uid), Enums.Security.Read), true);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Find or create Salesforce folder\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"sfAccountId\">Salesforce account Id</param>\n\t\t/// <param name=\"sfAccountName\">Salesforce account name</param>\n\t\t/// <param name=\"sfObjectId\">Salesforce object Id</param>\n\t\t/// <param name=\"sfObjectName\">Salesforce object name</param>\n\t\t/// <param name=\"sfObjectType\">Salesforce object type</param>\n\t\t/// <returns>SCMFolder object</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FindOrCreateSalesforceFolder']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FindOrCreateSalesforceFolder']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Find or create Salesforce folder\")]\n\t\tpublic SCMFolder FindOrCreateSalesforceFolder(string token, string sfAccountId, string sfAccountName, string sfObjectId, string sfObjectName, string sfObjectType)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tISalesForceFolderService folderService = ServiceLocator.GetInstance<ISalesForceFolderService>();\n\t\t\t\tFolder salesforceFolder = folderService.GetFolder(user, sfAccountId, sfAccountName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sfObjectId,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t sfObjectName, sfObjectType);\n\t\t\t\tif (salesforceFolder == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new PublicException(PublicException.FailReason.NonexistentObject, \"Failed to create folder.\");\n\t\t\t\t}\n\t\t\t\tSCMFolder scmFolder = new SCMFolder(user, salesforceFolder, true);\n\t\t\t\treturn scmFolder;\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Retrieve detailed folder info for a given folder by the folder's object id.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"folderId\">Id of the folder to load.</param>\n\t\t/// <param name=\"loadExtendedMetadata\">If true it will load any metadata related to the folder.</param>\n\t\t/// <returns>The folder object.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderGetById']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderGetById']/soap\" />\n        /// <seealso cref=\"DocumentGetById\">DocumentGetById</seealso>\n        /// <seealso cref=\"FolderSave\">FolderSave</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Retrieve detailed folder info for a given folder by the folder's object id.\")]\n        public SCMFolder FolderGetById(string token, string folderId, bool loadExtendedMetadata)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tFolder folder = LoadFolder(user, folderId, loadExtendedMetadata ? Enums.Security.Read : Enums.Security.See);\n                if (folder == null) return SCMFolder.Root;\n                return new SCMFolder(user,folder, loadExtendedMetadata);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Gets the full path to a folder.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"folderId\">Id of the folder to retrieve a path for.</param>\n\t\t/// <returns>A string containing the full path to a folder</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderGetPath']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Returns the full path to a folder\")]\n\t\tpublic string FolderGetPath(string token, string folderId)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tFolder f = LoadFolder(user, folderId, Enums.Security.Read);\n\n\t\t\t\treturn f.GetLogicalPath();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n        /// <summary>\n        /// List the contents of a given folder. This is a very usefull method to build out the tree of folders.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"systemFolder\">System folder to get all of the contents. Or root folder to start at.</param>\n        /// <param name=\"loadExtendedMetadata\">If true will load the metadata for ALL of the objects loaded.</param>\n        /// <param name=\"pager\">Object that facilitates getting a portion of the results, a page.</param>\n        /// <returns>A list of folders and documents under the root id.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderGetContents']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderGetContents']/soap\" />\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"List the contents of a given folder\")]\n\t\tpublic SCMList SystemFolderGetContents(string token, SCMSystemFolders systemFolder, bool loadExtendedMetadata, SCMDocumentPager pager)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn FolderGetContents(token, ((long)systemFolder).ToString(), loadExtendedMetadata, pager);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Lists a subset of the contents of a given folder. This is a very usefull method to build out the tree of folders.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"folderId\">Folder id to get all of the contents. Or root folder to start at.</param>\n\t\t/// <param name=\"loadExtendedMetadata\">If true will load the metadata for ALL of the objects loaded.</param>\n\t\t/// <param name=\"pager\">An SCMPager object to specify what subset of the folder to retrieve.</param>\n\t\t/// <returns>A list of folders and documents under the root id.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderGetContentsPaged']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"List the contents of a given folder\")]\n\t\tpublic SCMList FolderGetContents(string token, string folderId, bool loadExtendedMetadata, SCMDocumentPager pager)\n\t\t{\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tif(pager.PageSize > user.Account.Settings.MaxPageSize)\n\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t                          string.Format(\n\t\t\t\t\t                          \tWebServiceResource.error_TheRequestedPageSizeWasTooBigTheMaximumPageSizeIs0,\n\t\t\t\t\t                          \tuser.Account.Settings.MaxPageSize));\n\n                Folder folder = LoadFolder(user, folderId, Enums.Security.See);\n            \tGuid folderUid = Guid.Empty;\n\t\t\t\tif(folder != null)\n\t\t\t\t\tfolderUid = folder.Uid;\n\n            \tPager p = new Pager(pager.StartIndex,\n            \t                    pager.PageSize,\n            \t                    pager.SortColumn.ToString(),\n            \t                    pager.SortAscending);\n\n                // Get the items in the specified folder\n            \tint rowCount;\n\t\t\t\tList<INode> contents = DocumentRepository.ListFolderContentsPaged(user, folderUid,\n\t\t\t\t\tp, true, true, true, out rowCount);\n                List<Pair<Guid, int>> objectList = new List<Pair<Guid, int>>();\n                Folders folders = new Folders();\n\t\t\t\tDocuments lds = new Documents();\n            \tforeach (INode n in contents)\n            \t{\n                    objectList.Add(new Pair<Guid, int>(n.Uid, (int)n.Type));\n            \t\tif (n.Type == Enums.ObjectType.Folder)\n            \t\t\tfolders.Add((Folder) n);\n            \t\telse if (n.Type == Enums.ObjectType.Document)\n            \t\t\tlds.Add((Document) n);\n            \t}\n\n            \tDictionary<Enums.ObjectType, Dictionary<Guid, Metadatas>> mdLookup = null;\n\t\t\t\tif (loadExtendedMetadata) mdLookup = ServiceLocator.GetInstance<IMetadataRepository>().MetadataLoadByObjectUids(user.AccountId, objectList);\n\n                return new SCMList(user, folders, lds, mdLookup, rowCount);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Update the metadata for a given folder.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"scmFolder\">The folder object to save.</param>\n\t\t/// <returns>The folder in its updated state.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderSave']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderSave']/soap\" />\n        /// <seealso cref=\"FolderGetById\">FolderGetById</seealso>\n        /// <seealso cref=\"DocumentSave\">DocumentSave</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Update the metadata for a given folder\")]\n        public SCMFolder FolderSave(string token, SCMFolder scmFolder)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                Folder folder = LoadFolder(user, scmFolder.Id, Enums.Security.Write);\n                if (folder == null) Fail(PublicException.FailReason.ReadOnlyObject, \"The root folder may not be saved.\");\n                folder = scmFolder.Save(user, folder);\n                return new SCMFolder(user, folder, true);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Search for folders in the repository.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"search\">The folder search description object.</param>\n\t\t/// <param name=\"loadExtendedMetadata\">If true will load the metdata for all of the folder objects returned.</param>\n\t\t/// <returns>Folder objects that correspond with the search description.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderSearch']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderSearch']/soap\" />\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Search for folders in the repository\")]\n        public SCMFolder[] FolderSearch(string token, SCMSearchFolder search, bool loadExtendedMetadata)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                return search.SearchFolder(user, loadExtendedMetadata);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n                throw;\n            }\n        }\n\n\t\t/// <summary>\n\t\t/// Queues a list of documents and folders to be placed in a zip archive.\n\t\t///\n\t\t/// Folders are recursively expanded.\n\t\t///\n\t\t/// Documents within baseFolder will have paths inside the archive\n\t\t/// relative to that folder. All other documents will be placed in the\n\t\t/// root of the archive.\n\t\t///\n\t\t/// An optional destination folder scmDestinationFolder and name\n\t\t/// destinationName can be specified so that the resulting archive is\n\t\t/// placed in a folder in SpringCM. These archives can still be\n\t\t/// retrieved through calls to FolderArchiveDownload().\n\t\t///\n\t\t/// The status of the request can be checked using FolderArchiveGetStatus()\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"baseFolder\">A folder id. Paths within the archive will be relative to this folder.</param>\n\t\t/// <param name=\"nodes\">An SCMList of documents and folders to include in the archive.</param>\n\t\t/// <param name=\"scmDestinationFolder\">A folder to optionally place the resulting archive</param>\n\t\t/// <param name=\"destinationName\">A name for the archive to be placed in scmDestinationFolder</param>\n\t\t/// <returns>A unique token that identifies this request</returns>\n\t\t/// <seealso cref=\"FolderArchiveGetStatus\">FolderArchiveGetStatus</seealso>\n\t\t/// <seealso cref=\"FolderArchiveDownload\">FolderArchiveDownload</seealso>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderArchive']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderArchive']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Request documents and folders to be archived into a zip file\")]\n\t\tpublic string FolderArchive(string token, SCMFolder baseFolder, SCMList nodes, SCMFolder scmDestinationFolder, string destinationName)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tif(baseFolder == null)\n\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t\t\t  WebServiceResource.error_BaseFolderCannotBeNull);\n\n\t\t\t\tFolder folder = LoadFolder(user, baseFolder.Id, Enums.Security.Read);\n\n\t\t\t\tFolder destinationFolder = (scmDestinationFolder != null && !string.IsNullOrEmpty(scmDestinationFolder.Id)) ?\n\t\t\t\t\tLoadFolder(user, scmDestinationFolder.Id, Enums.Security.Create) : null;\n\n\t\t\t\tif(nodes == null)\n\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t                          WebServiceResource.error_DocumentAndFolderListCannotBeNull);\n\n\t\t\t\treturn QueueItemStateRepository.Request(user, new ArchiveTask\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tBaseFolderUid = folder.Uid,\n\t\t\t\t\t\t\t\t\t\tIds = string.Join(\"|\", nodes.SCMFolders.Select<SCMFolder, string>(f => \"f\" + f.Id)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.Union(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnodes.SCMDocuments.Select<SCMDocument, string>(d => d.Id))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.ToArray()),\n\t\t\t\t\t\t\t\t\t\tDestinationFolderUid = (destinationFolder != null) ? destinationFolder.Uid : Guid.Empty,\n\t\t\t\t\t\t\t\t\t\tDestinationName = destinationName\n\t\t\t\t\t\t\t\t\t}).ToString();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an SCMFolderArchiveResult object containing information\n\t\t/// about a FolderArchive request.\n\t\t///\n\t\t/// ArchiveSize will not be set until the request is complete.\n\t\t///\n\t\t/// Status may be set to Failure if the archive has expired and been\n\t\t/// deleted.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"requestToken\">Request token from a FolderArchive call.</param>\n\t\t/// <returns>An SCMQueueRequest containing information about the request</returns>\n\t\t/// <seealso cref=\"FolderArchiveGetStatus\">FolderArchive</seealso>\n\t\t/// <seealso cref=\"FolderArchiveDownload\">FolderArchiveDownload</seealso>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderArchiveGetStatus']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderArchiveGetStatus']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Request documents and folders to be archived into a zip file\")]\n\t\tpublic SCMFolderArchiveResult FolderArchiveGetStatus(string token, string requestToken)\n\t\t{\n\t\t\tSCMFolderArchiveResult result = new SCMFolderArchiveResult();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tstring message;\n\t\t\t\tresult.Status = (SCMQueueStatus)QueueItemStateRepository.Status(user,\n\t\t\t\t\trequestToken,\n\t\t\t\t\tout message);\n\t\t\t\tif(result.Status == SCMQueueStatus.Success)\n\t\t\t\t{\n\t\t\t\t\tresult.ArchiveSize = FolderArchiveRepository.GetSize(user, requestToken);\n\t\t\t\t\tresult.ArchiveId = message;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tresult.Message = message;\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Once a request has been successfully completed, this function may\n\t\t/// be used to download the archive.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"requestToken\">Request token from a FolderArchive call.</param>\n\t\t/// <param name=\"start\">Index of the stream to start downloading.</param>\n\t\t/// <param name=\"length\">Length of bytes to get.</param>\n\t\t/// <returns>Bytes of data represented in the archive.</returns>\n\t\t/// <seealso cref=\"FolderArchiveGetStatus\">FolderArchiveGetStatus</seealso>\n\t\t/// <seealso cref=\"FolderArchiveDownload\">FolderArchiveDownload</seealso>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderArchiveDownload']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='FolderArchiveDownload']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Download an archive that has completed.\")]\n\t\tpublic byte[] FolderArchiveDownload(string token, string requestToken, long start, long length)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tint allowedChunkSize = Configuration.GetInt32AppSetting(Constants.ApplicationSettings.WebServiceChunkSize, _defaultChunkSize);\n\t\t\t\tif ((length <= 0) || (length > allowedChunkSize)) Fail(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t$\"Illegal Length = {length}, maximum allowed chunk size = {allowedChunkSize}.\");\n\n\t\t\t\treturn FolderArchiveRepository.GetChunk(user, requestToken, start, length);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\n\t\t}\n\n        #endregion\n\n\t#region BPM Workflow specific methods\n\n        /// <summary>\n\t\t/// Initiate a predefined SpringCM BPM workflow.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"name\">The workflow name.</param>\n\t\t/// <param name=\"data\">XML content.</param>\n\t\t/// <returns>StartWorkflowTask Id.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='BPMInitiateWorkflow']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='BPMInitiateWorkflow']/soap\" />\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Initiate a predefined SpringCM BPM workflow.\")]\n\t\tpublic string BPMInitiateWorkflow(string token, string name, string data)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tif (name == string.Empty) throw new PublicException(PublicException.FailReason.InvalidArgument, \"Workflow name must be specified\");\n\n\t\t\t\tIWorkflowClient client = WorkflowRepository.GetClient(user.Account);\n                return Conversions.GuidToApiStringId((client.SendStartWorkflow(user, name, StartParameters.SOAPSourceType, null, data)));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Aborts a running SpringCM BPM workflow.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"instanceId\">The id of the workflow instance to abort.</param>\n\t\t/// <param name=\"comment\">An optional comment to include in the history.</param>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='BPMSignalWorkflow']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='BPMSignalWorkflow']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Aborts a running SpringCM BPM workflow.\")]\n\t\tpublic void BPMAbortWorkflow(string token, string instanceId, string comment)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tif (string.IsNullOrEmpty(instanceId)) throw new PublicException(PublicException.FailReason.InvalidArgument, \"WorkflowId must be specified\");\n\t\t\t\tInstance instance = WorkflowRepository.LoadWorkflowInstance(user.AccountId, user.Uid, instanceId);\n\t\t\t\tif (instance == null) throw new PublicException(PublicException.FailReason.NonexistentObject,\n\t\t\t\t\t$\"No workflow found for id {instanceId}\");\n\t\t\t\tif (instance.IsCompleted) throw new PublicException(PublicException.FailReason.InvalidState,\n\t\t\t\t\t$\"Workflow id {instanceId} is already completed\");\n\n\t\t\t\tIWorkflowClient client = WorkflowRepository.GetClient(user.Account, true);\n\t\t\t\tclient.KillWorkflow(user, instance.Uid, comment);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Signals a SpringCM BPM workflow to continue processing if it is currently waiting for the signal.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"instanceId\">The id of the workflow instance to signal.</param>\n\t\t/// <param name=\"value\">An optional value to return to the WaitForSignal activity that may be placed into a variable in the workflow.</param>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='BPMSignalWorkflow']/example\" />\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='BPMSignalWorkflow']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Signals a SpringCM BPM workflow to continue.\")]\n\t\tpublic void BPMSignalWorkflow(string token, string instanceId, string value)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tif (string.IsNullOrEmpty(instanceId)) throw new PublicException(PublicException.FailReason.InvalidArgument, \"WorkflowId must be specified\");\n\t\t\t\tInstance instance = WorkflowRepository.LoadWorkflowInstance(user.AccountId, user.Uid, instanceId);\n\t\t\t\tif (instance == null) throw new PublicException(PublicException.FailReason.NonexistentObject,\n\t\t\t\t\t$\"No workflow found for id {instanceId}\");\n\t\t\t\tif (instance.IsCompleted) throw new PublicException(PublicException.FailReason.InvalidState,\n\t\t\t\t\t$\"Workflow id {instanceId} is already completed\");\n\n\t\t\t\tIWorkflowClient client = WorkflowRepository.GetClient(user.Account);\n\t\t\t\tclient.SystemCallback(user.AccountId, instance.Uid, Guid.Empty, WorkflowRepository.CALLBACK_SIGNALLED, value);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t\t#endregion\n\n        #region Account administration methods\n        // Methods here require that a PAH of the account be logged in\n\n\t\t/// <summary>\n\t\t/// Get the account associated with the given token.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <returns>An SCMAccount associated with the given token.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='AccountGetCurrent']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Returns the account associated with the given token.\")]\n\t\tpublic SCMAccount AccountGetCurrent(string token)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new SCMAccount(AuthenticateFromToken(token).UserAccount.Account);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n        /// <summary>\n        /// Get all the users in the given account. The function may be called only if the authenticated user is a PAH in\n        /// the specified account.\n        /// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"accountId\">The id of the account for which to load users.</param>\n        /// <returns>Users of the account.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='UserGetByAccountId']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='UserGetByAccountId']/soap\" />\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Get all the active users in the given account. Only a PAH may call this function.\")]\n        public SCMUserAccount[] UserGetByAccountId(String token, string accountId)\n        {\n            try\n            {\n\t\t\t\tint acctId = int.Parse(accountId);\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tif (user.AccountId != acctId)\n                {\n\t\t\t\t\tUserAccount userAccount = UserAccountPersistence.GetInstance(user).LoadByAccountIdAndUserId(acctId, user.Uid);\n                    if(null == userAccount)\n                    {\n\t\t\t\t\t\tFail(PublicException.FailReason.NonexistentObject,\n\t\t\t\t\t\t\t$\"User {user.EmailAddress} is not a member of account {accountId}.\");\n                        return null;\n                    }\n                    user = userAccount;\n                }\n\n                if(user.Role != Enums.UserRole.Primary)\n                {\n                    Fail(PublicException.FailReason.PermissionDenied, \"Only a PAH may execute administrative functions.\");\n                    return null;\n                }\n\t\t\t\tUserAccounts userAccounts = UserAccountPersistence.GetInstance(user).LoadByAccountId(acctId);\n                return SCMUserAccount.Convert(userAccounts);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n\n            }\n            return null;\n        }\n\n\t\t/// <summary>\n\t\t/// Changes the user's password.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"newPassword\">A new password for the user.</param>\n\t\t/// <returns>True on success. Otherwise, throws an exception.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='UserSetPassword']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Change a user's password.\")]\n\t\tpublic bool UserSetPassword(string token, string newPassword)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tLogin login = ServiceLocator.GetInstance<ILoginRepository>().LoadLoginByAccountIdAndUserAccountUid(user.AccountId, user.Uid);\n\n\t\t\t\tstring message;\n\n\t\t\t\tif (!ServiceLocator.GetInstance<ILoginRepository>().SetLoginPassword(login, newPassword, out message))\n\t\t\t\t{\n\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidArgument, message);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\n        /// <summary>\n        /// Gets all of the Accounts related to the user defined by the token passed in.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <returns>Array of SCMAccounts</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='GetAccounts']/example\" />\n        [SOAPLogExtension]\n        [WebMethod(Description=\"Gets all of the Accounts related to the user defined by the token passed in.\")]\n        public SCMAccount[] GetAccounts(string token)\n        {\n            List<SCMAccount> SCMAccounts = new List<SCMAccount>();\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                Accounts AllAccounts = AccountPersistence.GetInstance(user).LoadByUserAccountUid(user.Uid);\n\n\n\t\t\t\tif (AllAccounts != null)\n                {\n                    foreach (Account a in AllAccounts)\n                    {\n\t\t\t\t\t\tif(IsStatusHandled(a))\n\t\t\t\t\t\t\tSCMAccounts.Add(new SCMAccount(a));\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n            return SCMAccounts.ToArray();\n        }\n\n        /// <summary>\n        /// Save a set of objects or optionally create them.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"ToSave\">SCMBaseObjects to Save. Be sure and set the ObjectType.</param>\n        /// <param name=\"CreateIfNew\">Boolean to help alleviate duplicates.</param>\n        /// <returns>A SaveResult object.  Will contain any errors in context with the object that was in error. Also the objects proposed to be saved with any new Id populated.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Save']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Save']/soap\" />\n        [SOAPLogExtension]\n        [WebMethod(Description=\"Save a set of objects or optionally create them.\")]\n        public SaveResult Save(string token, SCMBaseObject[] ToSave, bool CreateIfNew)\n        {\n            SaveResult result = new SaveResult();\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                ValidateArray(ToSave, \"ToSave\"); // do not internationalize\n                result.SavedObjects = ToSave;\n\n                //Jump to conclusions\n                foreach (SCMBaseObject obj in ToSave)\n                {\n                    _VerifyObjectType(obj);\n                    Error error = null;\n                    switch (obj.ObjectType)\n                    {\n                        case SCMObjectType.Account:\n                            error = SaveAccount(user, obj);\n                            break;\n                        case SCMObjectType.Contact:\n                            error = SaveContact(user, obj, CreateIfNew);\n                            break;\n                        case SCMObjectType.Group:\n                            //Does not check the array of members for size\n                            error = SaveGroup(user, obj, CreateIfNew);\n                            break;\n                        case SCMObjectType.User:\n                            error = SaveUserAccount(user, obj, CreateIfNew);\n                            break;\n                        case SCMObjectType.Document:\n                            //Does not create new\n                            error = SaveDocument((SCMDocument)obj,user);\n                            break;\n                        case SCMObjectType.Folder:\n                            error = SaveFolder(obj, user, CreateIfNew);\n                            break;\n                        default:\n                            if (obj is IPersistentObject)\n                            {\n                                error = ((IPersistentObject)obj).Save(user, CreateIfNew);\n                            }\n                            else\n                            {\n                                //loose one turn\n                                error = new Error(obj, WebServiceResource.error_InvalidObjectType);\n                            }\n                            break;\n                    }\n\n                    if (error != null) result.Add(error);\n                }\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n            return result;\n        }\n\n        /// <summary>\n        /// Load a set of objects based on a type and an array of Ids.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"type\">Type of object to load.</param>\n        /// <param name=\"Ids\">Array list of ids to load</param>\n        /// <param name=\"LoadExtendedMetadata\">Valid only for objects of type SCMObject not SCMBaseObject</param>\n        /// <returns>Array of SCMBaseObjects</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Load']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='Load']/soap\" />\n        [SOAPLogExtension]\n        [WebMethod(Description=\"Load a set of objects based on a type and an array of Ids.\")]\n        public SCMBaseObject[] Load(string token, SCMObjectType type, string[] Ids, bool LoadExtendedMetadata)\n        {\n            List<SCMBaseObject> objs = new List<SCMBaseObject>();\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                ValidateArray(Ids, \"Ids\");\n\t\t\t\tStringBuilder idsList = new StringBuilder();\n\t\t\t\tforeach (string id in Ids)\n\t\t\t\t{\n\t\t\t\t\tidsList.AppendFormat(\"{0}{1}\", id, id == Ids[Ids.Length - 1] ? string.Empty : \"|\");\n\t\t\t\t}\n\n                //The contact info stuff should be generic but\n                //For loading I need to convert the objects to\n                //Exactly what it is so code visibly looks repeated but isn't.\n                switch (type)\n                {\n                    case SCMObjectType.Account:\n                        Accounts accounts = AccountPersistence.AuthenticationInstance.LoadByUserAccountUid(user.Uid);\n\t\t\t\t\t\tforeach (string id in Ids)\n                        {\n                        \tint nid;\n                        \tint.TryParse(id, out nid);\n                            foreach (Account a in accounts)\n                            {\n\t\t\t\t\t\t\t\tif (a.Id == nid && IsStatusHandled(a))\n\t\t\t\t\t\t\t\t\tobjs.Add(new SCMAccount(a));\n                            }\n                        }\n                        break;\n                    case SCMObjectType.Contact:\n\t\t\t\t\t\tContacts contacts = ContactRepository.LoadByIds(user, idsList.ToString());\n                        foreach (Contact c in contacts)\n                        {\n                            if (c.IsOrlyAContact())\n                            {\n                                objs.Add(new SCMContact(c));\n                            }\n                        }\n                        break;\n                    case SCMObjectType.Group:\n\t\t\t\t\t\tContacts groups = ContactRepository.LoadByIds(user, idsList.ToString());\n                        foreach (Contact c in groups)\n                        {\n                            if (c.IsGroup())\n                            {\n                                objs.Add(new SCMGroup(user,c));\n                            }\n                        }\n                        break;\n                    case SCMObjectType.User:\n\t\t\t\t\t\tContacts users = ContactRepository.LoadByIds(user, idsList.ToString());\n                        foreach (Contact c in users)\n                        {\n                            if (!c.IsOrlyAContact())\n                            {\n                                objs.Add(new SCMUserAccount(c));\n                            }\n                        }\n                        break;\n                    case SCMObjectType.Document:\n                \t\tList<Guid> gList = new List<Guid>();\n\t\t\t\t\t\tforeach (string id in Ids)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGuid uid = Conversions.TryParseGuid(id);\n\t\t\t\t\t\t\tif (uid != Guid.Empty)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgList.Add(uid);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tDocuments docs = ServiceLocator.GetInstance<IDocumentRepository>().LoadList(user, gList, true, new ADEXS.Core.Domain.Lookup.Pager(0, ApplicationSettings.WebServiceMaxObjectArrayLength, \"Id\", true));\n                        foreach (Document d in docs)\n                        {\n                            objs.Add(new SCMDocument(user, d, LoadExtendedMetadata));\n                        }\n                        break;\n                    case SCMObjectType.Folder:\n\t\t\t\t\t\tFolders folders = ServiceLocator.GetInstance<IFolderRepository>().LoadList(user, idsList.ToString(), new ADEXS.Core.Domain.Lookup.Pager(0, ApplicationSettings.WebServiceMaxObjectArrayLength, \"Id\", true));\n                        foreach (Folder f in folders)\n                        {\n                            objs.Add(new SCMFolder(user, f, LoadExtendedMetadata));\n                        }\n                        break;\n                    default:\n                        FailInvalidObjectType(type);\n                        break;\n                }\n\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n\n            }\n            return objs.ToArray();\n        }\n\n\n\n        /* The ids of our objects are shared between all of our objects\n         * which requires knowledge of the object type to delete it. By\n         * accepting these parameters as SCMBaseObject it gets around\n         * matching up an array of types and an array of Ids.\n         */\n        /// <summary>\n        /// The base object will only require Id and ObjectType to be set in order to delete\n        /// the object, all other fields can be nulled.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"ToDelete\">Array of SCMBaseObjects to delete.</param>\n        /// <returns>A DeleteResult object that will contain any errors in context with the object in error. Most likely will be a permission problem.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DeleteBaseObjects']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='DeleteBaseObjects']/soap\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"The base object will only require Id and ObjectType to be set in order to delete the object, all other fields can be nulled.\")]\n        public DeleteResult DeleteBaseObjects(string token, SCMBaseObject[] ToDelete)\n        {\n            DeleteResult result = new DeleteResult();\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                ValidateArray(ToDelete, \"ToDelete\");\n                foreach (SCMBaseObject obj in ToDelete)\n                {\n                    _VerifyObjectType(obj);\n                    Error error = null;\n                    switch (obj.ObjectType)\n                    {\n                        case SCMObjectType.Account:\n                            error = new Error(obj, WebServiceResource.error_DeletingAccounts);\n                            break;\n                        case SCMObjectType.Contact:\n                        case SCMObjectType.User:\n                        case SCMObjectType.Group:\n                            error = DeleteContactInfo(obj, user);\n                            break;\n                        case SCMObjectType.Document:\n                            //Need to implement\n                            try\n                            {\n\t\t\t\t\t\t\t\tDocumentRepository.DeleteDocument(user, Conversions.TryParseGuid(obj.Id), WebServiceResource.ViaWebService);\n                            }\n                            catch (PublicException dPE)\n                            {\n                                error = new Error(obj, dPE.Message);\n                            }\n                            break;\n                        case SCMObjectType.Folder:\n                            try\n                            {\n                                DocumentRepository.DeleteFolder(user, Conversions.TryParseGuid(obj.Id));\n                            }\n                            catch (PublicException fPE)\n                            {\n                                error = new Error(obj, fPE.Message);\n                            }\n                            break;\n                        default:\n                            if (obj is IPersistentObject)\n                            {\n                                error = ((IPersistentObject)obj).Delete(user);\n                            }\n                            else\n                            {\n                                error = new Error(obj, WebServiceResource.error_InvalidObjectType);\n                            }\n                            break;\n                    }\n\n                    if (error != null) result.Add(error);\n                }\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n\n            return result;\n        }\n\n\n\n\n\t\t/// <summary>\n\t\t/// Searches for contacts in an account\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"SearchText\">Text to search for in a contact</param>\n\t\t/// <param name=\"IncludeDeleted\">Whether or not to include deleted contacts in the results.</param>\n\t\t/// <returns>An array of SCMContactInfos that match the search text.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='ContactFind']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Finds contacts in an account\")]\n\t\tpublic SCMContactInfo[] ContactFind(string token, string SearchText, bool IncludeDeleted)\n\t\t{\n\t\t\tList<SCMContactInfo> scmContacts = new List<SCMContactInfo>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tContacts contacts = ServiceLocator.GetInstance<IContactRepository>().Find(user,\n\t\t\t\t\tSearchText,\n\t\t\t\t\tSearchText,\n\t\t\t\t\tSearchText,\n\t\t\t\t\tSearchText,\n\t\t\t\t\tSearchText,\n\t\t\t\t\tnull,\n\t\t\t\t\t\"-2|-3|\",\n\t\t\t\t\tSearchText,\n\t\t\t\t\tIncludeDeleted,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tnull);\n\t\t\t\tforeach (Contact c in contacts)\n\t\t\t\t{\n\t\t\t\t\tif (c.IsGroup())\n\t\t\t\t\t{\n\t\t\t\t\t\t// we ignore groups here\n\t\t\t\t\t}\n\t\t\t\t\telse if (c.IsOrlyAContact())\n\t\t\t\t\t{\n\t\t\t\t\t\tscmContacts.Add(new SCMContact(c));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tscmContacts.Add(new SCMUserAccount(c));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t}\n\t\t\treturn scmContacts.ToArray();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Searches for groups in an account\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"name\">Name of the group to search for</param>\n\t\t/// <param name=\"IncludeDeleted\">Whether or not to include deleted contacts in the results.</param>\n\t\t/// <returns>An array of SCMGroups that match the search text.</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='GroupFind']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Finds groups in an account\")]\n\t\tpublic SCMGroup[] GroupFind(string token, string name, bool IncludeDeleted)\n\t\t{\n\t\t\tList<SCMGroup> scmGroups = new List<SCMGroup>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tContacts contacts = ServiceLocator.GetInstance<IContactRepository>().Find(user,\n\t\t\t\t\tnull,\n\t\t\t\t\tnull,\n\t\t\t\t\tnull,\n\t\t\t\t\tnull,\n\t\t\t\t\tnull,\n\t\t\t\t\tnull,\n\t\t\t\t\t\"1|0\",\n\t\t\t\t\tname,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tnull);\n\t\t\t\tforeach (Contact c in contacts)\n\t\t\t\t{\n\t\t\t\t\tscmGroups.Add(new SCMGroup(user, c));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t}\n\t\t\treturn scmGroups.ToArray();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns all groups a contact is in.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"contact\">The contact to look up</param>\n\t\t/// <returns>An array of groups the contact belongs to</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='GroupGetByContact']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Returns all groups a contact is in\")]\n\t\tpublic SCMGroup[] GroupGetByContact(string token, SCMContactInfo contact)\n\t\t{\n\t\t\tSCMGroup[] result = new SCMGroup[0];\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\n\t\t\t\tresult =\n\t\t\t\t\tGroupPersistence.GetInstance(user).LoadByMemberUserId(user,\n\t\t\t\t\t                                                      Conversions.TryParseGuid(contact.Id))\n\t\t\t\t\t                                                      .Select<Contact, SCMGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(x => new SCMGroup(user, x))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.ToArray();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tFail(e);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n        /// <summary>\n        /// Deletes anything that inherits from SCMContactInfo using the\n        /// ContactPersistence (this is valid because it uses the type of the object).\n        /// </summary>\n        /// <param name=\"info\"></param>\n        /// <param name=\"user\"></param>\n        /// <returns></returns>\n        private Error DeleteContactInfo(SCMBaseObject info, UserAccount user)\n        {\n            Error error = null;\n            Contact c = (Contact)LoadObject(user, info);\n\n            if (c == null)\n            {\n                error = new Error(info, WebServiceResource.error_ObjectNotExist);\n            }\n            //Check Deletable then sort out the real object\n            else if (c.IsDeletable(user))\n            {\n                try\n                {\n                    string message = null;\n                    bool success = true;\n                    if (c.IsGroup())\n                    {\n                        success = gr.Delete(user, (Group)c, ref message);\n                    }\n                    else if (c.IsOrlyAContact())\n                    {\n                        success = cr.Delete(user, c, ref message);\n                    }\n                    else if (c is UserAccount)\n                    {\n                        success = uar.Delete(user, ((UserAccount)c), ref message);\n                    }\n                    else\n                    {\n                        success = false;\n                        message = WebServiceResource.error_Unknown;\n                    }\n                    if (!success) error = new Error(info, message);\n                }\n                catch (Exception e)\n                {\n                    _log.ErrorNoPII($\"A:{user.AccountId} U:{user.Uid} Unknown error trying to delete a Contact {info.Id}\", e);\n                    error = new Error(info, WebServiceResource.error_Unknown);\n                }\n            }\n            else\n            {\n                error = new Error(info, WebServiceResource.error_DeletePermissionDenied);\n            }\n            return error;\n\n        }\n\n        /// <summary>\n        /// This does only save will not do the creation. If\n        /// the document does not exist it will fail.\n        /// </summary>\n        /// <param name=\"obj\"></param>\n        /// <param name=\"user\"></param>\n        /// <returns></returns>\n        private Error SaveDocument(SCMBaseObject obj, UserAccount user)\n        {\n            //ToDo: Too much validation in here move it out...\n            Error err = null;\n\n            try\n            {\n                Document doc = (Document)LoadObject(user, obj);\n            \tGuid objParentFolderUid = Guid.Empty;\n\t\t\t\tif (doc == null || doc.Uid == Guid.Empty)\n                {\n                    err = new Error(obj, WebServiceResource.error_CannotCreateDocFromMethod);\n                }\n\t\t\t\telse if (doc.FolderUid != (objParentFolderUid = Conversions.TryParseGuid(((SCMDocument)obj).ParentFolderId))\n\t\t\t\t\t&& !doc.HasSecurity(Enums.Security.Write | Enums.Security.Move))\n                {\n                    err = new Error(obj, WebServiceResource.MovePermissionDenied);\n                }\n                else if (!doc.HasSecurity(Enums.Security.Write))\n                {\n                    err = new Error(obj, WebServiceResource.error_UpdatePermissionDenied);\n                }\n                else\n                {\n                    //If there is a move we must check the parent move to folder security.\n\t\t\t\t\tif (doc.FolderUid != objParentFolderUid)\n                    {\n                        SCMFolder scmF = new SCMFolder();\n                        scmF.Id = ((SCMDocument)obj).ParentFolderId;\n\n                        Folder f = (Folder)LoadObject(user, scmF);\n                        if (!f.HasSecurity(Enums.Security.Create))\n                        {\n                            err = new Error(obj, WebServiceResource.MovePermissionDenied);\n                        }\n                    }\n                    //no errors save it\n                    if(err == null)\n                    {\n                        doc = ((SCMDocument)obj).Save(user, doc);\n                    }\n                }\n            }\n            catch(PublicException ex)\n            {\n                _log.ErrorNoPII(\n\t                $\"A:{user.AccountId} U:{user.Uid} Public excpetion occurred when trying to save document {obj.Id}.\", ex);\n                err = new Error(obj, ex.Message);\n            }\n\t\t\tcatch (Exception e)\n            {\n                _log.ErrorNoPII($\"A:{user.AccountId} U:{user.Uid} Failed to save document {obj.Id}.\", e);\n                err = new Error(obj, WebServiceResource.error_Unknown);//cannot extract real error\n            }\n\n            return err;\n        }\n\n\n        /// <summary>\n        /// Can create folders along with saving. Does Security test.\n        /// </summary>\n        /// <param name=\"obj\"></param>\n        /// <param name=\"user\"></param>\n        /// <param name=\"CreateIfNew\"></param>\n        /// <returns></returns>\n        private Error SaveFolder(SCMBaseObject obj, UserAccount user, bool CreateIfNew)\n        {\n            Error err = null;\n\n            try\n            {\n                Folder f = (Folder)LoadObject(user, obj);\n\n\t\t\t\tif (f == null || f.Uid == Guid.Empty)\n                {\n                    //If it is new then you must get the security of the parent document\n                    if (CreateIfNew)\n                    {\n                        SCMFolder scm = new SCMFolder();\n                        scm.Id = ((SCMFolder)obj).ParentFolderId;\n                        Folder newFolder = (Folder)LoadObject(user, scm);\n\n                        if (newFolder.HasSecurity(Enums.Security.Create))\n                        {\n                            ((SCMFolder)obj).SaveNew(user);\n                        }\n                        else\n                        {\n                            err = new Error(obj, WebServiceResource.error_CreatePermissionDenied);\n                        }\n                    }\n                    else\n                    {\n                        err = new Error(obj, WebServiceResource.error_ObjectNotExist);\n                    }\n                }\n                else if (f.HasSecurity(Enums.Security.Write))\n                {\n                    ((SCMFolder)obj).Save(user, f);\n                }\n                else\n                {\n                    err = new Error(obj, WebServiceResource.error_UpdatePermissionDenied);\n                }\n\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"A:{user.AccountId} U:{user.Uid} Failed to save Folder {obj.Id}.\", e);\n                err = new Error(obj, WebServiceResource.error_Unknown);\n            }\n            return err;\n        }\n\n        /// <summary>\n        /// Creates or saves a useraccount.  Will also create the needed user\n        /// object (meaning it will also save the user object).\n        /// </summary>\n        /// <param name=\"user\"></param>\n        /// <param name=\"obj\"></param>\n        /// <param name=\"CreateIfNew\"></param>\n        /// <returns></returns>\n        private Error SaveUserAccount(UserAccount user, SCMBaseObject obj, bool CreateIfNew)\n        {\n            Error error = null;\n            UserAccount uAccount = (UserAccount)LoadObject(user, obj);\n\n            if (uAccount == null && string.IsNullOrEmpty(obj.Id) && CreateIfNew)\n            {\n                //ToDo: Horrible naming\n                SCMUserAccount userAccount = (SCMUserAccount)obj;\n\t\t\t\tuAccount = userAccount.ConvertToUserAccount(user.AccountId);\n\t\t\t\tuAccount.AccountId = user.AccountId;\n\t\t\t\tuAccount.EmailAddress = userAccount.Email;\n\t\t\t\tuAccount.LoginName = uAccount.EmailAddress;\n\t\t\t\tuAccount.Status = uar.GetUserAccountStatus(uAccount);\n\n\t\t\t\terror = SetCountryState(userAccount, uAccount);\n\n                if (error == null)\n                {\n                    try\n                    {\n                        string message = null;\n\n                        if (!uar.Create(user, uAccount, ref message))\n                        {\n                            error = new Error(obj, message);\n                        }\n\t\t\t\t\t\tuserAccount.Id = Conversions.GuidToApiStringId(uAccount.Uid);\n\t\t\t\t\t\tuserAccount.UserId = Conversions.GuidToApiStringId(uAccount.Uid);\n\t\t\t\t\t}\n                    catch (Exception e)\n                    {\n                        _log.ErrorNoPII($\"A:{user.AccountId} U:{user.Uid} Error trying to add a new user {obj.Id}.\", e);\n                        error = new Error(obj, WebServiceResource.error_Unknown);\n                    }\n                }\n\n                if (error == null && user.Settings.WebServicesSendActivationEmail)\n                {\n\t\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(new UserAccountActivationEmail(user, uAccount)).QueueIt();\n                }\n            }\n            else if (uAccount == null)\n            {\n                error = new Error(obj, WebServiceResource.error_ObjectNotExist);\n            }\n            else\n            {\n\t\t\t\tUserAccount previousValues = new UserAccount(uAccount);\n\t\t\t\t((SCMUserAccount)obj).UpdateProperties(uAccount);\n\t\t\t\terror = SetCountryState((SCMContactInfo)obj, uAccount);\n\n\t\t\t\tif (error == null)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tstring message = null;\n\t\t\t\t\t\tif (!uar.Save(user, uAccount, previousValues, ref message)) error = new Error(obj, message);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII($\"A:{user.AccountId} U{user.Uid} Unknown error saving UserAccount {obj.Id}.\", e);\n\t\t\t\t\t\terror = new Error(obj, WebServiceResource.error_Unknown);\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n\n            return error;\n        }\n\n\n\n        /// <summary>\n        /// Create or Save Group. Along with members.\n        ///\n        /// </summary>\n        /// <param name=\"user\"></param>\n        /// <param name=\"obj\"></param>\n        /// <param name=\"CreateIfNew\"></param>\n        /// <returns></returns>\n        private Error SaveGroup(UserAccount user, SCMBaseObject obj, bool CreateIfNew)\n        {\n            Error error = null;\n            try\n            {\n                Contact group = (Contact)LoadObject(user, obj);\n\n\n                if (group == null && string.IsNullOrEmpty(obj.Id) && CreateIfNew)\n                {\n\t\t\t\t\tGroup g = new Group(user.AccountId);\n                    g.Name = obj.Name;\n                    g.OwnerUserAccountUid = user.Uid;\n                    g.GroupType = (Enums.GroupType)((SCMGroup)obj).GroupType;\n                    g.IsPrivate = ((SCMGroup)obj).IsPrivate;\n                    foreach (SCMContactInfo info in ((SCMGroup)obj).Members)\n                    {\n                        GroupMember member = new GroupMember();\n\t\t\t\t\t\tmember.MemberUid = Conversions.TryParseGuid(info.Id);\n                        g.GroupMembers.Add(member);\n                    }\n\n\n                    string Message = null;\n                    if (! gr.Create(user, g, ref Message)) error = new Error(obj, Message);\n\t\t\t\t\tobj.Id = Conversions.GuidToApiStringId(g.Uid);\n                }\n\t\t\t\telse if (group != null && group.Uid == Conversions.TryParseGuid(obj.Id))\n                {\n                    //Sly conversion from contact to group\n\t\t\t\t\tGroup CurrentGroup = new Group(group.AccountId);\n\t\t\t\t\tCurrentGroup.Uid = group.Uid;\n                    CurrentGroup.GroupType = group.GroupType;\n                    CurrentGroup.Name = group.Name;\n                    CurrentGroup.IsPrivate = group.IsPrivate;\n\n\n\t\t\t\t\tGroup NewGroup = new Group(group.AccountId);\n\t\t\t\t\tNewGroup.Uid = group.Uid;\n                    NewGroup.GroupType = group.GroupType;\n                    NewGroup.Name = obj.Name;\n                    NewGroup.IsPrivate = ((SCMGroup)obj).IsPrivate;\n\n                    GroupMembers NewMembers = new GroupMembers();\n                    foreach (SCMContactInfo info in ((SCMGroup)obj).Members)\n                    {\n                        GroupMember member = new GroupMember();\n\t\t\t\t\t\tmember.MemberUid = Conversions.TryParseGuid(info.Id);\n\t\t\t\t\t\tmember.GroupDataUid = group.Uid;\n                        NewMembers.Add(member);\n                    }\n\n                    string Message = null;\n                    if (! gr.SaveGroup(CurrentGroup, NewGroup, NewMembers, user, ref Message)) error = new Error(obj, Message);\n                }\n                else\n                {\n                    error = new Error(obj, WebServiceResource.error_ObjectNotExist);\n                }\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"A:{user.AccountId} U:{user.Uid} Could not save the group {obj.Id}.\", e);\n                error = new Error(obj, WebServiceResource.error_Unknown);\n            }\n            return error;\n\n\n        }\n\n        /// <summary>\n        /// No creation allowed. Will save the simple fields given to account.\n        /// </summary>\n        /// <param name=\"user\"></param>\n        /// <param name=\"obj\"></param>\n        /// <returns></returns>\n        private Error SaveAccount(UserAccount user, SCMBaseObject obj)\n        {\n            Error error = null;\n            Account acc = (Account)LoadObject(user, obj);\n\n            if (user.AccountId != int.Parse(obj.Id))\n            {\n                error = new Error(obj, WebServiceResource.error_ChangeAccountAuthTo);\n            }\n            else if (!user.Privileges.CanSetupAccount && !user.CanAdministerBilling)\n            {\n                error = new Error(obj, WebServiceResource.error_UpdatePermissionDenied);\n            }\n            else if (acc == null)\n            {\n                error = new Error(obj, WebServiceResource.error_ObjectNotExist);\n            }\n            else\n            {\n                try\n                {\n                    acc.Name = obj.Name;\n                    string msg = string.Empty;\n                    if (!AccountRepository.Instance.Save(user, acc, ref msg))\n                    {\n                        error = new Error(obj, msg);\n                    }\n                }\n                catch (Exception e)\n                {\n                    error = new Error(obj, WebServiceResource.error_Unknown);\n                    _log.WarnNoPII($\"A:{user.AccountId} U:{user.Uid} Could not save account {obj.Id}.\", e);\n                }\n            }\n            return error;\n        }\n\n        /// <summary>\n        /// Create or save a contact.\n        /// </summary>\n        /// <param name=\"user\"></param>\n        /// <param name=\"obj\"></param>\n        /// <param name=\"CreateIfNew\"></param>\n        /// <returns></returns>\n        private Error SaveContact(UserAccount user, SCMBaseObject obj, bool CreateIfNew)\n        {\n            Error error = null;\n            Contact contact = (Contact)LoadObject(user, obj);\n\n            if (contact == null && string.IsNullOrEmpty(obj.Id) && CreateIfNew)\n            {\n                //Creating new contact\n                SCMContact newContact = (SCMContact)obj;\n                contact = newContact.ConvertToContact();\n                contact.AccountId = user.AccountId;\n                contact.OwnerUserAccountUid = user.Uid;\n                error = SetCountryState(newContact, contact);\n            }\n            else if (contact == null)\n            {\n                error = new Error(obj, WebServiceResource.error_ObjectNotExist);\n            }\n            else\n            {\n                ((SCMContact)obj).UpdateProperties(contact);\n            }\n            if (error == null)\n            {\n                try\n                {\n                    string message = null;\n                    if (! cr.Save(user, contact, ref message)) error = new Error(obj, message);\n\t\t\t\t\tobj.Id = Conversions.GuidToApiStringId(contact.Uid);\n                }\n                catch (SqlException se)\n                {\n                    _log.ErrorNoPII($\"A:{user.AccountId} U:{user.Uid} Could not save the Contact {contact.Uid}.\", se);\n                    error = new Error(obj, WebServiceResource.error_Unknown);\n                }\n            }\n            return error;\n        }\n\n        #endregion\n\n        #region Reports\n        /// <summary>\n        /// Step 1 of 3. Executes a report with the parameters supplied and exports it to the format specified.\n        ///\n        /// This method simply requests the work to be done.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from Authenticate Call.</param>\n        /// <param name=\"reportName\">Name of the report.</param>\n        /// <param name=\"exportFormat\">Type of data to export to (ex. CSV)</param>\n        /// <param name=\"parameters\">Parameters that are on the report to be filled out.</param>\n        /// <returns>Result of the request for execute. Will contain a reference to check back with.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='ExecuteReport']/example\" />\n        [SOAPLogExtension]\n        [WebMethod(Description=\"Step 1 of 3. Executes a report with the parameters supplied and exports it to the format specified.\")]\n\t\tpublic ExecuteReportResult ExecuteReportBegin(string token, string reportName, ReportExportFormat exportFormat, ReportParameter[] parameters)\n\t\t{\n\t\t\tExecuteReportResult result = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tvar cr = CustomReportRepository.Instance.LoadByName(user, reportName);\n\t\t\t\tif (cr != null)\n\t\t\t\t{\n                    NameValuePair[] pairs = null;\n\t\t\t\t\tif (parameters != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpairs = new NameValuePair[parameters.Length];\n\t\t\t\t\t\tfor (int ndx = 0; ndx < pairs.Length; ndx++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpairs[ndx] = new NameValuePair(parameters[ndx].Name, parameters[ndx].Value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar processor = new SqlReportProcessor();\n\t\t\t\t\tstring guid = processor.StartReport(user, cr, (Enums.ReportExportFormat)(int)exportFormat, pairs).ToString();\n\n\t\t\t\t\tresult = new ExecuteReportResult\n\t\t\t\t\t{\n\t\t\t\t\t\tId = guid,\n\t\t\t\t\t\tStatus = ExecuteReportStatus.Pending,\n\t\t\t\t\t\tMessage = \"Requested\",\n\t\t\t\t\t};\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tFail(PublicException.FailReason.NonexistentObject, WebServiceResource.error_ObjectNotExist);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tFail(ex);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Step 2 of 3. Checks the status of a report execution.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from Authenticate Call.</param>\n\t\t/// <param name=\"result\">Result returned from ExecuteReportBegin</param>\n\t\t/// <returns></returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='ExecuteReport']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Step 2 of 3. Checks the status of a report execution.\")]\n\t\tpublic ExecuteReportResult ExecuteReportCheckStatus(string token, ExecuteReportResult result)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tstring message = string.Empty;\n\n\t\t\t\tswitch (new SqlReportProcessor().CheckStatus(user, result.Id, out message))\n\t\t\t\t{\n\t\t\t\t\tcase Enums.ReportExecutionStatus.Error:\n\t\t\t\t\t\tresult.Status = ExecuteReportStatus.Failed;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.ReportExecutionStatus.Finished:\n\t\t\t\t\t\tresult.Status = ExecuteReportStatus.Ready;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tresult.Status = ExecuteReportStatus.Pending;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresult.Message = message;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tFail(ex);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Step 3 of 3. Returns the export of the report in an array of bytes.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from Authenticate Call.</param>\n\t\t/// <param name=\"result\">Result returned from ExecuteReportBegin</param>\n\t\t/// <returns></returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n\t\t///     path=\"//Class[@name='SpringCMService']/Function[@name='ExecuteReport']/example\" />\n\t\t[SOAPLogExtension]\n\t\t[WebMethod(Description = \"Step 3 of 3. Returns the export of the report in an array of bytes.\")]\n\t\tpublic byte[] ExecuteReportDownload(string token, ExecuteReportResult result)\n\t\t{\n\t\t\tbyte[] returnBytes = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\treturnBytes = new SqlReportProcessor().GetReportData(user, result.Id);\n\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tFail(ex);\n\t\t\t}\n\t\t\treturn returnBytes;\n\t\t}\n\n\n\t\t#endregion\n\n\t\t#region Helper methods\n\t\t/// <summary>\n\t\t/// Used to set the state on contact objects based on the\n\t\t/// string values.\n\t\t/// </summary>\n\t\t/// <param name=\"info\"></param>\n\t\t/// <param name=\"c\"></param>\n\t\t/// <returns></returns>\n\t\tprivate Error SetCountryState(SCMContactInfo info, Contact c)\n        {//corner case removing country\n            Error error = null;\n            short CountryId = ParseCountry(info.Country);\n            short StateId = ParseState(info.ProvinceState, CountryId);\n\n            if (CountryId == short.MinValue && !string.IsNullOrEmpty(info.Country))\n            {\n                error = new Error(info, WebServiceResource.error_CountrInvalid);\n            }\n            {\n                c.CountryId = CountryId;\n            }\n            if (error == null && StateId == short.MinValue && !string.IsNullOrEmpty(info.ProvinceState))\n            {\n                error = new Error(info, WebServiceResource.error_StateInvalid);\n            }\n            else\n            {\n                c.ProvinceStateId = StateId;\n            }\n\n            return error;\n        }\n\n        /// <summary>\n        /// Parses a string version of country to an Id\n        /// </summary>\n        /// <param name=\"p\"></param>\n        /// <returns></returns>\n        private short ParseCountry(string p)\n        {\n            if (ApplicationCache.Countries != null)\n            {\n                foreach (ADEXS.Core.Domain.Lookup.Country country in ApplicationCache.Countries)\n                {\n                    if (country.Name == p) return country.Id;\n                }\n            }\n            return short.MinValue;\n        }\n\n\n        /// <summary>\n        /// Parses the string version of a state into an Id.  Based on countryid.\n        /// </summary>\n        /// <param name=\"p\"></param>\n        /// <param name=\"CountryId\"></param>\n        /// <returns></returns>\n        private short ParseState(string p, short CountryId)\n        {\n        \tCacheHashtable ch = ApplicationCache.ProvinceStateTable;\n        \tProvinceStates pss = (ProvinceStates)ch[CountryId];\n            if (pss != null)\n            {\n                foreach (ADEXS.Core.Domain.Lookup.ProvinceState state in pss)\n                {\n                    if (state.Name == p && CountryId == state.CountryId) return state.Id;\n                }\n            }\n            return short.MinValue;\n        }\n\n        /// <summary>\n        /// Will Validate an array passed into a webmethod.  Currently\n        /// we test for length and nulls.\n        /// </summary>\n        /// <param name=\"objs\"></param>\n        /// <param name=\"ParamName\"></param>\n        private void ValidateArray(Array objs, string ParamName)\n        {\n            //This keeps us from getting a person trying to move all of their documents that they uploaded to one\n            //folder to another and taking down our servers.(it would likely timeout anyways if they don't mess with the timeout option)\n            int Max = ApplicationSettings.WebServiceMaxObjectArrayLength;\n            if (objs != null && objs.Length > Max)\n            {\n                Fail(PublicException.FailReason.InvalidArgument, string.Format(WebServiceResource.ArgumentExceededMaximumFormat, ParamName, Max));\n            }\n            if (objs == null)\n            {\n                Fail(PublicException.FailReason.InvalidArgument, string.Format(WebServiceResource.ArgumentCanNotBeNullFormat, ParamName));\n            }\n        }\n\n        /// <summary>\n        /// Used in object agnostic functions to allow customers to fudge a bit on the objecttype...\n        /// </summary>\n        /// <param name=\"obj\"></param>\n        private void _VerifyObjectType(SCMBaseObject obj)\n        {\n            if (obj.ObjectType == SCMObjectType.Document)\n            {\n                if (obj.GetType() == typeof(SCMAccount)) obj.ObjectType = SCMObjectType.Account;\n                if (obj.GetType() == typeof(SCMUserAccount)) obj.ObjectType = SCMObjectType.User;\n                if (obj.GetType() == typeof(SCMContact)) obj.ObjectType = SCMObjectType.Contact;\n                if (obj.GetType() == typeof(SCMFolder)) obj.ObjectType = SCMObjectType.Folder;\n                if (obj.GetType() == typeof(SCMGroup)) obj.ObjectType = SCMObjectType.Group;\n            }\n        }\n\n\t\tprivate static bool IsStatusHandled(Account a)\n\t\t{\n\t\t\t// only certain account are accessible via web service\n\t\t\treturn\n\t\t\ta.Status == Enums.AccountStatus.Paid ||\n\t\t\ta.Status == Enums.AccountStatus.Unpaid ||\n\t\t\ta.Status == Enums.AccountStatus.Trial ||\n\t\t\ta.Status == Enums.AccountStatus.ExpiredTrial;\n\t\t}\n\n        #endregion\n\n        #region Licensing\n\n\n        /// <summary>\n        /// This function is used by proprietary software vendors to establish a license for a product\n        /// made available on the SpringCM platform.\n        /// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"productName\">Name of the product/client/</param>\n        /// <param name=\"version\">Version string for the product/client.</param>\n        /// <param name=\"data\">Product/client specific data.</param>\n        /// <param name=\"expirationDate\">Product/client expiration date.</param>\n        /// <param name=\"notes\">Product/client specific notes.</param>\n        /// <returns>Guid APIkey</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_RegisterLicense']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_RegisterLicense']/soap\" />\n        /// <seealso cref=\"APILicense_RegisterLicense\">APILicense_RegisterLicense</seealso>\n        [SOAPLogExtension]\n        [WebMethod(Description = \"Generates an APIKey (GUID) that must be saved for future reference.  This function is used by proprietary software vendors to establish a license for a product made available on the SpringCM platform.\")]\n        public string APILicense_RegisterProduct(string token, string productName, string version, string data, DateTime expirationDate, string notes)\n        {\n            //Note: This will only allow new registrations, we are not allowing the user to update existing registrations\n\n            APILicense newAPILicense = new APILicense();\n\n            try\n            {\n                UserAccount user = AuthenticateFromToken(token).UserAccount;\n\n                //create a new object to add to the database\n\n                newAPILicense.ProductName = productName;\n                newAPILicense.Version = version;\n                newAPILicense.Data = data;\n                newAPILicense.ExpirationDate = expirationDate;\n                newAPILicense.Notes = notes;\n\n\t\t\t\tAPILicenseRepository.Save(user, newAPILicense);\n\t\t\t}\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n\n            return newAPILicense.APIKey;\n        }\n\n\n        /// <summary>\n        /// Allows the registration of software licenses for the authenticated user and account.\n\t\t/// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"clientData\">Client specific data/identifier.</param>\n\t\t/// <returns>Guid Licensekey</returns>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_RegisterLicense']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_RegisterLicense']/soap\" />\n        /// <seealso cref=\"APILicense_RegisterProduct\">APILicense_RegisterProduct</seealso>\n        [SOAPLogExtension]\n\t\t[WebMethod(Description = \"Generates a LicenseKey (GUID) that must be saved for future reference.  Allows the registration of a software license for the authenticated user and account associated with the APIKey used during authentication.\")]\n\t\tpublic string APILicense_RegisterLicense(string token, string clientData)\n        {\n\t\t\tAPILicenseInstance apiLicenseInstance = new APILicenseInstance();\n\n\t\t\t//expiration can be derived from the created date of the registration or taken literally from the global ExpirationDate of the APILicense record\n\n            try\n            {\n\t\t\t\tServiceUserAccount user = AuthenticateFromToken(token);\n                apiLicenseInstance.AccountId = user.UserAccount.AccountId;\n\t\t\t\tapiLicenseInstance.UserAccountUid = user.UserAccount.Uid;\n                apiLicenseInstance.APIKey = user.APIKey;\n            \tapiLicenseInstance.ClientData = clientData;\n\n\t\t\t\t//Get the LicenseKey from the command object by calling a postSave delegate\n                APILicenseInstancePersistence.SaveCallback scb = new APILicenseInstancePersistence.SaveCallback(APILicenseInstancePersistence.GetGuid);\n\t\t\t\tAPILicenseInstancePersistence.AuthenticationInstance.Save(Constants.SystemUser, apiLicenseInstance, apiLicenseInstance.GetType(), null, scb);\n            }\n\t\t\tcatch (SqlException)\n\t\t\t{\n\t\t\t\tFail(PublicException.FailReason.InvalidArgument,\n\t\t\t\t\t$\"A license instance can not be associated with the current APIKey '{apiLicenseInstance.APIKey}'.\");\n\t\t\t}\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n\n        \treturn apiLicenseInstance.LicenseKey;\n        }\n\n        /// <summary>\n        /// Allows the un-registration of a software license for the authenticated user and account.\n        /// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"licenseKey\">The License key to be unregistered, this is the key that was passed back as a return value from the APILicense_RegisterLicense call.</param>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_UnRegisterLicense']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_UnRegisterLicense']/soap\" />\n        [SOAPLogExtension]\n        [WebMethod(Description = \"Allows the un-registration of a software license.\")]\n        public void APILicense_UnRegisterLicense(string token, string licenseKey)\n        {\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tAPILicenseInstancePersistence.AuthenticationInstance.DeleteByKey(licenseKey, user);\n\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n        }\n\n        /// <summary>\n        /// Returns an array of all of the licenses for the authenticated user and account.\n        /// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_ListLicenses']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_ListLicenses']/soap\" />\n        [SOAPLogExtension]\n        [WebMethod(Description = \"Returns an array of all of the licenses for the authenticated user.\")]\n        public SCMAPILicense[] APILicense_ListLicenses(string token)\n        {\n            APILicenses apiLicenses = new APILicenses();\n\n            try\n            {\n\t\t\t\tUserAccount user = AuthenticateFromToken(token).UserAccount;\n                apiLicenses = APILicensePersistence.AuthenticationInstance.LoadByUser(user.Uid, user.AccountId);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n\n            //map to a SCMAPILicenseInstance from the framework object\n            return SCMAPILicense.Convert(apiLicenses);\n        }\n\n\n        /// <summary>\n        /// Verifies that a particular license is registered by the authenticated user and account by passing in the Guid used to register the license.  The CreatedDate can be used to determine if a license is still valid.\n        /// </summary>\n\t\t/// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n\t\t/// <param name=\"licenseKey\">License key.</param>\n\t\t/// <param name=\"clientData\">Client specific data/identifier.</param>\n\t\t/// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_VerifyLicense']/example\" />\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='APILicense_VerifyLicense']/soap\" />\n        [SOAPLogExtension]\n        [WebMethod(Description = \"Verifies that a particular license is registered and valid.\")]\n        public SCMAPILicenseInstance APILicense_VerifyLicense(string token, string licenseKey, string clientData)\n        {\n            //expiration can be derived from the created date of the registration or taken literally from the global ExpirationDate of the APILicense record\n\n            APILicenseInstance apiLicenseInstance = new APILicenseInstance();\n\n            try\n            {\n                UserAccount user = AuthenticateFromToken(token).UserAccount;\n\t\t\t\tapiLicenseInstance = APILicenseInstancePersistence.AuthenticationInstance.Verify(licenseKey, user, clientData);\n            }\n            catch (Exception e)\n            {\n                Fail(e);\n            }\n\n            //map to a SCMAPILicenseInstance from the framework object\n            return SCMAPILicenseInstance.Convert(apiLicenseInstance);\n\n        }\n\n        #endregion\n\n        //WARNING: Web services must maintain backwards compatability.\n        //WARNING: Renaming/removing methods/properties or arguments will break backwards compatibility\n        //WARNING: Adding properties/methods or arguments (in an overload) is ok\n\n\n        #region ICaseManagementService Members\n\n\n        /// <summary>\n        /// Does a search for SCMCase based on a string.  Will include values in metadata.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"search\">Keywords to look for</param>\n        /// <param name=\"resultPager\">On initial call this can be unspecified or nil but subsequent calls it will be the page from the result. </param>\n        /// <param name=\"loadExtendedMetadata\">Optional loading of the attributes attached to the SCMCase</param>\n        /// <returns>An array of SCMCase that is relevant to the search string.</returns>\n        /// <include file=\"SpringCMService.doc.xml\"\n        ///     path=\"//Class[@name='SpringCMService']/Function[@name='CaseSearch']/example\" />\n        [SOAPLogExtension]\n        [WebMethod(Description=\"Does a search for SCMCaseData based on a string.  Will include values in metadata.\")]\n        public SCMPagedResult CaseSearch(string token, string search, SCMPager resultPager, bool loadExtendedMetadata)\n        {\n\t\t\tthrow new NotSupportedException(\"Case is deprecated\");\n\t\t}\n\n\n        /// <summary>\n        /// Get the users available in a case.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"caseId\">CaseId to lookup users for.</param>\n        /// <returns>List of users associated with the case.</returns>\n        [SOAPLogExtension]\n        [WebMethod(Description = \"Gets the users assigned to a specific case along with their role in the case.\")]\n        public SCMCaseUserAssignment[] CaseGetUsers(string token, string caseId)\n        {\n\t\t\tthrow new NotSupportedException(\"Case is deprecated\");\n\t\t}\n\n        /// <summary>\n        /// Gets the tasks associated to the case.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <param name=\"caseId\">CaseId to lookup users for.</param>\n        /// <returns>List of tasks.</returns>\n        [SOAPLogExtension]\n        [WebMethod]\n        public SCMCaseTask[] CaseGetTasks(string token, string caseId)\n        {\n\t\t\tthrow new NotSupportedException(\"Case is deprecated\");\n\t\t}\n\n        /// <summary>\n        /// This gets all of the possible case views/types that a case can have.\n        /// </summary>\n        /// <param name=\"token\">Authentication token from an Authenticate method call.</param>\n        /// <returns>List of SCMCaseType. Use this to create new cases.</returns>\n        [SOAPLogExtension]\n        [WebMethod]\n        public SCMCaseType[] CaseGetTypes(string token)\n        {\n            List<SCMCaseType> types = new List<SCMCaseType>();\n            return types.ToArray();\n        }\n\n        #endregion\n\n\t}\n}\n",
      "relevance_score": 0.7
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/ProfileLogger/ProfileLoggerComponent.cs",
      "content": "\ufeffusing System.Collections.Generic;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.MQ;\nusing ADEXS.MqWorkers;\n\n\n#if NET\nusing ADEXS.ServiceFramework;\n#endif\n\nnamespace ADEXS.ProfileLogger\n{\n\tpublic class ProfileLoggerComponent\n#if NET\n\t\t: ScmServicedComponent\n#else\n\t\t: AbstractServicedComponent\n#endif\n\t{\n\t\tprotected override void OnRun()\n\t\t{\n\t\t\tif (Configuration.GetBooleanAppSetting(\"UseSubscriptionWorker_Profile\", true))\n\t\t\t{\n\t\t\t\tRegisterWorkerGroup(new ProfileMessageQueueSubscriberWorker(this));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRegisterWorkerGroup(new ProfileMessageQueueWorker(this));\n\t\t\t}\n\n\t\t\tRegisterWorker(new AccountStatisticsWorker(this));\n\t\t}\n\n\t\tprotected override List<IServiceRegistry> GetServiceRegistries()\n\t\t{\n\t\t\tvar registries = base.GetServiceRegistries();\n#if !NET\n\t\t\tregistries.Add(new OneConfigServiceRegistry());\n\t\t\tregistries.Add(new ServiceConfigServiceRegistry(\"ProfileLogger.ini\"));\n#endif\n\t\t\tregistries.Add(new MessageQueueRegistry());\n\t\t\tregistries.Add(new MqWorkersRegistry());\n\t\t\tregistries.Add(new CoreDomainRegistry());\n\t\t\treturn registries;\n\t\t}\n\n#if NET\n\t\tprotected override void OnStop()\n\t\t{\n\t\t}\n#endif\n\n\t\tpublic static IList<IServiceRegistry> GetComponentServiceRegistries()\n\t\t{\n\t\t\treturn new ProfileLoggerComponent().GetServiceRegistries();\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    }
  ],
  "reasoning_chain": "ReasoningChain(strategy=<ReasoningStrategy.CHAIN_OF_THOUGHT: 'chain_of_thought'>, steps=[ReasoningStep(step_number=1, description='1. Analysis', reasoning='1. Analysis  \\n   \u2022 Goal: enrich the existing \u201cCLM-Web HTTP request\u201d span with two new attributes:  \\n     \u2013 HTTP_REFERER  \u2190 Request.Headers[\"Referer\"]  ', conclusion='     \u2013 HTTP_REFERER  \u2190 Request.Headers[\"Referer\"]  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=2, description='2. Planning', reasoning='2. Planning  \\n   \u2022 Find the file(s) that receive the ASP.NET request (asmx service) or that provide the\\n     common tracing wrapper for all web requests.  ', conclusion='     common tracing wrapper for all web requests.  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=3, description='3. Implementation \u2011 required code changes (high-level)', reasoning='3. Implementation \u2011 required code changes (high-level)  \\n   a) In the ASMX endpoint (SpringCMService.asmx.cs) \u2013 this is where the HTTP\\n      Context is readily available.  ', conclusion='      Context is readily available.  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=4, description='4. Validation', reasoning='4. Validation  \\n   \u2022 Run an integration test call that issues a Referer header and verifies, through the\\n     tracer backend (Jaeger / Zipkin / AI), that the span now contains both new', conclusion='     tracer backend (Jaeger / Zipkin / AI), that the span now contains both new', confidence=0.8, evidence=['LLM analysis'])], final_conclusion='Overall confidence : 0.46', overall_confidence=0.8, alternative_approaches=['Alternative approaches considered', '\u2022 Modifying every web method individually.  Would achieve the goal but is brittle;'])"
}