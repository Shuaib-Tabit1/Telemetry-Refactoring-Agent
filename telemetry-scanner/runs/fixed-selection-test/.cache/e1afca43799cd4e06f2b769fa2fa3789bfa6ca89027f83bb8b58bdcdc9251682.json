{
  "selected_files": [
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class DetectTypeProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class VideoInfoProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net.Mime;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.PhysicalStorage;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FileIO;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.MimeLookup;\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.ContentStorage;\n\nnamespace ADEXS.DetectTypeService\n{\n\tpublic partial class DetectTypeProcessor : CommonTaskProcessor<DetectTypeTaskPayload>\n\t{\n\t\tprivate readonly IAtlasPersistenceFactory _atlasPersistenceFactory;\n\n\t\tprivate readonly IAtlasPhysicalStorageFactory _atlasPhysicalStorageFactory;\n\n\t\tprivate readonly IMimeDetector _mimeDetector;\n\n\t\tprivate readonly IDetectTypeServiceFeaturesConfig _featuresConfig;\n\n\t\tpublic DetectTypeProcessor()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IAtlasPersistenceFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IAtlasPhysicalStorageFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IMimeDetector>(),\n\t\t\t\tServiceLocator.GetInstance<IServiceInstrumentation>(),\n\t\t\t\tServiceLocator.GetInstance<IDetectTypeServiceFeaturesConfig>())\n\t\t{\n\t\t}\n\n\t\tpublic DetectTypeProcessor(\n\t\t\tIAtlasPersistenceFactory atlasPersistenceFactory,\n\t\t\tIAtlasPhysicalStorageFactory atlasPhysicalStorageFactory,\n\t\t\tIMimeDetector mimeDetector,\n\t\t\tIServiceInstrumentation serviceInstrumentation,\n\t\t\tIDetectTypeServiceFeaturesConfig featuresConfig)\n\t\t{\n\t\t\t_atlasPersistenceFactory = atlasPersistenceFactory;\n\t\t\t_atlasPhysicalStorageFactory = atlasPhysicalStorageFactory;\n\t\t\t_mimeDetector = mimeDetector;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t\t_featuresConfig = featuresConfig;\n\t\t}\n\n\t\tpublic override ProcessTaskResult ProcessTask()\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t// get and report the status of whether Optimizely is the feature flag provider\n\t\t\tLogger.InfoNoPII($\"Verification: IsOptimizelyVerificationFlagEnabled is {_featuresConfig.IsOptimizelyVerificationFlagEnabled} for account '{Task.AccountId}' (context accountId: '{AtlasContext.Current.AccountId}')\");\n\n\t\t\tProcessTaskResult result = new ProcessTaskResult();\n\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\tvar fileDataPersistence = _atlasPersistenceFactory.Get<IFileDataPersistence>(Task.AccountId);\n\n\t\t\tFileData fd = fileDataPersistence.LoadByUid(DeserializedPayload.FileDataUid);\n\t\t\tif (fd == null)\n\t\t\t{\n\t\t\t\tLogger.WarnNoPII($\"FileDataUid {DeserializedPayload.FileDataUid} does not exist in the db; ignoring\");\n\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\tresult.Message = \"Filedata Doesn't Exist\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// first try and detect the MIME type\n\t\t\t\t\tstring mimeType;\n\t\t\t\t\tusing (TempFile temp = new TempFile(fd.Extension))\n\t\t\t\t\t{\n\t\t\t\t\t\t//We could possibly optimize this by reading the first 256 bytes and passing them to the underlying COM library urlmon.dll.\n\t\t\t\t\t\t//See https://msdn.microsoft.com/en-us/library/ms775107(v=vs.85).aspx (FindMimeFromData function)\n\t\t\t\t\t\t_atlasPhysicalStorageFactory.GetPhysicalStorage(fd.AccountId).GetFile(fd.AccountId, fd.FileName, StorageConstants.StorageFormat.Native, temp.FileName);\n\t\t\t\t\t\tmimeType = _mimeDetector.DetectMimeType(temp.FileName);\n\t\t\t\t\t}\n\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected MIME type '{0}' for fileDataUid {1}.\", mimeType, fd.FileDataUid);\n\n\t\t\t\t\t// if still not sure try to map the extension to the MIME type\n\t\t\t\t\tif (string.IsNullOrEmpty(mimeType) || (mimeType == MediaTypeNames.Application.Octet))\n\t\t\t\t\t{\n\t\t\t\t\t\tmimeType = FileUtil.GetMimeTypeByExtension(fd.Extension);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Matched extension to MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\n\t\t\t\t\t// once we have a new MIME type, save it\n\t\t\t\t\tif (!string.IsNullOrEmpty(mimeType) && mimeType != fd.MIMEType)\n\t\t\t\t\t{\n\t\t\t\t\t\tfileDataPersistence.UpdateMIMEType(fd.Uid, mimeType);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected and set MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\t\t\te.Trace();\n\t\t\t\t\tLogger.ErrorNoPII($\"Failed to process fileDataUid {fd.FileDataUid} with exception \", e);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tTask.LastErrorMessage = e.Message;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.ErrorNoPII($\"Failed to mark fileDataUid {fd.FileDataUid} as failed with exception \", e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactivity?.SetQueueTaskResultTags(Task, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.MQ;\nusing ADEXS.Core.Domain;\nusing System.Threading;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing System.IO;\nusing ADEXS.Core.Domain.Model;\nusing System.Diagnostics;\n\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.ServiceFramework;\nusing CLM.MessageDefines;\nusing CLM.MessageDefines.Constants;\nusing CLM.MessageDefines.Interfaces;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\n\nusing StructureMap;\nusing ADEXS.MqWorkers.Config.Context;\nusing ADEXS.MqWorkers.Extensions;\nusing ADEXS.MqWorkers.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.MqWorkers.Config;\n\nnamespace ADEXS.Services.MessageWorkerService\n{\n\t//Should probably make an interface that encapsulates the methods for loading and\n\t//updating the Tasks so that we don't have to be tied to MessageQueues for this type of worker\n\tpublic class DispatchedWorker<T, U> : AbstractServiceQueue<T> where T : class, IQueueTask, new() where U : class, ITaskProcessor<T>, new()\n\t{\n\t\tprivate const string DESIRED_WORKER_COUNT = \"_WorkerCount\";\n\t\tprivate const string DESIRED_WORKER_MULTIPLIER = \"_WorkerMultiplier\";\n\t\tprivate const string TASK_DISPATCHERS = \"_TaskDispatchers\";\n\t\tprivate const string DESIRED_STAND_ALONE = \"_StandAlone\";\n\t\tprivate const string DEFAULT_TASK_DISPATCHERS = \"DefaultTaskDispatchers\";\n\t\tprivate const int DEFAULT_WORKER_COUNT = 5;\n\t\tprivate const double DEAFULT_CORE_TO_WORKER_MULTIPLIER = 0;\n\t\tprivate readonly string TASKPROCESSOR = Configuration.GetStringAppSetting(PROCESSSTART_NAME, \"ADEXS.TaskProcessor.exe\");\n\t\tprivate const string PROCESSSTART_NAME = \"PROCESSSTART_NAME\";\n\t\tprivate string _typeName;\n\t\tprivate readonly TaskTypes _taskType;\n\t\tprivate bool _standAlone;\n\n\t\tprivate readonly IContainer _container;         // optionally injected DI container\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate readonly Func<U> _createProcessor;\n\t\tprivate int _fetchMod;\n\n\t\t[ThreadStatic]\n\t\tprivate static int _errorCount = 0;\n\n\t\tpublic override string Name => base.Name + TypeName;\n\n\t\t[EventSource(\"Workers\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly PropertyBagEventSource _workersEventSource = new PropertyBagEventSource();\n\n\t\t[Counter(\"Workers Count\", \"CLM.DispatchedWorker\", MeasureProperty = \"Count\", InstanceProperty = \"Description\")]\n\t\t[EventSource(\"Workers Count\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly CountEventSource _workersCountEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\")]\n\t\t[Counter(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\", InstanceProperty = \"Description\")]\n\t\tprivate static ExceptionEventSource _workerLoggingExceptionEventSource = new ExceptionEventSource();\n\n\t\tstatic DispatchedWorker()\n\t\t{\n\t\t\t// Kazmon emits from a generic type do not work without this call\n\t\t\tMonitoringRuntime.RegisterGenericType(typeof(DispatchedWorker<T, U>));\n\t\t}\n\n\t\tpublic string TypeName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\t_typeName ??= _taskType.ToString();\n\t\t\t\treturn _typeName;\n\t\t\t}\n\t\t}\n\n\t\tpublic IMessageQueueWrapperFactory MessageQueueWrapperFactory { get; set; }\n\n\t\t/// <summary>\n\t\t/// Legacy Constructor -- delegates to the new overload; passes DI container extracted from ServiceLocator.\n\t\t/// This method will be deprecated in the future -- prefer the (IServicedComponent, IContainer) overload.\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this dispatched worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\tpublic DispatchedWorker(IServicedComponent component, TaskTypes taskType, IWatchedSingletonConfig<ISiteConfig> siteConfig) : this(component, taskType, ServiceLocator.Container, Activator.CreateInstance<U>, siteConfig)\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor overload that accepts a DI container (stepping stone to moving away from SL pattern).\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\t/// <param name=\"container\">the DI container for service discovery and IOC</param>\n\t\tinternal DispatchedWorker(IServicedComponent component, TaskTypes taskType, IContainer container, Func<U> processorFactory, IWatchedSingletonConfig<ISiteConfig> siteConfig) : base(component)\n\t\t{\n\t\t\t_container = container;\n\t\t\t_createProcessor = processorFactory ?? (() => new U());\n\t\t\tServiceLocator.BuildUp(this);\n\t\t\t_taskType = taskType;\n\t\t\t//This is here to prevent a regression following ATL-81324\n\t\t\tif (TypeName != typeof(T).Name)\n\t\t\t\tthrow new ArgumentException($\"Failed to initialize DispatchedWorker: Task Name ({typeof(T).Name}) must match task type ({TypeName})\");\n\t\t\t_waitOnNoItems = false;\n\t\t\t_standAlone = Configuration.GetBooleanAppSetting(TypeName + DESIRED_STAND_ALONE, false);\n\t\t\tif (_standAlone) _log.DebugNoPII($\"Worker running in StandAlone mode for {TypeName}\");\n\t\t\t_siteConfig = siteConfig;\n\t\t}\n\n\t\tprivate ProcessTaskResult RunExternalTaskProcessor(ProcessTaskRequest taskRequest)\n\t\t{\n\t\t\tvar accountId = taskRequest.Task.AccountId;\n\t\t\tbool useAnonymousPipes = TasksManagementFeatureFlags.UseAnonymousPipeForExternalTaskProcessors &&\n\t\t\t                         Configuration.GetBooleanAppSetting(\n\t\t\t\t                         $\"{accountId}_UseAnonymousPipeForExternalTaskProcessors\", true);\n\t\t\t_log.InfoNoPII(useAnonymousPipes\n\t\t\t\t? \"Worker using Anonymous Pipes for Request and Results\"\n\t\t\t\t: \"Worker using Temp Files for Request and Results\");\n\t\t\tExternalTaskWorker externalTaskWorker = ExternalTaskWorkerFactory.GetExternalTaskWorker(useAnonymousPipes);\n\t\t\treturn externalTaskWorker.RunExternalProcessor(taskRequest,TASKPROCESSOR);\n\t\t}\n\n\t\tprotected override int MaxQueueDepth()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_WorkerMaxQueueDepth\", Configuration.GetInt32AppSetting(TypeName + WORKER_MAXSET, WORKER_MAXSET_DEFAULT)) * DesiredWorkerCount();\n\t\t}\n\n\t\tprotected override IList<T> Fetch(int fetchCount)\n\t\t{\n\t\t\tList<T> tasks = new List<T>();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPeriodicPulse();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not pulse for ''{TypeName}''.\", ex);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttasks = FetchFromQueues(fetchCount);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not load the items for the queue: {TypeName}\", ex);\n\t\t\t\t_lastFetchDate = DateTime.UtcNow;\n\t\t\t}\n\n\t\t\tAttemptRestorePropertiesFromPayload(tasks);\n\n\t\t\treturn tasks;\n\t\t}\n\n\t\tprivate List<T> FetchFromQueues(int fetchCount)\n\t\t{\n\t\t\tvar queuePaths = DefaultQueue.GetWorkerMqPaths(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\n\t\t\t// keep incrementing to pull from a different queue on each fetch, fetching from all queues seems to have an adverse effect on the channels\n\t\t\t_fetchMod %= queuePaths.Length;\n\t\t\tvar queuePath = queuePaths[_fetchMod];\n\t\t\t_fetchMod++;\n\n\t\t\treturn FetchSingleQueue(fetchCount, queuePath);\n\t\t}\n\n\t\tprivate List<T> FetchSingleQueue(int fetchCount, string path)\n\t\t{\n\t\t\tbool isMainPath = path == DefaultQueue.GetWorkerMqPath(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\t\t\tint waitTime = isMainPath ? TaskUtilities.InitialReceiveWaitMS(TypeName) : Configuration.GetInt32AppSetting(\"InitialReceiveWaitAdditionalQueueMS\", 20);\n\t\t\tusing (IMessageQueueWrapper pdfMQ = MessageQueueWrapperFactory.CreateReceiveInstance(Configuration.GetStringAppSetting(TypeName + \"_WorkerMQPath\", path)))\n\t\t\t{\n\t\t\t\treturn pdfMQ.ReceiveMultiple<T>(waitTime, MQApplicationSettings.DefaultExtraReceiveWaitMS, fetchCount);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Restore the task type properties from the payload. This will only live temporarily as we move\n\t\t/// all tasks toward using the CommonTask payload. If we fail to restore from properties we should log to kazmon\n\t\t/// but we should not not block tasks from getting processed. We are also logging when we find a task\n\t\t/// without a payload set.\n\t\t/// </summary>\n\t\tprivate void AttemptRestorePropertiesFromPayload(List<T> tasks)\n\t\t{\n\t\t\t// App Setting to disable this behavior just in case of issues\n\t\t\tvar restoreFromPayload = Configuration.GetBooleanAppSetting($\"RestoreTaskFromPayload_All\", true) &&\n\t\t\t\tConfiguration.GetBooleanAppSetting($\"RestoreTaskFromPayload_{TypeName}\", true);\n\n\t\t\tforeach (var task in tasks)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (task is CommonTask cTask)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string.IsNullOrEmpty(cTask.Payload))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Log to kazmon to ensure that we don't miss any tasks\n\t\t\t\t\t\t\tCommonTaskPayloadHelper.CommonTaskPayloadMissingEventSource.Emit(1, cTask.Label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (restoreFromPayload)\n\t\t\t\t\t\t\t\tcTask.RestorePropertiesFromPayload();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tCommonTaskPayloadHelper.PayloadRestoreExceptionEventSource.Emit(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate QueueItemType _lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\tpublic override void AdjustWorkers()\n\t\t{\n\t\t\tbase.AdjustWorkers();\n\n\t\t\tint desiredWorkerCount = DesiredWorkerCount(out double multiplier);\n\t\t\tSetEnabled(desiredWorkerCount > 0);\n\t\t\tQueueItemType currentQueueStatus = (desiredWorkerCount > 0) ? QueueItemType.QueueStarted : QueueItemType.QueueStopped;\n\t\t\tif (currentQueueStatus == _lastSentQueueStatus) return;\n\n\t\t\tEmitWorkerConfiguration(currentQueueStatus, desiredWorkerCount, multiplier);\n\t\t\tstring adminQueuePath = \"Unset\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tT startTask = new T\n\t\t\t\t{\n\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\tQueueItemType = currentQueueStatus,\n\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t};\n\n\t\t\t\tif (!_standAlone)\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueuePath = GetAdminQueuePath(machine);\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(adminQueuePath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(startTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = currentQueueStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:AdjustWorkers - Could not contact the administration queue: \" + adminQueuePath, ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitWorkerConfiguration(QueueItemType queueItemtype, int desiredWorkerCount, double multiplier)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_workersCountEventSource.Emit(desiredWorkerCount, TypeName);\n\n\t\t\t\tusing (var propertyBag = _workersEventSource.CreateEventPropertyBag(queueItemtype.ToString()))\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TaskType\", TypeName);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"DesiredWorkerCount\", desiredWorkerCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"Multiplier\", multiplier.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ProcessorCount\", Environment.ProcessorCount.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_workerLoggingExceptionEventSource.Emit(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetMachineName() => System.Net.Dns.GetHostName();\n\t\tprivate string GetTaskTypeName() => typeof(T).FullName;\n\n\t\tprivate static int _queueStateTouchIntervalMin = 60;\n\t\tprivate DateTime _nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\n\t\tprotected virtual void PeriodicPulse()\n\t\t{\n\t\t\tif (_nextStateTouchTime < DateTime.UtcNow)\n\t\t\t{\n\t\t\t\tQueueStatePersistence.AuthenticationInstance.Touch(GetMachineName(), GetTaskTypeName());\n\t\t\t\t_nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Blast the local queue back to the dispatcher so that it can be\n\t\t/// dispatched to another worker.\n\t\t///\n\t\t/// Also sends a disable me message\n\t\t/// </summary>\n\t\tpublic override void Stop()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//Try to do a prelim kill before the stop of the workers\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch\n\t\t\t{\n\t\t\t\t_log.DebugNoPII(\"Didn't kill processes first time\");\n\t\t\t}\n\n\t\t\tbase.Stop();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSetEnabled(false);\n\t\t\t\tif (!_standAlone && (_lastSentQueueStatus != QueueItemType.QueueStopped))\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tT stopTask = new T\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\t\t\tQueueItemType = QueueItemType.QueueStopped,\n\t\t\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(machine)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(stopTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\t\t\t}\n\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:Stop - Exception generated during stop:\", ex);\n\t\t\t}\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStopped, 0, 0);\n\t\t}\n\n\t\tprivate void KillTaskProcessors()\n\t\t{\n\t\t\tvar nestedContainer = CreateNestedContainer(null);\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);  // necessary to determine if processor would run out-of-process\n\t\t\t// attempt to kill any active out-of-process processors\n\t\t\tif (processor.RunInSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t\t\tstring processName = Path.GetFileNameWithoutExtension(TASKPROCESSOR);\n\t\t\t\tProcess[] tokill = System.Diagnostics.Process.GetProcessesByName(processName);\n\t\t\t\tif (tokill.Length > 0)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"Killing {processName} processes.\");\n\t\t\t\t\tforeach (Process p in tokill)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Failed to kill process with pid: {p.Id}\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void SetEnabled(bool enable)\n\t\t{\n\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\t\t\tbool alreadySet = false;\n\t\t\tstring taskTypeName = GetTaskTypeName();\n\t\t\t_log.DebugNoPII($\"Task type: {taskTypeName}, enable set to {enable}\");\n\n\t\t\tforeach (QueueState state in QueueStatePersistence.AuthenticationInstance.LoadAll())\n\t\t\t{\n\t\t\t\tif (state.MachineName.Equals(GetMachineName(), StringComparison.InvariantCultureIgnoreCase)\n\t\t\t\t\t&& state.TaskTypeName == taskTypeName)\n\t\t\t\t{\n\t\t\t\t\tif (enable)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine already exists for task type {taskTypeName}, attempting to enable it\");\n\t\t\t\t\t\tRegisterQueueState(state);\n\t\t\t\t\t\talreadySet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine exists for task type {taskTypeName}, attempting to disable it\");\n\t\t\t\t\t\tstate.Enabled = false;\n\t\t\t\t\t\tQueueStatePersistence.AuthenticationInstance.Save(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (enable && !alreadySet)\n\t\t\t{\n\t\t\t\t// must be a new entry in the queuestate table\n\t\t\t\t_log.DebugNoPII($\"Machine does not already exist for task type {taskTypeName}, attempting to create it\");\n\t\t\t\tRegisterQueueState(null);\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// This will either create the queuestate or update\n\t\t/// it as enabled.\n\t\t/// </summary>\n\t\tprivate void RegisterQueueState(QueueState queueState)\n\t\t{\n\t\t\tif (queueState == null)\n\t\t\t{\n\t\t\t\tqueueState = new QueueState();\n\t\t\t\tType taskType = typeof(T);\n\t\t\t\tqueueState.MachineName = GetMachineName();\n\t\t\t\tqueueState.TaskAssemblyName = taskType.Assembly.GetName().Name;\n\t\t\t\tqueueState.TaskTypeName = GetTaskTypeName();\n\t\t\t\t_log.DebugNoPII($\"Creating new entry in QueueState for tasktype: {queueState.TaskTypeName}\");\n\t\t\t}\n\n\t\t\tqueueState.Enabled = true;\n\t\t\tqueueState.WorkerCount = DesiredWorkerCount(out double multiplier);\n\n\t\t\t_log.DebugNoPII($\"Saving QueueState for task type: {queueState.TaskTypeName} with properties - machine name: {queueState.MachineName},\" +\n\t\t\t\t$\"assembly name: {queueState.TaskAssemblyName} enabled: {queueState.Enabled}, worker count: {queueState.WorkerCount}\");\n\n\t\t\tQueueStatePersistence.AuthenticationInstance.Save(queueState);\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStarted, queueState.WorkerCount, multiplier);\n\t\t}\n\n\t\tprotected override TaskResult Process(T task, out string message)\n\t\t{\n\t\t\tmessage = null;\n\n\t\t\tAtlasContext.Current.AccountId = task.AccountId;\n\t\t\tAtlasContext.Current.TransactionId = task.CorrelationId;\n\t\t\tif (task is IUserTask usrTask)\n\t\t\t{\n\t\t\t\tAtlasContext.Current.UserAccountUid = usrTask.UserAccountUid;\n\t\t\t}\n\n\t\t\tGuid corrToken;\n\t\t\tGuid.TryParse(task.CorrelationId, out corrToken);\n\n\t\t\tusing var activity = StartActivity(task, corrToken);\n\n\t\t\tstring telemetryLabel = task.Label;\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\tusing (var logger = new TaskServiceRequestEventLogger(corrToken, telemetryLabel))\n\t\t\t{\n\t\t\t\t// introduces request-scoped container for user context state (and any other future per-request DI state)\n\t\t\t\tusing var nestedContainer = CreateNestedContainer(AtlasContext.Current);\n\n\t\t\t\t// The DataPoint enum is defined in DocuSign sources. Trying to use some, hopefully with close enough semantics.\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, task.AccountId);\n\t\t\t\tServiceContext.Log(DataPoint.QueueItemId, task.UniqueId);\n\t\t\t\tServiceContext.Log(DataPoint.TimeQueued, $\"{task.CreatedDate:yyyy-MM-dd HH:mm:ss.fff}\");\n\t\t\t\tif (Guid.Empty != AtlasContext.Current.UserAccountUid)\n\t\t\t\t{\n\t\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The nugget inside the monitoring wrapper.\n\t\t\t\t\tTaskResult taskResult = ProcessTask(task, nestedContainer, out message, activity);\n\n\t\t\t\t\tServiceContext.Log(DataPoint.ApiStatus, $\"{taskResult}\");\n\t\t\t\t\tlogger.Success = (taskResult != TaskResult.Failure);\n\t\t\t\t\tactivity?.SetStatusFromTask(taskResult);\n\t\t\t\t\treturn taskResult;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tex.Trace().Report();\n\t\t\t\t\tthrow;\n \t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (!logger.Success && null != message)\n\t\t\t\t\t{\n\t\t\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate TaskResult ProcessTask(T task, IContainer nestedContainer, out string message, Activity activity)\n\t\t{\n\t\t\tProcessTaskResult result = new ProcessTaskResult() { Message = \"Context Set\" };\n\n\t\t\tif (TaskUtilities.CheckSuspendedTaskTypeForAccount(TypeName, task.AccountId))\n\t\t\t{\n\t\t\t\tmessage = $\"task failed because Aid {task.AccountId} is in the suspended account list for {TypeName}\";\n\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\ttask.ErrorCount = int.MaxValue;\n\t\t\t\treturn TaskResult.Failure;\n\t\t\t}\n\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);\n\n\t\t\tAtlasContext.Current.ActionType = processor.ActionType;\n\n\t\t\tif (processor.RunInSeparateProcess && !processor.HandleSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t \t\tProcessTaskRequest taskRequest = new ProcessTaskRequest()\n\t\t\t\t{\n\t\t\t\t\tAccountId = AtlasContext.Current.AccountId,\n\t\t\t\t\tUserAccountUid = AtlasContext.Current.UserAccountUid,\n\t\t\t\t\tActionType = AtlasContext.Current.ActionType,\n\t\t\t\t\tProcessorTypeName = processor.GetType().AssemblyQualifiedName,\n\t\t\t\t\tTask = task,\n\t\t\t\t\tTaskType = _taskType,\n\t\t\t\t\tCorrelationToken = MonitoringContext.CorrelationToken ?? Guid.Empty\n\t\t\t\t};\n\t\t\t\tresult = RunExternalTaskProcessor(taskRequest);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprocessor.Task = task;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tprocessor.PreProcess();\n\t\t\t\t\tresult = processor.ProcessTask();\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tprocessor.PostProcess();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = result.Message;\n\n\t\t\tactivity?.SetQueueTaskResultTags(task, new MqWorkers.DispatchedWorker.ProcessTaskResult { Message = message });\n\n\t\t\treturn result.TaskResult;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an instance of the ITaskProcessor that should be used when processing a request.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This method takes into account whether we are using a scoped DI container, and if so, will\n\t\t/// attempt to get the task processor from there to ensure that other scoped DI services (eg user context)\n\t\t/// are also correctly set up. If the supplied `container` parameter is null we create a non-scoped\n\t\t/// processor instance, otherwise we demand it from the container (which may throw if none is registered).\n\t\t/// </remarks>\n\t\t/// <param name=\"container\">Optional (nullable) DI container from which we acquire scoped processors</param>\n\t\t/// <returns>An instance of ITaskProcessor{T} that can process the task.</returns>\n\t\tprivate U CreateTaskProcessor(IContainer container)\n\t\t{\n\t\t\t// NOTE: If we have a nested DI container, defer to it for the ITaskProcessor instance.\n\t\t\t//       If there is no nested container, or it doesn't have a ITaskProcessor registered,\n\t\t\t//       instantiate one one locally.\n\t\t\treturn container?.GetInstance<U>() ?? _createProcessor.Invoke();\n\t\t}\n\n\t\tprotected override void UpdateFailure(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//this will requeue it if needed\n\t\t\t\ttask.QueueItemType = QueueItemType.Ack;\n\t\t\t}, () =>\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Again errors should pause the movement of the items.\n\t\t\t\t * For this worker.\n\t\t\t\t */\n\t\t\t\tif (_errorCount++ % Configuration.GetInt32AppSetting(\"ErrorCountSleepMod\", 100) == 0)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(SleepMilliSeconds());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateUnlock(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//task will requeue it\n\t\t\t\ttask.QueueItemType = QueueItemType.Task;\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateSuccess(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.QueueItemType = QueueItemType.Completed;\n\t\t\t});\n\t\t}\n\n\t\tprivate void SendTaskStatusUpdate(T task, Action beforeSend, Action afterSend = null)\n\t\t{\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\t{\n\t\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\n\t\t\t\tbeforeSend();\n\n\t\t\t\tstring sendMachine = task.SendMachine; // Send() changes the SendMachine property, so store it here in case we need to restore it after an exception.\n\n\t\t\t\tusing (IMessageQueueWrapper adminQueue = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(task.SendMachine)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueue.Send(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Detected IOException.  Will retry once.\", ioe);\n\n\t\t\t\t\t\tadminQueue.ReSend(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Restore original SendMachine, for the sake of the UpdateFailure() call from AbstractServiceQueue.\n\t\t\t\t\t\ttask.SendMachine = sendMachine;\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (afterSend != null)\n\t\t\t\t{\n\t\t\t\t\tafterSend();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Crate a nested DI container for the user context (and potentially other request-scoped DI state).\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// Introduced as part of ATL-72998 to add support for feature flag integration, which requires access to\n\t\t/// the request-scoped Account/User identity for flag resolution decisions.\n\t\t/// </remarks>\n\t\t/// <param name=\"atlasContext\">Atlas request context for this request/task</param>\n\t\t/// <returns>Disposable DI container for this request-scoped state</returns>\n\t\tprivate IContainer CreateNestedContainer(IAtlasContext atlasContext)\n\t\t{\n\t\t\tvar nestedContainer = _container.GetNestedContainer();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (atlasContext != null)\n\t\t\t\t{\n\t\t\t\t\tvar userContextSetter = nestedContainer.TryGetInstance<IUserContextSetter>();\n\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tuserContextSetter.AccountId = atlasContext.AccountId;\n\t\t\t\t\t\tuserContextSetter.UserId = atlasContext.UserAccountUid; // this may be null, but that's ok\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Should we have a specific OT telemetry event for this condition? It's most like incorrectly configured DI setup, but may not be a defect.\n\t\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire IUserContextSetter - transactionId {atlasContext.TransactionId} will proceed without scoped user context.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar taskContextSetter = nestedContainer.TryGetInstance<ITaskTypeContextSetter>();\n\n\t\t\t\tif (taskContextSetter != null)\n\t\t\t\t{\n\t\t\t\t\ttaskContextSetter.TaskType = _taskType;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire ITaskTypeContextSetter - {TypeName} will proceed without scoped task type context.\");\n\t\t\t\t}\n\n\t\t\t\treturn nestedContainer;\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\tnestedContainer?.Dispose();  // avoid leaking nested container\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic virtual int StandardSleepSeconds => 5;\n\t\tprotected override int SleepSeconds()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_SleepSeconds\", StandardSleepSeconds);\n\t\t}\n\n\t\tpublic virtual int StandardWorkerCount => DEFAULT_WORKER_COUNT;\n\n\t\tpublic override int DesiredWorkerCount()\n\t\t{\n\t\t\treturn DesiredWorkerCount(out _);\n\t\t}\n\n\t\tprivate int DesiredWorkerCount(out double multiplier)\n\t\t{\n\t\t\tmultiplier = 0;\n\t\t\tint count = -1;\n\t\t\tif (IsOneConfigEnabledForWorkerCount())\n\t\t\t{\n\t\t\t\tvar mqTasksconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IMqTasksConfig>>()?.Value;\n\t\t\t\tvar taskConfigs = mqTasksconfigs?.TaskConfigs;\n\t\t\t\tif (taskConfigs != null && taskConfigs.TryGetValue(TypeName, out var taskConfig))\n\t\t\t\t{\n\t\t\t\t\tcount = taskConfig.WorkerCount;\n\t\t\t\t\tmultiplier = taskConfig.WorkerMultiplier;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Failed to retrieve task configuration from INI file for TaskName: {TypeName}. Falling back to legacy processing.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count < 0)\n\t\t\t{\n\t\t\t\t// Rely on appsetting if oneConfig is disabled or if it cannot retrive from oneconfig\n\t\t\t\tcount = Configuration.GetInt32AppSetting(TypeName + DESIRED_WORKER_COUNT, StandardWorkerCount);\n\t\t\t\tmultiplier = Configuration.GetDoubleAppSetting(TypeName + DESIRED_WORKER_MULTIPLIER, DEAFULT_CORE_TO_WORKER_MULTIPLIER);\n\t\t\t}\n\n\t\t\t// we still want to be able to force the count to zero in order to turn off a worker group effectively\n\t\t\t// let's check the worker count based on the number of logical cores and a configured multiplier\n\t\t\tif (count != 0 && multiplier > 0)\n\t\t\t{\n\t\t\t\t// use the number of logical cores and a multiplier to determine a good worker count number.\n\t\t\t\tint numCores = Environment.ProcessorCount;\n\t\t\t\tcount = Math.Max((int)(numCores * multiplier), 1);  // we really never want a > 0 multiplier to cause a zero worker count\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tprivate bool IsOneConfigEnabledForWorkerCount()\n\t\t{\n\t\t\tbool isOneConfigEnabled = false;\n\t\t\tif(ConfigWrapper.UseOneConfigMqTasksConfig)\n\t\t\t{\n\t\t\t\tvar appconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOneConfigMqTasks_\" + appconfigs?.AppName, true))\n\t\t\t\t{\n\t\t\t\t\tisOneConfigEnabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isOneConfigEnabled;\n\t\t}\n\n\t\tprivate IEnumerable<string> DispatcherMachines()\n\t\t{\n\t\t\treturn StringUtil.Split('|', Configuration.GetStringAppSetting(TypeName + TASK_DISPATCHERS, Configuration.GetStringAppSetting(DEFAULT_TASK_DISPATCHERS, GetMachineName())));\n\t\t}\n\n\t\tprivate string GetAdminQueuePath(string machine)\n\t\t{\n\t\t\treturn string.Format(Configuration.GetStringAppSetting(TypeName + \"_EventMQPathFormat\", DefaultQueue.GetAdminMqPathFormat(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName))), machine ?? GetMachineName());\n\t\t}\n\n\t\tprivate Activity StartActivity(T task, Guid correlationToken) =>\n\t\t\tServiceInstrumentation.ActivitySource\n\t\t\t\t?.StartActivity(\n\t\t\t\t\ttask.Label ?? $\"{nameof(ADEXS.Services.MessageWorkerService)}\",\n\t\t\t\t\tActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
      "content": "#if NET\n#nullable enable\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService\n{\n    private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore\n#endif\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Threading;\nusing System.Web;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.RequestHeaders;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.MVC;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\nusing log4net;\n\nnamespace ADEXS.Web.Common.Profile\n{\n\tpublic class ProfileModule : IHttpModule\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(\"ADEXS.Web.Common\");\n\n\n\t\tprivate PerformanceLog _performanceLog;\n\t\tprivate IDisposable _logContext;\n\n\t\t[EventSource(\"Session Size\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Size\", \"CLM.SessionState\", DisplayUnit = CounterUnit.kilobytes,\n\t\t\tRanges = new double[10] { 1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 20000 },\n\t\t\tMeasureProperty = \"Count\", InstanceProperty = \"Description\", ShowVolume = true)]\n\t\tprivate static readonly CountEventSource _sessionSizeEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Session Serialization Timing\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Serialization Timing\", \"CLM.SessionState\", DisplayUnit = CounterUnit.milliseconds,\n\t\t\tRanges = new double[10] { 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t\tMeasureProperty = \"Duration\", SuccessProperty = \"Success\", InstanceProperty = \"Description\")]\n\t\tprivate static readonly TimingEventSource _sessionSerializationTimingEventSource = new TimingEventSource();\n\n\t\t[EventSource(\"Large Session\", \"CLM.SessionState\")]\n\t\t[Counter(\"Large Session\", \"CLM.SessionState\")]\n\t\tprivate static readonly PropertyBagEventSource _largeSessionEventSource = new PropertyBagEventSource();\n\n\t\t/// <summary>\n\t\t/// You will need to configure this module in the web.config file of your\n\t\t/// web and register it with IIS before being able to use it. For more information\n\t\t/// see the following link: http://go.microsoft.com/?linkid=8101007\n\t\t/// </summary>\n\t\t#region IHttpModule Members\n\n\t\tpublic void Dispose()\n\t\t{\n\t\t\t//clean-up code here.\n\t\t}\n\n\t\tpublic void Init(HttpApplication context)\n\t\t{\n\t\t\t// Below is an example of how you can handle LogRequest event and provide\n\t\t\t// custom logging implementation for it\n\t\t\tcontext.BeginRequest += OnBeginRequest;\n\t\t\tcontext.PreRequestHandlerExecute += OnPreRequestHandlerExecute;\n\t\t\tcontext.PostRequestHandlerExecute += OnPostRequestHandlerExecute;\n\t\t\tcontext.EndRequest += OnEndRequest;\n\t\t\tcontext.Error += OnError;\n\t\t}\n\n\t\t/* IIS request life cycle BeginRequest ->  AuthenticateRequest -> AuthorizeRequest -> ResolveRequestCache -> AcquireRequestState ->\n\t\t * PreRequestHandlerExecute -> ProcessRequest -> PostRequestHandlerExecute -> ReleaseRequestState -> UpdateRequestCache -> EndRequest */\n\n\t\tprivate void OnBeginRequest(object sender, EventArgs e)\n\t\t{\n\t\t\tif (_performanceLog == null)\n\t\t\t\t_performanceLog = new PerformanceLog();\n\n\t\t\t_performanceLog.Start(HttpContext.Current.Request);\n\t\t}\n\n\t\tprivate void OnPostRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(HttpContext.Current);\n\t\t\tLogSessionSize(HttpContext.Current?.Session);\n\t\t\t_performanceLog.SetSession(HttpContext.Current?.Session);\n\t\t}\n\n\t\tprivate void OnPreRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tHttpContext context = HttpContext.Current;\n\t\t\t\tAtlasContext.Reset();\n\n\t\t\t\t// MonitoringContext is initialized in the ScmLogRequestHttpModule module on\n\t\t\t\t// BeginRequest. This runs before this event handler. By this time the\n\t\t\t\t// CorrelationToken is set. Including getting it from the X-DocuSign-CorrelationToken header if available.\n\t\t\t\tGuid corrId = MonitoringContext.CorrelationToken ?? Guid.Empty;\n\t\t\t\tif (Guid.Empty == corrId)\n\t\t\t\t{\n\t\t\t\t\t// Only in extremely unlikely scenario\n\t\t\t\t\tGuid.TryParse(AtlasContext.Current.TransactionId, out corrId);\n\t\t\t\t\tMonitoringContext.CorrelationToken = corrId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAtlasContext.Current.TransactionId = corrId.ToString();\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t// Now we'll have TransactionId, CorrelationId, and CorrelationToken all set to the same value. Three is a crowd?...\n\t\t\t\t_logContext = LogContext.Set(AtlasContext.Current.TransactionId);\n\n\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"ServiceLocator:\\n{ServiceLocator.Container.WhatDoIHave(typeof(ILogContextStore))}\");\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Reset();\n\t\t\t\tif (context != null)\n\t\t\t\t{\n\t\t\t\t\tif (context.Request != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tAtlasContext.Current.ClientIpAddress = IPAddressUtil.FetchIpAddress(context.Request);\n\t\t\t\t\t\tAtlasContext.Current.ClientUserAgent = context.Request.UserAgent;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Similar code exists for web services, which don't use session.\n\t\t\t\t\t// That code is in SetContextIds\n\t\t\t\t\tHttpSessionState session = context.Session;\n\t\t\t\t\tif (session != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tUserAccount user = CommonData.CurrentUser;\n\t\t\t\t\t\tif (user != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAtlasContext.Current.AccountId = user.AccountId;\n\t\t\t\t\t\t\tAtlasContext.Current.UserAccountUid = user.Uid;\n\t\t\t\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = user.AccountId == int.MinValue ? \"null\" : user.AccountId.ToString();\n\n\t\t\t\t\t\t\tvar userContextSetter = AtlasWebDependencyResolver.ScopedInstance?.GetService<IUserContextSetter>();\n\t\t\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"The user's AccountId: {user.AccountId} for user id: {user.Uid} in OnPreRequestHandlerExecute.\");\n\t\t\t\t\t\t\t\t// ensure that DI consumers have access the user/account context\n\t\t\t\t\t\t\t\tuserContextSetter.AccountId = user.AccountId;\n\t\t\t\t\t\t\t\tuserContextSetter.UserId = user.Uid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII(\"No UserContextSetter is available - account context propagation will not work.\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar docusignAccountId = CommonData.DocuSignAccountId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignAccountId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignAccountId = docusignAccountId;\n\n\t\t\t\t\t\t\tvar docusignUserId = CommonData.DocuSignUserId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignUserId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignUserId = docusignUserId;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnPreRequestHandlerExecute in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Measuring session size ATL-56207\n\t\t/// </summary>\n\t\tprivate static void LogSessionSize(HttpSessionState session)\n\t\t{\n\t\t\tif (session == null || !Configuration.GetBooleanAppSetting(\"EnableSessionSizeLogging\", false))\n\t\t\t\treturn;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong totalSessionBytes = 0;\n\t\t\t\tstring largestItemKey = string.Empty;\n\t\t\t\tlong largestItemSizeBytes = 0;\n\t\t\t\tint itemCount = 0;\n\n\t\t\t\tusing (OperationTimer sessionSerializationTimer = _sessionSerializationTimingEventSource.CreateTimer())\n\t\t\t\t{\n\t\t\t\t\tBinaryFormatter formatter = new BinaryFormatter();\n\t\t\t\t\tforeach (var sessionKey in session)\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (Stream s = new MemoryStream())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring key = (string)sessionKey;\n\t\t\t\t\t\t\tvar item = session[key];\n\t\t\t\t\t\t\tif (item != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titemCount++;\n\n\t\t\t\t\t\t\t\tformatter.Serialize(s, item);\n\n\t\t\t\t\t\t\t\tif (s.Length > largestItemSizeBytes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlargestItemKey = key;\n\t\t\t\t\t\t\t\t\tlargestItemSizeBytes = s.Length;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttotalSessionBytes += s.Length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsessionSerializationTimer.SetResult(true);\n\t\t\t\t}\n\n\t\t\t\t_sessionSizeEventSource.Emit(totalSessionBytes);\n\n\t\t\t\tif (totalSessionBytes > Configuration.GetInt64AppSetting(\"LargeSessionSizeLoggingThreshold\", 1000000)) // default to 1MB\n\t\t\t\t{\n\t\t\t\t\tstring aid = AtlasContext.Current?.AccountId.ToString();\n\t\t\t\t\tstring userId = AtlasContext.Current?.UserAccountUid.ToString();\n\n\t\t\t\t\tusing (var propertyBag = _largeSessionEventSource.CreateEventPropertyBag())\n\t\t\t\t\t{\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"AccountId\", aid);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"UserAccountUid\", userId);\n\n\t\t\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionId\", session.SessionID);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionSizeInBytes\", totalSessionBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemKey\", largestItemKey);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemSizeInBytes\", largestItemSizeBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"TotalSessionItemCount\", itemCount.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"ThreadId\", Thread.CurrentThread.ManagedThreadId.ToString());\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.InfoNoPII($\"Detected Large SessionState. AccountId {aid} UserAccountUid {userId} SessionId {session.SessionID} SessionSizeInBytes {totalSessionBytes} TotalItemCount {itemCount} Largest Item Key {largestItemKey} ({largestItemSizeBytes})\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Exception occurred while attempting to measure session.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnError(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//get latest exception (top level exception is probably an HTTPUnhandledException which contains underlying exceptions via .InnerException)\n\n\t\t\t\tException baseException = null;\n\t\t\t\tvar lastError = HttpContext.Current.Server.GetLastError();\n\t\t\t\tif (lastError == null)\n\t\t\t\t{\n\t\t\t\t\tvar allError = HttpContext.Current.AllErrors;\n\t\t\t\t\tif (allError != null && allError.Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseException = allError[allError.Length - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseException = lastError.GetBaseException();\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Stop(baseException);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnError in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnEndRequest(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (_performanceLog != null)\n\t\t\t\t{\n\t\t\t\t\t_performanceLog.Stop();\n\t\t\t\t\t_performanceLog.Dispose();\n\t\t\t\t\t_performanceLog = null;\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t_logContext = null;\n\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = \"null\";\n\n\t\t\t\t// we are no longer looking for outstanding DB transactions here.\n\t\t\t\t// because the module does not have to run in the same thread as the request handler\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnEndRequest in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAtlasContext.Current.CacheClient.FlushCache();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not clear the user settings on the thread for the request.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\t}\n}\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/Middlewares/LogAsyncRequestHttpMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.API.Allocation.Telemetry;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.API.Allocation.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.API.Allocation\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Activities.HumanActivities;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.ActivityProperties;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.ExpressionService.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Config;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\nusing ADEXS.WINS.Interfaces;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\n\nusing Platform.Common;\n\nusing SCMAppenders;\n\nusing static ADEXS.Atlas.Workflow.Activities.Handlers.InstanceHandler;\n\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing InstanceVariable = ADEXS.Core.Domain.Model.Workflow.InstanceVariable;\nusing LoggingHelper = ADEXS.Atlas.Workflow.Activities.Infrastructure.LoggingHelper;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing UserAccount = ADEXS.Core.Domain.Model.UserAccount;\n\nnamespace ADEXS.WINS.Engine\n{\n\t/// <summary>\n\t/// An instance of a workflow -- a specific example of a definition.\n\t/// This class contains methods for controlling it, but all such calls should actually be fed through\n\t/// WorkflowManager so they can be queued, etc.\n\t/// </summary>\n\tpublic class WorkflowInstance : IWINSControlInstance\n    {\n        public const int SQL_SEVERITY_LEVEL_TRANSIENT = 12;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowInstance));\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IInstanceVariableGovernance _instanceVariableGovernance;\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepository;\n\t\tprivate IGovernor _governor;\n\t\tprivate IInstanceHandler _instanceHandler;\n\t\tprivate IServiceInstrumentation _serviceInstrumentation;\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> _workflowClientConfig;\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate ICacheRepository _cacheRepository;\n\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => (_instanceVariableGovernance ?? (_instanceVariableGovernance = ServiceLocator.GetInstance<IInstanceVariableGovernance>()));\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository ?? (_workflowSettingRepository = ServiceLocator.GetInstance<IWorkflowSettingRepository>());\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\t\tprivate IInstanceHandler InstanceHandler => _instanceHandler ?? (_instanceHandler = ServiceLocator.GetInstance<IInstanceHandler>());\n\n\n\t\tprivate IServiceInstrumentation ServiceInstrumentation => _serviceInstrumentation ?? (_serviceInstrumentation = ServiceLocator.GetInstance<IServiceInstrumentation>());\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> WorkflowClientConfig => _workflowClientConfig ?? (_workflowClientConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>());\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> SiteConfig => _siteConfig ?? (_siteConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>());\n\t\tprivate ICacheRepository CacheRepository => _cacheRepository ?? (_cacheRepository = ServiceLocator.GetInstance<ICacheRepository>());\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig ?? (_workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\n\t\t/// <summary>\n\t\t/// Loads (and locks) an existing instance.  Fails if the instance doesn't exist or can't be locked.\n\t\t/// </summary>\n\t\tpublic static WorkflowInstance LoadExisting(int accountId, Guid instanceUid, IWINSDataStore data)\n        {\n\t        DateTime lockExpirationDate;\n            InstancePersistence.LockResult lockResult = data.LockInstance(accountId, instanceUid, out lockExpirationDate);\n            switch (lockResult)\n            {\n                case InstancePersistence.LockResult.AlreadyCompleted:\n                    throw new InstanceAlreadyCompletedException(string.Format(\"InstanceUid {0} is already completed\", instanceUid));\n                case InstancePersistence.LockResult.DoesNotExist:\n                    throw new ApplicationException(string.Format(\"Invalid instanceUid {0}\", instanceUid));\n                case InstancePersistence.LockResult.LockedByOther:\n                    throw new InstanceLockedException(string.Format(\"InstanceUid {0} is locked by another process\", instanceUid));\n                case InstancePersistence.LockResult.Locked:\n                    // This is our success condition\n                    break;\n                default:\n                    throw new ApplicationException(string.Format(\"Unhandled lockResult for instanceUid {0}: {1}\", instanceUid, lockResult));\n            }\n            Instance instance = data.LoadInstanceByUid(accountId, Constants.WorkflowUser, instanceUid);\n            if (instance == null) throw new ApplicationException(string.Format(\"Failed to load workflow instanceUid {1} for account {0}.\", accountId, instanceUid));\n\n\t\t\ttry\n            {\n                if (instance.ScopeUid != Guid.Empty)\n                {\n                    Scope scope = ServiceLocator.GetInstance<IDocumentScopeRepository>().GetScopeByUid(accountId, instance.ScopeUid);\n                    if (scope != null)\n                        instance.ScopeName = scope.Name;\n                }\n            }\n            catch (Exception ex)\n            {\n                // the failure to load the scope should not cause the failure to load the instance, log it and move on\n                _log.WarnNoPII(string.Format(\"Could not load the scope '{0}' for workflow instance '{1}'.\", instance.ScopeUid, instanceUid), ex);\n            }\n\n\t\t\tRevision revision = data.LoadRevisionByUid(accountId, Constants.WorkflowUser, instance.RevisionUid);\n            if (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, instance.RevisionUid));\n            // ATL-68146: Populate RevisionCreatedDate here, because LoadInstanceByUid() doesn't populate it.\n            instance.RevisionCreatedDate = revision.CreatedDate;\n            WorkflowMap workflowMap = null;\n            instance.DefinitionUid = revision.DefinitionUid;\n\n\t\t\ttry\n            {\n\t            workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n            }\n            catch (InvalidDesignDefinitionException ex)\n            {\n\t            try\n\t            {\n\t\t            new WorkflowInstance(instance, data).Abort(UserAccount.WorkflowUserAccount(accountId), ex.Message);\n\t            }\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Error aborting workflow instance '{instanceUid}' with invalid definition\", e);\n\t\t\t\t}\n\n\t            throw;\n            }\n\n            var workflowInstance = new WorkflowInstance(instance, workflowMap, data);\n\t        workflowInstance.LockExpirationDate = lockExpirationDate;\n\t        return workflowInstance;\n\n        }\n\n        private readonly IWINSDataStore _data;\n        private readonly WorkflowMap _workflowMap;\n        private Instance _instance;\n\n        // The count of the activities that have been generated by this particular in-memory instance.  This doesn't get persisted anywhere, so is\n        // cleared whenever this WorkflowInstance gets unloaded (eg, when it enters into a Waiting state).\n        // It's use is to detect runaway workflows.\n        public const int MAX_IN_MEMORY_ACTIVITY_COUNT = 5000;\n        private int _inMemoryActivityCount = 0;\n\t\tprivate int _activityExecutionCountEnforcedLimit = 0;\n\t\tprivate Guid _revisionUid = Guid.Empty;\n\t\tprivate Guid _definitionUid = Guid.Empty;\n\t\tprivate DateTime _revisionCreatedDate = DateTime.MinValue;\n\t\tprivate bool _isActivityExecutionLimitReached = false;\n\n\t\tprivate readonly object _lockObject = new object();\n        private readonly IDictionary<Guid, InstanceActivity> _unfinishedActivities = new Dictionary<Guid, InstanceActivity>();\n        private readonly Queue<Event> _queuedControlEvents = new Queue<Event>();\n        private readonly Queue<Event> _queuedEvents = new Queue<Event>();\n\n        private readonly Dictionary<string, ContentDefinition> _contentDefinitions = new Dictionary<string, ContentDefinition>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, InstanceVariable> _variables = new Dictionary<string, InstanceVariable>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, IXmlVariableDefinition> _xmlVariableDefinitions = new Dictionary<string, IXmlVariableDefinition>(StringComparer.InvariantCultureIgnoreCase);\n\n        private readonly TimedLock _lock;\n\n        // Kind of a hack -- this is kept around so that if we end the instance without reaching the End step, we have an activity that we can\n        // log the message to.\n        private Guid _lastActivityUid;\n\n        private WorkflowInstance(Instance instance, IWINSDataStore data)\n        {\n\t        _data = data;\n\t        _lock = new TimedLock(instance.Uid.ToString());\n\t        _instance = instance;\n\t\t\t_revisionUid = _instance.RevisionUid;\n\t\t\t_revisionCreatedDate = instance.RevisionCreatedDate;\n\t        LastProcessDate = DateTime.UtcNow;\n\t\t\t_definitionUid = _instance.DefinitionUid;\n\t\t}\n\n\t\tpublic WorkflowInstance(Instance instance, WorkflowMap workflowMap, IWINSDataStore data) : this(instance, data)\n        {\n            _workflowMap = workflowMap;\n            // Load up any incomplete activities.  This is pointless to do for a new workflow, but it's not expensive either,\n            // so we simply avoid trying to figure that out and simply do it.\n            QueueIncompleteActivities();\n        }\n\n        /// <summary>\n        /// The AccountId this instance is running in.\n        /// </summary>\n        public int AccountId { get { return _instance.AccountId; } }\n\n        public Dictionary<string, ContentDefinition> ContentDefinitions { get { return _contentDefinitions; } }\n\n        public IWINSDataStore DataStore { get { return _data; } }\n\n        public TimedLock ThreadLock { get { return _lock; } }\n\n        /// <summary>\n        /// An in-memory, non-persisted value -- this is used when workers are finding instances to do work on.\n        /// It acts to make the WorkflowManager more FIFO, so that some workflows don't continually get ignored in favor of\n        /// newer work coming in.\n        /// </summary>\n        public DateTime LastProcessDate { get; private set; }\n\n        /// <summary>\n        /// The model Instance object; I didn't call this Instance because I didn't want it confused with a singleton pattern, and because\n        /// I didn't like seeing \"instance.Instance\".\n        /// </summary>\n        public Instance Model { get { return _instance; } }\n\n\t\tpublic DateTime LockExpirationDate { get; set; }\n\n\t\t/// <summary>\n\t\t/// The instance's Uid.  Primary key.\n\t\t/// </summary>\n\t\tpublic Guid Uid { get { return _instance.Uid; } }\n\n        public Dictionary<string, InstanceVariable> Variables { get { return _variables; } }\n\n        public Dictionary<string, IXmlVariableDefinition> XmlVariableDefinitions { get { return _xmlVariableDefinitions; } }\n\n        public Enums.WorkflowStepStatus Status => _instance.Status;\n\n        public bool HasQueuedWork\n        {\n            get { return _queuedEvents.Count > 0 || _queuedControlEvents.Count > 0; }\n        }\n\n        public bool HasUnfinishedActivities\n        {\n            get { return _unfinishedActivities.Count > 0; }\n        }\n\n        public void QueueActivity(InstanceActivity instanceActivity)\n        {\n            lock (_lockObject)\n            {\n                _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            }\n        }\n\n\t\tpublic int ActivityExecutionCount { get; set; }\n\n\t\tpublic int ActivityExecutionCountEnforcedLimit => _activityExecutionCountEnforcedLimit;\n\n\t\tpublic bool IsActivityExecutionLimitReached => _isActivityExecutionLimitReached;\n\n\t\tpublic Guid RevisionUid => _revisionUid;\n\n\t\tpublic Guid DefinitionUid => _definitionUid;\n\n\t\tpublic DateTime RevisionCreatedDate => _revisionCreatedDate;\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\t/// <param name=\"previousActivity\"></param>\n\t\t/// <param name=\"linkName\"></param>\n\t\t/// <param name=\"localContextId\"></param>\n\t\t/// <param name=\"followEmptyPathByDefault\"></param>\n\t\t/// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n\t\tpublic void QueueActivitiesByLink(InstanceActivity previousActivity, string linkName, int localContextId = 0, bool followEmptyPathByDefault = true, bool useLinkName = false)\n        {\n            IEnumerable<WorkflowMap.Link> links;\n            bool found = false;\n            if (_workflowMap.TryGetLinks(previousActivity.Name, linkName, out links))\n            {\n                foreach (WorkflowMap.Link link in links)\n                {\n                    QueueActivityByName(previousActivity, link.ToName, localContextId, linkName, useLinkName);\n                    found = true;\n                }\n            }\n            // If we got no matches, try to go for the default (empty) output.\n            if (followEmptyPathByDefault && !found && !string.IsNullOrEmpty(linkName)) QueueActivitiesByLink(previousActivity, string.Empty, localContextId);\n        }\n\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"previousActivity\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"localContextId\"></param>\n        /// <param name=\"linkName\"></param>\n        /// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n        public void QueueActivityByName(InstanceActivity previousActivity, string name, int localContextId = 0, string linkName = null, bool useLinkName = false)\n        {\n            IWINSActivity activity;\n            if (!_workflowMap.TryGetActivity(name, out activity)) throw new ApplicationException(string.Format(\"InstanceUid {0}: Tried to execute invalid activity '{1}'\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, name)));\n\n            if (localContextId <= 0) localContextId = (previousActivity == null ? int.MinValue : previousActivity.LocalContextId);\n\n            // Create a new activity\n            InstanceActivity instanceActivity = new InstanceActivity\n            {\n                AccountId = _instance.AccountId,\n                InstanceUid = _instance.Uid,\n                Name = name,\n                ActivityTypeName = activity.LegacyElementName(),\n                Status = Enums.WorkflowStepStatus.Pending,\n                InputActivityOutput = useLinkName ? linkName : (previousActivity == null ? string.Empty : previousActivity.Output),\n                InputActivityUid = (previousActivity == null ? Guid.Empty : previousActivity.Uid),\n                LocalContextId = localContextId,\n                IsWinsActivity = true,\n                CreatedDate = DateTime.UtcNow //make sure that the in memory copy has a value\n            };\n\n            try\n            {\n                _data.CreateActivity(instanceActivity);\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorWithPII($\"Failed to queue activity {{0}} for instance {_instance?.Uid} in account {_instance?.AccountId}\", ex, name);\n                _data.ActivityFailure(_instance, instanceActivity);\n            }\n\n            _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            QueueActivity(instanceActivity);\n        }\n\n        public void QueueEvent(Event e)\n        {\n            if (_instance.Status != Enums.WorkflowStepStatus.Failed && _instance.Status != Enums.WorkflowStepStatus.Aborted)\n            {\n                lock (_lockObject)\n                {\n                    Queue<Event> queue = (e.IsControlEvent ? _queuedControlEvents : _queuedEvents);\n                    if (e.Uid != Guid.Empty)\n                    {\n                        // Ensure this item isn't already in the list\n                        if (queue.Any(e2 => e2.Uid == e.Uid)) return;\n                    }\n                    queue.Enqueue(e);\n                    WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventQueued\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n                    wrk.Log();\n\t            }\n            }\n        }\n\n        public void QueueIncompleteActivities()\n        {\n            InstanceActivities activities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n            if (activities == null || activities.Count == 0) return;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in activities) _unfinishedActivities[activity.Uid] = activity;\n            }\n\n        }\n\n        public bool CheckActivityForCompletion(InstanceActivity instanceActivity)\n        {\n            // We only care about Waiting steps.\n            if (instanceActivity.Status != Enums.WorkflowStepStatus.Waiting) return false;\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.DebugNoPII($\"CheckActivityForCompletion called for ActivityUid {instanceActivity.Uid} ({instanceActivity.Name}).\");\n\t            try\n\t            {\n\t\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\t\t            ctx.CheckForCompletion();\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t            _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n\t\t\t            SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            return true;\n\t\t            }\n                    _log.DebugWithPII($\"CheckActivityForCompletion completed for Activity ({{0}}) in status: {instanceActivity.Status}.\", instanceActivity.Name);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n                    _log.ErrorNoPII($\"CheckActivityForCompletion failed.\", e);\n\t            }\n            }\n            return false;\n        }\n\n        public bool DoNextTask()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t        CheckAndHandleInstanceStateChanges();\n\n\t\t\t// If we're in a non-processing state, we want to respond only to control events.\n\t\t\t// If we have no control events, we can just skip everything else.\n\t\t\tif (!_ShouldProcessEvent())\n\t        {\n\t\t        return _ExecuteFirstEvent(controlOnly: true);\n\t        }\n\n\t        // If we have any queued events, do one of those.\n\t        if (_ExecuteFirstEvent(controlOnly: false)) return true;\n\n\t        if (!_ShouldProcess()) return false;\n\n\t        // Otherwise, check to see if any activities need to be executed; if so, do those.\n\t        if (_ExecuteFirstActivity()) return true;\n\n\t        // If we get here, it might be that we have some unfinished activities in the database that for some reason weren't loaded into memory.\n\t        // Check for that, and, if so, load them now.\n\t        QueueIncompleteActivities();\n\t        // Try to execute an activity again -- we may have just loaded some\n\t        if (_ExecuteFirstActivity()) return true;\n\t        // If we can complete a waiting activity, do that.\n\t        if (_CheckWaitingActivities()) return true;\n\n\t        // Otherwise, we've got nothing to do and can quit.\n\t        if (!HasQueuedWork && !HasUnfinishedActivities)\n\t        {\n\t\t        _MarkCompleted();\n\t\t\t\t// If we processed nothing (the activity count is 0) we don't want to mark ourselves as waiting.  This is mostly because\n\t\t\t\t// we don't want to update our UpdatedDate (see ATL-20570).  This case occurs when our workflow is already waiting and has been\n\t\t\t\t// picked up for the day and each activity checked to see if it's done waiting.  We don't want this to trigger an update if\n\t\t\t\t// nothing has actually changed.\n\t        }\n\t        else if (_inMemoryActivityCount > 0 || _instance.Status != Enums.WorkflowStepStatus.Waiting)\n\t        {\n\t\t\t\tvar workflowConfig = WorkflowConfig(_instance.AccountId);\n\t\t\t\tvar enableSmallBenRateLimits = workflowConfig?.EnableSmallBenRateLimits ?? false;\n\n\t\t\t\tif (_instance.Status == Enums.WorkflowStepStatus.Paused\n\t\t\t\t    && ((string.Equals(ADEXS.Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.EnableExpressionApiRateLimit, \"live\", StringComparison.OrdinalIgnoreCase)\n\t\t\t\t         && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit)\n\t\t\t\t\t|| (enableSmallBenRateLimits && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit)))\n\t\t\t\t{\n\t\t\t\t\t// keep throttled workflows in paused status\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_MarkWaiting();\n\t\t\t}\n\n\t\t    return false;\n        }\n\n        public void ExecuteActivity(InstanceActivity instanceActivity)\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteActivity called for Activity ({{0}}).\", instanceActivity.Name);\n\t            IWINSWorkflowContext ctx = null;\n\t            Stopwatch sw = Stopwatch.StartNew();\n\t            try\n\t            {\n\t\t            _lastActivityUid = instanceActivity.Uid;\n\n\t\t\t\t\tif (!_ShouldProcess()) throw new ApplicationException(string.Format(\"InstanceUid {0} is in an invalid state to execute activity {1}\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, instanceActivity.Name)));\n\n\t\t            // Check for runaway workflows.\n\t\t            if (++_inMemoryActivityCount >= MAX_IN_MEMORY_ACTIVITY_COUNT)\n\t\t            {\n\t\t\t            _log.WarnNoPII(string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t\t            throw new PublicException(PublicException.FailReason.InvalidState, string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t            }\n\n\t\t\t\t\t// Governance, check if activity execution limit has been reached\n\t\t\t\t\tif (PauseWhenActivityExecutionLimitReached())\n\t\t\t\t\t{\n\t\t\t\t\t\t// In this case, the workflow is paused, purge date is set and an e-mail has been sent to support team.\n\t\t\t\t\t\t// The current activity will not be executed, unless the limits are increased and the workflow resumed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_data.ActivityExecuting(_instance, instanceActivity);\n\n\t\t            ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\t\tif (!ShouldUseScopeEventHandler() && IsTrackItActivity(activity))\n\t\t\t\t\t{\n\t\t\t\t\t\tFireWorkflowScopeEvent(null, ScopeEventType.StepInitiated, activity, ctx);\n\t\t\t\t\t}\n\n\t\t\t\t\tactivity.Execute(ctx);\n\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n\t\t\t\t\tif (e is ArgumentNullException && ctx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar message =\n\t\t\t\t            string.Format(Resources.WINSResources.ActionFailed_ReferenceID_0, Guid.NewGuid()) +\n\t\t\t\t            $\". Inst: {instanceActivity.AccountId} '{instanceActivity.InstanceUid}'.\";\n\t\t\t            _log.ErrorNoPII(message, e);\n\t\t\t\t\t\t_data.CreateInstanceHistory(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, message, true);\n\t\t            }\n\n\t\t\t\t\t// Oh my...\n\t\t\t\t\t// Look at this catch block.\n\t\t\t\t\tbool isTransient = e is TransientException;\n\t\t            bool useFailureOutput = ctx != null && activity.HasFailureOutput;\n\n\t\t            if (isTransient) throw new TransientException(e);\n\t\t            if (useFailureOutput)\n\t\t            {\n\t\t\t\t\t\tctx.ActivityVariables.Set(\"Failure\", e.Message);\n\t\t\t\t\t\tctx.MarkAsCompleted(AbstractActivity.OUTPUT_FAILURE);\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.ActivityFailure(_instance, instanceActivity);\n\t\t\t            if (ctx == null) ctx = _CreateContext(activity, instanceActivity);\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\ttry\n\t\t\t            {\n\t\t\t\t            if (_instance.Status == Enums.WorkflowStepStatus.Failed)\n\t\t\t\t            {\n\t\t\t\t\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInstanceHandler.Fail(ctx, activity, GetUnfinishedWINSWorkflowContextsWINSActivities(instanceActivity.EndDate));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAccountId = ctx.AccountId,\n\t\t\t\t\t\t\t\t\t\tScopeUid = ctx.ScopeUid,\n\t\t\t\t\t\t\t\t\t\tScopeName = ctx.ScopeName,\n\t\t\t\t\t\t\t\t\t\tStepName = instanceActivity.Name,\n\t\t\t\t\t\t\t\t\t\tStepDisplayName = GetActivityDisplayName(activity, ctx),\n\t\t\t\t\t\t\t\t\t\tStepTypeName = instanceActivity.ActivityTypeName,\n\t\t\t\t\t\t\t\t\t\tStepUid = instanceActivity.Uid,\n\t\t\t\t\t\t\t\t\t\tPeriodStart = instanceActivity.EndDate,\n\t\t\t\t\t\t\t\t\t\tEventType = (int)ScopeEventType.WorkflowFailed,\n\t\t\t\t\t\t\t\t\t\tOutput = instanceActivity.Output,\n\t\t\t\t\t\t\t\t\t\tWorkflowUid = ctx.WorkflowInstanceUid,\n\t\t\t\t\t\t\t\t\t\tWorkflowName = ctx.WorkflowName\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tEventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n\n\t\t\t\t\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Failed, instanceActivity.EndDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t            }\n\t\t\t            catch (Exception ex)\n\t\t\t            {\n\t\t\t\t        _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.WorkflowFailed}\", ex);\n\t\t\t            }\n\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n\t\t            }\n\t            }\n\t            finally\n\t            {\n\t\t            ActivityExecutionCount++;\n\t            }\n\t\t\t}\n        }\n\n        public void ExecuteCallback(InstanceActivity instanceActivity, string name, object value)\n        {\n            LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteCallback called for Activity ({{0}}) with callback {name}.\", instanceActivity.Name);\n\n\t            if (!(_ShouldProcess(instanceActivity) && _ShouldProcessEvent()))\n\t            {\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoWithPII($\"ExecuteCallback did not complete because the activity was already completed. Activity {{0}} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}. Instance status: {Model.Status}\", instanceActivity.Name);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _log.ErrorWithPII($\"InstanceUid {Uid} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}.  Instance status: {Model.Status}\");\n\t\t\t\t\t}\n\t\t            return;\n\t\t\t\t}\n\n\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\ttry\n\t\t        {\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t            activity.ExecuteCallback(ctx, name, value);\n\n\t\t            if (_instance.Status != Enums.WorkflowStepStatus.Aborted)\n\t\t            {\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\n\t\t\t\t\t// Throw so that the calling method will handle re-queuing the failed event\n\t\t\t\t\t// When resumed we will retry the recurring reminder callback\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t            catch (Exception e)\n\t            {\n\t\t\t\t\t// Note that we don't fail the workflow here -- see ATL-21019\n\t\t\t\t\tif (instanceActivity.Status == Enums.WorkflowStepStatus.Completed ||\n\t\t                Model.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoNoPII($\"The callback is unnecessary: workflow activity '{instanceActivity.Uid}' [{instanceActivity.Status}] or instance '{instanceActivity.InstanceUid}' [{Model.Status}] has already completed.\");\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t\t\t\tvar pe = e as PublicException;\n\t\t\t\t\t\t_log.ErrorNoPII($\"ExecuteCallback failed.\", pe?.InnerException ?? e);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void ExecuteEvent(Event e, bool queueOnFailure = true)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            if (e == null) return;\n\n            using var span = StartActivity();\n\n            using (ScmNDC.Push(BuildNDCTags(e)))\n            {\n\t            // If we have Uid but the lock expired we don't want to process the event as it was persisted and some other worker probably has already picked it.\n\t            if (e.Uid != Guid.Empty && e.LockExpirationDate <= LastProcessDate)\n\t            {\n\t\t            _log.InfoNoPII($\"Aborting event execution - ExecuteEvent called with an event that has an expired lock ({e.LockExpirationDate}) for callback {e.CallbackName}.\");\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t\t            return;\n\t            }\n\n\t            _log.InfoNoPII($\"ExecuteEvent called with callback {e.CallbackName}.\");\n\t            try\n\t            {\n\t\t            Stopwatch sw = Stopwatch.StartNew();\n\t\t            if (e.ActivityUid == Guid.Empty)\n\t\t            {\n\t\t\t            // We expect these to be control codes\n\t\t\t            string comment = (e.CallbackObject == null ? \"\" : e.CallbackObject.ToString());\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            case Event.ControlNames.Abort:\n\t\t\t\t\t            Abort(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForAccountCancel:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tSetPurgeDateForAccountCancel();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForRevisionSuspended:\n\t\t\t\t\t\t\t\tPauseForRevisionSuspended(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.ResumeForSuspendedRevision:\n\t\t\t\t\t\t\t\t ResumeForSuspendedRevision(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.Pause:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t            case Event.ControlNames.Resume:\n\t\t\t\t\t            Resume(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.ResumeFromError:\n\t\t\t\t\t            ResumeFromError(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.StartActivity:\n\t\t\t\t\t            QueueActivityByName(null, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            default:\n\t\t\t\t\t            throw new ApplicationException(string.Format(\"Unhandled event {0}\", e.CallbackName));\n\t\t\t            }\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            // These *may* be control codes.  If they're not control codes, then\n\t\t\t            // we expect them to be a callback to an activity.\n\t\t\t            InstanceActivity activity;\n\t\t\t            if (!_unfinishedActivities.TryGetValue(e.ActivityUid, out activity)) activity = _data.LoadActivityByUid(_instance.AccountId, Constants.WorkflowUser, e.ActivityUid);\n\t\t\t            if (activity == null || activity.InstanceUid != e.InstanceUid) throw new ApplicationException(string.Format(\"Invalid ActivityUid {0} for InstanceUid {1}\", e.ActivityUid, e.InstanceUid));\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            // TODO: Start specific steps, fire specific outputs, complete specific steps, etc.\n\t\t\t\t            default:\n\t\t\t\t\t            ExecuteCallback(activity, e.CallbackName, e.CallbackObject);\n\t\t\t\t\t            break;\n\t\t\t            }\n\t\t            }\n\t\t            if (e.Uid != Guid.Empty) _data.EventSuccess(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventExecuted\")\n\t\t\t\t\t{\n\t\t\t\t\t\tTotalMs = sw.ElapsedMilliseconds,\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid, WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t            wrk.Log();\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t            catch (Exception excp)\n\t            {\n\t\t            _log.ErrorNoPII($\"Error processing eventUid {e.Uid} ({e.CallbackName}).\", excp);\n\t\t            if (!queueOnFailure) throw;\n\t\t            if (e.Uid == Guid.Empty)\n\t\t            {\n\t\t\t            e.NextProcessDate = _data.NextProcessDate();\n\t\t\t            e.ErrorCount = 1;\n\t\t\t            e.LastErrorMessage = excp.Message;\n\t\t\t            _data.CreateEvent(e);\n\t\t\t            WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnExecuteException\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t\t};\n\t\t\t            wrk.Log();\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.EventFailure(e.AccountId, e.Uid, _data.NextProcessDate(), excp.Message);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void Abort(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in _unfinishedActivities.Values)\n                {\n\t                try\n\t                {\n\t\t                IWINSActivity winsActivity = _SafeGetActivity(activity);\n\t\t                IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n\t\t                winsActivity.OnActivityAborted(ctx);\n\t                }\n\t                catch (Exception ex)\n\t                {\n\t\t                _log.ErrorNoPII(string.Format(\"Failed OnActivityAborted AccountId {0}, ActivityUid {1}\", user.AccountId, activity.Uid), ex);\n\t\t\t\t\t}\n                }\n                new WorkflowControlInstance(Model).Abort(user, comment);\n\n\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t{\n\t\t\t\t\tInstanceHandler.Abort(_instance, user, GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime.UtcNow));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Aborted, DateTime.UtcNow);\n\t\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowAborted);\n\t\t\t\t}\n\n\t\t\t\t_ForceReload();\n            }\n        }\n\n        public int SetPurgeDateForAccountCancel()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        var daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForAccountCancel();\n\t\t        _ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t        }\n        }\n\n        public void ClearPurgeDate()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        new WorkflowControlInstance(Model).ClearPurgeDate();\n\t\t        _ForceReload();\n\t        }\n        }\n\n\t\tpublic void Pause(UserAccount user, string comment)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Pause - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).Pause);\n\t\t}\n\n\t\tpublic void PauseForRevisionSuspended(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status == Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - No action taken, instance already paused\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).PauseForRevisionSuspended);\n\t\t}\n\n\t\tpublic void ResumeForSuspendedRevision(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status != Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, instance not paused. Status:{Model.Status}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if instance UpdatedBy has changed since the PauseForRevisionSuspended was invoked, if it has we do not want to do anything.\n\t\t\tif (Model.UpdatedBy != WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, UpdatedBy is not {WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - Resuming\");\n\t\t\tResume(user, comment);\n\t\t\tClearPurgeDate();\n\t\t}\n\n\t\tpublic bool PauseWhenActivityExecutionLimitReached()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Governance, check whether the number of executed activities exceeded the configured limit\n\t\t\t\t_isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(AccountId, Uid, _instance.RevisionUid, _instance.RevisionCreatedDate, ActivityExecutionCount, out _activityExecutionCountEnforcedLimit);\n\n\t\t\t\tif (_isActivityExecutionLimitReached)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum limit (Actual={ActivityExecutionCount}, EnforcedLimit={_activityExecutionCountEnforcedLimit}) and will be paused.\");\n\n\t\t\t\t\tPause(UserAccount.WorkflowUserAccount(AccountId), \"Workflow activity execution limit reached.\");\n\n\t\t\t\t\tTrySendActivityExecutionLimitExceedNotification(SetPurgeDateForAccountCancel());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' activity execution limit\", e);\n\t\t\t}\n\n\t\t\treturn _isActivityExecutionLimitReached;\n\t\t}\n\n\t\tpublic void PauseWhenThrottled(InstanceActivity activity, WorkflowApiRequestThrottledException exception)\n\t\t{\n\t\t\tRequires.NotNull(activity, nameof(InstanceActivity));\n\t\t\tRequires.NotNull(exception, nameof(WorkflowApiRequestThrottledException));\n\n\t\t\tif (exception.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.NotThrottled)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' is not throttled and will not be paused.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tactivity.Status = Enums.WorkflowStepStatus.Paused;\n\t\t\t\tvar throttledByApi = exception.ThrottledApiAsString();\n\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum {throttledByApi} request limit and will be paused. Message: {exception.Message}\");\n\n\t\t\t\tPauseInstance(UserAccount.WorkflowUserAccount(AccountId), $\"{throttledByApi} requests limit reached.\", new WorkflowControlInstance(Model).PauseForWorkflowRateLimitExceed);\n\n\t\t\t\t// Send notification\n\t\t\t\tswitch (exception.WorkflowThrottledStatus)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit:\n\t\t\t\t\t\tTrySendExpressionRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit:\n\t\t\t\t\t\tTrySendSmallBenRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_log.WarnNoPII(\"No notifications sent for unsupported throttle status\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mark instance as throttled for current workflow run session, WorkflowThrottledStatus property is not persisted and refreshed on reload\n\t\t\t\t_instance.WorkflowThrottledStatus = exception.WorkflowThrottledStatus;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception e)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' rate limit request limit with status {exception?.WorkflowThrottledStatus}\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublic int SetPurgeDateForWorkflowRateLimit()\n\t\t{\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tvar daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForWorkflowRateLimit();\n\t\t\t\t_ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid GetAdvancedWorkflowNotificationUserAccountUid()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while retrieving AdvancedWorkflowNotificationUserAccountUid for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\t\t}\n\n\t\tpublic void TrySendSmallBenRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\t// Send notification - pending ATL-90622\n\t\t}\n\n\t\tpublic void TrySendExpressionRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\tif (!ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetEnableWorkflowLimitNotifications(AccountId))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"EnableWorkflowLimitNotifications disabled for account {AccountId}, not sending expression rate limit exceeded notification\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (advancedWorkflowNotificationUserAccountUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {advancedWorkflowNotificationUserAccountUid} to receive expression rate limit exceeded notification\");\n\t\t\t\tUserAccount notificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, advancedWorkflowNotificationUserAccountUid);\n\n\t\t\t\tif (string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"AdvancedWorkflowNotificationUser '{advancedWorkflowNotificationUserAccountUid}' not found or missing email address. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar emailRecipients = new List<string>() { notificationUser.EmailAddress };\n\n\t\t\t\t_log.InfoNoPII($\"Sending expression rate limit exceeded notification to user '{advancedWorkflowNotificationUserAccountUid}' for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseExpressionRateLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowInstanceId = _instance.Id,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Resume(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).Resume(user, comment);\n                _ForceReload();\n            }\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Resume(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n        }\n\n        public void ResumeFromError(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).ResumeFromError(user, comment);\n                _ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.ResumeFromError(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n\t\t}\n\n        public void SaveToDatabase()\n        {\n            // We may have in-memory events that need to be saved to the db.\n\t\t\tPersistEvents();\n            _PersistVariables();\n        }\n\n        public void SaveEventsToDatabase()\n        {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPersistEvents();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save unsaved events for instance {Uid} to db\", e);\n\t\t\t}\n\t\t}\n\n\t    public void ArchiveVariables()\n        {\n            var incompleteActivities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, _instance.Uid);\n            // don't archive if there are any incomplete activites besides the one that has triggered this\n            if (incompleteActivities != null && incompleteActivities.Count > 1)\n            {\n                return;\n            }\n            _data.ArchiveVariables(AccountId, Constants.WorkflowUser, Uid);\n        }\n\n\t    public bool HasExistingLockExpired()\n\t    {\n\t\t    return LockExpirationDate < DateTime.UtcNow;\n\t    }\n\n\n        /// <summary>\n        /// Replaces variables provided in the dictionary returning replaced variables\n        /// </summary>\n        public void SetVariables(\n\t        InstanceActivity instanceActivity,\n\t        Dictionary<string, object> variables,\n\t        out List<InstanceVariable> oldVariables,\n\t        out bool areVariablesOverTotalSizeLimit,\n\t        out int totalVariablesSizeBytes,\n\t        out int totalVariablesSizeLimitBytes,\n\t\t\tout Dictionary<string, int> oversizedVariables,\n\t        out int variableValueSizeLimitBytes)\n        {\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            _log.DebugWithPII($\"SetVariables called for ActivityUid {instanceActivity.Uid} ({{0}}).\", instanceActivity.Name);\n\n            // We create the context so that the variable dictionaries get populated\n            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n            oldVariables = new List<InstanceVariable>();\n            var newVariables = UpdateVariablesHelper.PopulateContextVariables(ctx, this.Model, variables);\n\n            // Only set variables that are under the size limit\n\t\t\toversizedVariables = InstanceVariableGovernance.GetOversizedVariables(ctx.AccountId, newVariables, ctx.SubmittedDate, out variableValueSizeLimitBytes);\n\t\t\tforeach (InstanceVariable variable in newVariables)\n\t\t\t{\n\t\t\t\tif (!oversizedVariables.ContainsKey(variable.Name))\n\t\t\t\t{\n\t\t\t\t\toldVariables.Add(Variables[variable.Name]);\n\t\t\t\t\t// we could do \"ctx.Variables.Set(variable.Key, variable.Value);\" but that would log as the instanceActivity and we don't want that...\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Undo setting the variables, if the instance's total variable size exceeds the limit\n\t\t\tareVariablesOverTotalSizeLimit = InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(ctx.AccountId,\n\t\t\t\tVariables.Select(x => x.Value), ctx.SubmittedDate, activityConfiguration: null, out totalVariablesSizeBytes, out totalVariablesSizeLimitBytes);\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tforeach (InstanceVariable variable in oldVariables)\n\t\t\t\t{\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n        }\n\n        public DateTime GetLastAbortNotificationDate()\n        {\n\t        if (!_contextInitialized)\n\t        {\n\t\t        _LoadVariables();\n            }\n\n\t        if (_variables.TryGetValue(WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE, out InstanceVariable lastNotificationDate) &&\n\t            DateTime.TryParse(lastNotificationDate.Value.ToString(), out DateTime dateTime))\n\t        {\n\t\t        return dateTime;\n\t        }\n\n            return DateTime.MinValue;\n        }\n\n        public void SaveLastAbortNotificationDate(int accountId, Guid workflowInstanceUid, DateTime lastAbortNotificationDate)\n        {\n            var variable = InstanceVariable.CreateFromValue(\n\t            accountId,\n\t            workflowInstanceUid,\n\t            WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE,\n\t            Enums.WorkflowVariableType.Date,\n\t            lastAbortNotificationDate);\n\n            ServiceLocator.GetInstance<IInstanceVariablePersistence>().Save(Constants.WorkflowUser, variable);\n\n        }\n\n        /// <summary>\n        /// Called when we've finished work on an activity -- either executing it or performing a callback on it.\n        /// </summary>\n        private void _ActivityWorkCompleted(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx, Stopwatch sw)\n        {\n\t        // If it's flagged as completed, update in the db, queue up any next activities, and remove it from our list.\n            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n            {\n                _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n                SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t\tlock (_unfinishedActivities)\n                {\n                    if (_unfinishedActivities.ContainsKey(instanceActivity.Uid)) _unfinishedActivities.Remove(instanceActivity.Uid);\n                }\n            }\n            else\n            {\n                // Otherwise, it's still running.  Flag it as waiting so it doesn't get processed again.\n                instanceActivity.Status = Enums.WorkflowStepStatus.Waiting;\n                _data.SaveInstanceActivity(instanceActivity);\n            }\n\n            _log.InfoWithPII($\"_ActivityWorkCompleted done for Activity ({{0}}) in status: {instanceActivity.Status} ({sw.ElapsedMilliseconds} ms).\", instanceActivity.Name);\n\n\n            // log workload data\n            try\n            {\n                WorkflowWorkload ww = new WorkflowWorkload();\n                ww.Add(ctx);\n                ww.TotalMs = sw.ElapsedMilliseconds;\n\t\t\t\tww.StartTime = DateTime.UtcNow.AddMilliseconds(-ww.TotalMs);\n                ww.Status = instanceActivity.Status.ToString();\n                ww.Output = instanceActivity.Output;\n                ww.ActivityCreatedDate = instanceActivity.CreatedDate;\n                ww.ActivityStartDate = instanceActivity.StartDate;\n                if (DateTime.MinValue < instanceActivity.EndDate && instanceActivity.EndDate < DateTime.MaxValue)\n                    ww.ActivityEndDate = instanceActivity.EndDate;\n                if (DateTime.MinValue < _instance.CreatedDate && _instance.CreatedDate < DateTime.MaxValue)\n\t                ww.InstanceCreatedDate = _instance.CreatedDate;\n                ww.ActivityKind = activity.Kind.ToString();\n                ww.RevisionUid = _instance.RevisionUid.ToString();\n\t\t\t\tww.DefinitionUid = _instance.DefinitionUid.ToString();\n\t\t\t\tww.WorkflowDB = DataStore.GetDbNameForAccount(instanceActivity.AccountId);\n\n\t\t\t\tww.Log();\n            }\n            catch (Exception ex)\n            {\n                _log.WarnNoPII(\"Failed to log workload.\", ex);\n            }\n        }\n\n\t\tprivate void CompleteScopeStep(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n            try\n            {\n                if (IsTrackItActivity(activity))\n                {\n                    Documents documents = null;\n                    if (ctx.TrackActivity())\n                    {\n                        documents = ((ITrackItActivity)activity).GetDocuments(ctx);\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, instanceActivity.Uid,\n                            documents, instanceActivity.Output, instanceActivity.Status,\n                            instanceActivity.EndDate);\n                    }\n\n                    WorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n                    {\n                        AccountId = ctx.AccountId,\n                        Documents = documents?.Select(d => new WorkflowScopeEvent.DocumentDetail() { Uid = d.Uid, Name = d.Name }).ToList(),\n                        ScopeUid = ctx.ScopeUid,\n                        ScopeName = ctx.ScopeName,\n                        StepName = instanceActivity.Name,\n                        StepDisplayName = GetActivityDisplayName(activity, ctx),\n                        StepTypeName = instanceActivity.ActivityTypeName,\n                        StepUid = instanceActivity.Uid,\n                        PeriodStart = instanceActivity.EndDate,\n                        EventType = (int)ScopeEventType.StepFinished,\n                        Output = instanceActivity.Output,\n                        WorkflowUid = ctx.WorkflowInstanceUid,\n                        WorkflowName = ctx.WorkflowName\n                    };\n                    WorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n                    {\n                        EventData = scopeEventData\n                    };\n                    EventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.StepFinished}\", ex);\n            }\n        }\n\n        private void SaveInstanceActivityVariables(InstanceActivity instanceActivity, IWINSWorkflowContext ctx)\n        {\n\t        if (ctx.WorkflowUserAccount.Account.Settings.EnableWorkflowVariableHistory)\n\t        {\n\t\t        var instanceVariableRepository = ServiceLocator.GetInstance<IInstanceVariableRepository>();\n\t\t        instanceVariableRepository.SaveVariableHistory(instanceActivity.AccountId, ctx.WorkflowUserAccount.Uid,\n\t\t\t        instanceActivity.InstanceUid, instanceActivity.Uid, ctx.Variables.GetAllVariables());\n\t        }\n        }\n\n        private List<WINSWorkflowContextWINSActivity> GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime endDate)\n        {\n\t\t\tvar list = new List<WINSWorkflowContextWINSActivity>();\n\n\t\t\tif (!HasUnfinishedActivities) return list;\n\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values);\n            }\n\n            IWINSWorkflowContext ctx = null;\n            foreach (var activity in activities)\n            {\n                var winsActivity = _SafeGetActivity(activity);\n                ctx = _CreateContext(winsActivity, activity);\n\n                if (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n                {\n\t\t\t\t\tlist.Add(new WINSWorkflowContextWINSActivity { EndDate = endDate, WINSActivity = winsActivity, WINSWorkflowContext = ctx });\n\t\t\t\t}\n            }\n\n\t\t\treturn list;\n        }\n\n\t\tprivate void AbortOrFailScopeStep(Enums.WorkflowStepStatus status, DateTime endDate)\n\t\t{\n\t\t\tif (!HasUnfinishedActivities) return;\n\n\t\t\tList<InstanceActivity> activities;\n\t\t\tlock (_unfinishedActivities)\n\t\t\t{\n\t\t\t\tactivities = new List<InstanceActivity>(_unfinishedActivities.Values);\n\t\t\t}\n\t\t\tIWINSWorkflowContext ctx = null;\n\t\t\tforeach (var activity in activities)\n\t\t\t{\n\t\t\t\tvar winsActivity = _SafeGetActivity(activity);\n\t\t\t\tctx = _CreateContext(winsActivity, activity);\n\n\t\t\t\tif (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n\t\t\t\t{\n\t\t\t\t\tvar documents = ((ITrackItActivity)winsActivity).GetDocuments(ctx);\n\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, activity.Uid, documents, null, status, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool _CheckWaitingActivities()\n        {\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values.Where(n => n.Status == Enums.WorkflowStepStatus.Waiting));\n            }\n            bool success = false;\n            foreach (InstanceActivity activity in activities)\n            {\n                if (CheckActivityForCompletion(activity)) success = true;\n            }\n            return success;\n        }\n\n        private bool _contextInitialized = false;\n        private IWINSWorkflowContext _CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n            IWINSWorkflowContext ctx = CreateContext(activity, instanceActivity);\n            AtlasContext.Current.UserAccount = ctx.WorkflowUserAccount;\n            // Only do this once.  If it's been done, it's done.\n            if (_contextInitialized) return ctx;\n\n            // This all depends on the properties for the Start step.  We always want a Start step for normal processing;\n            // however, we don't necessarily have a Start step for our tests.\n            StartActivity start = _workflowMap.StartActivity;\n            if (start == null)\n            {\n                if (_data.IsTest) return ctx;\n                throw new ApplicationException(string.Format(\"Cannot find StartActivity for InstanceUid {0}\", _instance.Uid));\n            }\n\n            // Contents\n            string[][] contents = start.DefinedContents;\n            if (contents != null && contents.Length > 0)\n            {\n                foreach (string[] t in contents)\n                {\n                    ContentDefinition definition = new ContentDefinition(t);\n                    if (!_contentDefinitions.ContainsKey(definition.Name)) _contentDefinitions[definition.Name] = definition;\n                }\n            }\n\n            _LoadVariables();\n\n            // XML Variables\n            // Because XmlVariables have dependencies on the variables as well, it's easier to feed this through the xml variable handler\n            // rather than replicate the code.\n            List<IXmlVariableDefinition> definitions = start.DefinedXmlVariables;\n            if (definitions != null && definitions.Count > 0)\n            {\n                foreach (IXmlVariableDefinition definition in definitions)\n                {\n                    if (!_xmlVariableDefinitions.ContainsKey(definition.Name)) ctx.XmlVariables.Declare(definition, logMessage: false);\n                }\n            }\n\n            _contextInitialized = true;\n            return ctx;\n\t\t}\n\n        public IWINSWorkflowContext CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowContextFactory>().CreateWorkflowContext(this, activity, instanceActivity);\n        }\n\n\t\tprivate void _LoadVariables()\n        {\n\t        // Variables\n\t        Dictionary<string, InstanceVariable> variables = _data.LoadVariablesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n\t        foreach (InstanceVariable variable in variables.Values)\n\t        {\n\t\t        if (!_variables.ContainsKey(variable.Name)) _variables[variable.Name] = variable;\n\t        }\n        }\n\n        private bool _ExecuteFirstActivity()\n        {\n            InstanceActivity activity = null;\n            lock (_unfinishedActivities)\n            {\n                if (_unfinishedActivities.Count > 0) activity = _unfinishedActivities.Values.FirstOrDefault(n => n.Status == Enums.WorkflowStepStatus.Pending || n.Status == Enums.WorkflowStepStatus.Executing);\n            }\n            if (activity == null) return false;\n            ExecuteActivity(activity);\n            return true;\n        }\n\n        private bool _ExecuteFirstEvent(bool controlOnly = false)\n        {\n            // We always try to execute control events first.\n            Event e = null;\n            lock (_queuedControlEvents)\n            {\n                if (_queuedControlEvents.Count > 0) e = _queuedControlEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            // If we're only caring about control events, we can quit now.\n            if (controlOnly) return false;\n\n            // Otherwise, we do the same thing with the rest of the events.\n            lock (_queuedEvents)\n            {\n                if (_queuedEvents.Count > 0) e = _queuedEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            return false;\n        }\n\n        private void _ForceReload()\n        {\n            // Reload the object to get new state -- we do this inside the lock so that there's no race condition\n            // between this and a worker who may be working on the object\n            lock (_lockObject)\n            {\n                Guid instanceUid = Uid;\n                _instance = _data.LoadInstanceByUid(AccountId, Constants.WorkflowUser, instanceUid);\n                if (_instance == null) throw new ApplicationException(string.Format(\"Failed to reload instanceUid: {0}\", instanceUid));\n            }\n        }\n\n        private void _MarkCompleted()\n        {\n\t        if (_instance.IsCompleted)\n\t        {\n\t\t        _log.InfoNoPII($\"Instance {_instance.Uid} is already complete with status {_instance.Status}\");\n\t\t        return;\n\t        }\n\n            _PersistVariables();\n            bool endActivityFailure = _workflowMap.HasEndActivity() && !_instance.EndActivityReached;\n            Enums.WorkflowStepStatus endStatus = endActivityFailure ? Enums.WorkflowStepStatus.Failed : Enums.WorkflowStepStatus.Completed;\n            _data.SaveInstance(_instance);\n            _data.InstanceCompleted(_instance, endStatus);\n\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Complete(_instance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventType = _instance.Status == Enums.WorkflowStepStatus.Failed ? ScopeEventType.WorkflowFailed : ScopeEventType.WorkflowFinished;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t{\n\t\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\t\tPeriodStart = _instance.EndDate,\n\t\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\t\tWorkflowName = _instance.Name\n\t\t\t\t\t};\n\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t\t{\n\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t};\n\t\t\t\t\tEventRepo.FireEvent(_instance.AccountId, scopeEvent);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event {_instance.ScopeUid} for eventtype {eventType}\", ex);\n\t\t\t\t}\n\t\t\t}\n\n            if (endActivityFailure && _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                if (_lastActivityUid == Guid.Empty)\n                {\n                    _log.WarnNoPII($\"No activities for workflow.\");\n                }\n                else\n                {\n                    InstanceActivity activity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, _lastActivityUid);\n                    IWINSActivity winsActivity = _SafeGetActivity(activity);\n                    IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n                    LoggingHelper.LogActivityErrorNoPII(ctx, Resources.WINSResources.WorkflowExitedWithoutReachingTheEndActivity);\n                }\n\n            }\n            if (_instance.Status == Enums.WorkflowStepStatus.Completed || _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n            }\n        }\n\n        private void _MarkWaiting()\n        {\n            _PersistVariables();\n            _instance.Status = Enums.WorkflowStepStatus.Waiting;\n            _data.SaveInstance(_instance);\n        }\n\n        private void _PersistVariables()\n        {\n            InstanceVariables variables = new InstanceVariables();\n            foreach (InstanceVariable variable in _variables.Values) if (variable.IsModified) variables.Add(variable);\n            _data.SaveInstanceVariables(AccountId, Constants.WorkflowUser, variables);\n        }\n\n        private void PersistEvents()\n\t\t{\n\t\t\tlock (_queuedControlEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedControlEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedControlEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlock (_queuedEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        private void PersistEvent(Event e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_data.CreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_data.UnlockEvent(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventUnlockedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save event {e.Uid}, for instance {e.InstanceUid}, activity {e.ActivityUid}, and callback name {e.CallbackName} to db\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate IWINSActivity _SafeGetActivity(InstanceActivity instanceActivity)\n        {\n            try\n            {\n                IWINSActivity activity;\n                if (_workflowMap.TryGetActivity(instanceActivity.Name, out activity)) return activity;\n                // There is a problem with old MWF workflow data where the name of the activity is really the type name.\n                // Don't ask.  It's a stupid and boring story.\n                // But we still should handle it, at least for awhile.  So: if we get here because we didn't match name, we should see\n                // if we match type name.\n                // This whole thing is a huge hack that should get removed when it can.\n                InstanceActivity inputActivity = null;\n                if (instanceActivity.InputActivityUid != Guid.Empty) inputActivity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, instanceActivity.InputActivityUid);\n                if (_workflowMap.LegacyTryGetActivityByTypeName(instanceActivity.Name, inputActivity == null ? \"\" : inputActivity.Name, instanceActivity.InputActivityOutput ?? \"\", out activity))\n                {\n                    // Rename it so we get one less instance of this in the future\n                    instanceActivity.Name = activity.Name;\n                    return activity;\n                }\n                throw new ApplicationException(string.Format(\"Invalid activity name '{0}' for instanceUid '{1}'.\", instanceActivity.Name, instanceActivity.InstanceUid));\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"_SafeGetActivity failed.\", e);\n                return null;\n            }\n        }\n\n        private bool _ShouldProcess(InstanceActivity instanceActivity)\n        {\n            switch (instanceActivity.Status)\n            {\n                case Enums.WorkflowStepStatus.Executing:\n                case Enums.WorkflowStepStatus.Pending:\n                case Enums.WorkflowStepStatus.Waiting:\n                case Enums.WorkflowStepStatus.Aborted:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool _ShouldProcess()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        private bool _ShouldProcessEvent()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                    case Enums.WorkflowStepStatus.Aborted:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        //ITrackItActivity interface is implemented by activities whose data is tracked in DocumentScope and ScopeEvent tables.\n        private bool IsTrackItActivity(IWINSActivity activity)\n        {\n            return activity is ITrackItActivity;\n        }\n\n\t\tprivate void FireWorkflowScopeEvent(UserAccount user, ScopeEventType eventType, IWINSActivity activity = null, IWINSWorkflowContext ctx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo\n\t\t\t\t{\n\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\tPeriodStart = DateTime.UtcNow,\n\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\tWorkflowName = _instance.Name,\n\t\t\t\t\tEventBy = user == null ? null : new WorkflowScopeEvent.Assignee() { Email = user.EmailAddress, Name = user.FriendlyName, Uid = user.Uid }\n\t\t\t\t};\n\n\t\t\t\tif (activity != null && ctx != null)\n\t\t\t\t{\n\t\t\t\t\tscopeEventData.StepName = ctx.ActivityName;\n\t\t\t\t\tscopeEventData.StepDisplayName = GetActivityDisplayName(activity, ctx);\n\t\t\t\t\tscopeEventData.StepTypeName = ctx.ActivityTypeName;\n\t\t\t\t\tscopeEventData.StepUid = ctx.ActivityUid;\n\t\t\t\t}\n\n\t\t\t\tEventRepo.FireEvent(_instance.AccountId, new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t{\n\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event scopeUid: {_instance.ScopeUid}, instanceUid: {_instance.Uid} eventType: {eventType}\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void RemoveProperties(InstanceActivity instanceActivity, IWINSActivity activity)\n\t    {\n\t\t    // We need to delete properties if this is not a human activity or WaitForNextStepAfterCompletion is not set\n\t\t    if (activity is AbstractHumanActivity && ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetWaitForNextStepAfterCompletion(instanceActivity.AccountId))\n\t\t    {\n\t\t\t\t_data.DeleteActivityPropertiesWithExclusion(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, new List<string> { nameof(AbstractHumanActivity.WaitForNextStep) });\n\t\t\t\t_log.InfoNoPII(\"Removing activity properties except WaitForNextStep\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    _data.DeleteActivityProperties(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid);\n\t\t\t    _log.InfoNoPII(\"Removing activity properties\");\n\t\t    }\n\t    }\n\n\t\tprivate string[] BuildNDCTags(InstanceActivity instanceActivity) => instanceActivity != null ? new[] { $\"ActivityId:{instanceActivity.Uid}\",$\"W:{instanceActivity.InstanceUid}\" } : new string[] { };\n\t    private string[] BuildNDCTags(Event e) => e != null ? new[] { $\"ActivityId:{e.ActivityUid}\", $\"W:{e.InstanceUid}\" } : new string[] { };\n\n\t\t/// <summary>\n\t\t/// Try to send an e-mail to support when a workflow instance activity execution account exceeds configured threshold.\n\t\t/// </summary>\n\t\t/// <param name=\"pausedPurgeDays\">Number of days to purge workflow related data</param>\n\t\t/// <returns>\n\t\t/// True\t-> Success.\n\t\t/// False\t-> Fail to send email.\n\t\t/// </returns>\n\t\tprivate bool TrySendActivityExecutionLimitExceedNotification(int pausedPurgeDays)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\t// Support should get the email\n\t\t\t\tvar supportEmailAddress = WorkflowSettingRepository.GetSupportNotificationEmailAddress(AccountId);\n\t\t\t\tif (!string.IsNullOrEmpty(supportEmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(supportEmailAddress);\n\t\t\t\t}\n\n\t\t\t\t// Also send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive activity execution limit exceeded notification\");\n\t\t\t\t\tnotificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, notificationUserUid);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Email support address setting is empty, and there is no AdvancedWorkflowNotificationUser configured. Thus, not sending activity execution limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Sending activity execution limit exceeded notification to {emailRecipients.Count} {(emailRecipients.Count > 1 ? \"recipients\" : \"recipient\")} for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseActivityExecutionLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowRevisionUid = _instance.RevisionUid,\n\t\t\t\t\tNumberOfActivitiesExecuted = ActivityExecutionCount,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetActivityDisplayName(IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n\t\t\treturn activity is AbstractHumanActivity abstractHumanActivity\n\t\t\t\t? abstractHumanActivity.ActivityDisplayName.Evaluate(ctx)\n\t\t\t\t: null;\n\t\t}\n\n\t\tprivate bool ShouldUseScopeEventHandler() => WorkflowFeatureFlags.UseScopeEventHandler &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t Model?.EngineVersion == Core.Workflow.Constants.EngineVersionV2;\n\n\t\tprivate void PauseInstance(UserAccount user, string comment, Action<UserAccount, string> pauseMethod)\n\t\t{\n\t\t\tRequires.NotNull(pauseMethod, nameof(pauseMethod));\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tpauseMethod(user, comment);\n\t\t\t\t_ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Pause(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowPaused);\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{\n\t\t\tvar environmentType = SiteConfig?.Value?.EnvironmentType;\n\t\t\tvar isGrpcEnabled = WorkflowClientConfig?.Value?.IsGrpcClientEnabled == true;\n\n\t\t\tvar isRunningOnCloudWithGrpcEnabled = environmentType == Core.Util.Config.EnvironmentType.Cloud && isGrpcEnabled;\n\n\t\t\tif (isRunningOnCloudWithGrpcEnabled && InstanceStateChangedHelper.IsInstanceStateChanged(_instance.Uid, ActivityExecutionCount, CacheRepository, WorkflowSettingRepository))\n\t\t\t{\n\t\t\t\t_ForceReload();\n\t\t\t\tInstanceStateChangedHelper.RemoveInstanceStateChanged(_instance.Uid, CacheRepository);\n\t\t\t}\n\t\t}\n    }\n}\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
      "content": "\ufeffusing System;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Domain.Repository.Workflow.PropertyExpressions;\n\nnamespace ADEXS.Atlas.Workflow.Activities.PropertyTypes\n{\n\t[Serializable]\n\tpublic class StringProperty : IProperty<string>\n\t{\n\t\tprivate readonly IPropertyExpression _propertyExpression;\n\n\t\tpublic StringProperty(IPropertyExpression propertyExpression)\n\t\t{\n\t\t\t_propertyExpression = propertyExpression;\n\t\t}\n\n\t\tbool IProperty.TryEvaluate(IWorkflowContext ctx, out object result)\n\t\t{\n\t\t\tstring value;\n\t\t\tbool valid = TryEvaluate(ctx, out value);\n\t\t\tresult = value;\n\t\t\treturn valid;\n\t\t}\n\n\t\tbool IProperty.TryEvaluateWithoutContext(out object result)\n\t\t{\n\t\t\tstring value;\n\t\t\tbool valid = TryEvaluateWithoutContext(out value);\n\t\t\tresult = value;\n\t\t\treturn valid;\n\t\t}\n\n\t\tpublic string Evaluate(IWorkflowContext ctx)\n\t\t{\n\t\t\tstring value;\n\t\t\tTryEvaluate(ctx, out value);\n\t\t\treturn value;\n\t\t}\n\n\t\tpublic bool IsEmpty\n\t\t{\n\t\t\tget { return _propertyExpression == null || _propertyExpression.IsEmpty; }\n\t\t}\n\n\t\tpublic object Serialize()\n\t\t{\n\t\t\treturn _propertyExpression.Serialize();\n\t\t}\n\n\t\tpublic string Text\n\t\t{\n\t\t\tget { return _propertyExpression.Text; }\n\t\t}\n\n\t\tpublic bool TryEvaluate(IWorkflowContext ctx, out string result)\n\t\t{\n\t\t\tstring errorMessage;\n\t\t\tif (!_propertyExpression.TryEvaluate(ctx, out result, out errorMessage)) return false;\n\t\t\tWorkflowExpression expression = WorkflowExpression.Evaluate(ctx, result);\n\t\t\tresult = expression.ProcessedExpression;\n\t\t\treturn expression.IsValid;\n\t\t}\n\n\t\tpublic bool TryEvaluateWithoutContext(out string result)\n\t\t{\n\t\t\tstring errorMessage;\n\t\t\tif (!_propertyExpression.TryEvaluateWithoutContext(out result, out errorMessage)) return false;\n\t\t\tWorkflowExpression expression = WorkflowExpression.EvaluateWithoutContext(result);\n\t\t\tresult = expression.ProcessedExpression;\n\t\t\treturn expression.IsValid;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// This exists so you can do 'MyActivity.MyProperty = \"blah\";'.  Mostly used by the unit tests.\n\t\t/// </summary>\n\t\tpublic static implicit operator StringProperty(string s)\n\t\t{\n\t\t\treturn new StringProperty(new StringPropertyExpression(\"Literal\", s));\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/PerformanceLog.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Web;\nusing System.Web.SessionState;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.RequestHeaders;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\n\nusing SCMAppenders;\n\nnamespace ADEXS.Web.Common.Profile;\n\n/// <summary>\n/// Generates profile messages.\n/// The profile messages are controlled by the usual Profile application setting.\n/// </summary>\npublic class PerformanceLog : IDisposable\n{\n\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(PerformanceLog));\n\n\n\tprivate DateTime _executeStart = DateTime.MinValue;\n\tprivate HttpRequest _request;\n\tprivate string _sessionAnalyticsId;\n\n\tpublic void Dispose() { }\n\n\tpublic void Reset() { }\n\n\tpublic void Start(HttpRequest request)\n\t{\n\t\tif (null == request)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t_executeStart = DateTime.Now;\n\t\t_request = request;\n\t\tScmNDC.Clear();\n\t\tScmNDC.Push(_request.HttpMethod, GetRequestText());\n\t}\n\n\tpublic void Stop(Exception e)\n\t{\n\t\tif (null == _request)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tvar elapsedMilliseconds = (int)(DateTime.Now - _executeStart).TotalMilliseconds;\n\t\t\tvar pEvent = new ProfileEvent\n\t\t\t{\n\t\t\t\tEllapsedMS = elapsedMilliseconds,\n\t\t\t\tTemplate = GetRequestText(),\n\t\t\t\tData = GetRequestData(),\n\t\t\t\tMessage = (e == null) ? string.Empty : $\"Exception: {e.Message}: {e.StackTrace}\",\n\t\t\t\tDbName = string.Empty,\n\n\t\t\t\tHttpMethod = _request.HttpMethod,\n\t\t\t\tRequestIP = IPAddressUtil.FetchIpAddress(_request),\n\t\t\t\tSessionID = _sessionAnalyticsId,\n\t\t\t\tUserAgent = _request.Headers[\"User-Agent\"],\n\t\t\t\tAcceptHeader = _request.Headers[\"Accept\"]\n\t\t\t};\n\n\t\t\tProfiler.AppLog(pEvent);\n\t\t}\n\t\tcatch (Exception exception)\n\t\t{\n\t\t\t_log.WarnNoPII(\"Failed to log profile event.\", exception);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tScmNDC.Pop();\n\t\t\t_request = null;\n\t\t}\n\t}\n\n\tpublic void Stop()\n\t{\n\t\tStop(null);\n\t}\n\n\tpublic void SetSession(HttpSessionState session)\n\t{\n\t\t_sessionAnalyticsId = session?[\"AnalyticsId\"]?.ToString();\n\t}\n\n\tprivate string GetRequestData()\n\t{\n\t\tif (null == _request)\n\t\t{\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tvar build = new StringBuilder();\n\t\t\tif (_request.RequestContext.HttpContext.Items.Contains(Constants.HttpContextCache.RouteDictionary))\n\t\t\t{\n\t\t\t\tvar dictionary =\n\t\t\t\t\t(IDictionary<string, object>)_request.RequestContext.HttpContext.Items[\n\t\t\t\t\t\tConstants.HttpContextCache.RouteDictionary];\n\n\t\t\t\tforeach (var key in dictionary.Keys)\n\t\t\t\t{\n\t\t\t\t\tbuild.AppendFormat(\"{0}={1} \", key, dictionary[key]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach (string key in _request.QueryString)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvar value = _request.QueryString[key];\n\t\t\t\t\tbuild.AppendFormat(\"{0}={1} \", key, value);\n\t\t\t\t}\n\t\t\t\tcatch (HttpRequestValidationException exception)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Potentially dangerous value for query string key: {key}, Message: {exception.Message}\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn build.ToString();\n\t\t}\n#pragma warning disable CA1031 // Do not block logging code\n\t\tcatch (Exception exception)\n#pragma warning restore CA1031\n\t\t{\n\t\t\t_log.WarnNoPII(\"Failed to get request data.\", exception);\n\t\t\treturn string.Empty;\n\t\t}\n\t}\n\n\tprivate string GetRequestText()\n\t{\n\t\tif (null == _request)\n\t\t{\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tvar soapAction = _request.Headers[\"SOAPAction\"];\n\t\t\tif (!string.IsNullOrEmpty(soapAction))\n\t\t\t{\n\t\t\t\treturn soapAction;\n\t\t\t}\n\n\t\t\tif (_request.RequestContext.HttpContext.Items.Contains(Constants.HttpContextCache.RouteTemplate))\n\t\t\t{\n\t\t\t\treturn (string)_request.RequestContext.HttpContext.Items[Constants.HttpContextCache.RouteTemplate];\n\t\t\t}\n\n\t\t\tvar url = _request.Url.AbsolutePath;\n\n\t\t\tvar atIndex = url.IndexOf('@');\n\t\t\tif (atIndex > -1)\n\t\t\t{\n\t\t\t\t// no emails in urls\n\t\t\t\tvar precedingSlash = url.LastIndexOf(\"/\", atIndex, StringComparison.Ordinal) + 1;\n\t\t\t\tvar followSlash = url.IndexOf(\"/\", atIndex, StringComparison.Ordinal);\n\t\t\t\tif (followSlash == -1)\n\t\t\t\t{\n\t\t\t\t\tfollowSlash = url.Length;\n\t\t\t\t}\n\n\t\t\t\tvar email = url.Substring(precedingSlash, followSlash - precedingSlash);\n\t\t\t\treturn url.Replace(email, PII.Encode(email));\n\t\t\t}\n\n\t\t\treturn url;\n\t\t}\n#pragma warning disable CA1031 // Do not block logging code\n\t\tcatch (Exception exception)\n#pragma warning restore CA1031\n\t\t{\n\t\t\t_log.WarnNoPII(\"Failed to get request text.\", exception);\n\t\t\treturn string.Empty;\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    }
  ],
  "reasoning_chain": "ReasoningChain(strategy=<ReasoningStrategy.CHAIN_OF_THOUGHT: 'chain_of_thought'>, steps=[ReasoningStep(step_number=1, description='1. Analysis', reasoning='1. Analysis  \\n   \u2022 Requirement: Add two new attributes (HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION) to every HTTP *server* span.  \\n   \u2022 These attributes can be populated during request/response processing (i.e., middleware).  ', conclusion='   \u2022 These attributes can be populated during request/response processing (i.e., middleware).  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=2, description='2. Planning', reasoning='2. Planning  \\n   \u2022 In an ASP.NET-Core application the most straightforward, low-risk place to enrich spans is inside a custom middleware that already has access to both the HttpRequest and HttpResponse objects.  \\n   \u2022 Candidate list shows exactly one file whose name indicates it is such a middleware:  ', conclusion='   \u2022 Candidate list shows exactly one file whose name indicates it is such a middleware:  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=3, description='3. Implementation', reasoning='3. Implementation  \\n   \u2022 Inside LogAsyncRequestHttpMiddleware.Invoke/InvokeAsync:  \\n     \u2013 Just after HttpContext.Request is available, read Request.Headers[\"Referer\"] and set Activity.Current?.SetTag(\"HTTP_REFERER\", value).  ', conclusion='     \u2013 Just after HttpContext.Request is available, read Request.Headers[\"Referer\"] and set Activity.Current?.SetTag(\"HTTP_REFERER\", value).  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=4, description='4. Validation', reasoning='4. Validation  \\n   \u2022 Run any integration test or hit an endpoint while exporting spans (e.g., to console) and confirm the two new tags are present.  \\n   \u2022 Make sure tags are omitted when headers are missing (null-check).', conclusion='   \u2022 Make sure tags are omitted when headers are missing (null-check).', confidence=0.8, evidence=['LLM analysis'])], final_conclusion='\u2022 Adding an ActivityEnrichment callback where OpenTelemetry is configured; however, that would require finding and modifying the startup/DI code (not listed) and potentially multiple files\u2014violating the \u201cminimal, targeted changes\u201d guideline.', overall_confidence=0.8, alternative_approaches=['Alternative considered'])"
}