{
  "execution_summary": {
    "total_stages": 9,
    "completed": 9,
    "failed": 0,
    "cache_hits": 0,
    "total_execution_time": 340.1611473560333
  },
  "stage_details": {
    "ticket_processing": {
      "stage_name": "ticket_processing",
      "status": "StageStatus.COMPLETED",
      "result": "## OpenTelemetry Span Attributes Missing - HTTP Redirect Tracking\n\n**Summary:** Add missing HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION attributes to CLM web application spans\n\n**Problem Description:**\nOur OpenTelemetry spans in the CLM (Contract Lifecycle Management) web application are missing critical HTTP attributes needed for debugging redirect flows and investigating user journey issues. Specifically:\n\n1. **Missing Attribute**: `HTTP_REFERER` - The referring page URL that led to the current request\n2. **Missing Attribute**: `HTTP_RESPONSE_REDIRECT_LOCATION` - The destination URL when a 302/redirect response occurs\n\n**Business Impact:**\n- Cannot trace user navigation flows through CLM application\n- Difficult to investigate redirect-related issues and errors\n- Missing context for 302 responses that redirect to error pages\n\n**Technical Details:**\n\n**Target Application:** CLM Web Application (clm-web)\n**Environment:** Demo (but affects all environments)\n**Specific Pages Affected:**\n- `/clm/Documents/BrowseDocuments.aspx`\n- `/clm/SSO/SSOEndpoint.ashx` \n- Any page that handles redirects (HTTP 302 responses)\n\n**Expected Kusto Query Results:**\nAfter fix, this query should show the missing attributes:\n```kusto\nOtlpSpanEvents\n| where Environment == \"Demo\"\n| where url_path == \"/clm/Documents/BrowseDocuments.aspx\"\n| where http_status_code > 200\n| project Timestamp, url_path, http_status_code, HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION\n```\n\n**Implementation Requirements:**\n\n1. **Add HTTP_REFERER attribute** to all incoming HTTP requests\n   - Source: `Request.Headers[\"Referer\"]` or `HttpContext.Request.Headers.Referer`\n   - Add to span as: `activity.SetTag(\"HTTP_REFERER\", refererValue)`\n\n2. **Add HTTP_RESPONSE_REDIRECT_LOCATION attribute** for redirect responses\n   - Source: `Response.Headers[\"Location\"]` when status code is 301/302/303/307/308\n   - Add to span as: `activity.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", locationValue)`\n\n**Files to Look For:**\n- CLM web application middleware or request handling code\n- ASP.NET request pipeline components\n- OpenTelemetry instrumentation configuration\n- Files containing \"ActivitySource\", \"SetTag\", or \"AddTag\" method calls\n- Middleware files that handle HTTP requests/responses\n- Look for existing telemetry code in CLM-related projects\n\n**Acceptance Criteria:**\n- [ ] HTTP_REFERER attribute captured from incoming request headers\n- [ ] HTTP_RESPONSE_REDIRECT_LOCATION attribute captured for 302+ responses  \n- [ ] Attributes visible in OtlpSpanEvents Kusto table\n- [ ] No performance degradation from additional attribute collection\n- [ ] Proper null/empty value handling for missing headers\n\n**Technical Notes:**\n- Follow existing OpenTelemetry patterns in the codebase\n- Ensure attribute names match exactly: \"HTTP_REFERER\" and \"HTTP_RESPONSE_REDIRECT_LOCATION\"\n- Add attributes to HTTP request spans, not separate spans\n- Handle edge cases where headers might be missing or empty\n",
      "error": null,
      "execution_time": 0.00046515464782714844,
      "cache_hit": false
    },
    "intent_extraction": {
      "stage_name": "intent_extraction",
      "status": "StageStatus.COMPLETED",
      "result": {
        "issue_category": "INSTRUMENTATION",
        "static_analysis_query": {
          "find_method_call": "SetTag"
        },
        "semantic_description": "Add HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION attributes to existing HTTP request spans in the CLM web application.",
        "search_keywords": [
          "HTTP_REFERER",
          "HTTP_RESPONSE_REDIRECT_LOCATION",
          "activity.SetTag",
          "OpenTelemetry",
          "CLM"
        ],
        "telemetry_operation": {
          "type": "span",
          "target_name": null,
          "action": "ADD_ATTRIBUTES",
          "attributes_to_add": [
            {
              "name": "HTTP_REFERER",
              "value_source": "Request.Headers[\"Referer\"]"
            },
            {
              "name": "HTTP_RESPONSE_REDIRECT_LOCATION",
              "value_source": "Response.Headers[\"Location\"]"
            }
          ],
          "new_span_name": null,
          "new_metric_details": {}
        },
        "confidence": "IntentConfidence.HIGH",
        "operation_type": "OperationType.MULTI_FILE",
        "complexity_score": 4,
        "estimated_files": 2,
        "validation_result": {
          "is_valid": true,
          "confidence": "IntentConfidence.HIGH",
          "issues": [],
          "suggestions": []
        },
        "sub_tasks": [
          {
            "order": 1,
            "name": "Codebase Discovery & Design",
            "action": "locate_configuration",
            "description": "\u2022 Search the CLM solution for ActivitySource / OpenTelemetry setup.\n\u2022 Identify the project that bootstraps OpenTelemetry (e.g. Startup.cs, Program.cs or telemetry-specific Extension methods).\n\u2022 Locate any existing request/response enrichment middleware.\n\u2022 Confirm whether HTTP Server instrumentation is already enabled (AspNetCoreInstrumentation or custom ActivitySource).",
            "tools": [
              "ripgrep -i \"ActivitySource\"",
              "IDE global search for  \"SetTag(\""
            ],
            "expected_files": [
              "Startup.cs",
              "TelemetryExtensions.cs",
              "OpenTelemetryConfig.cs",
              "any Middleware (e.g. TelemetryEnrichmentMiddleware.cs)"
            ],
            "validation_criteria": "Locations of current span creation/enrichment are documented in the design notes."
          },
          {
            "order": 2,
            "name": "Static Analysis \u2013  Gap Confirmation",
            "action": "static_analysis",
            "description": "Run the static analysis query (find_method_call = \"SetTag\") to confirm neither HTTP_REFERER nor HTTP_RESPONSE_REDIRECT_LOCATION are currently set.",
            "dependencies": [
              1
            ],
            "validation_criteria": "No existing SetTag calls for the two attributes."
          },
          {
            "order": 3,
            "name": "Select Insertion Point",
            "action": "design_instrumentation",
            "description": "Decide whether to:\nA) Extend current enrichment middleware, OR\nB) Add a new dedicated TelemetryHeaderEnrichmentMiddleware placed early (for request headers) and late (for response headers) in pipeline.\nDocument the chosen approach and sequence position in Startup.cs.",
            "dependencies": [
              1
            ],
            "validation_criteria": "Design document updated with class diagram and pipeline order."
          },
          {
            "order": 4,
            "name": "Implementation \u2013  Request Header (HTTP_REFERER)",
            "action": "implement_request_enrichment",
            "description": "Inside `Invoke(HttpContext context)` of the chosen middleware:\n```\nvar referer = context.Request.Headers[\"Referer\"].FirstOrDefault();\nif (!string.IsNullOrEmpty(referer))\n{\n    Activity.Current?.SetTag(\"HTTP_REFERER\", referer);\n}\n```\nFollow existing null / empty guard patterns.",
            "dependencies": [
              3
            ],
            "expected_files_modified_or_created": [
              "TelemetryHeaderEnrichmentMiddleware.cs"
            ],
            "validation_criteria": "Code compiles; unit test shows tag exists when header present."
          },
          {
            "order": 5,
            "name": "Implementation \u2013  Response Header (HTTP_RESPONSE_REDIRECT_LOCATION)",
            "action": "implement_response_enrichment",
            "description": "After `await _next(context);` so status code & headers are set:\n```\nif (context.Response.StatusCode >= 301 && context.Response.StatusCode <= 308)\n{\n    var location = context.Response.Headers[\"Location\"].FirstOrDefault();\n    if (!string.IsNullOrEmpty(location))\n    {\n        Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", location);\n    }\n}\n```",
            "dependencies": [
              4
            ],
            "expected_files_modified_or_created": [
              "TelemetryHeaderEnrichmentMiddleware.cs"
            ],
            "validation_criteria": "Redirect unit test shows tag populated for 302."
          },
          {
            "order": 6,
            "name": "Unit Tests",
            "action": "create_unit_tests",
            "description": "Add tests using WebApplicationFactory or TestServer:\n\u2022 Assert HTTP_REFERER tag is absent/present according to header value.\n\u2022 Assert HTTP_RESPONSE_REDIRECT_LOCATION tag set only for 3xx responses.",
            "dependencies": [
              4,
              5
            ],
            "expected_files": [
              "TelemetryHeaderEnrichmentMiddlewareTests.cs"
            ],
            "validation_criteria": "All new unit tests pass in CI."
          },
          {
            "order": 7,
            "name": "Performance / PII Review",
            "action": "review_security_compliance",
            "description": "\u2022 Run benchmark (wrk / k6) on a sandbox build to ensure <1 ms overhead per request.\n\u2022 Verify Referer & Location headers do not violate existing data-handling policy. Mask or hash if required.",
            "dependencies": [
              6
            ],
            "validation_criteria": "Performance delta <2 %; compliance sign-off obtained."
          },
          {
            "order": 8,
            "name": "Integration in Demo Environment",
            "action": "deploy_demo",
            "description": "\u2022 Merge feature branch behind `Telemetry.RedirectAttributes` feature flag (default ON in Demo).\n\u2022 Deploy to Demo using existing Azure DevOps pipeline.",
            "dependencies": [
              7
            ],
            "validation_criteria": "Deployment successful; health checks green."
          },
          {
            "order": 9,
            "name": "Observability Verification",
            "action": "run_kusto_query",
            "description": "Execute expected Kusto query:\n```\nOtlpSpanEvents\n| where Environment == \"Demo\"\n| where url_path == \"/clm/Documents/BrowseDocuments.aspx\"\n| where http_status_code > 200\n| project Timestamp, url_path, http_status_code, HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION\n```",
            "dependencies": [
              8
            ],
            "validation_criteria": "Query returns rows with both new attributes populated."
          },
          {
            "order": 10,
            "name": "Rollout to All Environments",
            "action": "progressive_deployment",
            "description": "\u2022 Enable feature flag in Stage \u2192 Prod progressively (10 %, 25 %, 100 %).\n\u2022 Monitor APM metrics and error budgets for 24 h after full rollout.",
            "dependencies": [
              9
            ],
            "validation_criteria": "No increase in latency or error rate; attributes visible in Production spans."
          }
        ],
        "contextual_hints": [
          "Hooking into ASP.NET pipeline after response headers are set in order to read `Location` for 3xx",
          "Ensuring enrichment code works for both synchronous and asynchronous request paths without throwing when headers are missing"
        ],
        "similar_patterns": [
          "http_header_attribute_enrichment",
          "missing_span_attributes"
        ]
      },
      "error": null,
      "execution_time": 36.082417011260986,
      "cache_hit": false
    },
    "project_parsing": {
      "stage_name": "project_parsing",
      "status": "StageStatus.COMPLETED",
      "result": [
        "/Users/shuaib.tabit/Documents/Atlas/src/ActIntegration\\ActIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdminService\\AdminService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdvancedInsightsService\\AdvancedInsightsService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdvancedInsightsService.IntegrationTests\\AdvancedInsightsService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AgreementDefinitionModel\\AdmIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.ABAC.PDP\\API.ABAC.PDP.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation.IntegrationTests/API.Allocation.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/API.Allocation.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Authentication\\API.Authentication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Common\\API.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Content\\API.Content.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Content.EndToEndTests\\API.Content.EndToEndTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal.Common\\API.DocuSignInternal.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal.IntegrationTests\\API.DocuSignInternal.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal\\API.DocuSignInternal.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper.IntegrationTests/API.GateKeeper.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper\\API.GateKeeper.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch.EndToEndTests\\API.OpenSearch.EndToEndTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch\\API.OpenSearch.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Provisioning.IntegrationTests/API.Provisioning.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Provisioning\\API.Provisioning.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI\\API.SfGenAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WebAPI\\API.WebAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities\\API.WorkflowActivities.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities.IntegrationTests\\API.WorkflowActivities.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities.Client/API.WorkflowActivities.Client.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowDesign\\API.WorkflowDesign.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowDesign.IntegrationTests\\API.WorkflowDesign.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities\\Atlas.Workflow.Activities.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Client\\Atlas.Workflow.Client.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Readers\\Atlas.Workflow.Readers.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService\\AtlasDataManipulationService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService.IntegrationTests\\AtlasDataManipulationService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthenticationApplication\\AuthenticationApplication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthenticationApplication.IntegrationTests\\AuthenticationApplication.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthMaintenanceService\\AuthMaintenanceService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthMaintenanceService.IntegrationTests\\AuthMaintenanceService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Automation.Toolkit.Tests\\Automation.Toolkit.Tests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ChatNotification\\ChatNotification.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CodeRunner\\CodeRunner.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Collaboration.Core\\Collaboration.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Collaboration.Infrastructure\\Collaboration.Infrastructure.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ConnectServiceIntegration\\ConnectServiceIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain.Testing\\Core.Domain.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain\\Core.Domain.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework\\Core.ServiceFramework.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework.Testing\\Core.ServiceFramework.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types\\Core.Types.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRules\\CustomRules.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRuleService\\CustomRuleService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRuleService.IntegrationTests\\CustomRuleService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService\\DetectTypeService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService.IntegrationTests\\DetectTypeService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocToPDFService\\DocToPDFService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocToPDFService.IntegrationTests\\DocToPDFService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentAssembly\\DocumentAssembly.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCompareService\\DocumentCompareService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCompareService.IntegrationTests\\DocumentCompareService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCreation\\DocumentCreation.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCreation.IntegrationTests\\DocumentCreation.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElasticCore\\ElasticCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElasticIndexing\\ElasticIndexing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElectronicSignature\\ElectronicSignature.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService\\ESignatureService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService.IntegrationTests\\ESignatureService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ETL\\ETL.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ExtractService\\ExtractService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ExtractService.IntegrationTests\\ExtractService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Fax\\Fax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/FormGen\\FormGen.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GenericEventProcessor\\GenericEventProcessor.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GenericEventProcessor.IntegrationTests\\GenericEventProcessor.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GraphQLCore\\GraphQLCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/HtmlService\\HtmlService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/InboundFax\\InboundFax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/InteractivePreviewCore\\InteractivePreviewCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MaintenanceService\\MaintenanceService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MenuActions\\DocumentReviewMenuActions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService\\MessageWorkerService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/NewsService\\NewsService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/NewsService.IntegrationTests\\NewsService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ObligationManagementIntegration\\ObligationManagementIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OfficeWebAppsAPI.IntegrationTests/OfficeWebAppsAPI.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OfficeWebAppsAPI\\OfficeWebAppsAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OneConfig.Testing\\OneConfig.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients\\DacDocGenApiClient\\DacDocGenApiClient.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients\\Doc2PdfApiClient\\Doc2PdfApiClient.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OrchestrationIntegration\\OrchestrationIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEmail\\OutboundEmail.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEmail.IntegrationTests\\OutboundEmail.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEvent\\OutboundEvent.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEvent.IntegrationTests\\OutboundEvent.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundFax\\OutboundFax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundHttpService\\OutboundHttpService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Packaging\\Packaging.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/PdfService\\PdfService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProcessBuilder\\ProcessBuilder.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProfileLogger\\ProfileLogger.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProxyLayer\\ProxyLayer.Core\\ProxyLayer.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProxyLayer\\ProxyLayer.Infrastructure\\ProxyLayer.Infrastructure.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ReportingService\\ReportingService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ReportingService.IntegrationTests\\ReportingService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication\\REST.Authentication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Common\\REST.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content\\REST.Content.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.WebServices\\REST.WebServices.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/RtmIntegration\\RtmIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SANitationService\\SANitationService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SForce.Core\\SForce.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SForce.Services\\SForce.Services.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SFTPServer\\SFTPServer.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SFTPServer.IntegrationTests\\SFTPServer.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SharedTemplates\\SharedTemplates.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SMTPServer\\SMTPServer.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SMTPServer.IntegrationTests\\SMTPServer.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/StructuredDocumentService\\StructuredDocumentService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/StructuredDocumentService.IntegrationTests\\StructuredDocumentService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TaskProcessor\\TaskProcessor.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TreeService\\TreeService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TreeService.IntegrationTests\\TreeService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/UserTaskList\\UserTaskList.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback\\VendorCallback.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Testing\\Web.Common.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Abstractions/Web.Common.Abstractions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Resources/Web.Common.Resources.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common\\Web.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Web.Common.AspNetCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.Abstractions\\Web.CommonUI.Abstractions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.Resources/Web.CommonUI.Resources.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI\\Web.CommonUI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.AspNetCore\\Web.CommonUI.AspNetCore\\Web.CommonUI.AspNetCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.IntegrationTests\\Web.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Testing\\Web.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web\\Web.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebNet\\WebNet.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebNet.IntegrationTests\\WebNet.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebContent\\WebContent.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebShare\\WebShare.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap\\WebSoap.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WINS.Protocol\\WINS.Protocol.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WINS\\WINS.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CLM.Search\\dirs.proj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap.EndToEndTests\\WebSoap.EndToEndTests.csproj"
      ],
      "error": null,
      "execution_time": 0.007102012634277344,
      "cache_hit": false
    },
    "graph_building": {
      "stage_name": "graph_building",
      "status": "StageStatus.COMPLETED",
      "result": {
        "projects_count": 143,
        "graph_loaded": true
      },
      "error": null,
      "execution_time": 243.88577795028687,
      "cache_hit": false
    },
    "intelligent_search": {
      "stage_name": "intelligent_search",
      "status": "StageStatus.COMPLETED",
      "result": [
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (4 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions, Pattern: ActivitySource; Contains method call: SetTag (4 times)",
          "matching_patterns": [
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "SetTag",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Pattern: Metrics"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)",
            "?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);",
            "?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (4 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions, Pattern: ActivitySource; Contains method call: SetTag (4 times)",
          "matching_patterns": [
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "SetTag",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Pattern: Metrics"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)",
            "?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);",
            "?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "Logger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (2 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: OpenTelemetry.Metrics; Contains method call: SetTag (2 times)",
          "matching_patterns": [
            "Pattern: UseOpenTelemetry",
            "Import: DocuSign.CLM.Monitoring",
            "Pattern: OpenTelemetry",
            "SetTag",
            "Import: OpenTelemetry.Trace",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: Instrumentation",
            "Pattern: Monitoring",
            "Import: OpenTelemetry.Metrics",
            "Pattern: Metrics"
          ],
          "context_snippets": [
            "{\n\t\t\t\t\t\t\toptions.EnrichWithHttpResponse = (Activity activity, HttpResponse response) =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tactivity.SetTag(OtelSemanticConventions.AttributeHttpResponseRedirectUrl, response?.Headers[\"Location\"]);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\toptions.EnrichWithHttpRequest = (Activity activity, HttpRequest request) =>\n\t\t\t\t\t\t\t{",
            "};\n\t\t\t\t\t\t\toptions.EnrichWithHttpRequest = (Activity activity, HttpRequest request) =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tactivity.SetTag(OtelSemanticConventions.AttributeHttpReferer, request?.Headers[\"Referer\"]);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t})\n\t\t\t\t\t.AddSource(typeof(RedisSessionStateProviderWrapper).FullName);"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions; Contains method call: SetTag (3 times)",
          "matching_patterns": [
            "Import: DocuSign.Monitoring",
            "Import: DocuSign.CLM.Monitoring",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "SetTag",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Import: var activity = StartActivity(task, corrToken)",
            "Pattern: Monitoring",
            "Pattern: StartActivity"
          ],
          "context_snippets": [
            "ActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);",
            "parentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (9 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid), Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid); Contains method call: SetTag (9 times)",
          "matching_patterns": [
            "Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid)",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid)",
            "SetTag",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Import: var span = StartActivity()"
          ],
          "context_snippets": [
            "LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));",
            "LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;",
            "private Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)",
            "?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)",
            ".SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);",
            ".SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);",
            ".SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()",
            ".SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (54 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: OpenTelemetry.Trace, Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId); Contains method call: SetTag (54 times)",
          "matching_patterns": [
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid)",
            "SetTag",
            "Import: OpenTelemetry.Trace",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid)",
            "Pattern: OpenTelemetry",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: AddTag",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)",
            "Pattern: Instrumentation",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)",
            "Pattern: StartActivity",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)"
          ],
          "context_snippets": [
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);",
            "{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.StartParameters?.Submitter);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartRoutingApprovalWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t\treturn Task.FromResult(new SendStartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);",
            "{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "private void OnPostRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(HttpContext.Current);\n\t\t\tLogSessionSize(HttpContext.Current?.Session);\n\t\t\t_performanceLog.SetSession(HttpContext.Current?.Session);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tPopulateFeatureFlagContext(AtlasContext.Current.UserAccount, context);\n\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions; Contains method call: SetTag (1 times)",
          "matching_patterns": [
            "Import: OpenTelemetry.Instrumentation.AspNet",
            "Import: var activity = StartActivity()",
            "Import: DocuSign.Monitoring",
            "Import: DocuSign.CLM.Monitoring",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "SetTag",
            "Import: OpenTelemetry.Trace",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: Instrumentation",
            "Pattern: Monitoring",
            "Pattern: StartActivity",
            "Import: var activity = StartActivity()\n\t\t\t\t?.SetStatus(ActivityStatusCode.Ok)",
            "Import: OpenTelemetry.Context.Propagation"
          ],
          "context_snippets": [
            "private Activity StartActivity([CallerMemberName] string name = \"\") =>\n\t\t\tSessionStateProviderActivitySource\n\t\t\t\t.StartActivity($\"{nameof(RedisSessionStateProviderWrapper)}.{name}\")\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n\n\t\t#endregion\n\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions, Import: var activity = StartActivity(); Contains method call: SetTag (3 times)",
          "matching_patterns": [
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Import: var activity = StartActivity()",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "SetTag",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Pattern: Metrics"
          ],
          "context_snippets": [
            "{\n\t\t\tvar result = MimeLookup.GetMimeType(filePath);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))",
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.UrlMon))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);",
            "?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.UrlMon))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n\n\tstatic class MimeLookup"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions, Import: var activity = StartActivity(); Contains method call: SetTag (3 times)",
          "matching_patterns": [
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Import: var activity = StartActivity()",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "SetTag",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Pattern: Metrics"
          ],
          "context_snippets": [
            "using var stream = File.OpenRead(filePath);\n\t\t\tvar result = MimeGuesser.GuessMimeType(stream);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))",
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.MimeGuesser))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n}",
            "?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.MimeGuesser))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (5 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions, Import: var activity = StartActivity(); Contains method call: SetTag (5 times)",
          "matching_patterns": [
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Import: var activity = StartActivity()",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "SetTag",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Pattern: Metrics"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity($\"{InstrumentationNames.MediaInfo}.{name}\")\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t\t?.SetMetricName(InstrumentationNames.MediaInfo);\n\n\t\tprivate Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>",
            "private Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);",
            "private Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}",
            "activity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}",
            "?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (6 occurrences); Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "where T : IQueueTask\n\t\t=>\n\t\tactivity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);",
            "=>\n\t\tactivity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);",
            "activity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);\n\n\tpublic static Activity? SetQueueTaskResultTags<T>(this Activity? activity, T task, ProcessTaskResult result)",
            "?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);\n\n\tpublic static Activity? SetQueueTaskResultTags<T>(this Activity? activity, T task, ProcessTaskResult result)\n\t\twhere T : IQueueTask",
            "where T : IQueueTask\n\t\t=>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageResultMessage, result.Message)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageLastErrorMessage, task.LastErrorMessage);\n}\n#nullable restore",
            "=>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageResultMessage, result.Message)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageLastErrorMessage, task.LastErrorMessage);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring.HttpModules, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
          "matching_patterns": [
            "Pattern: Activity.Current",
            "Import: DocuSign.Monitoring",
            "Pattern: OpenTelemetry",
            "SetTag",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Import: DocuSign.CLM.Monitoring.HttpModules",
            "Pattern: Monitoring"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/SSO/SSOEndpoint.ashx.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (2 occurrences); Contains method call: SetTag (2 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t\t{\n#if NETFRAMEWORK\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context.ApplicationInstance?.Context);\n#else\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n#endif",
            "#if NETFRAMEWORK\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context.ApplicationInstance?.Context);\n#else\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n#endif\n\n\t\t\t\tif (!string.IsNullOrEmpty(context.Request[Constants.QueryStringParameters.SAMLResponse]))"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (15 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: var saveActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes)), Import: var loadActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid); Contains method call: SetTag (15 times)",
          "matching_patterns": [
            "Import: var loadCascadingDropdownOptionsActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid)",
            "Import: var saveActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes))",
            "Import: var refreshActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid)",
            "Import: var loadGroupSchemaActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid)",
            "Pattern: ActivitySource",
            "Pattern: OpenTelemetry",
            "SetTag",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Pattern: SetAttribute",
            "Import: var loadActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid)"
          ],
          "context_snippets": [
            "using var saveActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes));\n\t\t\tsaveActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar stopwatch = Stopwatch.StartNew();",
            "?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes));\n\t\t\tsaveActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar statusMessages = new Messages();",
            "{\n\t\t\t\tattrvm = WebUtility.HtmlDecode(attrvm);\n\t\t\t\tvar attributes = attrvm.ToObject<AttributesViewModel>();\n\t\t\t\tsaveActivity?.SetTag(\"docusign.document.id\", attributes.docUid);\n\n\t\t\t\tvar document = LoadAndValidateDocument(attributes.docUid);",
            "using var loadActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\tif (!HasSufficientRightsToView())",
            "using var loadGroupSchemaActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry",
            "using var refreshActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "using var loadCascadingDropdownOptionsActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Ajax/UploadFiles.ashx.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (2 occurrences); Contains method call: SetTag (2 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t\t{\n#if NETFRAMEWORK\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context?.ApplicationInstance?.Context);\n#else\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n#endif",
            "#if NETFRAMEWORK\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context?.ApplicationInstance?.Context);\n#else\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n#endif\n\n\t\t\t\tFileUploadInfo fileUploadInfo = null;"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/HttpRequestAuditHelper.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "public virtual void BeginRequest(HttpContext httpContext)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n\n\t\t\tif (httpContext.Handler is MvcHandler)\n\t\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Filters/MvcAuditedRequestAttribute.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (2 occurrences); Contains method call: SetTag (2 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "AttemptEventSource.Emit(counterInstanceName);\n\n#if NETFRAMEWORK\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext?.ApplicationInstance?.Context);\n#else\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n#endif",
            "#if NETFRAMEWORK\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext?.ApplicationInstance?.Context);\n#else\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n#endif\n\n\t\t\tStopwatch sw = Stopwatch.StartNew();"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Controls/FormExtensions.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (10 occurrences); Contains method call: SetTag (10 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "{\n               tag.MergeAttribute(\"id\", id);\n           }\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, Dictionary<string, string> attributes)",
            "private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, Dictionary<string, string> attributes)\n       {\n           tag.MergeAttributes(attributes);\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasImageTag(TTagBuilder tag, string spriteClassName, string additionalClassName)",
            "{\n           tag.ApplyHtmlAttributes(htmlAttributes);\n           tag.AddCssClass(\"LinkButton\");\n           SetTagContent(tag, string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Close : text);\n           if (!tag.Attributes.ContainsKey(\"onclick\"))\n           {\n               tag.Attributes.Add(\"onclick\", \"CloseWindoid();return false;\");",
            "}\n           }, TTagRenderMode.SelfClosing);\n\n           SetTagContent(tag, imageHtml);\n       }\n\n       private static THtml BuildAtlasMetadataField(THtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value, CultureInfo culture)",
            "div.ApplyHtmlAttributes(htmlAttributes);\n           div.AddCssClass(\"atlasfield\");\n           div.Attributes.Add(\"id\", $\"{member.Member.Name}Field\");\n           SetTagContent(div, labelHtml, controlHtml);\n       }\n\n       private static void ConfigureFaUxFieldFor<TModel, TValue>(TTagBuilder div, Expression<Func<TModel, TValue>> expression, object htmlAttributes, THtml labelHtml, THtml controlHtml)",
            "t.AddCssClass(\"theme_primary-dark_background-color\");\n           });\n\n           SetTagContent(div, icon, controlHtml, labelHtml, spanLine);\n       }\n\n       private static TTagBuilder BuildLabel(string name, string displayName)",
            "var tag = new TTagBuilder(\"label\");\n           tag.Attributes[\"for\"] = name;\n           tag.AddCssClass(AtlasLabelName);\n           SetTagContent(tag, displayName);\n           return tag;\n       }",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, string content)\n       {\n#if NETFRAMEWORK\n           tag.SetInnerText(content);",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, THtml htmlContent)\n       {\n#if NETFRAMEWORK\n           tag.InnerHtml = htmlContent.ToHtmlString();",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, params THtml[] htmlContents)\n       {\n#if NETFRAMEWORK\n           using (var writer = new StringWriter())"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ProfileMiddleware.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "private static void OnPostRequestHandlerExecute(HttpContext context)\n\t{\n\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\tif (HasSession(context))\n\t\t{\n\t\t\tLogSessionSize(context.Session);"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowScopeEvents/WorkflowScopeEventsController.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (6 occurrences); Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowActivities/WorkflowActivitiesController.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (6 occurrences); Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowDefinition/WorkflowDefinitionController.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (4 occurrences); Contains method call: SetTag (4 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/DocumentCreation/OpenXmlExtensions.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "return sdtElement.SdtProperties.GetFirstChild<Tag>().Val.Value;\n        }\n\n        public static void SetTag(this SdtElement sdtElement, string tag)\n        {\n            if (sdtElement == null) return;\n            if (sdtElement.SdtProperties == null) sdtElement.SdtProperties = new SdtProperties();"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (7 occurrences); Contains method call: SetTag (7 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "namespace ADEXS.Core.Domain.Utilities;\npublic static class ActivityEnricher\n{\n\tpublic static void SetTagsWithCommonFields(this Activity activity, HttpContext context)\n\t{\n\t\tif (activity == null)\n\t\t{",
            "{\n\t\tif (AtlasContext.Current != null && AtlasContext.Current.AccountId != 0 && AtlasContext.Current.AccountId != int.MinValue)\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, AtlasContext.Current.AccountId);\n\t\t\treturn;\n\t\t}",
            "var account = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(account))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, account);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}",
            "{\n\t\tif (AtlasContext.Current != null && !System.Guid.Empty.Equals(AtlasContext.Current.UserAccountUid))\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, AtlasContext.Current.UserAccountUid);\n\t\t\treturn;\n\t\t}",
            "var userId = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(userId))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userId);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}",
            "{\n\t\tif (!string.IsNullOrEmpty(context?.Session?.SessionID))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, context?.Session?.SessionID);\n\t\t}\n\t}\n#else",
            "var session = context == null ? null : GetSession(context);\n\t\tif (!string.IsNullOrEmpty(session?.Id))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, session?.Id);\n\t\t}\n\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/DocumentCreation/MergeType/RepeatingSectionMergeType.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "mergeType.Merge();\n                }\n\n                newSection.SetTag(string.Empty);\n            }\n\n            _sdtElement.Remove();"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/Workflow/Client/WorkflowV1GrpcClient.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (54 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions; Contains method call: SetTag (54 times)",
          "matching_patterns": [
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, sourceVersionUid)",
            "Import: DocuSign.CLM.Monitoring",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, userAccount.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, activityUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,\n\t\t\t\tsourceInstanceUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid,\n\t\t\t\tsourceActivityUid)",
            "SetTag",
            "Import: OpenTelemetry.Trace",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid,\n\t\t\t\trevisionUid.ToString())",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, versionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid,\n\t\t\t\trevisionUid.ToString())",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, workItemUid)",
            "Pattern: OpenTelemetry",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revision.Uid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, revision.VersionUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,\n\t\t\t\trevision.DefinitionUid)",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: Monitoring",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revisionUid)",
            "Import: DocuSign.Monitoring",
            "Pattern: ActivitySource",
            "Pattern: Instrumentation",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, version.Uid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,\n\t\t\t\tversion.DefinitionUid)",
            "Pattern: StartActivity",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid,\n\t\t\t\tactivityUid.ToString())"
          ],
          "context_snippets": [
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "headers: GetHeaders(request.User.AccountId),\n\t\t\t\t\t\t\t\tcancellationToken: cancellationToken)));\n\n\t\t\t\tactivity?.SetTag(\n\t\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,\n\t\t\t\t\tresponse.Definition.Uid);",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, versionUid);\n\n\t\treturn ExecuteWithResults(",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, versionUid);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, sourceVersionUid);\n\n\t\treturn ExecuteWithResults(",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, sourceVersionUid);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t// NOTE: can't rely on exact instance. See RemoteWorkflowClient.RouteRemoteRequest. We need to find other way. E.g. use messages.",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t// NOTE: can't rely on exact instance. See RemoteWorkflowClient.RouteRemoteRequest. We need to find other way. E.g. use messages.\n\t\tvar serviceClient = GetWinsServiceClient(user.AccountId, instanceUid);",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "object? callbackData = null)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())",
            "{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())\n\t\t\t.SetTag(",
            ".SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid,\n\t\t\t\tactivityUid.ToString());",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString());",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())\n\t\t\t.SetTag(",
            ".SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid,\n\t\t\t\tinstanceUid.ToString())\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid,\n\t\t\t\trevisionUid.ToString());",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid,\n\t\t\t\trevisionUid.ToString());",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid,\n\t\t\t\trevisionUid.ToString());",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, workItemUid);\n\n\t\tvar serviceClient = GetWinsServiceClientByWorkItem(user.AccountId, workItemUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, workItemUid);\n\n\t\tvar serviceClient = GetWinsServiceClientByWorkItem(user.AccountId, workItemUid);",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, version.Uid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, version.Uid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,\n\t\t\t\tversion.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, version.Uid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,\n\t\t\t\tversion.DefinitionUid);",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revision.Uid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, revision.VersionUid)\n\t\t\t.SetTag(",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revision.Uid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, revision.VersionUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revision.Uid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, revision.VersionUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,\n\t\t\t\trevision.DefinitionUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revision.Uid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, revision.VersionUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid,\n\t\t\t\trevision.DefinitionUid);",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, user.AccountId);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, userAccount.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, activityUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, userAccount.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, activityUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,\n\t\t\t\tsourceInstanceUid)",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, userAccount.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, activityUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,\n\t\t\t\tsourceInstanceUid)\n\t\t\t.SetTag(",
            ".SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,\n\t\t\t\tsourceInstanceUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid,\n\t\t\t\tsourceActivityUid);",
            "}\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, userAccount.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, activityUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, userAccount.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, activityUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,\n\t\t\t\tsourceInstanceUid)",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, userAccount.AccountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, activityUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,\n\t\t\t\tsourceInstanceUid)\n\t\t\t.SetTag(",
            ".SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid,\n\t\t\t\tsourceInstanceUid)\n\t\t\t.SetTag(\n\t\t\t\tWorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid,\n\t\t\t\tsourceActivityUid);",
            "int activityExecutionCount)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revisionUid);",
            "{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revisionUid);\n\n\t\treturn ExecuteWithResults(",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid)\n\t\t\t.SetTag(WorkflowServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, revisionUid);\n\n\t\treturn ExecuteWithResults(\n\t\t\tactivity,",
            "private Activity? StartActivity([CallerMemberName] string name = \"\") => _instrumentation?.ActivitySource\n\t\t?.StartActivity($\"{nameof(WorkflowV1GrpcClient)}.{name}\", ActivityKind.Client)\n\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n\n\tprivate WinsService.WinsServiceClient GetWinsServiceClientByWorkItem(int accountId, Guid workItemUid)\n\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics, Import: OpenTelemetry.Metrics; Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics",
            "Import: DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters",
            "CLM",
            "OpenTelemetry",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Import: OpenTelemetry.Metrics",
            "Config file: program.cs",
            "Pattern: Metrics"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: ADEXS.Caching.OpenTelemetry.Extensions, Import: ADEXS.CqlCorePersistence.OpenTelemetry, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
          "matching_patterns": [
            "Import: ADEXS.Caching.OpenTelemetry.Extensions",
            "Import: ADEXS.CqlCorePersistence.OpenTelemetry",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry",
            "Import: OpenTelemetry.Exporter",
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: ConfigureServices",
            "Config file: startup.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/ICoreInstrumentationLifetimeService.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace, Pattern: OpenTelemetry",
          "matching_patterns": [
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: TracerProvider",
            "Pattern: MeterProvider",
            "Config file: icoreinstrumentationlifetimeservice.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/CoreInstrumentationLifetimeService.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: ADEXS.ServiceFramework.OpenTelemetry.Extensions, Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace",
          "matching_patterns": [
            "Import: ADEXS.ServiceFramework.OpenTelemetry.Extensions",
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: TracerProvider",
            "Pattern: MeterProvider",
            "Config file: coreinstrumentationlifetimeservice.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/internal/AtlasCustomerSupport/Global.asax.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace",
          "matching_patterns": [
            "Import: DocuSign.CLM.Monitoring",
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: Activity.Current",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Monitoring",
            "Pattern: Metrics",
            "Pattern: UseOpenTelemetry"
          ],
          "context_snippets": [
            "exception = allError[allError.Length - 1];\n\t\t\t}\n\t\t\tvar guid = Activity.Current?.Id ?? Guid.NewGuid().ToString();\n\t\t\tvar message = $\"An unhandled exception occured. ReferenceId: {guid}\";\n\t\t\t_log.ErrorNoPII(message, exception);"
          ],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 95,
          "reasoning": "Telemetry infrastructure: Import: Monitoring = DocuSign.Monitoring, Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar result = WINSClientLibrary.CreateNewWorkflowDefinition(user, workflowName), Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
          "matching_patterns": [
            "Import: Monitoring = DocuSign.Monitoring",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar result = WINSClientLibrary.CreateNewWorkflowDefinition(user, workflowName)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.LoadWorkItem(user, workItemUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII(string.Format(\"SubmitWorkItem: WorkItemUid {0}, output {1}\", workItemUid, PII.Encode(output)))",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IVersionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, version.Uid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IRevisionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, revision.Uid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = new Legacy2Designer(new DefinitionReaderLegacy(oldDesign)).Convert(user)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tstring jwtToken = null",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(userAccount.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(userAccount.AccountId, sourceInstanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = WINSClientLibrary.ExportWorkflowDefinition(user, workflowName, versionNumber, revisionNumber)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, workflowName, sourceVersionNumber, sourceRevisionNumber, newVersionNumber, comment)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, sourceVersionUid, sourceRevisionNumber, newVersionNumber, comment)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tbool isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(accountId, instanceUid, revisionUid, revisionCreatedDate, activityExecutionCount, out _)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tStartParameters startParameters = new StartParameters(user, xmlParam, sourceType, sourceId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tGuid result = WorkflowRepository.SendStartWorkflow(user, workflowName, sourceType, sourceId, xmlParam)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, user.Uid, workflowName, xmlParam, sourceType, sourceId, instanceUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, revisionUid, startParameters, instanceUid)",
            "Pattern: Monitoring"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Controllers/WorkflowActivitiesController.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 95,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.Monitoring, Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid), Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
          "matching_patterns": [
            "Import: DocuSign.Monitoring",
            "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
            "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
            "Import: (_logger.BeginScope(\"AccountId: {AccountId}, UserAccountUid: {UserAccountUid}\", accountId, userAccountUid))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
            "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
            "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
            "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
            "Pattern: Instrumentation",
            "Pattern: Monitoring",
            "Pattern: StartActivity"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Program.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 90,
          "reasoning": "Telemetry infrastructure: Import: ADEXS.DetectTypeService.Telemetry.Metrics.MetricsEmitters, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics, Pattern: OpenTelemetry",
          "matching_patterns": [
            "Import: ADEXS.DetectTypeService.Telemetry.Metrics.MetricsEmitters",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Config file: program.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/AdvancedInsightsService/Program.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 90,
          "reasoning": "Telemetry infrastructure: Import: ADEXS.AdvancedInsightsService.Telemetry.MetricsEmitters, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics, Pattern: OpenTelemetry",
          "matching_patterns": [
            "Import: ADEXS.AdvancedInsightsService.Telemetry.MetricsEmitters",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Config file: program.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/CoreDomainRegistry.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 90,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/AbstractServicedComponent.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 85,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: service invocation to start process,\n\t\t\t\t\t// so Assembly.EntryAssembly is not represents correct service assembly. We are\n\t\t\t\t\t// using GetType().Assembly instead, which would provide correct release version.\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: this.GetType().Assembly))\n\t\t\t\t\t\t\t.GetAwaiter().GetResult()",
          "matching_patterns": [
            "Import: DocuSign.CLM.Monitoring",
            "Import: DocuSign.Monitoring",
            "Import: service invocation to start process,\n\t\t\t\t\t// so Assembly.EntryAssembly is not represents correct service assembly. We are\n\t\t\t\t\t// using GetType().Assembly instead, which would provide correct release version.\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: this.GetType().Assembly))\n\t\t\t\t\t\t\t.GetAwaiter().GetResult()",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Monitoring",
            "Pattern: UseOpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Ems/EmsRestClient.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 85,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnameof(SaveDocumentIngestPayload),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew ClmTimingPhase(nameof(EmsRestClient)))",
          "matching_patterns": [
            "Import: DocuSign.CLM.Monitoring",
            "Import: DocuSign.Monitoring",
            "Import: var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnameof(SaveDocumentIngestPayload),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew ClmTimingPhase(nameof(EmsRestClient)))",
            "Import: var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnameof(SaveCustomAttributeDefinition),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew ClmTimingPhase(nameof(EmsRestClient)))",
            "Import: var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource,\n                                                                nameof(FinalizeCustomAttributeDefinition),\n                                                                new ClmTimingPhase(nameof(EmsRestClient)))",
            "Import: var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource,\n\t\t\tnameof(UpdateDocumentIdOfAgreementDocument),\n\t\t\tnew ClmTimingPhase(nameof(EmsRestClient)))",
            "Pattern: Monitoring"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/UnifiedRepository/UnifiedRepositoryIngestionService.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 85,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: (var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource, CounterInstanceDetails.ProcessPermissions, CounterInstanceDetails.DocumentIngestionTiming))\n\t\t\t{\n\t\t\t\tLog.InfoNoPII($\"Processing Document Permissions\")",
          "matching_patterns": [
            "Import: DocuSign.CLM.Monitoring",
            "Import: DocuSign.Monitoring",
            "Import: (var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource, CounterInstanceDetails.ProcessPermissions, CounterInstanceDetails.DocumentIngestionTiming))\n\t\t\t{\n\t\t\t\tLog.InfoNoPII($\"Processing Document Permissions\")",
            "Import: (var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource, CounterInstanceDetails.ProcessAttributes, CounterInstanceDetails.DocumentIngestionTiming))\n\t\t{\n\t\t\tLog.InfoNoPII($\"Processing Document Attributes\")",
            "Import: (var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource, CounterInstanceDetails.AttributeSyncUsingIngestionService, CounterInstanceDetails.DocumentIngestionTiming))\n\t\t{\n\t\t\tLog.InfoNoPII($\"Processing Document Attributes\")",
            "Import: (var timer = TimingEventSourceUtilities.GetTimer(MonitoringTimingEventSource, CounterInstanceDetails.ProcessHistory, CounterInstanceDetails.DocumentIngestionTiming))\n\t\t\t{\n\t\t\t\tLog.InfoNoPII($\"Processing Document History\")",
            "Pattern: Monitoring"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/GlobalSuppressions.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/SForce.Services/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCompareService/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/ProfileLogger/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCreation/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/StructuredDocumentService/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/HtmlService/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/TreeService/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEmail/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM; Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "CLM",
            "OpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DocToPDFService/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: OpenTelemetry, CLM",
          "matching_patterns": [
            "OpenTelemetry",
            "CLM"
          ],
          "context_snippets": [],
          "confidence": 0.6
        }
      ],
      "error": null,
      "execution_time": 2.8839597702026367,
      "cache_hit": false
    },
    "advanced_analysis": {
      "stage_name": "advanced_analysis",
      "status": "StageStatus.COMPLETED",
      "result": {
        "impact_analysis": {
          "direct_impact": [
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Ajax/UploadFiles.ashx.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web/SSO/SSOEndpoint.ashx.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs"
          ],
          "indirect_impact": [
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasUrl/AuthUrl.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web/Addressbook/MVC/Models/EntityDataSource.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/AtlasWebUrl.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/InstanceWorker.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/Workflow/WorkflowConversion.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/WebUrl.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasUrl/AjaxUrl.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/BaseApiHandlerSecure.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/PerformanceLog.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebShare/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.ABAC.PDP/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.WebServices/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Persistence/Model/QueueStatePersistence.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/DocumentRepository/DocumentReader.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.WebAPI/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/Workflow/InstanceVariable.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/User/UserAccountRepository.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Activities/Helpers/UpdateVariablesHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowXmlVariableHandler.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowContext.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Helpers/InstanceStateChangedHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/CommonWebUrl.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.Authentication/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/UploadFileHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI/Global.asax.cs"
          ],
          "risk_score": 10,
          "affected_patterns": [
            "ArchitecturalPattern.SINGLETON",
            "ArchitecturalPattern.FACTORY"
          ],
          "breaking_changes": [
            "Service registration changes may affect dependency injection"
          ],
          "test_requirements": [
            "Integration tests for telemetry data collection",
            "OpenTelemetry span validation tests",
            "Service registration validation tests",
            "Middleware pipeline integration tests",
            "Unit tests for modified methods"
          ]
        },
        "code_clusters": [
          {
            "name": "Service Layer",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (11 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/InstanceWorker.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/InstanceWorker.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs"
              ]
            },
            "architectural_patterns": [
              "ArchitecturalPattern.SINGLETON"
            ],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 11
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Ajax/UploadFiles.ashx.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasUrl/AjaxUrl.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Ajax/UploadFiles.ashx.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasUrl/AjaxUrl.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasUrl/AjaxUrl.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/Addressbook/MVC/Models/EntityDataSource.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/Addressbook/MVC/Models/EntityDataSource.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web/Addressbook/MVC/Models/EntityDataSource.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (3 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 3
          },
          {
            "name": "Cluster (8 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs"
            ],
            "test_coverage": 0.0,
            "complexity_score": 8
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (4 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/AtlasWebUrl.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/SSO/SSOEndpoint.ashx.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasUrl/AuthUrl.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/WebUrl.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/AtlasWebUrl.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/SSO/SSOEndpoint.ashx.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/AtlasWebUrl.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasUrl/AuthUrl.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/WebUrl.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasUrl/AuthUrl.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web/AtlasUrl/WebUrl.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 4
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs"
              ]
            },
            "architectural_patterns": [
              "ArchitecturalPattern.FACTORY"
            ],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (3 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 3
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Service Layer",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Service Layer",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/Workflow/WorkflowConversion.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/Workflow/WorkflowConversion.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/Workflow/WorkflowConversion.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/Workflow/WorkflowConversion.cs"
              ]
            },
            "architectural_patterns": [
              "ArchitecturalPattern.SINGLETON"
            ],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 3
          }
        ]
      },
      "error": null,
      "execution_time": 0.0051021575927734375,
      "cache_hit": false
    },
    "file_selection": {
      "stage_name": "file_selection",
      "status": "StageStatus.COMPLETED",
      "result": {
        "selected_files": [
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
            "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class DetectTypeProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
            "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class VideoInfoProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net.Mime;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.PhysicalStorage;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FileIO;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.MimeLookup;\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.ContentStorage;\n\nnamespace ADEXS.DetectTypeService\n{\n\tpublic partial class DetectTypeProcessor : CommonTaskProcessor<DetectTypeTaskPayload>\n\t{\n\t\tprivate readonly IAtlasPersistenceFactory _atlasPersistenceFactory;\n\n\t\tprivate readonly IAtlasPhysicalStorageFactory _atlasPhysicalStorageFactory;\n\n\t\tprivate readonly IMimeDetector _mimeDetector;\n\n\t\tprivate readonly IDetectTypeServiceFeaturesConfig _featuresConfig;\n\n\t\tpublic DetectTypeProcessor()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IAtlasPersistenceFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IAtlasPhysicalStorageFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IMimeDetector>(),\n\t\t\t\tServiceLocator.GetInstance<IServiceInstrumentation>(),\n\t\t\t\tServiceLocator.GetInstance<IDetectTypeServiceFeaturesConfig>())\n\t\t{\n\t\t}\n\n\t\tpublic DetectTypeProcessor(\n\t\t\tIAtlasPersistenceFactory atlasPersistenceFactory,\n\t\t\tIAtlasPhysicalStorageFactory atlasPhysicalStorageFactory,\n\t\t\tIMimeDetector mimeDetector,\n\t\t\tIServiceInstrumentation serviceInstrumentation,\n\t\t\tIDetectTypeServiceFeaturesConfig featuresConfig)\n\t\t{\n\t\t\t_atlasPersistenceFactory = atlasPersistenceFactory;\n\t\t\t_atlasPhysicalStorageFactory = atlasPhysicalStorageFactory;\n\t\t\t_mimeDetector = mimeDetector;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t\t_featuresConfig = featuresConfig;\n\t\t}\n\n\t\tpublic override ProcessTaskResult ProcessTask()\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t// get and report the status of whether Optimizely is the feature flag provider\n\t\t\tLogger.InfoNoPII($\"Verification: IsOptimizelyVerificationFlagEnabled is {_featuresConfig.IsOptimizelyVerificationFlagEnabled} for account '{Task.AccountId}' (context accountId: '{AtlasContext.Current.AccountId}')\");\n\n\t\t\tProcessTaskResult result = new ProcessTaskResult();\n\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\tvar fileDataPersistence = _atlasPersistenceFactory.Get<IFileDataPersistence>(Task.AccountId);\n\n\t\t\tFileData fd = fileDataPersistence.LoadByUid(DeserializedPayload.FileDataUid);\n\t\t\tif (fd == null)\n\t\t\t{\n\t\t\t\tLogger.WarnNoPII($\"FileDataUid {DeserializedPayload.FileDataUid} does not exist in the db; ignoring\");\n\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\tresult.Message = \"Filedata Doesn't Exist\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// first try and detect the MIME type\n\t\t\t\t\tstring mimeType;\n\t\t\t\t\tusing (TempFile temp = new TempFile(fd.Extension))\n\t\t\t\t\t{\n\t\t\t\t\t\t//We could possibly optimize this by reading the first 256 bytes and passing them to the underlying COM library urlmon.dll.\n\t\t\t\t\t\t//See https://msdn.microsoft.com/en-us/library/ms775107(v=vs.85).aspx (FindMimeFromData function)\n\t\t\t\t\t\t_atlasPhysicalStorageFactory.GetPhysicalStorage(fd.AccountId).GetFile(fd.AccountId, fd.FileName, StorageConstants.StorageFormat.Native, temp.FileName);\n\t\t\t\t\t\tmimeType = _mimeDetector.DetectMimeType(temp.FileName);\n\t\t\t\t\t}\n\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected MIME type '{0}' for fileDataUid {1}.\", mimeType, fd.FileDataUid);\n\n\t\t\t\t\t// if still not sure try to map the extension to the MIME type\n\t\t\t\t\tif (string.IsNullOrEmpty(mimeType) || (mimeType == MediaTypeNames.Application.Octet))\n\t\t\t\t\t{\n\t\t\t\t\t\tmimeType = FileUtil.GetMimeTypeByExtension(fd.Extension);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Matched extension to MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\n\t\t\t\t\t// once we have a new MIME type, save it\n\t\t\t\t\tif (!string.IsNullOrEmpty(mimeType) && mimeType != fd.MIMEType)\n\t\t\t\t\t{\n\t\t\t\t\t\tfileDataPersistence.UpdateMIMEType(fd.Uid, mimeType);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected and set MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\t\t\te.Trace();\n\t\t\t\t\tLogger.ErrorNoPII($\"Failed to process fileDataUid {fd.FileDataUid} with exception \", e);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tTask.LastErrorMessage = e.Message;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.ErrorNoPII($\"Failed to mark fileDataUid {fd.FileDataUid} as failed with exception \", e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactivity?.SetQueueTaskResultTags(Task, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
            "content": "\ufeff// BUGBUG: ATL-71924 Move code dependent on System.Web out of Core.Domain\n#if NETFRAMEWORK\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.ServiceFramework.Helpers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.FeatureFlags;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing log4net;\nusing log4net.Config;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing ApplicationInfo = ADEXS.Core.Domain.Utilities.ApplicationInfo;\n\nnamespace ADEXS.Web.Common;\n\n/// <summary>\n/// Base class for all SCM web applications.\n/// </summary>\npublic abstract class ScmHttpApplication : HttpApplication\n{\n\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\t/// <summary>\n\t/// Don't use the standard Application_Start(). .Net picks one via reflection\n\t/// and runs it. Ends up being this one here, not the one in the derived class.\n\t/// </summary>\n\tprotected void ApplicationStart()\n\t{\n\t\t// log4net initialization\n\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n\t\tXmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\tConfigurationHelper.InitializeConfiguration();\n\n\t\tif (ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\n\t\t// Use MSF specific env variable, fallback to app settings.\n\t\tvar appName = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? AppConfig.AppName(ApplicationInfo.Name);\n\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? SiteConfig.Environment(\"Unknown\");\n\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\n\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\tapplicationName: appName,\n\t\t\tappVersion: typeof(ScmHttpApplication).Assembly.GetName().Version.ToString(),\n\t\t\tenvironmentName: environment,\n\t\t\tsiteName: site,\n\t\t\tpartitionName: partition,\n\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\tshouldEnableLogFileListener: () => Configuration.GetBooleanAppSetting(\"KazmonEnableLogFileListener\", false));\n\n\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t{\n\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\tassembly: typeof(ScmHttpApplication).Assembly,\n\t\t\t\t\tconfigureTracer: tracerProviderBuilder =>\n\t\t\t\t\t{\n\t\t\t\t\t\t_ = tracerProviderBuilder\n\t\t\t\t\t\t// [ATL-90561] Adding HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION to traces for NetFramework\n\t\t\t\t\t\t.AddAspNetInstrumentation(options =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toptions.EnrichWithHttpResponse = (Activity activity, HttpResponse response) =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tactivity.SetTag(OtelSemanticConventions.AttributeHttpResponseRedirectUrl, response?.Headers[\"Location\"]);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\toptions.EnrichWithHttpRequest = (Activity activity, HttpRequest request) =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tactivity.SetTag(OtelSemanticConventions.AttributeHttpReferer, request?.Headers[\"Referer\"]);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t})\n\t\t\t\t\t.AddSource(typeof(RedisSessionStateProviderWrapper).FullName);\n\t\t\t\t\t},\n\t\t\t\t\tconfigureMeter: o => o.AddAspNetInstrumentation(options => options.Enrich = (HttpContext context, ref TagList tags) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!tags.Any(t => t.Key == \"http.route\") &&\n\t\t\t\t\t\t\tcontext.Request != null &&\n\t\t\t\t\t\t\t(context.Request.Url.AbsolutePath.EndsWith(\"aspx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"asmx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"ashx\", StringComparison.OrdinalIgnoreCase)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttags.Add(\"url.path\", context.Request.Url.AbsolutePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}))).GetAwaiter().GetResult();\n\t\t\t}\n\t\t}\n\n\t\tif (!ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This one stays the standard Application_End(), as no derive class overrides it.\n\t/// </summary>\n\tprotected virtual void Application_End()\n\t{\n\t\ttry\n\t\t{\n\t\t\tLogManager.Shutdown();\n\t\t}\n\t\tcatch { }\n\n\t\tUninitializeFeatureFlags();\n\n\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t{\n\t\t\t// Run synchronously\n\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t}\n\n\t\tKazmonMonitoring.ShutdownKazmon();\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to initialize feature flags.\n\t/// </summary>\n\tprotected virtual void InitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t}\n\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application shutdown to uninitialize feature flags.\n\t/// </summary>\n\tprotected virtual void UninitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to bootstrap the dependency injection container.\n\t/// </summary>\n\tprotected virtual void Bootstrap()\n\t{\n\t}\n}\n\n#endif\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.MQ;\nusing ADEXS.Core.Domain;\nusing System.Threading;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing System.IO;\nusing ADEXS.Core.Domain.Model;\nusing System.Diagnostics;\n\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.ServiceFramework;\nusing CLM.MessageDefines;\nusing CLM.MessageDefines.Constants;\nusing CLM.MessageDefines.Interfaces;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\n\nusing StructureMap;\nusing ADEXS.MqWorkers.Config.Context;\nusing ADEXS.MqWorkers.Extensions;\nusing ADEXS.MqWorkers.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.MqWorkers.Config;\n\nnamespace ADEXS.Services.MessageWorkerService\n{\n\t//Should probably make an interface that encapsulates the methods for loading and\n\t//updating the Tasks so that we don't have to be tied to MessageQueues for this type of worker\n\tpublic class DispatchedWorker<T, U> : AbstractServiceQueue<T> where T : class, IQueueTask, new() where U : class, ITaskProcessor<T>, new()\n\t{\n\t\tprivate const string DESIRED_WORKER_COUNT = \"_WorkerCount\";\n\t\tprivate const string DESIRED_WORKER_MULTIPLIER = \"_WorkerMultiplier\";\n\t\tprivate const string TASK_DISPATCHERS = \"_TaskDispatchers\";\n\t\tprivate const string DESIRED_STAND_ALONE = \"_StandAlone\";\n\t\tprivate const string DEFAULT_TASK_DISPATCHERS = \"DefaultTaskDispatchers\";\n\t\tprivate const int DEFAULT_WORKER_COUNT = 5;\n\t\tprivate const double DEAFULT_CORE_TO_WORKER_MULTIPLIER = 0;\n\t\tprivate readonly string TASKPROCESSOR = Configuration.GetStringAppSetting(PROCESSSTART_NAME, \"ADEXS.TaskProcessor.exe\");\n\t\tprivate const string PROCESSSTART_NAME = \"PROCESSSTART_NAME\";\n\t\tprivate string _typeName;\n\t\tprivate readonly TaskTypes _taskType;\n\t\tprivate bool _standAlone;\n\n\t\tprivate readonly IContainer _container;         // optionally injected DI container\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate readonly Func<U> _createProcessor;\n\t\tprivate int _fetchMod;\n\n\t\t[ThreadStatic]\n\t\tprivate static int _errorCount = 0;\n\n\t\tpublic override string Name => base.Name + TypeName;\n\n\t\t[EventSource(\"Workers\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly PropertyBagEventSource _workersEventSource = new PropertyBagEventSource();\n\n\t\t[Counter(\"Workers Count\", \"CLM.DispatchedWorker\", MeasureProperty = \"Count\", InstanceProperty = \"Description\")]\n\t\t[EventSource(\"Workers Count\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly CountEventSource _workersCountEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\")]\n\t\t[Counter(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\", InstanceProperty = \"Description\")]\n\t\tprivate static ExceptionEventSource _workerLoggingExceptionEventSource = new ExceptionEventSource();\n\n\t\tstatic DispatchedWorker()\n\t\t{\n\t\t\t// Kazmon emits from a generic type do not work without this call\n\t\t\tMonitoringRuntime.RegisterGenericType(typeof(DispatchedWorker<T, U>));\n\t\t}\n\n\t\tpublic string TypeName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\t_typeName ??= _taskType.ToString();\n\t\t\t\treturn _typeName;\n\t\t\t}\n\t\t}\n\n\t\tpublic IMessageQueueWrapperFactory MessageQueueWrapperFactory { get; set; }\n\n\t\t/// <summary>\n\t\t/// Legacy Constructor -- delegates to the new overload; passes DI container extracted from ServiceLocator.\n\t\t/// This method will be deprecated in the future -- prefer the (IServicedComponent, IContainer) overload.\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this dispatched worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\tpublic DispatchedWorker(IServicedComponent component, TaskTypes taskType, IWatchedSingletonConfig<ISiteConfig> siteConfig) : this(component, taskType, ServiceLocator.Container, Activator.CreateInstance<U>, siteConfig)\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor overload that accepts a DI container (stepping stone to moving away from SL pattern).\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\t/// <param name=\"container\">the DI container for service discovery and IOC</param>\n\t\tinternal DispatchedWorker(IServicedComponent component, TaskTypes taskType, IContainer container, Func<U> processorFactory, IWatchedSingletonConfig<ISiteConfig> siteConfig) : base(component)\n\t\t{\n\t\t\t_container = container;\n\t\t\t_createProcessor = processorFactory ?? (() => new U());\n\t\t\tServiceLocator.BuildUp(this);\n\t\t\t_taskType = taskType;\n\t\t\t//This is here to prevent a regression following ATL-81324\n\t\t\tif (TypeName != typeof(T).Name)\n\t\t\t\tthrow new ArgumentException($\"Failed to initialize DispatchedWorker: Task Name ({typeof(T).Name}) must match task type ({TypeName})\");\n\t\t\t_waitOnNoItems = false;\n\t\t\t_standAlone = Configuration.GetBooleanAppSetting(TypeName + DESIRED_STAND_ALONE, false);\n\t\t\tif (_standAlone) _log.DebugNoPII($\"Worker running in StandAlone mode for {TypeName}\");\n\t\t\t_siteConfig = siteConfig;\n\t\t}\n\n\t\tprivate ProcessTaskResult RunExternalTaskProcessor(ProcessTaskRequest taskRequest)\n\t\t{\n\t\t\tvar accountId = taskRequest.Task.AccountId;\n\t\t\tbool useAnonymousPipes = TasksManagementFeatureFlags.UseAnonymousPipeForExternalTaskProcessors &&\n\t\t\t                         Configuration.GetBooleanAppSetting(\n\t\t\t\t                         $\"{accountId}_UseAnonymousPipeForExternalTaskProcessors\", true);\n\t\t\t_log.InfoNoPII(useAnonymousPipes\n\t\t\t\t? \"Worker using Anonymous Pipes for Request and Results\"\n\t\t\t\t: \"Worker using Temp Files for Request and Results\");\n\t\t\tExternalTaskWorker externalTaskWorker = ExternalTaskWorkerFactory.GetExternalTaskWorker(useAnonymousPipes);\n\t\t\treturn externalTaskWorker.RunExternalProcessor(taskRequest,TASKPROCESSOR);\n\t\t}\n\n\t\tprotected override int MaxQueueDepth()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_WorkerMaxQueueDepth\", Configuration.GetInt32AppSetting(TypeName + WORKER_MAXSET, WORKER_MAXSET_DEFAULT)) * DesiredWorkerCount();\n\t\t}\n\n\t\tprotected override IList<T> Fetch(int fetchCount)\n\t\t{\n\t\t\tList<T> tasks = new List<T>();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPeriodicPulse();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not pulse for ''{TypeName}''.\", ex);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttasks = FetchFromQueues(fetchCount);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not load the items for the queue: {TypeName}\", ex);\n\t\t\t\t_lastFetchDate = DateTime.UtcNow;\n\t\t\t}\n\n\t\t\tAttemptRestorePropertiesFromPayload(tasks);\n\n\t\t\treturn tasks;\n\t\t}\n\n\t\tprivate List<T> FetchFromQueues(int fetchCount)\n\t\t{\n\t\t\tvar queuePaths = DefaultQueue.GetWorkerMqPaths(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\n\t\t\t// keep incrementing to pull from a different queue on each fetch, fetching from all queues seems to have an adverse effect on the channels\n\t\t\t_fetchMod %= queuePaths.Length;\n\t\t\tvar queuePath = queuePaths[_fetchMod];\n\t\t\t_fetchMod++;\n\n\t\t\treturn FetchSingleQueue(fetchCount, queuePath);\n\t\t}\n\n\t\tprivate List<T> FetchSingleQueue(int fetchCount, string path)\n\t\t{\n\t\t\tbool isMainPath = path == DefaultQueue.GetWorkerMqPath(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\t\t\tint waitTime = isMainPath ? TaskUtilities.InitialReceiveWaitMS(TypeName) : Configuration.GetInt32AppSetting(\"InitialReceiveWaitAdditionalQueueMS\", 20);\n\t\t\tusing (IMessageQueueWrapper pdfMQ = MessageQueueWrapperFactory.CreateReceiveInstance(Configuration.GetStringAppSetting(TypeName + \"_WorkerMQPath\", path)))\n\t\t\t{\n\t\t\t\treturn pdfMQ.ReceiveMultiple<T>(waitTime, MQApplicationSettings.DefaultExtraReceiveWaitMS, fetchCount);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Restore the task type properties from the payload. This will only live temporarily as we move\n\t\t/// all tasks toward using the CommonTask payload. If we fail to restore from properties we should log to kazmon\n\t\t/// but we should not not block tasks from getting processed. We are also logging when we find a task\n\t\t/// without a payload set.\n\t\t/// </summary>\n\t\tprivate void AttemptRestorePropertiesFromPayload(List<T> tasks)\n\t\t{\n\t\t\t// App Setting to disable this behavior just in case of issues\n\t\t\tvar restoreFromPayload = Configuration.GetBooleanAppSetting($\"RestoreTaskFromPayload_All\", true) &&\n\t\t\t\tConfiguration.GetBooleanAppSetting($\"RestoreTaskFromPayload_{TypeName}\", true);\n\n\t\t\tforeach (var task in tasks)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (task is CommonTask cTask)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string.IsNullOrEmpty(cTask.Payload))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Log to kazmon to ensure that we don't miss any tasks\n\t\t\t\t\t\t\tCommonTaskPayloadHelper.CommonTaskPayloadMissingEventSource.Emit(1, cTask.Label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (restoreFromPayload)\n\t\t\t\t\t\t\t\tcTask.RestorePropertiesFromPayload();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tCommonTaskPayloadHelper.PayloadRestoreExceptionEventSource.Emit(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate QueueItemType _lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\tpublic override void AdjustWorkers()\n\t\t{\n\t\t\tbase.AdjustWorkers();\n\n\t\t\tint desiredWorkerCount = DesiredWorkerCount(out double multiplier);\n\t\t\tSetEnabled(desiredWorkerCount > 0);\n\t\t\tQueueItemType currentQueueStatus = (desiredWorkerCount > 0) ? QueueItemType.QueueStarted : QueueItemType.QueueStopped;\n\t\t\tif (currentQueueStatus == _lastSentQueueStatus) return;\n\n\t\t\tEmitWorkerConfiguration(currentQueueStatus, desiredWorkerCount, multiplier);\n\t\t\tstring adminQueuePath = \"Unset\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tT startTask = new T\n\t\t\t\t{\n\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\tQueueItemType = currentQueueStatus,\n\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t};\n\n\t\t\t\tif (!_standAlone)\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueuePath = GetAdminQueuePath(machine);\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(adminQueuePath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(startTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = currentQueueStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:AdjustWorkers - Could not contact the administration queue: \" + adminQueuePath, ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitWorkerConfiguration(QueueItemType queueItemtype, int desiredWorkerCount, double multiplier)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_workersCountEventSource.Emit(desiredWorkerCount, TypeName);\n\n\t\t\t\tusing (var propertyBag = _workersEventSource.CreateEventPropertyBag(queueItemtype.ToString()))\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TaskType\", TypeName);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"DesiredWorkerCount\", desiredWorkerCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"Multiplier\", multiplier.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ProcessorCount\", Environment.ProcessorCount.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_workerLoggingExceptionEventSource.Emit(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetMachineName() => System.Net.Dns.GetHostName();\n\t\tprivate string GetTaskTypeName() => typeof(T).FullName;\n\n\t\tprivate static int _queueStateTouchIntervalMin = 60;\n\t\tprivate DateTime _nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\n\t\tprotected virtual void PeriodicPulse()\n\t\t{\n\t\t\tif (_nextStateTouchTime < DateTime.UtcNow)\n\t\t\t{\n\t\t\t\tQueueStatePersistence.AuthenticationInstance.Touch(GetMachineName(), GetTaskTypeName());\n\t\t\t\t_nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Blast the local queue back to the dispatcher so that it can be\n\t\t/// dispatched to another worker.\n\t\t///\n\t\t/// Also sends a disable me message\n\t\t/// </summary>\n\t\tpublic override void Stop()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//Try to do a prelim kill before the stop of the workers\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch\n\t\t\t{\n\t\t\t\t_log.DebugNoPII(\"Didn't kill processes first time\");\n\t\t\t}\n\n\t\t\tbase.Stop();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSetEnabled(false);\n\t\t\t\tif (!_standAlone && (_lastSentQueueStatus != QueueItemType.QueueStopped))\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tT stopTask = new T\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\t\t\tQueueItemType = QueueItemType.QueueStopped,\n\t\t\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(machine)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(stopTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\t\t\t}\n\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:Stop - Exception generated during stop:\", ex);\n\t\t\t}\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStopped, 0, 0);\n\t\t}\n\n\t\tprivate void KillTaskProcessors()\n\t\t{\n\t\t\tvar nestedContainer = CreateNestedContainer(null);\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);  // necessary to determine if processor would run out-of-process\n\t\t\t// attempt to kill any active out-of-process processors\n\t\t\tif (processor.RunInSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t\t\tstring processName = Path.GetFileNameWithoutExtension(TASKPROCESSOR);\n\t\t\t\tProcess[] tokill = System.Diagnostics.Process.GetProcessesByName(processName);\n\t\t\t\tif (tokill.Length > 0)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"Killing {processName} processes.\");\n\t\t\t\t\tforeach (Process p in tokill)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Failed to kill process with pid: {p.Id}\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void SetEnabled(bool enable)\n\t\t{\n\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\t\t\tbool alreadySet = false;\n\t\t\tstring taskTypeName = GetTaskTypeName();\n\t\t\t_log.DebugNoPII($\"Task type: {taskTypeName}, enable set to {enable}\");\n\n\t\t\tforeach (QueueState state in QueueStatePersistence.AuthenticationInstance.LoadAll())\n\t\t\t{\n\t\t\t\tif (state.MachineName.Equals(GetMachineName(), StringComparison.InvariantCultureIgnoreCase)\n\t\t\t\t\t&& state.TaskTypeName == taskTypeName)\n\t\t\t\t{\n\t\t\t\t\tif (enable)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine already exists for task type {taskTypeName}, attempting to enable it\");\n\t\t\t\t\t\tRegisterQueueState(state);\n\t\t\t\t\t\talreadySet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine exists for task type {taskTypeName}, attempting to disable it\");\n\t\t\t\t\t\tstate.Enabled = false;\n\t\t\t\t\t\tQueueStatePersistence.AuthenticationInstance.Save(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (enable && !alreadySet)\n\t\t\t{\n\t\t\t\t// must be a new entry in the queuestate table\n\t\t\t\t_log.DebugNoPII($\"Machine does not already exist for task type {taskTypeName}, attempting to create it\");\n\t\t\t\tRegisterQueueState(null);\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// This will either create the queuestate or update\n\t\t/// it as enabled.\n\t\t/// </summary>\n\t\tprivate void RegisterQueueState(QueueState queueState)\n\t\t{\n\t\t\tif (queueState == null)\n\t\t\t{\n\t\t\t\tqueueState = new QueueState();\n\t\t\t\tType taskType = typeof(T);\n\t\t\t\tqueueState.MachineName = GetMachineName();\n\t\t\t\tqueueState.TaskAssemblyName = taskType.Assembly.GetName().Name;\n\t\t\t\tqueueState.TaskTypeName = GetTaskTypeName();\n\t\t\t\t_log.DebugNoPII($\"Creating new entry in QueueState for tasktype: {queueState.TaskTypeName}\");\n\t\t\t}\n\n\t\t\tqueueState.Enabled = true;\n\t\t\tqueueState.WorkerCount = DesiredWorkerCount(out double multiplier);\n\n\t\t\t_log.DebugNoPII($\"Saving QueueState for task type: {queueState.TaskTypeName} with properties - machine name: {queueState.MachineName},\" +\n\t\t\t\t$\"assembly name: {queueState.TaskAssemblyName} enabled: {queueState.Enabled}, worker count: {queueState.WorkerCount}\");\n\n\t\t\tQueueStatePersistence.AuthenticationInstance.Save(queueState);\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStarted, queueState.WorkerCount, multiplier);\n\t\t}\n\n\t\tprotected override TaskResult Process(T task, out string message)\n\t\t{\n\t\t\tmessage = null;\n\n\t\t\tAtlasContext.Current.AccountId = task.AccountId;\n\t\t\tAtlasContext.Current.TransactionId = task.CorrelationId;\n\t\t\tif (task is IUserTask usrTask)\n\t\t\t{\n\t\t\t\tAtlasContext.Current.UserAccountUid = usrTask.UserAccountUid;\n\t\t\t}\n\n\t\t\tGuid corrToken;\n\t\t\tGuid.TryParse(task.CorrelationId, out corrToken);\n\n\t\t\tusing var activity = StartActivity(task, corrToken);\n\n\t\t\tstring telemetryLabel = task.Label;\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\tusing (var logger = new TaskServiceRequestEventLogger(corrToken, telemetryLabel))\n\t\t\t{\n\t\t\t\t// introduces request-scoped container for user context state (and any other future per-request DI state)\n\t\t\t\tusing var nestedContainer = CreateNestedContainer(AtlasContext.Current);\n\n\t\t\t\t// The DataPoint enum is defined in DocuSign sources. Trying to use some, hopefully with close enough semantics.\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, task.AccountId);\n\t\t\t\tServiceContext.Log(DataPoint.QueueItemId, task.UniqueId);\n\t\t\t\tServiceContext.Log(DataPoint.TimeQueued, $\"{task.CreatedDate:yyyy-MM-dd HH:mm:ss.fff}\");\n\t\t\t\tif (Guid.Empty != AtlasContext.Current.UserAccountUid)\n\t\t\t\t{\n\t\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The nugget inside the monitoring wrapper.\n\t\t\t\t\tTaskResult taskResult = ProcessTask(task, nestedContainer, out message, activity);\n\n\t\t\t\t\tServiceContext.Log(DataPoint.ApiStatus, $\"{taskResult}\");\n\t\t\t\t\tlogger.Success = (taskResult != TaskResult.Failure);\n\t\t\t\t\tactivity?.SetStatusFromTask(taskResult);\n\t\t\t\t\treturn taskResult;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tex.Trace().Report();\n\t\t\t\t\tthrow;\n \t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (!logger.Success && null != message)\n\t\t\t\t\t{\n\t\t\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate TaskResult ProcessTask(T task, IContainer nestedContainer, out string message, Activity activity)\n\t\t{\n\t\t\tProcessTaskResult result = new ProcessTaskResult() { Message = \"Context Set\" };\n\n\t\t\tif (TaskUtilities.CheckSuspendedTaskTypeForAccount(TypeName, task.AccountId))\n\t\t\t{\n\t\t\t\tmessage = $\"task failed because Aid {task.AccountId} is in the suspended account list for {TypeName}\";\n\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\ttask.ErrorCount = int.MaxValue;\n\t\t\t\treturn TaskResult.Failure;\n\t\t\t}\n\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);\n\n\t\t\tAtlasContext.Current.ActionType = processor.ActionType;\n\n\t\t\tif (processor.RunInSeparateProcess && !processor.HandleSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t \t\tProcessTaskRequest taskRequest = new ProcessTaskRequest()\n\t\t\t\t{\n\t\t\t\t\tAccountId = AtlasContext.Current.AccountId,\n\t\t\t\t\tUserAccountUid = AtlasContext.Current.UserAccountUid,\n\t\t\t\t\tActionType = AtlasContext.Current.ActionType,\n\t\t\t\t\tProcessorTypeName = processor.GetType().AssemblyQualifiedName,\n\t\t\t\t\tTask = task,\n\t\t\t\t\tTaskType = _taskType,\n\t\t\t\t\tCorrelationToken = MonitoringContext.CorrelationToken ?? Guid.Empty\n\t\t\t\t};\n\t\t\t\tresult = RunExternalTaskProcessor(taskRequest);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprocessor.Task = task;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tprocessor.PreProcess();\n\t\t\t\t\tresult = processor.ProcessTask();\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tprocessor.PostProcess();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = result.Message;\n\n\t\t\tactivity?.SetQueueTaskResultTags(task, new MqWorkers.DispatchedWorker.ProcessTaskResult { Message = message });\n\n\t\t\treturn result.TaskResult;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an instance of the ITaskProcessor that should be used when processing a request.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This method takes into account whether we are using a scoped DI container, and if so, will\n\t\t/// attempt to get the task processor from there to ensure that other scoped DI services (eg user context)\n\t\t/// are also correctly set up. If the supplied `container` parameter is null we create a non-scoped\n\t\t/// processor instance, otherwise we demand it from the container (which may throw if none is registered).\n\t\t/// </remarks>\n\t\t/// <param name=\"container\">Optional (nullable) DI container from which we acquire scoped processors</param>\n\t\t/// <returns>An instance of ITaskProcessor{T} that can process the task.</returns>\n\t\tprivate U CreateTaskProcessor(IContainer container)\n\t\t{\n\t\t\t// NOTE: If we have a nested DI container, defer to it for the ITaskProcessor instance.\n\t\t\t//       If there is no nested container, or it doesn't have a ITaskProcessor registered,\n\t\t\t//       instantiate one one locally.\n\t\t\treturn container?.GetInstance<U>() ?? _createProcessor.Invoke();\n\t\t}\n\n\t\tprotected override void UpdateFailure(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//this will requeue it if needed\n\t\t\t\ttask.QueueItemType = QueueItemType.Ack;\n\t\t\t}, () =>\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Again errors should pause the movement of the items.\n\t\t\t\t * For this worker.\n\t\t\t\t */\n\t\t\t\tif (_errorCount++ % Configuration.GetInt32AppSetting(\"ErrorCountSleepMod\", 100) == 0)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(SleepMilliSeconds());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateUnlock(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//task will requeue it\n\t\t\t\ttask.QueueItemType = QueueItemType.Task;\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateSuccess(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.QueueItemType = QueueItemType.Completed;\n\t\t\t});\n\t\t}\n\n\t\tprivate void SendTaskStatusUpdate(T task, Action beforeSend, Action afterSend = null)\n\t\t{\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\t{\n\t\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\n\t\t\t\tbeforeSend();\n\n\t\t\t\tstring sendMachine = task.SendMachine; // Send() changes the SendMachine property, so store it here in case we need to restore it after an exception.\n\n\t\t\t\tusing (IMessageQueueWrapper adminQueue = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(task.SendMachine)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueue.Send(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Detected IOException.  Will retry once.\", ioe);\n\n\t\t\t\t\t\tadminQueue.ReSend(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Restore original SendMachine, for the sake of the UpdateFailure() call from AbstractServiceQueue.\n\t\t\t\t\t\ttask.SendMachine = sendMachine;\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (afterSend != null)\n\t\t\t\t{\n\t\t\t\t\tafterSend();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Crate a nested DI container for the user context (and potentially other request-scoped DI state).\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// Introduced as part of ATL-72998 to add support for feature flag integration, which requires access to\n\t\t/// the request-scoped Account/User identity for flag resolution decisions.\n\t\t/// </remarks>\n\t\t/// <param name=\"atlasContext\">Atlas request context for this request/task</param>\n\t\t/// <returns>Disposable DI container for this request-scoped state</returns>\n\t\tprivate IContainer CreateNestedContainer(IAtlasContext atlasContext)\n\t\t{\n\t\t\tvar nestedContainer = _container.GetNestedContainer();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (atlasContext != null)\n\t\t\t\t{\n\t\t\t\t\tvar userContextSetter = nestedContainer.TryGetInstance<IUserContextSetter>();\n\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tuserContextSetter.AccountId = atlasContext.AccountId;\n\t\t\t\t\t\tuserContextSetter.UserId = atlasContext.UserAccountUid; // this may be null, but that's ok\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Should we have a specific OT telemetry event for this condition? It's most like incorrectly configured DI setup, but may not be a defect.\n\t\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire IUserContextSetter - transactionId {atlasContext.TransactionId} will proceed without scoped user context.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar taskContextSetter = nestedContainer.TryGetInstance<ITaskTypeContextSetter>();\n\n\t\t\t\tif (taskContextSetter != null)\n\t\t\t\t{\n\t\t\t\t\ttaskContextSetter.TaskType = _taskType;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire ITaskTypeContextSetter - {TypeName} will proceed without scoped task type context.\");\n\t\t\t\t}\n\n\t\t\t\treturn nestedContainer;\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\tnestedContainer?.Dispose();  // avoid leaking nested container\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic virtual int StandardSleepSeconds => 5;\n\t\tprotected override int SleepSeconds()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_SleepSeconds\", StandardSleepSeconds);\n\t\t}\n\n\t\tpublic virtual int StandardWorkerCount => DEFAULT_WORKER_COUNT;\n\n\t\tpublic override int DesiredWorkerCount()\n\t\t{\n\t\t\treturn DesiredWorkerCount(out _);\n\t\t}\n\n\t\tprivate int DesiredWorkerCount(out double multiplier)\n\t\t{\n\t\t\tmultiplier = 0;\n\t\t\tint count = -1;\n\t\t\tif (IsOneConfigEnabledForWorkerCount())\n\t\t\t{\n\t\t\t\tvar mqTasksconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IMqTasksConfig>>()?.Value;\n\t\t\t\tvar taskConfigs = mqTasksconfigs?.TaskConfigs;\n\t\t\t\tif (taskConfigs != null && taskConfigs.TryGetValue(TypeName, out var taskConfig))\n\t\t\t\t{\n\t\t\t\t\tcount = taskConfig.WorkerCount;\n\t\t\t\t\tmultiplier = taskConfig.WorkerMultiplier;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Failed to retrieve task configuration from INI file for TaskName: {TypeName}. Falling back to legacy processing.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count < 0)\n\t\t\t{\n\t\t\t\t// Rely on appsetting if oneConfig is disabled or if it cannot retrive from oneconfig\n\t\t\t\tcount = Configuration.GetInt32AppSetting(TypeName + DESIRED_WORKER_COUNT, StandardWorkerCount);\n\t\t\t\tmultiplier = Configuration.GetDoubleAppSetting(TypeName + DESIRED_WORKER_MULTIPLIER, DEAFULT_CORE_TO_WORKER_MULTIPLIER);\n\t\t\t}\n\n\t\t\t// we still want to be able to force the count to zero in order to turn off a worker group effectively\n\t\t\t// let's check the worker count based on the number of logical cores and a configured multiplier\n\t\t\tif (count != 0 && multiplier > 0)\n\t\t\t{\n\t\t\t\t// use the number of logical cores and a multiplier to determine a good worker count number.\n\t\t\t\tint numCores = Environment.ProcessorCount;\n\t\t\t\tcount = Math.Max((int)(numCores * multiplier), 1);  // we really never want a > 0 multiplier to cause a zero worker count\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tprivate bool IsOneConfigEnabledForWorkerCount()\n\t\t{\n\t\t\tbool isOneConfigEnabled = false;\n\t\t\tif(ConfigWrapper.UseOneConfigMqTasksConfig)\n\t\t\t{\n\t\t\t\tvar appconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOneConfigMqTasks_\" + appconfigs?.AppName, true))\n\t\t\t\t{\n\t\t\t\t\tisOneConfigEnabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isOneConfigEnabled;\n\t\t}\n\n\t\tprivate IEnumerable<string> DispatcherMachines()\n\t\t{\n\t\t\treturn StringUtil.Split('|', Configuration.GetStringAppSetting(TypeName + TASK_DISPATCHERS, Configuration.GetStringAppSetting(DEFAULT_TASK_DISPATCHERS, GetMachineName())));\n\t\t}\n\n\t\tprivate string GetAdminQueuePath(string machine)\n\t\t{\n\t\t\treturn string.Format(Configuration.GetStringAppSetting(TypeName + \"_EventMQPathFormat\", DefaultQueue.GetAdminMqPathFormat(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName))), machine ?? GetMachineName());\n\t\t}\n\n\t\tprivate Activity StartActivity(T task, Guid correlationToken) =>\n\t\t\tServiceInstrumentation.ActivitySource\n\t\t\t\t?.StartActivity(\n\t\t\t\t\ttask.Label ?? $\"{nameof(ADEXS.Services.MessageWorkerService)}\",\n\t\t\t\t\tActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Activities.HumanActivities;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.ActivityProperties;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.ExpressionService.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Config;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\nusing ADEXS.WINS.Interfaces;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\n\nusing Platform.Common;\n\nusing SCMAppenders;\n\nusing static ADEXS.Atlas.Workflow.Activities.Handlers.InstanceHandler;\n\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing InstanceVariable = ADEXS.Core.Domain.Model.Workflow.InstanceVariable;\nusing LoggingHelper = ADEXS.Atlas.Workflow.Activities.Infrastructure.LoggingHelper;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing UserAccount = ADEXS.Core.Domain.Model.UserAccount;\n\nnamespace ADEXS.WINS.Engine\n{\n\t/// <summary>\n\t/// An instance of a workflow -- a specific example of a definition.\n\t/// This class contains methods for controlling it, but all such calls should actually be fed through\n\t/// WorkflowManager so they can be queued, etc.\n\t/// </summary>\n\tpublic class WorkflowInstance : IWINSControlInstance\n    {\n        public const int SQL_SEVERITY_LEVEL_TRANSIENT = 12;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowInstance));\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IInstanceVariableGovernance _instanceVariableGovernance;\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepository;\n\t\tprivate IGovernor _governor;\n\t\tprivate IInstanceHandler _instanceHandler;\n\t\tprivate IServiceInstrumentation _serviceInstrumentation;\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> _workflowClientConfig;\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate ICacheRepository _cacheRepository;\n\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => (_instanceVariableGovernance ?? (_instanceVariableGovernance = ServiceLocator.GetInstance<IInstanceVariableGovernance>()));\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository ?? (_workflowSettingRepository = ServiceLocator.GetInstance<IWorkflowSettingRepository>());\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\t\tprivate IInstanceHandler InstanceHandler => _instanceHandler ?? (_instanceHandler = ServiceLocator.GetInstance<IInstanceHandler>());\n\n\n\t\tprivate IServiceInstrumentation ServiceInstrumentation => _serviceInstrumentation ?? (_serviceInstrumentation = ServiceLocator.GetInstance<IServiceInstrumentation>());\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> WorkflowClientConfig => _workflowClientConfig ?? (_workflowClientConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>());\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> SiteConfig => _siteConfig ?? (_siteConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>());\n\t\tprivate ICacheRepository CacheRepository => _cacheRepository ?? (_cacheRepository = ServiceLocator.GetInstance<ICacheRepository>());\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig ?? (_workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\n\t\t/// <summary>\n\t\t/// Loads (and locks) an existing instance.  Fails if the instance doesn't exist or can't be locked.\n\t\t/// </summary>\n\t\tpublic static WorkflowInstance LoadExisting(int accountId, Guid instanceUid, IWINSDataStore data)\n        {\n\t        DateTime lockExpirationDate;\n            InstancePersistence.LockResult lockResult = data.LockInstance(accountId, instanceUid, out lockExpirationDate);\n            switch (lockResult)\n            {\n                case InstancePersistence.LockResult.AlreadyCompleted:\n                    throw new InstanceAlreadyCompletedException(string.Format(\"InstanceUid {0} is already completed\", instanceUid));\n                case InstancePersistence.LockResult.DoesNotExist:\n                    throw new ApplicationException(string.Format(\"Invalid instanceUid {0}\", instanceUid));\n                case InstancePersistence.LockResult.LockedByOther:\n                    throw new InstanceLockedException(string.Format(\"InstanceUid {0} is locked by another process\", instanceUid));\n                case InstancePersistence.LockResult.Locked:\n                    // This is our success condition\n                    break;\n                default:\n                    throw new ApplicationException(string.Format(\"Unhandled lockResult for instanceUid {0}: {1}\", instanceUid, lockResult));\n            }\n            Instance instance = data.LoadInstanceByUid(accountId, Constants.WorkflowUser, instanceUid);\n            if (instance == null) throw new ApplicationException(string.Format(\"Failed to load workflow instanceUid {1} for account {0}.\", accountId, instanceUid));\n\n\t\t\ttry\n            {\n                if (instance.ScopeUid != Guid.Empty)\n                {\n                    Scope scope = ServiceLocator.GetInstance<IDocumentScopeRepository>().GetScopeByUid(accountId, instance.ScopeUid);\n                    if (scope != null)\n                        instance.ScopeName = scope.Name;\n                }\n            }\n            catch (Exception ex)\n            {\n                // the failure to load the scope should not cause the failure to load the instance, log it and move on\n                _log.WarnNoPII(string.Format(\"Could not load the scope '{0}' for workflow instance '{1}'.\", instance.ScopeUid, instanceUid), ex);\n            }\n\n\t\t\tRevision revision = data.LoadRevisionByUid(accountId, Constants.WorkflowUser, instance.RevisionUid);\n            if (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, instance.RevisionUid));\n            // ATL-68146: Populate RevisionCreatedDate here, because LoadInstanceByUid() doesn't populate it.\n            instance.RevisionCreatedDate = revision.CreatedDate;\n            WorkflowMap workflowMap = null;\n            instance.DefinitionUid = revision.DefinitionUid;\n\n\t\t\ttry\n            {\n\t            workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n            }\n            catch (InvalidDesignDefinitionException ex)\n            {\n\t            try\n\t            {\n\t\t            new WorkflowInstance(instance, data).Abort(UserAccount.WorkflowUserAccount(accountId), ex.Message);\n\t            }\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Error aborting workflow instance '{instanceUid}' with invalid definition\", e);\n\t\t\t\t}\n\n\t            throw;\n            }\n\n            var workflowInstance = new WorkflowInstance(instance, workflowMap, data);\n\t        workflowInstance.LockExpirationDate = lockExpirationDate;\n\t        return workflowInstance;\n\n        }\n\n        private readonly IWINSDataStore _data;\n        private readonly WorkflowMap _workflowMap;\n        private Instance _instance;\n\n        // The count of the activities that have been generated by this particular in-memory instance.  This doesn't get persisted anywhere, so is\n        // cleared whenever this WorkflowInstance gets unloaded (eg, when it enters into a Waiting state).\n        // It's use is to detect runaway workflows.\n        public const int MAX_IN_MEMORY_ACTIVITY_COUNT = 5000;\n        private int _inMemoryActivityCount = 0;\n\t\tprivate int _activityExecutionCountEnforcedLimit = 0;\n\t\tprivate Guid _revisionUid = Guid.Empty;\n\t\tprivate Guid _definitionUid = Guid.Empty;\n\t\tprivate DateTime _revisionCreatedDate = DateTime.MinValue;\n\t\tprivate bool _isActivityExecutionLimitReached = false;\n\n\t\tprivate readonly object _lockObject = new object();\n        private readonly IDictionary<Guid, InstanceActivity> _unfinishedActivities = new Dictionary<Guid, InstanceActivity>();\n        private readonly Queue<Event> _queuedControlEvents = new Queue<Event>();\n        private readonly Queue<Event> _queuedEvents = new Queue<Event>();\n\n        private readonly Dictionary<string, ContentDefinition> _contentDefinitions = new Dictionary<string, ContentDefinition>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, InstanceVariable> _variables = new Dictionary<string, InstanceVariable>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, IXmlVariableDefinition> _xmlVariableDefinitions = new Dictionary<string, IXmlVariableDefinition>(StringComparer.InvariantCultureIgnoreCase);\n\n        private readonly TimedLock _lock;\n\n        // Kind of a hack -- this is kept around so that if we end the instance without reaching the End step, we have an activity that we can\n        // log the message to.\n        private Guid _lastActivityUid;\n\n        private WorkflowInstance(Instance instance, IWINSDataStore data)\n        {\n\t        _data = data;\n\t        _lock = new TimedLock(instance.Uid.ToString());\n\t        _instance = instance;\n\t\t\t_revisionUid = _instance.RevisionUid;\n\t\t\t_revisionCreatedDate = instance.RevisionCreatedDate;\n\t        LastProcessDate = DateTime.UtcNow;\n\t\t\t_definitionUid = _instance.DefinitionUid;\n\t\t}\n\n\t\tpublic WorkflowInstance(Instance instance, WorkflowMap workflowMap, IWINSDataStore data) : this(instance, data)\n        {\n            _workflowMap = workflowMap;\n            // Load up any incomplete activities.  This is pointless to do for a new workflow, but it's not expensive either,\n            // so we simply avoid trying to figure that out and simply do it.\n            QueueIncompleteActivities();\n        }\n\n        /// <summary>\n        /// The AccountId this instance is running in.\n        /// </summary>\n        public int AccountId { get { return _instance.AccountId; } }\n\n        public Dictionary<string, ContentDefinition> ContentDefinitions { get { return _contentDefinitions; } }\n\n        public IWINSDataStore DataStore { get { return _data; } }\n\n        public TimedLock ThreadLock { get { return _lock; } }\n\n        /// <summary>\n        /// An in-memory, non-persisted value -- this is used when workers are finding instances to do work on.\n        /// It acts to make the WorkflowManager more FIFO, so that some workflows don't continually get ignored in favor of\n        /// newer work coming in.\n        /// </summary>\n        public DateTime LastProcessDate { get; private set; }\n\n        /// <summary>\n        /// The model Instance object; I didn't call this Instance because I didn't want it confused with a singleton pattern, and because\n        /// I didn't like seeing \"instance.Instance\".\n        /// </summary>\n        public Instance Model { get { return _instance; } }\n\n\t\tpublic DateTime LockExpirationDate { get; set; }\n\n\t\t/// <summary>\n\t\t/// The instance's Uid.  Primary key.\n\t\t/// </summary>\n\t\tpublic Guid Uid { get { return _instance.Uid; } }\n\n        public Dictionary<string, InstanceVariable> Variables { get { return _variables; } }\n\n        public Dictionary<string, IXmlVariableDefinition> XmlVariableDefinitions { get { return _xmlVariableDefinitions; } }\n\n        public Enums.WorkflowStepStatus Status => _instance.Status;\n\n        public bool HasQueuedWork\n        {\n            get { return _queuedEvents.Count > 0 || _queuedControlEvents.Count > 0; }\n        }\n\n        public bool HasUnfinishedActivities\n        {\n            get { return _unfinishedActivities.Count > 0; }\n        }\n\n        public void QueueActivity(InstanceActivity instanceActivity)\n        {\n            lock (_lockObject)\n            {\n                _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            }\n        }\n\n\t\tpublic int ActivityExecutionCount { get; set; }\n\n\t\tpublic int ActivityExecutionCountEnforcedLimit => _activityExecutionCountEnforcedLimit;\n\n\t\tpublic bool IsActivityExecutionLimitReached => _isActivityExecutionLimitReached;\n\n\t\tpublic Guid RevisionUid => _revisionUid;\n\n\t\tpublic Guid DefinitionUid => _definitionUid;\n\n\t\tpublic DateTime RevisionCreatedDate => _revisionCreatedDate;\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\t/// <param name=\"previousActivity\"></param>\n\t\t/// <param name=\"linkName\"></param>\n\t\t/// <param name=\"localContextId\"></param>\n\t\t/// <param name=\"followEmptyPathByDefault\"></param>\n\t\t/// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n\t\tpublic void QueueActivitiesByLink(InstanceActivity previousActivity, string linkName, int localContextId = 0, bool followEmptyPathByDefault = true, bool useLinkName = false)\n        {\n            IEnumerable<WorkflowMap.Link> links;\n            bool found = false;\n            if (_workflowMap.TryGetLinks(previousActivity.Name, linkName, out links))\n            {\n                foreach (WorkflowMap.Link link in links)\n                {\n                    QueueActivityByName(previousActivity, link.ToName, localContextId, linkName, useLinkName);\n                    found = true;\n                }\n            }\n            // If we got no matches, try to go for the default (empty) output.\n            if (followEmptyPathByDefault && !found && !string.IsNullOrEmpty(linkName)) QueueActivitiesByLink(previousActivity, string.Empty, localContextId);\n        }\n\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"previousActivity\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"localContextId\"></param>\n        /// <param name=\"linkName\"></param>\n        /// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n        public void QueueActivityByName(InstanceActivity previousActivity, string name, int localContextId = 0, string linkName = null, bool useLinkName = false)\n        {\n            IWINSActivity activity;\n            if (!_workflowMap.TryGetActivity(name, out activity)) throw new ApplicationException(string.Format(\"InstanceUid {0}: Tried to execute invalid activity '{1}'\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, name)));\n\n            if (localContextId <= 0) localContextId = (previousActivity == null ? int.MinValue : previousActivity.LocalContextId);\n\n            // Create a new activity\n            InstanceActivity instanceActivity = new InstanceActivity\n            {\n                AccountId = _instance.AccountId,\n                InstanceUid = _instance.Uid,\n                Name = name,\n                ActivityTypeName = activity.LegacyElementName(),\n                Status = Enums.WorkflowStepStatus.Pending,\n                InputActivityOutput = useLinkName ? linkName : (previousActivity == null ? string.Empty : previousActivity.Output),\n                InputActivityUid = (previousActivity == null ? Guid.Empty : previousActivity.Uid),\n                LocalContextId = localContextId,\n                IsWinsActivity = true,\n                CreatedDate = DateTime.UtcNow //make sure that the in memory copy has a value\n            };\n\n            try\n            {\n                _data.CreateActivity(instanceActivity);\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorWithPII($\"Failed to queue activity {{0}} for instance {_instance?.Uid} in account {_instance?.AccountId}\", ex, name);\n                _data.ActivityFailure(_instance, instanceActivity);\n            }\n\n            _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            QueueActivity(instanceActivity);\n        }\n\n        public void QueueEvent(Event e)\n        {\n            if (_instance.Status != Enums.WorkflowStepStatus.Failed && _instance.Status != Enums.WorkflowStepStatus.Aborted)\n            {\n                lock (_lockObject)\n                {\n                    Queue<Event> queue = (e.IsControlEvent ? _queuedControlEvents : _queuedEvents);\n                    if (e.Uid != Guid.Empty)\n                    {\n                        // Ensure this item isn't already in the list\n                        if (queue.Any(e2 => e2.Uid == e.Uid)) return;\n                    }\n                    queue.Enqueue(e);\n                    WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventQueued\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n                    wrk.Log();\n\t            }\n            }\n        }\n\n        public void QueueIncompleteActivities()\n        {\n            InstanceActivities activities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n            if (activities == null || activities.Count == 0) return;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in activities) _unfinishedActivities[activity.Uid] = activity;\n            }\n\n        }\n\n        public bool CheckActivityForCompletion(InstanceActivity instanceActivity)\n        {\n            // We only care about Waiting steps.\n            if (instanceActivity.Status != Enums.WorkflowStepStatus.Waiting) return false;\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.DebugNoPII($\"CheckActivityForCompletion called for ActivityUid {instanceActivity.Uid} ({instanceActivity.Name}).\");\n\t            try\n\t            {\n\t\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\t\t            ctx.CheckForCompletion();\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t            _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n\t\t\t            SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            return true;\n\t\t            }\n                    _log.DebugWithPII($\"CheckActivityForCompletion completed for Activity ({{0}}) in status: {instanceActivity.Status}.\", instanceActivity.Name);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n                    _log.ErrorNoPII($\"CheckActivityForCompletion failed.\", e);\n\t            }\n            }\n            return false;\n        }\n\n        public bool DoNextTask()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t        CheckAndHandleInstanceStateChanges();\n\n\t\t\t// If we're in a non-processing state, we want to respond only to control events.\n\t\t\t// If we have no control events, we can just skip everything else.\n\t\t\tif (!_ShouldProcessEvent())\n\t        {\n\t\t        return _ExecuteFirstEvent(controlOnly: true);\n\t        }\n\n\t        // If we have any queued events, do one of those.\n\t        if (_ExecuteFirstEvent(controlOnly: false)) return true;\n\n\t        if (!_ShouldProcess()) return false;\n\n\t        // Otherwise, check to see if any activities need to be executed; if so, do those.\n\t        if (_ExecuteFirstActivity()) return true;\n\n\t        // If we get here, it might be that we have some unfinished activities in the database that for some reason weren't loaded into memory.\n\t        // Check for that, and, if so, load them now.\n\t        QueueIncompleteActivities();\n\t        // Try to execute an activity again -- we may have just loaded some\n\t        if (_ExecuteFirstActivity()) return true;\n\t        // If we can complete a waiting activity, do that.\n\t        if (_CheckWaitingActivities()) return true;\n\n\t        // Otherwise, we've got nothing to do and can quit.\n\t        if (!HasQueuedWork && !HasUnfinishedActivities)\n\t        {\n\t\t        _MarkCompleted();\n\t\t\t\t// If we processed nothing (the activity count is 0) we don't want to mark ourselves as waiting.  This is mostly because\n\t\t\t\t// we don't want to update our UpdatedDate (see ATL-20570).  This case occurs when our workflow is already waiting and has been\n\t\t\t\t// picked up for the day and each activity checked to see if it's done waiting.  We don't want this to trigger an update if\n\t\t\t\t// nothing has actually changed.\n\t        }\n\t        else if (_inMemoryActivityCount > 0 || _instance.Status != Enums.WorkflowStepStatus.Waiting)\n\t        {\n\t\t\t\tvar workflowConfig = WorkflowConfig(_instance.AccountId);\n\t\t\t\tvar enableSmallBenRateLimits = workflowConfig?.EnableSmallBenRateLimits ?? false;\n\n\t\t\t\tif (_instance.Status == Enums.WorkflowStepStatus.Paused\n\t\t\t\t    && ((string.Equals(ADEXS.Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.EnableExpressionApiRateLimit, \"live\", StringComparison.OrdinalIgnoreCase)\n\t\t\t\t         && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit)\n\t\t\t\t\t|| (enableSmallBenRateLimits && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit)))\n\t\t\t\t{\n\t\t\t\t\t// keep throttled workflows in paused status\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_MarkWaiting();\n\t\t\t}\n\n\t\t    return false;\n        }\n\n        public void ExecuteActivity(InstanceActivity instanceActivity)\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteActivity called for Activity ({{0}}).\", instanceActivity.Name);\n\t            IWINSWorkflowContext ctx = null;\n\t            Stopwatch sw = Stopwatch.StartNew();\n\t            try\n\t            {\n\t\t            _lastActivityUid = instanceActivity.Uid;\n\n\t\t\t\t\tif (!_ShouldProcess()) throw new ApplicationException(string.Format(\"InstanceUid {0} is in an invalid state to execute activity {1}\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, instanceActivity.Name)));\n\n\t\t            // Check for runaway workflows.\n\t\t            if (++_inMemoryActivityCount >= MAX_IN_MEMORY_ACTIVITY_COUNT)\n\t\t            {\n\t\t\t            _log.WarnNoPII(string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t\t            throw new PublicException(PublicException.FailReason.InvalidState, string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t            }\n\n\t\t\t\t\t// Governance, check if activity execution limit has been reached\n\t\t\t\t\tif (PauseWhenActivityExecutionLimitReached())\n\t\t\t\t\t{\n\t\t\t\t\t\t// In this case, the workflow is paused, purge date is set and an e-mail has been sent to support team.\n\t\t\t\t\t\t// The current activity will not be executed, unless the limits are increased and the workflow resumed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_data.ActivityExecuting(_instance, instanceActivity);\n\n\t\t            ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\t\tif (!ShouldUseScopeEventHandler() && IsTrackItActivity(activity))\n\t\t\t\t\t{\n\t\t\t\t\t\tFireWorkflowScopeEvent(null, ScopeEventType.StepInitiated, activity, ctx);\n\t\t\t\t\t}\n\n\t\t\t\t\tactivity.Execute(ctx);\n\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n\t\t\t\t\tif (e is ArgumentNullException && ctx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar message =\n\t\t\t\t            string.Format(Resources.WINSResources.ActionFailed_ReferenceID_0, Guid.NewGuid()) +\n\t\t\t\t            $\". Inst: {instanceActivity.AccountId} '{instanceActivity.InstanceUid}'.\";\n\t\t\t            _log.ErrorNoPII(message, e);\n\t\t\t\t\t\t_data.CreateInstanceHistory(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, message, true);\n\t\t            }\n\n\t\t\t\t\t// Oh my...\n\t\t\t\t\t// Look at this catch block.\n\t\t\t\t\tbool isTransient = e is TransientException;\n\t\t            bool useFailureOutput = ctx != null && activity.HasFailureOutput;\n\n\t\t            if (isTransient) throw new TransientException(e);\n\t\t            if (useFailureOutput)\n\t\t            {\n\t\t\t\t\t\tctx.ActivityVariables.Set(\"Failure\", e.Message);\n\t\t\t\t\t\tctx.MarkAsCompleted(AbstractActivity.OUTPUT_FAILURE);\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.ActivityFailure(_instance, instanceActivity);\n\t\t\t            if (ctx == null) ctx = _CreateContext(activity, instanceActivity);\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\ttry\n\t\t\t            {\n\t\t\t\t            if (_instance.Status == Enums.WorkflowStepStatus.Failed)\n\t\t\t\t            {\n\t\t\t\t\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInstanceHandler.Fail(ctx, activity, GetUnfinishedWINSWorkflowContextsWINSActivities(instanceActivity.EndDate));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAccountId = ctx.AccountId,\n\t\t\t\t\t\t\t\t\t\tScopeUid = ctx.ScopeUid,\n\t\t\t\t\t\t\t\t\t\tScopeName = ctx.ScopeName,\n\t\t\t\t\t\t\t\t\t\tStepName = instanceActivity.Name,\n\t\t\t\t\t\t\t\t\t\tStepDisplayName = GetActivityDisplayName(activity, ctx),\n\t\t\t\t\t\t\t\t\t\tStepTypeName = instanceActivity.ActivityTypeName,\n\t\t\t\t\t\t\t\t\t\tStepUid = instanceActivity.Uid,\n\t\t\t\t\t\t\t\t\t\tPeriodStart = instanceActivity.EndDate,\n\t\t\t\t\t\t\t\t\t\tEventType = (int)ScopeEventType.WorkflowFailed,\n\t\t\t\t\t\t\t\t\t\tOutput = instanceActivity.Output,\n\t\t\t\t\t\t\t\t\t\tWorkflowUid = ctx.WorkflowInstanceUid,\n\t\t\t\t\t\t\t\t\t\tWorkflowName = ctx.WorkflowName\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tEventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n\n\t\t\t\t\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Failed, instanceActivity.EndDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t            }\n\t\t\t            catch (Exception ex)\n\t\t\t            {\n\t\t\t\t        _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.WorkflowFailed}\", ex);\n\t\t\t            }\n\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n\t\t            }\n\t            }\n\t            finally\n\t            {\n\t\t            ActivityExecutionCount++;\n\t            }\n\t\t\t}\n        }\n\n        public void ExecuteCallback(InstanceActivity instanceActivity, string name, object value)\n        {\n            LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteCallback called for Activity ({{0}}) with callback {name}.\", instanceActivity.Name);\n\n\t            if (!(_ShouldProcess(instanceActivity) && _ShouldProcessEvent()))\n\t            {\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoWithPII($\"ExecuteCallback did not complete because the activity was already completed. Activity {{0}} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}. Instance status: {Model.Status}\", instanceActivity.Name);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _log.ErrorWithPII($\"InstanceUid {Uid} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}.  Instance status: {Model.Status}\");\n\t\t\t\t\t}\n\t\t            return;\n\t\t\t\t}\n\n\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\ttry\n\t\t        {\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t            activity.ExecuteCallback(ctx, name, value);\n\n\t\t            if (_instance.Status != Enums.WorkflowStepStatus.Aborted)\n\t\t            {\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\n\t\t\t\t\t// Throw so that the calling method will handle re-queuing the failed event\n\t\t\t\t\t// When resumed we will retry the recurring reminder callback\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t            catch (Exception e)\n\t            {\n\t\t\t\t\t// Note that we don't fail the workflow here -- see ATL-21019\n\t\t\t\t\tif (instanceActivity.Status == Enums.WorkflowStepStatus.Completed ||\n\t\t                Model.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoNoPII($\"The callback is unnecessary: workflow activity '{instanceActivity.Uid}' [{instanceActivity.Status}] or instance '{instanceActivity.InstanceUid}' [{Model.Status}] has already completed.\");\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t\t\t\tvar pe = e as PublicException;\n\t\t\t\t\t\t_log.ErrorNoPII($\"ExecuteCallback failed.\", pe?.InnerException ?? e);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void ExecuteEvent(Event e, bool queueOnFailure = true)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            if (e == null) return;\n\n            using var span = StartActivity();\n\n            using (ScmNDC.Push(BuildNDCTags(e)))\n            {\n\t            // If we have Uid but the lock expired we don't want to process the event as it was persisted and some other worker probably has already picked it.\n\t            if (e.Uid != Guid.Empty && e.LockExpirationDate <= LastProcessDate)\n\t            {\n\t\t            _log.InfoNoPII($\"Aborting event execution - ExecuteEvent called with an event that has an expired lock ({e.LockExpirationDate}) for callback {e.CallbackName}.\");\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t\t            return;\n\t            }\n\n\t            _log.InfoNoPII($\"ExecuteEvent called with callback {e.CallbackName}.\");\n\t            try\n\t            {\n\t\t            Stopwatch sw = Stopwatch.StartNew();\n\t\t            if (e.ActivityUid == Guid.Empty)\n\t\t            {\n\t\t\t            // We expect these to be control codes\n\t\t\t            string comment = (e.CallbackObject == null ? \"\" : e.CallbackObject.ToString());\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            case Event.ControlNames.Abort:\n\t\t\t\t\t            Abort(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForAccountCancel:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tSetPurgeDateForAccountCancel();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForRevisionSuspended:\n\t\t\t\t\t\t\t\tPauseForRevisionSuspended(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.ResumeForSuspendedRevision:\n\t\t\t\t\t\t\t\t ResumeForSuspendedRevision(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.Pause:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t            case Event.ControlNames.Resume:\n\t\t\t\t\t            Resume(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.ResumeFromError:\n\t\t\t\t\t            ResumeFromError(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.StartActivity:\n\t\t\t\t\t            QueueActivityByName(null, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            default:\n\t\t\t\t\t            throw new ApplicationException(string.Format(\"Unhandled event {0}\", e.CallbackName));\n\t\t\t            }\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            // These *may* be control codes.  If they're not control codes, then\n\t\t\t            // we expect them to be a callback to an activity.\n\t\t\t            InstanceActivity activity;\n\t\t\t            if (!_unfinishedActivities.TryGetValue(e.ActivityUid, out activity)) activity = _data.LoadActivityByUid(_instance.AccountId, Constants.WorkflowUser, e.ActivityUid);\n\t\t\t            if (activity == null || activity.InstanceUid != e.InstanceUid) throw new ApplicationException(string.Format(\"Invalid ActivityUid {0} for InstanceUid {1}\", e.ActivityUid, e.InstanceUid));\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            // TODO: Start specific steps, fire specific outputs, complete specific steps, etc.\n\t\t\t\t            default:\n\t\t\t\t\t            ExecuteCallback(activity, e.CallbackName, e.CallbackObject);\n\t\t\t\t\t            break;\n\t\t\t            }\n\t\t            }\n\t\t            if (e.Uid != Guid.Empty) _data.EventSuccess(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventExecuted\")\n\t\t\t\t\t{\n\t\t\t\t\t\tTotalMs = sw.ElapsedMilliseconds,\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid, WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t            wrk.Log();\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t            catch (Exception excp)\n\t            {\n\t\t            _log.ErrorNoPII($\"Error processing eventUid {e.Uid} ({e.CallbackName}).\", excp);\n\t\t            if (!queueOnFailure) throw;\n\t\t            if (e.Uid == Guid.Empty)\n\t\t            {\n\t\t\t            e.NextProcessDate = _data.NextProcessDate();\n\t\t\t            e.ErrorCount = 1;\n\t\t\t            e.LastErrorMessage = excp.Message;\n\t\t\t            _data.CreateEvent(e);\n\t\t\t            WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnExecuteException\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t\t};\n\t\t\t            wrk.Log();\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.EventFailure(e.AccountId, e.Uid, _data.NextProcessDate(), excp.Message);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void Abort(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in _unfinishedActivities.Values)\n                {\n\t                try\n\t                {\n\t\t                IWINSActivity winsActivity = _SafeGetActivity(activity);\n\t\t                IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n\t\t                winsActivity.OnActivityAborted(ctx);\n\t                }\n\t                catch (Exception ex)\n\t                {\n\t\t                _log.ErrorNoPII(string.Format(\"Failed OnActivityAborted AccountId {0}, ActivityUid {1}\", user.AccountId, activity.Uid), ex);\n\t\t\t\t\t}\n                }\n                new WorkflowControlInstance(Model).Abort(user, comment);\n\n\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t{\n\t\t\t\t\tInstanceHandler.Abort(_instance, user, GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime.UtcNow));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Aborted, DateTime.UtcNow);\n\t\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowAborted);\n\t\t\t\t}\n\n\t\t\t\t_ForceReload();\n            }\n        }\n\n        public int SetPurgeDateForAccountCancel()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        var daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForAccountCancel();\n\t\t        _ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t        }\n        }\n\n        public void ClearPurgeDate()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        new WorkflowControlInstance(Model).ClearPurgeDate();\n\t\t        _ForceReload();\n\t        }\n        }\n\n\t\tpublic void Pause(UserAccount user, string comment)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Pause - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).Pause);\n\t\t}\n\n\t\tpublic void PauseForRevisionSuspended(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status == Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - No action taken, instance already paused\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).PauseForRevisionSuspended);\n\t\t}\n\n\t\tpublic void ResumeForSuspendedRevision(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status != Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, instance not paused. Status:{Model.Status}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if instance UpdatedBy has changed since the PauseForRevisionSuspended was invoked, if it has we do not want to do anything.\n\t\t\tif (Model.UpdatedBy != WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, UpdatedBy is not {WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - Resuming\");\n\t\t\tResume(user, comment);\n\t\t\tClearPurgeDate();\n\t\t}\n\n\t\tpublic bool PauseWhenActivityExecutionLimitReached()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Governance, check whether the number of executed activities exceeded the configured limit\n\t\t\t\t_isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(AccountId, Uid, _instance.RevisionUid, _instance.RevisionCreatedDate, ActivityExecutionCount, out _activityExecutionCountEnforcedLimit);\n\n\t\t\t\tif (_isActivityExecutionLimitReached)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum limit (Actual={ActivityExecutionCount}, EnforcedLimit={_activityExecutionCountEnforcedLimit}) and will be paused.\");\n\n\t\t\t\t\tPause(UserAccount.WorkflowUserAccount(AccountId), \"Workflow activity execution limit reached.\");\n\n\t\t\t\t\tTrySendActivityExecutionLimitExceedNotification(SetPurgeDateForAccountCancel());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' activity execution limit\", e);\n\t\t\t}\n\n\t\t\treturn _isActivityExecutionLimitReached;\n\t\t}\n\n\t\tpublic void PauseWhenThrottled(InstanceActivity activity, WorkflowApiRequestThrottledException exception)\n\t\t{\n\t\t\tRequires.NotNull(activity, nameof(InstanceActivity));\n\t\t\tRequires.NotNull(exception, nameof(WorkflowApiRequestThrottledException));\n\n\t\t\tif (exception.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.NotThrottled)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' is not throttled and will not be paused.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tactivity.Status = Enums.WorkflowStepStatus.Paused;\n\t\t\t\tvar throttledByApi = exception.ThrottledApiAsString();\n\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum {throttledByApi} request limit and will be paused. Message: {exception.Message}\");\n\n\t\t\t\tPauseInstance(UserAccount.WorkflowUserAccount(AccountId), $\"{throttledByApi} requests limit reached.\", new WorkflowControlInstance(Model).PauseForWorkflowRateLimitExceed);\n\n\t\t\t\t// Send notification\n\t\t\t\tswitch (exception.WorkflowThrottledStatus)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit:\n\t\t\t\t\t\tTrySendExpressionRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit:\n\t\t\t\t\t\tTrySendSmallBenRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_log.WarnNoPII(\"No notifications sent for unsupported throttle status\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mark instance as throttled for current workflow run session, WorkflowThrottledStatus property is not persisted and refreshed on reload\n\t\t\t\t_instance.WorkflowThrottledStatus = exception.WorkflowThrottledStatus;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception e)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' rate limit request limit with status {exception?.WorkflowThrottledStatus}\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublic int SetPurgeDateForWorkflowRateLimit()\n\t\t{\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tvar daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForWorkflowRateLimit();\n\t\t\t\t_ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid GetAdvancedWorkflowNotificationUserAccountUid()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while retrieving AdvancedWorkflowNotificationUserAccountUid for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\t\t}\n\n\t\tpublic void TrySendSmallBenRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\t// Send notification - pending ATL-90622\n\t\t}\n\n\t\tpublic void TrySendExpressionRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\tif (!ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetEnableWorkflowLimitNotifications(AccountId))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"EnableWorkflowLimitNotifications disabled for account {AccountId}, not sending expression rate limit exceeded notification\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (advancedWorkflowNotificationUserAccountUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {advancedWorkflowNotificationUserAccountUid} to receive expression rate limit exceeded notification\");\n\t\t\t\tUserAccount notificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, advancedWorkflowNotificationUserAccountUid);\n\n\t\t\t\tif (string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"AdvancedWorkflowNotificationUser '{advancedWorkflowNotificationUserAccountUid}' not found or missing email address. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar emailRecipients = new List<string>() { notificationUser.EmailAddress };\n\n\t\t\t\t_log.InfoNoPII($\"Sending expression rate limit exceeded notification to user '{advancedWorkflowNotificationUserAccountUid}' for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseExpressionRateLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowInstanceId = _instance.Id,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Resume(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).Resume(user, comment);\n                _ForceReload();\n            }\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Resume(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n        }\n\n        public void ResumeFromError(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).ResumeFromError(user, comment);\n                _ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.ResumeFromError(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n\t\t}\n\n        public void SaveToDatabase()\n        {\n            // We may have in-memory events that need to be saved to the db.\n\t\t\tPersistEvents();\n            _PersistVariables();\n        }\n\n        public void SaveEventsToDatabase()\n        {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPersistEvents();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save unsaved events for instance {Uid} to db\", e);\n\t\t\t}\n\t\t}\n\n\t    public void ArchiveVariables()\n        {\n            var incompleteActivities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, _instance.Uid);\n            // don't archive if there are any incomplete activites besides the one that has triggered this\n            if (incompleteActivities != null && incompleteActivities.Count > 1)\n            {\n                return;\n            }\n            _data.ArchiveVariables(AccountId, Constants.WorkflowUser, Uid);\n        }\n\n\t    public bool HasExistingLockExpired()\n\t    {\n\t\t    return LockExpirationDate < DateTime.UtcNow;\n\t    }\n\n\n        /// <summary>\n        /// Replaces variables provided in the dictionary returning replaced variables\n        /// </summary>\n        public void SetVariables(\n\t        InstanceActivity instanceActivity,\n\t        Dictionary<string, object> variables,\n\t        out List<InstanceVariable> oldVariables,\n\t        out bool areVariablesOverTotalSizeLimit,\n\t        out int totalVariablesSizeBytes,\n\t        out int totalVariablesSizeLimitBytes,\n\t\t\tout Dictionary<string, int> oversizedVariables,\n\t        out int variableValueSizeLimitBytes)\n        {\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            _log.DebugWithPII($\"SetVariables called for ActivityUid {instanceActivity.Uid} ({{0}}).\", instanceActivity.Name);\n\n            // We create the context so that the variable dictionaries get populated\n            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n            oldVariables = new List<InstanceVariable>();\n            var newVariables = UpdateVariablesHelper.PopulateContextVariables(ctx, this.Model, variables);\n\n            // Only set variables that are under the size limit\n\t\t\toversizedVariables = InstanceVariableGovernance.GetOversizedVariables(ctx.AccountId, newVariables, ctx.SubmittedDate, out variableValueSizeLimitBytes);\n\t\t\tforeach (InstanceVariable variable in newVariables)\n\t\t\t{\n\t\t\t\tif (!oversizedVariables.ContainsKey(variable.Name))\n\t\t\t\t{\n\t\t\t\t\toldVariables.Add(Variables[variable.Name]);\n\t\t\t\t\t// we could do \"ctx.Variables.Set(variable.Key, variable.Value);\" but that would log as the instanceActivity and we don't want that...\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Undo setting the variables, if the instance's total variable size exceeds the limit\n\t\t\tareVariablesOverTotalSizeLimit = InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(ctx.AccountId,\n\t\t\t\tVariables.Select(x => x.Value), ctx.SubmittedDate, activityConfiguration: null, out totalVariablesSizeBytes, out totalVariablesSizeLimitBytes);\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tforeach (InstanceVariable variable in oldVariables)\n\t\t\t\t{\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n        }\n\n        public DateTime GetLastAbortNotificationDate()\n        {\n\t        if (!_contextInitialized)\n\t        {\n\t\t        _LoadVariables();\n            }\n\n\t        if (_variables.TryGetValue(WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE, out InstanceVariable lastNotificationDate) &&\n\t            DateTime.TryParse(lastNotificationDate.Value.ToString(), out DateTime dateTime))\n\t        {\n\t\t        return dateTime;\n\t        }\n\n            return DateTime.MinValue;\n        }\n\n        public void SaveLastAbortNotificationDate(int accountId, Guid workflowInstanceUid, DateTime lastAbortNotificationDate)\n        {\n            var variable = InstanceVariable.CreateFromValue(\n\t            accountId,\n\t            workflowInstanceUid,\n\t            WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE,\n\t            Enums.WorkflowVariableType.Date,\n\t            lastAbortNotificationDate);\n\n            ServiceLocator.GetInstance<IInstanceVariablePersistence>().Save(Constants.WorkflowUser, variable);\n\n        }\n\n        /// <summary>\n        /// Called when we've finished work on an activity -- either executing it or performing a callback on it.\n        /// </summary>\n        private void _ActivityWorkCompleted(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx, Stopwatch sw)\n        {\n\t        // If it's flagged as completed, update in the db, queue up any next activities, and remove it from our list.\n            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n            {\n                _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n                SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t\tlock (_unfinishedActivities)\n                {\n                    if (_unfinishedActivities.ContainsKey(instanceActivity.Uid)) _unfinishedActivities.Remove(instanceActivity.Uid);\n                }\n            }\n            else\n            {\n                // Otherwise, it's still running.  Flag it as waiting so it doesn't get processed again.\n                instanceActivity.Status = Enums.WorkflowStepStatus.Waiting;\n                _data.SaveInstanceActivity(instanceActivity);\n            }\n\n            _log.InfoWithPII($\"_ActivityWorkCompleted done for Activity ({{0}}) in status: {instanceActivity.Status} ({sw.ElapsedMilliseconds} ms).\", instanceActivity.Name);\n\n\n            // log workload data\n            try\n            {\n                WorkflowWorkload ww = new WorkflowWorkload();\n                ww.Add(ctx);\n                ww.TotalMs = sw.ElapsedMilliseconds;\n\t\t\t\tww.StartTime = DateTime.UtcNow.AddMilliseconds(-ww.TotalMs);\n                ww.Status = instanceActivity.Status.ToString();\n                ww.Output = instanceActivity.Output;\n                ww.ActivityCreatedDate = instanceActivity.CreatedDate;\n                ww.ActivityStartDate = instanceActivity.StartDate;\n                if (DateTime.MinValue < instanceActivity.EndDate && instanceActivity.EndDate < DateTime.MaxValue)\n                    ww.ActivityEndDate = instanceActivity.EndDate;\n                if (DateTime.MinValue < _instance.CreatedDate && _instance.CreatedDate < DateTime.MaxValue)\n\t                ww.InstanceCreatedDate = _instance.CreatedDate;\n                ww.ActivityKind = activity.Kind.ToString();\n                ww.RevisionUid = _instance.RevisionUid.ToString();\n\t\t\t\tww.DefinitionUid = _instance.DefinitionUid.ToString();\n\t\t\t\tww.WorkflowDB = DataStore.GetDbNameForAccount(instanceActivity.AccountId);\n\n\t\t\t\tww.Log();\n            }\n            catch (Exception ex)\n            {\n                _log.WarnNoPII(\"Failed to log workload.\", ex);\n            }\n        }\n\n\t\tprivate void CompleteScopeStep(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n            try\n            {\n                if (IsTrackItActivity(activity))\n                {\n                    Documents documents = null;\n                    if (ctx.TrackActivity())\n                    {\n                        documents = ((ITrackItActivity)activity).GetDocuments(ctx);\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, instanceActivity.Uid,\n                            documents, instanceActivity.Output, instanceActivity.Status,\n                            instanceActivity.EndDate);\n                    }\n\n                    WorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n                    {\n                        AccountId = ctx.AccountId,\n                        Documents = documents?.Select(d => new WorkflowScopeEvent.DocumentDetail() { Uid = d.Uid, Name = d.Name }).ToList(),\n                        ScopeUid = ctx.ScopeUid,\n                        ScopeName = ctx.ScopeName,\n                        StepName = instanceActivity.Name,\n                        StepDisplayName = GetActivityDisplayName(activity, ctx),\n                        StepTypeName = instanceActivity.ActivityTypeName,\n                        StepUid = instanceActivity.Uid,\n                        PeriodStart = instanceActivity.EndDate,\n                        EventType = (int)ScopeEventType.StepFinished,\n                        Output = instanceActivity.Output,\n                        WorkflowUid = ctx.WorkflowInstanceUid,\n                        WorkflowName = ctx.WorkflowName\n                    };\n                    WorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n                    {\n                        EventData = scopeEventData\n                    };\n                    EventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.StepFinished}\", ex);\n            }\n        }\n\n        private void SaveInstanceActivityVariables(InstanceActivity instanceActivity, IWINSWorkflowContext ctx)\n        {\n\t        if (ctx.WorkflowUserAccount.Account.Settings.EnableWorkflowVariableHistory)\n\t        {\n\t\t        var instanceVariableRepository = ServiceLocator.GetInstance<IInstanceVariableRepository>();\n\t\t        instanceVariableRepository.SaveVariableHistory(instanceActivity.AccountId, ctx.WorkflowUserAccount.Uid,\n\t\t\t        instanceActivity.InstanceUid, instanceActivity.Uid, ctx.Variables.GetAllVariables());\n\t        }\n        }\n\n        private List<WINSWorkflowContextWINSActivity> GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime endDate)\n        {\n\t\t\tvar list = new List<WINSWorkflowContextWINSActivity>();\n\n\t\t\tif (!HasUnfinishedActivities) return list;\n\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values);\n            }\n\n            IWINSWorkflowContext ctx = null;\n            foreach (var activity in activities)\n            {\n                var winsActivity = _SafeGetActivity(activity);\n                ctx = _CreateContext(winsActivity, activity);\n\n                if (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n                {\n\t\t\t\t\tlist.Add(new WINSWorkflowContextWINSActivity { EndDate = endDate, WINSActivity = winsActivity, WINSWorkflowContext = ctx });\n\t\t\t\t}\n            }\n\n\t\t\treturn list;\n        }\n\n\t\tprivate void AbortOrFailScopeStep(Enums.WorkflowStepStatus status, DateTime endDate)\n\t\t{\n\t\t\tif (!HasUnfinishedActivities) return;\n\n\t\t\tList<InstanceActivity> activities;\n\t\t\tlock (_unfinishedActivities)\n\t\t\t{\n\t\t\t\tactivities = new List<InstanceActivity>(_unfinishedActivities.Values);\n\t\t\t}\n\t\t\tIWINSWorkflowContext ctx = null;\n\t\t\tforeach (var activity in activities)\n\t\t\t{\n\t\t\t\tvar winsActivity = _SafeGetActivity(activity);\n\t\t\t\tctx = _CreateContext(winsActivity, activity);\n\n\t\t\t\tif (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n\t\t\t\t{\n\t\t\t\t\tvar documents = ((ITrackItActivity)winsActivity).GetDocuments(ctx);\n\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, activity.Uid, documents, null, status, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool _CheckWaitingActivities()\n        {\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values.Where(n => n.Status == Enums.WorkflowStepStatus.Waiting));\n            }\n            bool success = false;\n            foreach (InstanceActivity activity in activities)\n            {\n                if (CheckActivityForCompletion(activity)) success = true;\n            }\n            return success;\n        }\n\n        private bool _contextInitialized = false;\n        private IWINSWorkflowContext _CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n            IWINSWorkflowContext ctx = CreateContext(activity, instanceActivity);\n            AtlasContext.Current.UserAccount = ctx.WorkflowUserAccount;\n            // Only do this once.  If it's been done, it's done.\n            if (_contextInitialized) return ctx;\n\n            // This all depends on the properties for the Start step.  We always want a Start step for normal processing;\n            // however, we don't necessarily have a Start step for our tests.\n            StartActivity start = _workflowMap.StartActivity;\n            if (start == null)\n            {\n                if (_data.IsTest) return ctx;\n                throw new ApplicationException(string.Format(\"Cannot find StartActivity for InstanceUid {0}\", _instance.Uid));\n            }\n\n            // Contents\n            string[][] contents = start.DefinedContents;\n            if (contents != null && contents.Length > 0)\n            {\n                foreach (string[] t in contents)\n                {\n                    ContentDefinition definition = new ContentDefinition(t);\n                    if (!_contentDefinitions.ContainsKey(definition.Name)) _contentDefinitions[definition.Name] = definition;\n                }\n            }\n\n            _LoadVariables();\n\n            // XML Variables\n            // Because XmlVariables have dependencies on the variables as well, it's easier to feed this through the xml variable handler\n            // rather than replicate the code.\n            List<IXmlVariableDefinition> definitions = start.DefinedXmlVariables;\n            if (definitions != null && definitions.Count > 0)\n            {\n                foreach (IXmlVariableDefinition definition in definitions)\n                {\n                    if (!_xmlVariableDefinitions.ContainsKey(definition.Name)) ctx.XmlVariables.Declare(definition, logMessage: false);\n                }\n            }\n\n            _contextInitialized = true;\n            return ctx;\n\t\t}\n\n        public IWINSWorkflowContext CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowContextFactory>().CreateWorkflowContext(this, activity, instanceActivity);\n        }\n\n\t\tprivate void _LoadVariables()\n        {\n\t        // Variables\n\t        Dictionary<string, InstanceVariable> variables = _data.LoadVariablesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n\t        foreach (InstanceVariable variable in variables.Values)\n\t        {\n\t\t        if (!_variables.ContainsKey(variable.Name)) _variables[variable.Name] = variable;\n\t        }\n        }\n\n        private bool _ExecuteFirstActivity()\n        {\n            InstanceActivity activity = null;\n            lock (_unfinishedActivities)\n            {\n                if (_unfinishedActivities.Count > 0) activity = _unfinishedActivities.Values.FirstOrDefault(n => n.Status == Enums.WorkflowStepStatus.Pending || n.Status == Enums.WorkflowStepStatus.Executing);\n            }\n            if (activity == null) return false;\n            ExecuteActivity(activity);\n            return true;\n        }\n\n        private bool _ExecuteFirstEvent(bool controlOnly = false)\n        {\n            // We always try to execute control events first.\n            Event e = null;\n            lock (_queuedControlEvents)\n            {\n                if (_queuedControlEvents.Count > 0) e = _queuedControlEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            // If we're only caring about control events, we can quit now.\n            if (controlOnly) return false;\n\n            // Otherwise, we do the same thing with the rest of the events.\n            lock (_queuedEvents)\n            {\n                if (_queuedEvents.Count > 0) e = _queuedEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            return false;\n        }\n\n        private void _ForceReload()\n        {\n            // Reload the object to get new state -- we do this inside the lock so that there's no race condition\n            // between this and a worker who may be working on the object\n            lock (_lockObject)\n            {\n                Guid instanceUid = Uid;\n                _instance = _data.LoadInstanceByUid(AccountId, Constants.WorkflowUser, instanceUid);\n                if (_instance == null) throw new ApplicationException(string.Format(\"Failed to reload instanceUid: {0}\", instanceUid));\n            }\n        }\n\n        private void _MarkCompleted()\n        {\n\t        if (_instance.IsCompleted)\n\t        {\n\t\t        _log.InfoNoPII($\"Instance {_instance.Uid} is already complete with status {_instance.Status}\");\n\t\t        return;\n\t        }\n\n            _PersistVariables();\n            bool endActivityFailure = _workflowMap.HasEndActivity() && !_instance.EndActivityReached;\n            Enums.WorkflowStepStatus endStatus = endActivityFailure ? Enums.WorkflowStepStatus.Failed : Enums.WorkflowStepStatus.Completed;\n            _data.SaveInstance(_instance);\n            _data.InstanceCompleted(_instance, endStatus);\n\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Complete(_instance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventType = _instance.Status == Enums.WorkflowStepStatus.Failed ? ScopeEventType.WorkflowFailed : ScopeEventType.WorkflowFinished;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t{\n\t\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\t\tPeriodStart = _instance.EndDate,\n\t\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\t\tWorkflowName = _instance.Name\n\t\t\t\t\t};\n\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t\t{\n\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t};\n\t\t\t\t\tEventRepo.FireEvent(_instance.AccountId, scopeEvent);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event {_instance.ScopeUid} for eventtype {eventType}\", ex);\n\t\t\t\t}\n\t\t\t}\n\n            if (endActivityFailure && _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                if (_lastActivityUid == Guid.Empty)\n                {\n                    _log.WarnNoPII($\"No activities for workflow.\");\n                }\n                else\n                {\n                    InstanceActivity activity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, _lastActivityUid);\n                    IWINSActivity winsActivity = _SafeGetActivity(activity);\n                    IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n                    LoggingHelper.LogActivityErrorNoPII(ctx, Resources.WINSResources.WorkflowExitedWithoutReachingTheEndActivity);\n                }\n\n            }\n            if (_instance.Status == Enums.WorkflowStepStatus.Completed || _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n            }\n        }\n\n        private void _MarkWaiting()\n        {\n            _PersistVariables();\n            _instance.Status = Enums.WorkflowStepStatus.Waiting;\n            _data.SaveInstance(_instance);\n        }\n\n        private void _PersistVariables()\n        {\n            InstanceVariables variables = new InstanceVariables();\n            foreach (InstanceVariable variable in _variables.Values) if (variable.IsModified) variables.Add(variable);\n            _data.SaveInstanceVariables(AccountId, Constants.WorkflowUser, variables);\n        }\n\n        private void PersistEvents()\n\t\t{\n\t\t\tlock (_queuedControlEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedControlEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedControlEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlock (_queuedEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        private void PersistEvent(Event e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_data.CreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_data.UnlockEvent(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventUnlockedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save event {e.Uid}, for instance {e.InstanceUid}, activity {e.ActivityUid}, and callback name {e.CallbackName} to db\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate IWINSActivity _SafeGetActivity(InstanceActivity instanceActivity)\n        {\n            try\n            {\n                IWINSActivity activity;\n                if (_workflowMap.TryGetActivity(instanceActivity.Name, out activity)) return activity;\n                // There is a problem with old MWF workflow data where the name of the activity is really the type name.\n                // Don't ask.  It's a stupid and boring story.\n                // But we still should handle it, at least for awhile.  So: if we get here because we didn't match name, we should see\n                // if we match type name.\n                // This whole thing is a huge hack that should get removed when it can.\n                InstanceActivity inputActivity = null;\n                if (instanceActivity.InputActivityUid != Guid.Empty) inputActivity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, instanceActivity.InputActivityUid);\n                if (_workflowMap.LegacyTryGetActivityByTypeName(instanceActivity.Name, inputActivity == null ? \"\" : inputActivity.Name, instanceActivity.InputActivityOutput ?? \"\", out activity))\n                {\n                    // Rename it so we get one less instance of this in the future\n                    instanceActivity.Name = activity.Name;\n                    return activity;\n                }\n                throw new ApplicationException(string.Format(\"Invalid activity name '{0}' for instanceUid '{1}'.\", instanceActivity.Name, instanceActivity.InstanceUid));\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"_SafeGetActivity failed.\", e);\n                return null;\n            }\n        }\n\n        private bool _ShouldProcess(InstanceActivity instanceActivity)\n        {\n            switch (instanceActivity.Status)\n            {\n                case Enums.WorkflowStepStatus.Executing:\n                case Enums.WorkflowStepStatus.Pending:\n                case Enums.WorkflowStepStatus.Waiting:\n                case Enums.WorkflowStepStatus.Aborted:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool _ShouldProcess()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        private bool _ShouldProcessEvent()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                    case Enums.WorkflowStepStatus.Aborted:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        //ITrackItActivity interface is implemented by activities whose data is tracked in DocumentScope and ScopeEvent tables.\n        private bool IsTrackItActivity(IWINSActivity activity)\n        {\n            return activity is ITrackItActivity;\n        }\n\n\t\tprivate void FireWorkflowScopeEvent(UserAccount user, ScopeEventType eventType, IWINSActivity activity = null, IWINSWorkflowContext ctx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo\n\t\t\t\t{\n\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\tPeriodStart = DateTime.UtcNow,\n\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\tWorkflowName = _instance.Name,\n\t\t\t\t\tEventBy = user == null ? null : new WorkflowScopeEvent.Assignee() { Email = user.EmailAddress, Name = user.FriendlyName, Uid = user.Uid }\n\t\t\t\t};\n\n\t\t\t\tif (activity != null && ctx != null)\n\t\t\t\t{\n\t\t\t\t\tscopeEventData.StepName = ctx.ActivityName;\n\t\t\t\t\tscopeEventData.StepDisplayName = GetActivityDisplayName(activity, ctx);\n\t\t\t\t\tscopeEventData.StepTypeName = ctx.ActivityTypeName;\n\t\t\t\t\tscopeEventData.StepUid = ctx.ActivityUid;\n\t\t\t\t}\n\n\t\t\t\tEventRepo.FireEvent(_instance.AccountId, new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t{\n\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event scopeUid: {_instance.ScopeUid}, instanceUid: {_instance.Uid} eventType: {eventType}\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void RemoveProperties(InstanceActivity instanceActivity, IWINSActivity activity)\n\t    {\n\t\t    // We need to delete properties if this is not a human activity or WaitForNextStepAfterCompletion is not set\n\t\t    if (activity is AbstractHumanActivity && ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetWaitForNextStepAfterCompletion(instanceActivity.AccountId))\n\t\t    {\n\t\t\t\t_data.DeleteActivityPropertiesWithExclusion(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, new List<string> { nameof(AbstractHumanActivity.WaitForNextStep) });\n\t\t\t\t_log.InfoNoPII(\"Removing activity properties except WaitForNextStep\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    _data.DeleteActivityProperties(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid);\n\t\t\t    _log.InfoNoPII(\"Removing activity properties\");\n\t\t    }\n\t    }\n\n\t\tprivate string[] BuildNDCTags(InstanceActivity instanceActivity) => instanceActivity != null ? new[] { $\"ActivityId:{instanceActivity.Uid}\",$\"W:{instanceActivity.InstanceUid}\" } : new string[] { };\n\t    private string[] BuildNDCTags(Event e) => e != null ? new[] { $\"ActivityId:{e.ActivityUid}\", $\"W:{e.InstanceUid}\" } : new string[] { };\n\n\t\t/// <summary>\n\t\t/// Try to send an e-mail to support when a workflow instance activity execution account exceeds configured threshold.\n\t\t/// </summary>\n\t\t/// <param name=\"pausedPurgeDays\">Number of days to purge workflow related data</param>\n\t\t/// <returns>\n\t\t/// True\t-> Success.\n\t\t/// False\t-> Fail to send email.\n\t\t/// </returns>\n\t\tprivate bool TrySendActivityExecutionLimitExceedNotification(int pausedPurgeDays)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\t// Support should get the email\n\t\t\t\tvar supportEmailAddress = WorkflowSettingRepository.GetSupportNotificationEmailAddress(AccountId);\n\t\t\t\tif (!string.IsNullOrEmpty(supportEmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(supportEmailAddress);\n\t\t\t\t}\n\n\t\t\t\t// Also send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive activity execution limit exceeded notification\");\n\t\t\t\t\tnotificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, notificationUserUid);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Email support address setting is empty, and there is no AdvancedWorkflowNotificationUser configured. Thus, not sending activity execution limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Sending activity execution limit exceeded notification to {emailRecipients.Count} {(emailRecipients.Count > 1 ? \"recipients\" : \"recipient\")} for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseActivityExecutionLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowRevisionUid = _instance.RevisionUid,\n\t\t\t\t\tNumberOfActivitiesExecuted = ActivityExecutionCount,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetActivityDisplayName(IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n\t\t\treturn activity is AbstractHumanActivity abstractHumanActivity\n\t\t\t\t? abstractHumanActivity.ActivityDisplayName.Evaluate(ctx)\n\t\t\t\t: null;\n\t\t}\n\n\t\tprivate bool ShouldUseScopeEventHandler() => WorkflowFeatureFlags.UseScopeEventHandler &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t Model?.EngineVersion == Core.Workflow.Constants.EngineVersionV2;\n\n\t\tprivate void PauseInstance(UserAccount user, string comment, Action<UserAccount, string> pauseMethod)\n\t\t{\n\t\t\tRequires.NotNull(pauseMethod, nameof(pauseMethod));\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tpauseMethod(user, comment);\n\t\t\t\t_ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Pause(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowPaused);\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{\n\t\t\tvar environmentType = SiteConfig?.Value?.EnvironmentType;\n\t\t\tvar isGrpcEnabled = WorkflowClientConfig?.Value?.IsGrpcClientEnabled == true;\n\n\t\t\tvar isRunningOnCloudWithGrpcEnabled = environmentType == Core.Util.Config.EnvironmentType.Cloud && isGrpcEnabled;\n\n\t\t\tif (isRunningOnCloudWithGrpcEnabled && InstanceStateChangedHelper.IsInstanceStateChanged(_instance.Uid, ActivityExecutionCount, CacheRepository, WorkflowSettingRepository))\n\t\t\t{\n\t\t\t\t_ForceReload();\n\t\t\t\tInstanceStateChangedHelper.RemoveInstanceStateChanged(_instance.Uid, CacheRepository);\n\t\t\t}\n\t\t}\n    }\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
            "content": "#if NET\n#nullable enable\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService\n{\n    private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore\n#endif\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
            "content": "#if NET\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Domain.Repository.Workflow.Mappers;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Workflow.Model;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing Google.Protobuf.WellKnownTypes;\nusing Google.Rpc;\n\nusing Grpc.Core;\n\nusing Microsoft.Extensions.Logging;\n\nusing OpenTelemetry.Trace;\n\nusing Definition = ADEXS.Core.Domain.Model.Workflow.Definition;\nusing Design = DocuSign.CLM.Workflow.Core.Persistence.Model.Design;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing StartParameters = ADEXS.Core.Domain.Model.Workflow.StartParameters;\nusing Status = Grpc.Core.Status;\nusing StatusCode = Grpc.Core.StatusCode;\nusing ValueExpressionOneOfCase = ADEXS.WINS.V1.VariableUpdate.ValueExpressionOneofCase;\nusing VariableUpdate = ADEXS.Core.Domain.Repository.Workflow.Types.VariableUpdate;\nusing Version = ADEXS.Core.Domain.Model.Workflow.Version;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService : WINS.V1.WinsService.WinsServiceBase\n{\n\tprivate static readonly Status StatusInvalidArgumentInstanceUid = new(StatusCode.InvalidArgument, \"InstanceUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentActivityUid = new(StatusCode.InvalidArgument, \"ActivityUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentVersionUid = new(StatusCode.InvalidArgument, \"VersionUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentRevisionUid = new(StatusCode.InvalidArgument, \"RevisionUid is malformed\");\n\n\tprivate readonly ILogger _logger;\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate readonly IUserAccountRepository _userAccountRepository;\n\n\tprivate readonly IWorkflowClient _workflowClient;\n\n\tprivate readonly IWorkflowV1GrpcMapper _workflowV1GrpcMapper;\n\n\tpublic WinsService(\n\t\tIWorkflowClient workflowClient,\n\t\tIUserAccountRepository userAccountRepository,\n\t\tIWorkflowV1GrpcMapper workflowV1GrpcMapper,\n\t\tIServiceInstrumentation serviceInstrumentation,\n\t\tILogger<WinsService> logger)\n\t{\n\t\t_workflowClient = workflowClient;\n\t\t_userAccountRepository = userAccountRepository;\n\t\t_workflowV1GrpcMapper = workflowV1GrpcMapper;\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t_logger = logger;\n\t}\n\n\tpublic override Task<CreateNewWorkflowDefinitionResponse> CreateNewWorkflowDefinition(\n\t\t[NotNull] CreateNewWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.CreateNewWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar definitionModel = _workflowClient.CreateNewWorkflowDefinition(userAccount, request.WorkflowName);\n\n\t\t\tvar definition = _workflowV1GrpcMapper.Map<Definition, WINS.V1.Definition>(definitionModel);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new CreateNewWorkflowDefinitionResponse {Definition = definition});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ExportWorkflowDefinitionResponse> ExportWorkflowDefinition(\n\t\t[NotNull] ExportWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ExportWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar definitionXml = _workflowClient.ExportWorkflowDefinition(userAccount, request.WorkflowName);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ExportWorkflowDefinitionResponse {DefinitionXml = definitionXml});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ImportWorkflowDefinitionResponse> ImportWorkflowDefinition(\n\t\t[NotNull] ImportWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ImportWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revisionModel = _workflowClient.ImportWorkflowDefinition(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.DefinitionXml,\n\t\t\t\trequest.OverwriteExistingWorkflow,\n\t\t\t\trequest.Comment,\n\t\t\t\trequest.TemplateId,\n\t\t\t\trequest.TemplateVersion);\n\n\t\t\tvar revision = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revisionModel);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ImportWorkflowDefinitionResponse {Revision = revision});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PublishWorkflowResponse> PublishWorkflow(\n\t\t[NotNull] PublishWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))\n\t\t{\n\t\t\tLogger.PublishWorkflowInvalidArgument(_logger, request.User.AccountId, ex: null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentVersionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PublishWorkflow(_logger, request.User.AccountId, request.VersionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowClient.PublishWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\tversionUid,\n\t\t\t\trequest.RevisionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar revisionResponse = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revision);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PublishWorkflowResponse {Revision = revisionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PublishWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PublishWorkflowByNameResponse> PublishWorkflowByName(\n\t\t[NotNull] PublishWorkflowByNameRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PublishWorkflowByName(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowClient.PublishWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.VersionNumber,\n\t\t\t\trequest.RevisionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar revisionResponse = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revision);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PublishWorkflowByNameResponse {Revision = revisionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<VersionWorkflowResponse> VersionWorkflow(\n\t\t[NotNull] VersionWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))\n\t\t{\n\t\t\tLogger.VersionWorkflowInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentVersionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.VersionWorkflow(_logger, request.User.AccountId, request.SourceVersionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowClient.VersionWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\tsourceVersionUid,\n\t\t\t\trequest.SourceRevisionNumber,\n\t\t\t\trequest.NewVersionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar versionResponse = _workflowV1GrpcMapper.Map<Version, WINS.V1.Version>(version);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new VersionWorkflowResponse {Version = versionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.VersionWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<VersionWorkflowByNameResponse> VersionWorkflowByName(\n\t\t[NotNull] VersionWorkflowByNameRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.VersionWorkflowByName(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowClient.VersionWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceVersionNumber,\n\t\t\t\trequest.SourceRevisionNumber,\n\t\t\t\trequest.NewVersionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar versionResponse = _workflowV1GrpcMapper.Map<Version, WINS.V1.Version>(version);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new VersionWorkflowByNameResponse {Version = versionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<KillWorkflowResponse> KillWorkflow(KillWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.KillWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.KillWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.KillWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new KillWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.KillWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.KillWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.KillWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PauseWorkflowResponse> PauseWorkflow(PauseWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.PauseWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PauseWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.PauseWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PauseWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PauseWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PauseWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PauseWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ResumeWorkflowResponse> ResumeWorkflow(\n\t\tResumeWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.ResumeWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.ResumeWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.ResumeWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ResumeWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ResumeWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ResumeWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ResumeWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ResumeFailedWorkflowResponse> ResumeFailedWorkflow(\n\t\tResumeFailedWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.ResumeFailedWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.ResumeFailedWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ResumeFailedWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SystemCallbackResponse> SystemCallback(\n\t\t[NotNull] SystemCallbackRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(request.CallbackName))\n\t\t{\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(StatusCode.InvalidArgument, $\"{nameof(request.CallbackName)} is null or empty\"));\n\t\t}\n\n\t\tLogger.SystemCallback(\n\t\t\t_logger,\n\t\t\trequest.AccountId,\n\t\t\trequest.InstanceUid,\n\t\t\trequest.ActivityUid,\n\t\t\trequest.CallbackName);\n\n\t\ttry\n\t\t{\n\t\t\t_workflowClient.SystemCallback(\n\t\t\t\trequest.AccountId,\n\t\t\t\tinstanceUid,\n\t\t\t\tactivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\trequest.CallbackData);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new SystemCallbackResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SystemCallbackInvalidArgument(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\targEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SystemCallbackFailed(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\tpublicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SystemCallbackFailed(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\tex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowResponse> StartWorkflow(StartWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.StartWorkflow(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.StartWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowFromSourceResponse> StartWorkflowFromSource(\n\t\tStartWorkflowFromSourceRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.StartWorkflowFromSource(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar newInstanceUid = _workflowClient.StartWorkflowFromSource(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam,\n\t\t\t\tinstanceUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.AddTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, newInstanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowFromSourceResponse {InstanceUid = newInstanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowWithParametersResponse> StartWorkflowWithParameters(\n\t\tStartWorkflowWithParametersRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\t\tValidateUser(request?.StartParameters?.Submitter);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tValidateAndParseUserUid(request.StartParameters!.Submitter.Uid, request.StartParameters.Submitter.AccountId, out var submitterUserAccountUid);\n\n\t\tLogger.StartWorkflowWithParameters(_logger, request.User.AccountId, request.InstanceUid, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar submitterUserAccount = LoadUserAccountSafe(request.StartParameters.Submitter.AccountId, submitterUserAccountUid);\n\n\t\t\tvar startParameters = new StartParameters(submitterUserAccount, null, null, null);\n\t\t\t_workflowV1GrpcMapper.Map(request.StartParameters, startParameters);\n\n\t\t\tvar newInstanceUid = _workflowClient.StartWorkflowWithParameters(\n\t\t\t\tuserAccount,\n\t\t\t\trevisionUid,\n\t\t\t\tstartParameters,\n\t\t\t\tinstanceUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.AddTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, newInstanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowWithParametersResponse {InstanceUid = newInstanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartRoutingApprovalWorkflowResponse> StartRoutingApprovalWorkflow(\n\t\tStartRoutingApprovalWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.StartRoutingApprovalWorkflow(_logger, request.User.AccountId, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.StartRoutingApprovalWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trevisionUid,\n\t\t\t\trequest.RoutingApprovalName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartRoutingApprovalWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SendStartWorkflowResponse> SendStartWorkflow(\n\t\tSendStartWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.SendStartWorkflow(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.SendStartWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t\treturn Task.FromResult(new SendStartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SendStartWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SendStartWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SendStartWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SubmitWorkItemResponse> SubmitWorkItem(\n\t\tSubmitWorkItemRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))\n\t\t{\n\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, ex: null);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"WorkItemUid is malformed\"));\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.SubmitWorkItem(_logger, request.User.AccountId, request.WorkItemUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables = new Dictionary<string, object>();\n\n\t\t\tforeach (var wireVariable in request.UpdatedVariables)\n\t\t\t{\n\t\t\t\tvar workflowVariableType =\n\t\t\t\t\t_workflowV1GrpcMapper.Map<WorkflowVariableType, Enums.WorkflowVariableType>(wireVariable.Type);\n\n\t\t\t\tif (!WorkflowConversion.TryParseVariableValue(\n\t\t\t\t\t    request.User.AccountId,\n\t\t\t\t\t    workflowVariableType,\n\t\t\t\t\t    wireVariable.Value.ToStringUtf8(),\n\t\t\t\t\t    out var outputValue))\n\t\t\t\t{\n\t\t\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, null);\n\t\t\t\t\tthrow new RpcException(\n\t\t\t\t\t\tnew Status(StatusCode.InvalidArgument, \"Unable to parse one of updated variables\"));\n\t\t\t\t}\n\n\t\t\t\tupdatedVariables[wireVariable.Name] = outputValue;\n\t\t\t}\n\n\t\t\t_workflowClient.SubmitWorkItem(\n\t\t\t\tuserAccount,\n\t\t\t\tworkItemUid,\n\t\t\t\trequest.Output,\n\t\t\t\trequest.Comments,\n\t\t\t\trequest.ActivityMessages,\n\t\t\t\tupdatedVariables);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new SubmitWorkItemResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SubmitWorkItemFailed(_logger, request.User.AccountId, request.WorkItemUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SubmitWorkItemFailed(_logger, request.User.AccountId, request.WorkItemUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<LoadDesignResponse> LoadDesign(LoadDesignRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.LoadDesign(_logger, request.User.AccountId, request.Version.Uid, request.Version.DefinitionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowV1GrpcMapper.Map<WINS.V1.Version, Version>(request.Version);\n\n\t\t\tvar design = _workflowClient.LoadDesign(userAccount, version);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(design);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new LoadDesignResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.LoadDesignInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.LoadDesignFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.LoadDesignFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<LoadDesignByRevisionResponse> LoadDesignByRevision(\n\t\tLoadDesignByRevisionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.LoadDesignByRevision(_logger, request.User.AccountId, request.Revision.Uid, request.Revision.VersionUid, request.Revision.DefinitionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowV1GrpcMapper.Map<WINS.V1.Revision, Revision>(request.Revision);\n\n\t\t\tvar design = _workflowClient.LoadDesign(userAccount, revision);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(design);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new LoadDesignByRevisionResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ConvertLegacyDefinitionResponse> ConvertLegacyDefinition(\n\t\tConvertLegacyDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ConvertLegacyDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar oldDesign = _workflowV1GrpcMapper.Map<WINS.V1.Design, Design>(request.OldDesign);\n\n\t\t\tvar newDesign = _workflowClient.ConvertLegacyDefinition(userAccount, oldDesign);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(newDesign);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ConvertLegacyDefinitionResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<CompileExpressionBuilderExpressionResponse> CompileExpressionBuilderExpression(\n\t\tCompileExpressionBuilderExpressionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (string.IsNullOrWhiteSpace(request.Code))\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"Code is null or empty\"));\n\t\t}\n\n\t\tLogger.CompileExpressionBuilderExpression(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar output = _workflowClient.CompileExpressionBuilderExpression(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.Code,\n\t\t\t\trequest.AdditionalCode,\n\t\t\t\trequest.ReturnType);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new CompileExpressionBuilderExpressionResponse {Output = output});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<UpdateVariablesResponse> UpdateVariables(\n\t\tUpdateVariablesRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceInstanceUid, out var sourceInstanceUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceActivityUid, out var sourceActivityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tLogger.UpdateVariables(_logger, request.User.AccountId, request.ActivityUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables =\n\t\t\t\t_workflowV1GrpcMapper\n\t\t\t\t\t.Map<List<ADEXS.WINS.V1.VariableUpdate>, List<VariableUpdate>>(\n\t\t\t\t\t\trequest.VariableUpdates.ToList());\n\n\t\t\tvar result = _workflowClient.UpdateVariables(\n\t\t\t\tuserAccount,\n\t\t\t\tactivityUid,\n\t\t\t\tupdatedVariables,\n\t\t\t\tsourceInstanceUid,\n\t\t\t\tsourceActivityUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new UpdateVariablesResponse {Result = result});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.UpdateVariablesFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<UpdateVariablesWithResultResponse> UpdateVariablesWithResult(\n\t\tUpdateVariablesWithResultRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceInstanceUid, out var sourceInstanceUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceActivityUid, out var sourceActivityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tLogger.UpdateVariablesWithResult(_logger, request.User.AccountId, request.ActivityUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables =\n\t\t\t\t_workflowV1GrpcMapper\n\t\t\t\t\t.Map<List<ADEXS.WINS.V1.VariableUpdate>, List<VariableUpdate>>(\n\t\t\t\t\t\trequest.VariableUpdates.ToList());\n\n\t\t\tvar result = _workflowClient.UpdateVariablesWithResult(\n\t\t\t\tuserAccount,\n\t\t\t\tactivityUid,\n\t\t\t\tupdatedVariables,\n\t\t\t\tsourceInstanceUid,\n\t\t\t\tsourceActivityUid);\n\n\t\t\tvar resultResponse = _workflowV1GrpcMapper\n\t\t\t\t.Map<WorkflowEnums.UpdateParentVariableResult, UpdateParentVariableResult>(result);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new UpdateVariablesWithResultResponse {Result = resultResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<IsActivityExecutionLimitReachedResponse> IsActivityExecutionLimitReached(\n\t\t[NotNull] IsActivityExecutionLimitReachedRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tLogger.IsActivityExecutionLimitReached(_logger, request.AccountId, request.InstanceUid, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar revisionCreatedDate = _workflowV1GrpcMapper.Map<Timestamp, DateTime>(request.RevisionCreatedDate);\n\n\t\t\tvar isLimitReached = _workflowClient.IsActivityExecutionLimitReached(\n\t\t\t\trequest!.AccountId,\n\t\t\t\tinstanceUid,\n\t\t\t\trevisionUid,\n\t\t\t\trevisionCreatedDate,\n\t\t\t\trequest.ActivityExecutionCount);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new IsActivityExecutionLimitReachedResponse {IsLimitReached = isLimitReached});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedFailed(_logger, request.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedFailed(_logger, request.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tprivate static RpcException HandleArgumentException(Activity? activity, ArgumentException argEx)\n\t{\n\t\tactivity?.AddException(argEx);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)StatusCode.InvalidArgument,\n\t\t\tMessage = string.Empty,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(argEx.ToRpcDebugInfo())\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static RpcException HandleUnknownException(Activity? activity, Exception ex)\n\t{\n\t\tactivity?.AddException(ex);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)StatusCode.Internal,\n\t\t\tMessage = string.Empty,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(ex.ToRpcDebugInfo())\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static RpcException HandlePublicException(Activity? activity, PublicException ex)\n\t{\n\t\tactivity?.AddException(ex);\n\t\tvar statusCode = GetStatusCodeFromFailReason(ex.Reason);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)statusCode,\n\t\t\tMessage = ex.Message,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(ex.ToRpcDebugInfo()),\n\t\t\t\tAny.Pack(new ErrorInfo\n\t\t\t\t{\n\t\t\t\t\tDomain = nameof(PublicException),\n\t\t\t\t\tReason = ex.Reason.ToString(),\n\t\t\t\t\tMetadata =\n\t\t\t\t\t{\n\t\t\t\t\t\t{ nameof(ex.Message), ex.Message },\n\t\t\t\t\t\t{ nameof(ex.InternalMessage), ex.InternalMessage }\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static StatusCode GetStatusCodeFromFailReason(PublicException.FailReason failReason)\n\t{\n\t\treturn failReason switch\n\t\t{\n\t\t\tPublicException.FailReason.NonexistentObject => StatusCode.NotFound,\n\t\t\tPublicException.FailReason.InvalidArgument => StatusCode.InvalidArgument,\n\t\t\tPublicException.FailReason.InvalidState => StatusCode.FailedPrecondition,\n\t\t\tPublicException.FailReason.InternalError => StatusCode.Internal,\n\t\t\tPublicException.FailReason.TemporarilyUnavailable => StatusCode.Unavailable,\n\t\t\tPublicException.FailReason.PermissionDenied => StatusCode.PermissionDenied,\n\t\t\tPublicException.FailReason.ObjectAlreadyExists => StatusCode.AlreadyExists,\n\t\t\t_ => StatusCode.Internal, // Default case\n\t\t};\n\t}\n\n\tprivate static void ValidateUser(UserAccount? user)\n\t{\n\t\tif (user == null)\n\t\t{\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"User is null\"));\n\t\t}\n\t}\n\n\tprivate void ValidateAndParseUserUid(string userUid, int accountId, out Guid userAccountUid)\n\t{\n\t\tif (!Guid.TryParse(userUid, out userAccountUid))\n\t\t{\n\t\t\tLogger.UserUidFormatError(_logger, userUid, accountId);\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(\n\t\t\t\t\tStatusCode.InvalidArgument,\n\t\t\t\t\t\"User.Uid is malformed\"));\n\t\t}\n\t}\n\n\tprivate void ValidateWorkflowName(string workflowName)\n\t{\n\t\tif (string.IsNullOrEmpty(workflowName))\n\t\t{\n\t\t\tLogger.WorkflowFormatError(_logger);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"WorkflowName is null or empty\"));\n\t\t}\n\t}\n\n\tprivate Core.Domain.Model.UserAccount? LoadUserAccountSafe(int accountId, Guid userAccountUid)\n\t{\n\t\tvar userAccount = _userAccountRepository.LoadByUid(accountId, userAccountUid);\n\n\t\tif (userAccount == null)\n\t\t{\n\t\t\tLogger.UserAccountNotFound(_logger, userAccountUid, accountId);\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(\n\t\t\t\t\tStatusCode.NotFound,\n\t\t\t\t\t$\"User {userAccountUid} not found in account {accountId}\"));\n\t\t}\n\n\t\treturn userAccount;\n\t}\n}\n\n#nullable restore\n#endif\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Threading;\nusing System.Web;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.RequestHeaders;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.MVC;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\nusing log4net;\n\nnamespace ADEXS.Web.Common.Profile\n{\n\tpublic class ProfileModule : IHttpModule\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(\"ADEXS.Web.Common\");\n\n\n\t\tprivate PerformanceLog _performanceLog;\n\t\tprivate IDisposable _logContext;\n\n\t\t[EventSource(\"Session Size\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Size\", \"CLM.SessionState\", DisplayUnit = CounterUnit.kilobytes,\n\t\t\tRanges = new double[10] { 1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 20000 },\n\t\t\tMeasureProperty = \"Count\", InstanceProperty = \"Description\", ShowVolume = true)]\n\t\tprivate static readonly CountEventSource _sessionSizeEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Session Serialization Timing\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Serialization Timing\", \"CLM.SessionState\", DisplayUnit = CounterUnit.milliseconds,\n\t\t\tRanges = new double[10] { 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t\tMeasureProperty = \"Duration\", SuccessProperty = \"Success\", InstanceProperty = \"Description\")]\n\t\tprivate static readonly TimingEventSource _sessionSerializationTimingEventSource = new TimingEventSource();\n\n\t\t[EventSource(\"Large Session\", \"CLM.SessionState\")]\n\t\t[Counter(\"Large Session\", \"CLM.SessionState\")]\n\t\tprivate static readonly PropertyBagEventSource _largeSessionEventSource = new PropertyBagEventSource();\n\n\t\t/// <summary>\n\t\t/// You will need to configure this module in the web.config file of your\n\t\t/// web and register it with IIS before being able to use it. For more information\n\t\t/// see the following link: http://go.microsoft.com/?linkid=8101007\n\t\t/// </summary>\n\t\t#region IHttpModule Members\n\n\t\tpublic void Dispose()\n\t\t{\n\t\t\t//clean-up code here.\n\t\t}\n\n\t\tpublic void Init(HttpApplication context)\n\t\t{\n\t\t\t// Below is an example of how you can handle LogRequest event and provide\n\t\t\t// custom logging implementation for it\n\t\t\tcontext.BeginRequest += OnBeginRequest;\n\t\t\tcontext.PreRequestHandlerExecute += OnPreRequestHandlerExecute;\n\t\t\tcontext.PostRequestHandlerExecute += OnPostRequestHandlerExecute;\n\t\t\tcontext.EndRequest += OnEndRequest;\n\t\t\tcontext.Error += OnError;\n\t\t}\n\n\t\t/* IIS request life cycle BeginRequest ->  AuthenticateRequest -> AuthorizeRequest -> ResolveRequestCache -> AcquireRequestState ->\n\t\t * PreRequestHandlerExecute -> ProcessRequest -> PostRequestHandlerExecute -> ReleaseRequestState -> UpdateRequestCache -> EndRequest */\n\n\t\tprivate void OnBeginRequest(object sender, EventArgs e)\n\t\t{\n\t\t\tif (_performanceLog == null)\n\t\t\t\t_performanceLog = new PerformanceLog();\n\n\t\t\t_performanceLog.Start(HttpContext.Current.Request);\n\t\t}\n\n\t\tprivate void OnPostRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(HttpContext.Current);\n\t\t\tLogSessionSize(HttpContext.Current?.Session);\n\t\t\t_performanceLog.SetSession(HttpContext.Current?.Session);\n\t\t}\n\n\t\tprivate void OnPreRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tHttpContext context = HttpContext.Current;\n\t\t\t\tAtlasContext.Reset();\n\n\t\t\t\t// MonitoringContext is initialized in the ScmLogRequestHttpModule module on\n\t\t\t\t// BeginRequest. This runs before this event handler. By this time the\n\t\t\t\t// CorrelationToken is set. Including getting it from the X-DocuSign-CorrelationToken header if available.\n\t\t\t\tGuid corrId = MonitoringContext.CorrelationToken ?? Guid.Empty;\n\t\t\t\tif (Guid.Empty == corrId)\n\t\t\t\t{\n\t\t\t\t\t// Only in extremely unlikely scenario\n\t\t\t\t\tGuid.TryParse(AtlasContext.Current.TransactionId, out corrId);\n\t\t\t\t\tMonitoringContext.CorrelationToken = corrId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAtlasContext.Current.TransactionId = corrId.ToString();\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t// Now we'll have TransactionId, CorrelationId, and CorrelationToken all set to the same value. Three is a crowd?...\n\t\t\t\t_logContext = LogContext.Set(AtlasContext.Current.TransactionId);\n\n\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"ServiceLocator:\\n{ServiceLocator.Container.WhatDoIHave(typeof(ILogContextStore))}\");\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Reset();\n\t\t\t\tif (context != null)\n\t\t\t\t{\n\t\t\t\t\tif (context.Request != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tAtlasContext.Current.ClientIpAddress = IPAddressUtil.FetchIpAddress(context.Request);\n\t\t\t\t\t\tAtlasContext.Current.ClientUserAgent = context.Request.UserAgent;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Similar code exists for web services, which don't use session.\n\t\t\t\t\t// That code is in SetContextIds\n\t\t\t\t\tHttpSessionState session = context.Session;\n\t\t\t\t\tif (session != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tUserAccount user = CommonData.CurrentUser;\n\t\t\t\t\t\tif (user != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAtlasContext.Current.AccountId = user.AccountId;\n\t\t\t\t\t\t\tAtlasContext.Current.UserAccountUid = user.Uid;\n\t\t\t\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = user.AccountId == int.MinValue ? \"null\" : user.AccountId.ToString();\n\n\t\t\t\t\t\t\tvar userContextSetter = AtlasWebDependencyResolver.ScopedInstance?.GetService<IUserContextSetter>();\n\t\t\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"The user's AccountId: {user.AccountId} for user id: {user.Uid} in OnPreRequestHandlerExecute.\");\n\t\t\t\t\t\t\t\t// ensure that DI consumers have access the user/account context\n\t\t\t\t\t\t\t\tuserContextSetter.AccountId = user.AccountId;\n\t\t\t\t\t\t\t\tuserContextSetter.UserId = user.Uid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII(\"No UserContextSetter is available - account context propagation will not work.\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar docusignAccountId = CommonData.DocuSignAccountId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignAccountId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignAccountId = docusignAccountId;\n\n\t\t\t\t\t\t\tvar docusignUserId = CommonData.DocuSignUserId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignUserId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignUserId = docusignUserId;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnPreRequestHandlerExecute in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Measuring session size ATL-56207\n\t\t/// </summary>\n\t\tprivate static void LogSessionSize(HttpSessionState session)\n\t\t{\n\t\t\tif (session == null || !Configuration.GetBooleanAppSetting(\"EnableSessionSizeLogging\", false))\n\t\t\t\treturn;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong totalSessionBytes = 0;\n\t\t\t\tstring largestItemKey = string.Empty;\n\t\t\t\tlong largestItemSizeBytes = 0;\n\t\t\t\tint itemCount = 0;\n\n\t\t\t\tusing (OperationTimer sessionSerializationTimer = _sessionSerializationTimingEventSource.CreateTimer())\n\t\t\t\t{\n\t\t\t\t\tBinaryFormatter formatter = new BinaryFormatter();\n\t\t\t\t\tforeach (var sessionKey in session)\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (Stream s = new MemoryStream())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring key = (string)sessionKey;\n\t\t\t\t\t\t\tvar item = session[key];\n\t\t\t\t\t\t\tif (item != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titemCount++;\n\n\t\t\t\t\t\t\t\tformatter.Serialize(s, item);\n\n\t\t\t\t\t\t\t\tif (s.Length > largestItemSizeBytes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlargestItemKey = key;\n\t\t\t\t\t\t\t\t\tlargestItemSizeBytes = s.Length;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttotalSessionBytes += s.Length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsessionSerializationTimer.SetResult(true);\n\t\t\t\t}\n\n\t\t\t\t_sessionSizeEventSource.Emit(totalSessionBytes);\n\n\t\t\t\tif (totalSessionBytes > Configuration.GetInt64AppSetting(\"LargeSessionSizeLoggingThreshold\", 1000000)) // default to 1MB\n\t\t\t\t{\n\t\t\t\t\tstring aid = AtlasContext.Current?.AccountId.ToString();\n\t\t\t\t\tstring userId = AtlasContext.Current?.UserAccountUid.ToString();\n\n\t\t\t\t\tusing (var propertyBag = _largeSessionEventSource.CreateEventPropertyBag())\n\t\t\t\t\t{\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"AccountId\", aid);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"UserAccountUid\", userId);\n\n\t\t\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionId\", session.SessionID);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionSizeInBytes\", totalSessionBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemKey\", largestItemKey);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemSizeInBytes\", largestItemSizeBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"TotalSessionItemCount\", itemCount.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"ThreadId\", Thread.CurrentThread.ManagedThreadId.ToString());\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.InfoNoPII($\"Detected Large SessionState. AccountId {aid} UserAccountUid {userId} SessionId {session.SessionID} SessionSizeInBytes {totalSessionBytes} TotalItemCount {itemCount} Largest Item Key {largestItemKey} ({largestItemSizeBytes})\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Exception occurred while attempting to measure session.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnError(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//get latest exception (top level exception is probably an HTTPUnhandledException which contains underlying exceptions via .InnerException)\n\n\t\t\t\tException baseException = null;\n\t\t\t\tvar lastError = HttpContext.Current.Server.GetLastError();\n\t\t\t\tif (lastError == null)\n\t\t\t\t{\n\t\t\t\t\tvar allError = HttpContext.Current.AllErrors;\n\t\t\t\t\tif (allError != null && allError.Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseException = allError[allError.Length - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseException = lastError.GetBaseException();\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Stop(baseException);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnError in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnEndRequest(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (_performanceLog != null)\n\t\t\t\t{\n\t\t\t\t\t_performanceLog.Stop();\n\t\t\t\t\t_performanceLog.Dispose();\n\t\t\t\t\t_performanceLog = null;\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t_logContext = null;\n\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = \"null\";\n\n\t\t\t\t// we are no longer looking for outstanding DB transactions here.\n\t\t\t\t// because the module does not have to run in the same thread as the request handler\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnEndRequest in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAtlasContext.Current.CacheClient.FlushCache();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not clear the user settings on the thread for the request.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Text;\nusing System.Threading;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Web.Common.Helpers;\n\nusing DocuSign.DynamicSettings;\nusing DocuSign.Monitoring;\n\nnamespace ADEXS.Web.Common;\n/// <summary>\n/// Temporary Base class to redirect the ASHX API call to new Controller API as part of the effort of web migration to .net6\n/// This will eventually cleaned up once we move to .net6\n/// </summary>\npublic abstract class BaseApiHandler : IHttpHandler\n{\n\t[EventSource(\"Exception\", \"CLM.FeatureFlags.PopulateFeatureFlagContext\")]\n\t[Counter(\"Exception\", \"CLM.FeatureFlags.PopulateFeatureFlagContext\", InstanceProperty = \"Description\")]\n\tprivate static ExceptionEventSource _featureFlagContextExceptionEventSource = new ExceptionEventSource();\n\n\tprivate static readonly IDiscreetLogger Logger = DiscreetLogger.GetLogger(typeof(BaseApiHandler));\n\n\t// reletive path for new controller api. ex) \"A/TileView/GetTiles\"\n\t// where full url is https://localhost/atlas/A/TileView/GetTiles\n\tprotected abstract string Path { get; }\n\n\tpublic virtual bool IsReusable { get; set; }\n\n\tpublic virtual void ProcessRequest(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tPopulateFeatureFlagContext(AtlasContext.Current.UserAccount, context);\n\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to Populate Feature Flag Context: {LogData()}\", ex);\n\t\t}\n\n\t\tif (ShouldRedirectHelper())\n\t\t{\n\t\t\tRedirect(context);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tHandleRequest(context);\n\t\t}\n\t}\n\n\tprotected abstract bool ShouldRedirect();\n\tprotected abstract void HandleRequest(HttpContext context);\n\n\tprivate string LogData()\n\t{\n\t\treturn $\"aid:{AtlasContext.Current.AccountId} uid:{AtlasContext.Current.UserAccountUid} relativeUrl: {Path}\";\n\t}\n\tprivate void Redirect(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t\t}\n\n\t\t\t// Get the original path info\n\t\t\tvar pathInfo = !string.IsNullOrEmpty(context.Request.PathInfo) ? context.Request.PathInfo : \"\";\n\n\t\t\t// Get the original query string\n\t\t\tvar queryString = context.Request.QueryString;\n\n\t\t\t// URL-encode pathInfo and queryString before building the new URL\n\t\t\tvar encodedPathInfo = HttpUtility.UrlPathEncode(pathInfo);\n\t\t\tvar encodedQueryString = ToUrlEncodedQueryString(queryString);\n\n\t\t\tvar baseUrl = AtlasUrlHelper.WebApplicationBasePath();\n\t\t\tvar newUrl = $\"{baseUrl}/{Path}{encodedPathInfo}{encodedQueryString}\";\n\n\t\t\t// Set the status code to 307 Temporary Redirect\n\t\t\tcontext.Response.StatusCode = Microsoft.AspNetCore.Http.StatusCodes.Status307TemporaryRedirect;\n\n\t\t\t// Set the Location header with the new Controller URL\n\t\t\tcontext.Response.AddHeader(\"Location\", newUrl);\n\n\t\t}\n\t\tcatch (ThreadAbortException)\n\t\t{\n\t\t\t// Do nothing intentionally.\n\t\t\t// The above Redirect call is *meant* to abort the thread with an exception and we do _not_ want it caught by the below catch block.\n\t\t\t// See this article for why we are catching it here and why we do nothing in this block.\n\t\t\t// https://learn.microsoft.com/en-us/dotnet/standard/threading/destroying-threads#handling-threadabortexception\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to Redirect: {LogData()}\", ex);\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprivate bool ShouldRedirectHelper()\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn ShouldRedirect();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to evaluate ShouldRedirect: {LogData()}\", ex);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void PopulateFeatureFlagContext(UserAccount currentUser, HttpContext context)\n\t{\n\t\tif (context == null)\n\t\t{\n\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t}\n\n\t\tif (currentUser == null || !ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId > 0)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = AtlasContext.Current.AccountId;\n\t\t\t}\n\t\t\telse if (context.Request.QueryString[Constants.QueryStringParameters.AccountIdAbbreviated] != null)\n\t\t\t{\n\t\t\t\tif (int.TryParse(context.Request.QueryString[Constants.QueryStringParameters.AccountIdAbbreviated], out var accountId))\n\t\t\t\t{\n\t\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = accountId;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = currentUser.AccountId;\n\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.UserId] = currentUser.Uid;\n\t\t\tif (currentUser.Account != null)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountType] = currentUser.Account.AccountType;\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.PlanName] = NpsUtilities.GetPlanIdName(currentUser.Account);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t_featureFlagContextExceptionEventSource.Emit(ex);\n\t\t}\n\t}\n\n\tprivate static string ToUrlEncodedQueryString(NameValueCollection collection)\n\t{\n\t\tif (collection == null || collection.Count == 0)\n\t\t{\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\tvar builder = new StringBuilder();\n\t\tvar first = true;\n\t\tfor (var i = 0; i < collection.Count; i++)\n\t\t{\n\t\t\tvar key = collection.GetKey(i);\n\t\t\tvar value = collection.Get(i);\n\t\t\tbuilder.Append(first ? '?' : '&');\n\t\t\tfirst = false;\n\t\t\tbuilder.Append(HttpUtility.UrlEncode(key));\n\t\t\tbuilder.Append('=');\n\t\t\tbuilder.Append(HttpUtility.UrlEncode(value));\n\t\t}\n\n\t\treturn builder.ToString();\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Web.Common.Helpers;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing Grpc.Core;\n\nusing Microsoft.AspNet.SessionState;\nusing Microsoft.Web.Redis;\n\nusing OpenTelemetry.Context.Propagation;\nusing OpenTelemetry.Instrumentation.AspNet;\nusing OpenTelemetry.Trace;\n\nnamespace ADEXS.Web.Common.Session\n{\n\tpublic class RedisSessionStateProviderWrapper : RedisSessionStateProvider\n\t{\n\t\t[EventSource(\"RedisSessionStateProvider\", \"CLM.SessionState\")]\n\t\t[Counter(\"RedisSessionStateProvider\", \"CLM.SessionState\",\n\t\t\tInstanceProperty = \"Description\",\n\t\t\tDisplayUnit = CounterUnit.milliseconds,\n\t\t\tRanges = new double[10] { 1, 5, 10, 25, 50, 100, 250, 500, 1000, 5000 },\n\t\t\tMeasureProperty = \"Duration\",\n\t\t\tSuccessProperty = \"Success\")]\n\t\tprivate static readonly TimingEventSource _redisSessionTimingEventSource = new TimingEventSource();\n\n\t\t[EventSource(\"Throttling errors\", \"CLM.SessionState\")]\n\t\t[Counter(\"Throttling errors\", \"CLM.SessionState\")]\n\t\tprivate static readonly SimpleEventSource _throttingErrorsEventSource = new SimpleEventSource();\n\n\t\tprivate static readonly ActivitySource SessionStateProviderActivitySource = new ActivitySource(typeof(RedisSessionStateProviderWrapper).FullName);\n\n\t\tprivate static DateTime LastConnectionResetTime = new DateTime();\n\n\t\tprivate const string SESSION_STATE_THROTTLING_KEY = \"SESSION_STATE_THROTTLING_KEY\";\n\n\t\tprivate static IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(RedisSessionStateProviderWrapper));\n\n\t\t#region Public Overridden Methods\n\n\t\tpublic override async Task CreateUninitializedItemAsync(System.Web.HttpContextBase context, string id, int timeout,\n\t\t\tCancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.CreateUninitializedItemAsync(context, id, timeout, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task SetAndReleaseItemExclusiveAsync(System.Web.HttpContextBase context, string id,\n\t\t\tSystem.Web.SessionState.SessionStateStoreData item, object lockId, bool newItem,\n\t\t\tCancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.SetAndReleaseItemExclusiveAsync(context, id, item, lockId, newItem, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task ResetItemTimeoutAsync(System.Web.HttpContextBase context, string id, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.ResetItemTimeoutAsync(context, id, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task RemoveItemAsync(System.Web.HttpContextBase context, string id, object lockId,\n\t\t\tSystem.Web.SessionState.SessionStateStoreData item, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.RemoveItemAsync(context, id, lockId, item, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task ReleaseItemExclusiveAsync(System.Web.HttpContextBase context, string id, object lockId, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.ReleaseItemExclusiveAsync(context, id, lockId, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task<GetItemResult> GetItemExclusiveAsync(System.Web.HttpContextBase context, string id, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tThrottle(context);\n\t\t\treturn await ExecuteTaskWithResult(context, () => base.GetItemExclusiveAsync(context, id, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task<GetItemResult> GetItemAsync(System.Web.HttpContextBase context, string id, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tThrottle(context);\n\t\t\treturn await ExecuteTaskWithResult(context, () => base.GetItemAsync(context, id, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task EndRequestAsync(System.Web.HttpContextBase context)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.EndRequestAsync(context));\n\t\t}\n\n\t\tpublic void Reset(System.Web.HttpContextBase context)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t_log.WarnNoPII(\"Resetting RedisSessionState connection.\");\n\t\t\tLastConnectionResetTime = DateTime.UtcNow;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"RedisSessionStateReset\", false))\n\t\t\t\t{\n\t\t\t\t\t// static internal fields that can't be access directly\n\t\t\t\t\t// have to use reflection to update the ConnectionString and SharedConnection property\n\t\t\t\t\tResetConnectionString();\n\t\t\t\t\tResetSharedConnection();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to change the connection string\", e);\n\t\t\t}\n\n\t\t\tTask.WaitAll(base.EndRequestAsync(context));\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Private Methods\n\n\t\tprivate static void ResetConnectionString()\n\t\t{\n\t\t\tvar configurationCreationLockField = typeof(RedisSessionStateProvider).GetField(\"configurationCreationLock\",\n\t\t\t\tBindingFlags.NonPublic | BindingFlags.Static);\n\n\t\t\tif (configurationCreationLockField == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get configurationCreationLockField\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar configurationCreationLockObj = configurationCreationLockField.GetValue(null);\n\n\t\t\tif (configurationCreationLockObj == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get configurationCreationLockObj\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlock (configurationCreationLockObj)\n\t\t\t{\n\t\t\t\tvar configField = typeof(RedisSessionStateProvider).GetField(\"configuration\",\n\t\t\t\t\tBindingFlags.NonPublic | BindingFlags.Static);\n\n\t\t\t\tif (configField == null)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get configField\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar configObj = configField.GetValue(null);\n\n\t\t\t\tif (configObj == null)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get configObj\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar connectionStringProperty = configObj.GetType().GetProperty(\"ConnectionString\");\n\n\t\t\t\tif (connectionStringProperty == null)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get connectionStringProperty\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconnectionStringProperty.SetValue(configObj,\n\t\t\t\t\tnew RedisSessionStateConfig().GetRedisConnectionString());\n\t\t\t}\n\t\t}\n\n\t\tprivate void ResetSharedConnection()\n\t\t{\n\t\t\tvar cacheField = typeof(RedisSessionStateProvider).GetField(\"cache\",\n\t\t\t\tBindingFlags.NonPublic | BindingFlags.Instance);\n\n\t\t\tif (cacheField == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get cacheField\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cacheObj = cacheField.GetValue(this);\n\n\t\t\tif (cacheObj == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get cacheObj\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lockForSharedConnectionField = cacheObj.GetType().GetField(\"lockForSharedConnection\",\n\t\t\t\tBindingFlags.NonPublic | BindingFlags.Static);\n\n\t\t\tif (lockForSharedConnectionField == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get lockForSharedConnectionField\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lockForSharedConnectionObj = lockForSharedConnectionField.GetValue(null);\n\n\t\t\tif (lockForSharedConnectionObj == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get lockForSharedConnectionObj\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlock (lockForSharedConnectionObj)\n\t\t\t{\n\t\t\t\tvar sharedConnectionField = cacheObj.GetType().GetField(\"sharedConnection\",\n\t\t\t\t\tBindingFlags.NonPublic | BindingFlags.Static);\n\t\t\t\tif (sharedConnectionField == null)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get sharedConnectionField\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsharedConnectionField.SetValue(null, null);\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task ExecuteTask(System.Web.HttpContextBase context, Func<Task> baseMethod, [CallerMemberName] string callerFunction = null)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\t\t\tvar sw = Stopwatch.StartNew();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tawait baseMethod();\n\t\t\t\tEmitTelemetry(sw, true, callerFunction);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tEmitTelemetry(sw, false, callerFunction);\n\t\t\t\tReportException(ex, callerFunction);\n\t\t\t\tif (DateTime.UtcNow > LastConnectionResetTime.AddMinutes(Configuration.GetInt32AppSetting(\"RedisSessionStateResetTimerMin\", 10)))\n\t\t\t\t{\n\t\t\t\t\tReset(context);\n\t\t\t\t}\n\n\t\t\t\tactivity\n\t\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t\t.AddException(ex);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task<T> ExecuteTaskWithResult<T>(System.Web.HttpContextBase context, Func<Task<T>> baseMethod, [CallerMemberName] string callerFunction = null)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\t\t\tvar sw = Stopwatch.StartNew();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar result = await baseMethod();\n\t\t\t\tEmitTelemetry(sw, true, callerFunction);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tEmitTelemetry(sw, false, callerFunction);\n\t\t\t\tReportException(ex, callerFunction);\n\t\t\t\tif (DateTime.UtcNow >\n\t\t\t\t    LastConnectionResetTime.AddMinutes(Configuration.GetInt32AppSetting(\"RedisSessionStateResetTimerMin\", 10)))\n\t\t\t\t{\n\t\t\t\t\tReset(context);\n\t\t\t\t}\n\n\t\t\t\tactivity\n\t\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t\t.AddException(ex);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitTelemetry(Stopwatch stopWatch, bool success, string callerFunction)\n\t\t{\n\t\t\tif (ApplicationSettings.EnableSessionProviderTelemetry)\n\t\t\t{\n\t\t\t\tusing (var timer = _redisSessionTimingEventSource.CreateTimer(callerFunction, TimingPhase.Redis,\n\t\t\t\t\ttimingPhaseDetails: new TimingPhaseDetails(callerFunction, ApplicationSettings.RedisPhaseDurationThreshold, TimingPhaseProperty.Duration)))\n\t\t\t\t{\n\t\t\t\t\ttimer.SetTimer(stopWatch);\n\t\t\t\t\ttimer.SetResult(success);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void ReportException(Exception exception, string callerFunction)\n\t\t{\n\t\t\tif (ApplicationSettings.EnableSessionProviderTelemetry)\n\t\t\t\texception?.Report(callerFunction);\n\t\t}\n\n\t\tprivate void Throttle(System.Web.HttpContextBase context, [System.Runtime.CompilerServices.CallerMemberName] string callerFunction = \"\")\n\t\t{\n\t\t\tusing var activity = StartActivity()\n\t\t\t\t?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar sessionStateGovernor = GetSessionStateGovernor(context);\n\t\t\t\tsessionStateGovernor?.IncrementCallCount(callerFunction);\n\t\t\t}\n\t\t\tcatch(AtlasHttpResponseException resEx)\n\t\t\t{\n\t\t\t\tactivity\n\t\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t\t.AddException(resEx);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_throttingErrorsEventSource.Emit();\n\t\t\t\tex.Report();\n\n\t\t\t\tactivity\n\t\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t\t.AddException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate ISessionStateGovernor GetSessionStateGovernor(System.Web.HttpContextBase context)\n\t\t{\n\t\t\tvar sessionStateGovernor = context.Items[SESSION_STATE_THROTTLING_KEY] as ISessionStateGovernor;\n\t\t\tif (sessionStateGovernor == null)\n\t\t\t{\n\t\t\t\tsessionStateGovernor = new RedisSessionStateGovernor();\n\t\t\t\tcontext.Items[SESSION_STATE_THROTTLING_KEY] = sessionStateGovernor;\n\t\t\t}\n\t\t\treturn sessionStateGovernor;\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") =>\n\t\t\tSessionStateProviderActivitySource\n\t\t\t\t.StartActivity($\"{nameof(RedisSessionStateProviderWrapper)}.{name}\")\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n\n\t\t#endregion\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
            "content": "\ufeff#nullable enable\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nnamespace ADEXS.DetectTypeService.MimeLookup;\n\npublic class MimeDetectorWindows : IMimeDetector\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tpublic MimeDetectorWindows(IServiceInstrumentation serviceInstrumentation)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic string? DetectMimeType(string? filePath)\n\t{\n\t\tusing var activity = StartActivity();\n\t\ttry\n\t\t{\n\t\t\tvar result = MimeLookup.GetMimeType(filePath);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.UrlMon))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n\n\tstatic class MimeLookup\n\t{\n\t\t[DllImport(\"urlmon.dll\", CharSet = CharSet.Auto)]\n\t\tinternal static extern int FindMimeFromData(\n\t\t\tIntPtr pBC,\n\t\t\t[MarshalAs(UnmanagedType.LPWStr)] string? pwzUrl,\n\t\t\tIntPtr pBuffer,\n\t\t\tint cbSize,\n\t\t\t[MarshalAs(UnmanagedType.LPWStr)] string? pwzMimeProposed,\n\t\t\tint dwMimeFlags,\n\t\t\t[MarshalAs(UnmanagedType.LPWStr)] out string? ppwzMimeOut,\n\t\t\tint dwReserved);\n\n\t\t[MethodImpl(MethodImplOptions.Synchronized)]\n\t\tstatic public string? GetMimeType(string? filename)\n\t\t{\n\t\t\tstring? mimeType = null;\n\t\t\tFindMimeFromData(IntPtr.Zero, filename, IntPtr.Zero, 0, null, 0, out mimeType, 0);\n\t\t\treturn mimeType;\n\t\t}\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
            "content": "\ufeff#nullable enable\nusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing HeyRed.Mime;\n\nnamespace ADEXS.DetectTypeService.MimeLookup;\n\npublic class MimeDetectorCrossPlatform : IMimeDetector\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tpublic MimeDetectorCrossPlatform(IServiceInstrumentation serviceInstrumentation)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic string DetectMimeType(string filePath)\n\t{\n\t\tusing var activity = StartActivity();\n\t\ttry\n\t\t{\n\t\t\tusing var stream = File.OpenRead(filePath);\n\t\t\tvar result = MimeGuesser.GuessMimeType(stream);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.MimeGuesser))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing DocuSign.CLM.ContentStorage;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing MediaInfo;\n\nnamespace ADEXS.DetectTypeService.VideoInfo\n{\n\tpublic class VideoInfo : IVideoInfo\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(VideoInfo));\n\n\t\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\t\tpublic VideoInfo(IServiceInstrumentation serviceInstrumentation)\n\t\t{\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t}\n\n\t\tpublic VideoInfoModel GetVideoInformation(Document document)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t//Test if version of DLL is compatible : 3rd argument is \"version of DLL tested;Your application name;Your application version\"\n\n\t\t\tMediaInfo.MediaInfo mediaInfo = new MediaInfo.MediaInfo();\n\n\t\t\tstring output = mediaInfo.Option(\"Info_Version\", \"0.7.0.0;MediaInfoDLL_Example_CS;0.7.0.0\");\n\t\t\tif (string.IsNullOrEmpty(output))\n\t\t\t{\n\t\t\t\tthrow new ApplicationException(\"MediaInfo.Dll: this version of the DLL is not compatible\").Trace();\n\t\t\t}\n\n\t\t\tSystemDocumentReader docReader = new SystemDocumentReader(document);\n\t\t\tlong length = docReader.GetContentLength(StorageConstants.StorageFormat.Native);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tmediaInfo.OpenBufferInit(length, 0);\n\n\t\t\t\tbyte[] mngdBuffer = new byte[81920];\n\t\t\t\tusing (var stream = docReader.OpenNativeStream())\n\t\t\t\t{\n\t\t\t\t\tint totalBytesSent = 0;\n\t\t\t\t\tint continueResult = 5; // initialize to 5, because that is what is returned when MediaInfo wants more bytes\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\t\t\tIntPtr ptrBuffer = default(IntPtr);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tptrBuffer = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)) * mngdBuffer.Length);\n\t\t\t\t\t\tint read;\n\t\t\t\t\t\twhile ((read = stream.Read(mngdBuffer, 0, mngdBuffer.Length)) > 0 && continueResult == 5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMarshal.Copy(mngdBuffer, 0, ptrBuffer, read); // Copy the array to unmanaged memory.\n\t\t\t\t\t\t\tcontinueResult = (int)mediaInfo.OpenBufferContinue(ptrBuffer, (IntPtr)read);\n\t\t\t\t\t\t\ttotalBytesSent += read;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_log.DebugNoPII(\n\t\t\t\t\t\t\t$\"Stopped sending bytes to MediaInfo in {sw.ElapsedMilliseconds} ms. Last chunk sent result: {continueResult}, total bytes sent: {totalBytesSent} of {length}\");\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptrBuffer != default(IntPtr))\n\t\t\t\t\t\t\tMarshal.FreeHGlobal(ptrBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmediaInfo.OpenBufferFinalize();\n\n\t\t\t\tint height;\n\t\t\t\tint width;\n\t\t\t\tlong durationMs;\n\t\t\t\tif (!int.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Height\"), out height)) height = 0;\n\t\t\t\tif (!int.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Width\"), out width)) width = 0;\n\t\t\t\tif (!long.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Duration\"), out durationMs)) durationMs = 0;\n\t\t\t\tstring codec = mediaInfo.Get(StreamKind.General, 0, \"CodecID\") ?? string.Empty;\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\tvar videoInfoModel = new VideoInfoModel { Height = height, Width = width, Codec = codec, Duration = durationMs };\n\n\t\t\t\tSetVideoInfoTags(activity, videoInfoModel);\n\n\t\t\t\treturn videoInfoModel;\n\t\t\t}\n\t\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t\t{\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmediaInfo.Close();\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") =>\n\t\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity($\"{InstrumentationNames.MediaInfo}.{name}\")\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t\t?.SetMetricName(InstrumentationNames.MediaInfo);\n\n\t\tprivate Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
            "content": "\ufeff#nullable enable\nusing System.Diagnostics;\n\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\n\nusing CLM.MessageDefines.Interfaces;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing ServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService.Extensions.Telemetry;\n\npublic static class ActivityExtensions\n{\n\tpublic static Activity? SetQueueTaskTags<T>(this Activity? activity, T task)\n\t\twhere T : IQueueTask\n\t\t=>\n\t\tactivity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);\n\n\tpublic static Activity? SetQueueTaskResultTags<T>(this Activity? activity, T task, ProcessTaskResult result)\n\t\twhere T : IQueueTask\n\t\t=>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageResultMessage, result.Message)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageLastErrorMessage, task.LastErrorMessage);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.API.GateKeeper.Telemetry;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.API.GateKeeper.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.API.GateKeeper\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing ADEXS.Web.Telemetry;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\nusing ADEXS.Core.Domain.Utilities;\n\nnamespace ADEXS.Web.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.WebNet\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/SSO/SSOEndpoint.ashx.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Web;\nusing System.Xml;\nusing ADEXS.Core.Domain.Repository.SSO;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Web.Common;\nusing ADEXS.Core.Types;\nusing ADEXS.Web.AtlasUrl;\nusing ADEXS.Web.Common.Logger;\nusing ADEXS.Web.Common.Helpers;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.DocuSignSync.Exceptions;\n\nusing CLM.MessageDefines.Event;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.Repository.EventRepository;\nusing ADEXS.Core.Domain.Repository.OAuth;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.Client;\nusing ADEXS.Web.Common.Exceptions;\nusing ADEXS.Web.Common.Interfaces;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.RequestHeaders;\n\nnamespace ADEXS.Web.SSO\n{\n\t/// <summary>\n\t/// Summary description for $codebehindclassname$\n\t/// </summary>\n\tpublic class SSOEndpoint : BaseApiHandler, IRequiresSessionState\n\t{\n\t\tprotected static readonly IDiscreetWebLog _log = DiscreetWebLogger.GetLogger(typeof(SSOEndpoint));\n\n\t\tpublic override bool IsReusable\n\t\t{\n\t\t\t// Return false in case your Managed Handler cannot be reused for another request.\n\t\t\t// Usually this would be false in case you have some state information preserved per request.\n\t\t\tget { return true; }\n\t\t}\n\n\t\tprotected override string Path => \"A/SSO/SSOEndpoint\";\n\n\t\tprotected override void HandleRequest(HttpContext context)\n\t\t{\n\t\t\tGuid errorReferenceId = Guid.NewGuid();\n\t\t\tXmlElement samlResponse = null;\n\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n#if NETFRAMEWORK\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context.ApplicationInstance?.Context);\n#else\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n#endif\n\n\t\t\t\tif (!string.IsNullOrEmpty(context.Request[Constants.QueryStringParameters.SAMLResponse]))\n\t\t\t\t{\n\t\t\t\t\t//Ok so check if samlResponse, if not check for aid, if not check domain\n\t\t\t\t\t//if samlresponse load account from idp stuff\n\t\t\t\t\tstring relayState;\n\t\t\t\t\tvar ssoHelper = ServiceLocator.GetInstance<ISsoHelper>();\n\n\t\t\t\t\tssoHelper.ReceiveSAMLResponse(context, out samlResponse, out relayState);\n\n\t\t\t\t\tUserAccount user = ssoHelper.GetUserFromContext(context, samlResponse);\n\t\t\t\t\t//No SSO for APIUsers\n\t\t\t\t\tif (user == null || user.IsApiUser)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII($\"SSO Failed for client: could not load user or user is an API user.  Reference Id: {errorReferenceId}\");\n\t\t\t\t\t\tcontext.Response.Redirect(WebUrl.Common.ErrorReferenceId(Resources.SSO.error_FailedSSO, errorReferenceId));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstring samlCookie = CookieHelper.Get3PCookie(context.Request.Cookies, Constants.HttpContextCookie.SamlCookie,\n\t\t\t\t\t\tConstants.HttpContextCookie.SamlCookiePartitioned)?.Value;\n\t\t\t\t\tbool success = false;\n\t\t\t\t\tstring message = string.Empty;\n\t\t\t\t\tstring responseUrl = WebUrl.Common.ErrorReferenceId(Resources.SSO.error_FailedSSO, errorReferenceId);\n\t\t\t\t\tstring issuer = string.Empty;\n\t\t\t\t\tstring sessionIndex = string.Empty;\n\t\t\t\t\tstring targetRestriction = string.Empty;\n\t\t\t\t\tstring ipAddress = IPAddressUtil.FetchIpAddress(context.Request);\n\t\t\t\t\tif (ServiceLocator.GetInstance<ISSORepository>().ValidateSamlResponse(samlResponse, user.Account, samlCookie, out message, out issuer, out sessionIndex, out targetRestriction))\n\t\t\t\t\t{\n\t\t\t\t\t\tSAMLToken token = new SAMLToken();\n\t\t\t\t\t\ttoken.TokenId = samlResponse.Attributes[\"ID\"].Value;\n\t\t\t\t\t\ttoken.AccountId = user.AccountId;\n\t\t\t\t\t\tstring msg = string.Empty;\n\t\t\t\t\t\tif (ServiceLocator.GetInstance<ISSORepository>().Create(user, token, ref msg))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ApplicationSettings.AllowInternetExplorer && UserAgent.Instance.IsIe && IsValidOAuthClient(relayState, out Guid clientId))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Desktop Applications authenticate with IE, an unsupported browser, so this condition determines if the login request came from a desktop application by checking if\n\t\t\t\t\t\t\t\t// the clientId is coming from an app registered in the DB. We read and clear this cookie in SessionData.Login()\n\t\t\t\t\t\t\t\t// See ATL-64113\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"Login request came from an OAuth client through an unsupported browser. ClientId: {clientId}\");\n\t\t\t\t\t\t\t\tvar cookieValue = Guid.NewGuid().ToString();\n\t\t\t\t\t\t\t\tCookieHelper.AddPartitioned3PCookies(context.Response?.Cookies,\n\t\t\t\t\t\t\t\t\tnew CreateCookieOptions(Constants.HttpContextCookie.IE11DeprecationOAuthClient, cookieValue, new BaseUrlprovider().BaseDomain(context.Request?.Url))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tExpires = DateTime.UtcNow.AddSeconds(120),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tnew CreateCookieOptions(Constants.HttpContextCookie.IE11DeprecationOAuthClientPartitioned, cookieValue, new BaseUrlprovider().BaseDomain(context.Request?.Url))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tExpires = DateTime.UtcNow.AddSeconds(120),\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tSessionData.Clear();\n\t\t\t\t\t\t\tbool isPasswordLogin = (!user.Account.SSOEnabled || SSORepository.IsAuthenticationApplicationRequest(issuer));\n\t\t\t\t\t\t\tSessionData.Login(user, ipAddress, out message, isPasswordLogin, false, false, (isPasswordLogin ? Enums.LoginAccessPoint.WebUI : Enums.LoginAccessPoint.SSO));\n\t\t\t\t\t\t\tif (string.IsNullOrEmpty(message))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tServiceLocator.GetInstance<IUserAccountRepository>().MarkUserActive(user);\n\n\t\t\t\t\t\t\t\t//Used for Single Logout\n\t\t\t\t\t\t\t\tif (issuer.Trim() != Constants.Authentication.AUTHENTICATION_APPLICATION_ISSUER)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSessionData.IsFederatedSession = true;\n\t\t\t\t\t\t\t\t\tSessionData.SSOSessionIndex = sessionIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//Restriction is only supported for MVC controllers currently, but can be extended to web forms pages if needed\n\t\t\t\t\t\t\t\tSessionData.RestrictedTo = targetRestriction;\n\n\t\t\t\t\t\t\t\tHttpCookie atlasCookie = context.Response.Cookies[Constants.HttpContextCookie.COOKIE_NAME];\n\t\t\t\t\t\t\t\tif (atlasCookie == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t(new UserCookie(context.Request) { FederatedAccountID = user.AccountId, UserId = user.Uid }).Set(context.Response);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tUserCookie userCookie = new UserCookie(atlasCookie);\n\t\t\t\t\t\t\t\t\tuserCookie.FederatedAccountID = user.AccountId;\n\t\t\t\t\t\t\t\t\tuserCookie.UserId = user.Uid;\n\t\t\t\t\t\t\t\t\tuserCookie.Set(context.Response);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tEventRepository.Instance.FireEvent(user, new UserLoginEvent(user.AccountId, user.Uid, Guid.Empty, 0, user.LastLoginDate));\n\t\t\t\t\t\t\t\tsuccess = true;\n\n\t\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(relayState))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trelayState = WebUrl.EnsureSpringUrl(relayState);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(relayState) && !relayState.Contains(\"/atlas/Login\"))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresponseUrl = relayState;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresponseUrl = WebUrl.Common.LandingPage;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ServiceLocator.GetInstance<IUserAccountRepository>().LoadReplicatedUserAndWaitForSecurityCalc(user.AccountId, user.Uid) == null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tresponseUrl = WebUrl.Atlas.FirstTimeUserSplashPage(responseUrl);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tresponseUrl = WebUrl.Common.Error(message, WebUrl.Auth.DefaultLogoutRedirectUrl());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Invalid SAMLResponse msg: {msg}  Reference Id: {errorReferenceId}\");\n\t\t\t\t\t\t\tresponseUrl = WebUrl.Common.ErrorReferenceId(msg, errorReferenceId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresponseUrl = WebUrl.Common.ErrorReferenceId(message, errorReferenceId);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!success)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Invalid SAMLResponse Xml Reference Id: {errorReferenceId}\");\n\t\t\t\t\t\t_log.DebugNoPII(samlResponse.OuterXml);\n\n\t\t\t\t\t\tCore.Domain.Model.Login login = ServiceLocator.GetInstance<ILoginRepository>().LoadLoginByAccountIdAndUserAccountUid(user.AccountId, user.Uid);\n\t\t\t\t\t\t//if the sso failed and the user has a password set then send them to login page\n\t\t\t\t\t\tif (!string.IsNullOrWhiteSpace(login?.AuthenticationHash ?? string.Empty) && user.Account.SSOEnabled && !SSORepository.IsAuthenticationApplicationRequest(issuer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresponseUrl = WebUrl.Auth.Login();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!string.IsNullOrWhiteSpace(message))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Invalid SAMLResponse Reference Id: {errorReferenceId}\");\n\t\t\t\t\t\t\t_log.DebugNoPII(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!SSORepository.IsAuthenticationApplicationRequest(issuer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tServiceLocator.GetInstance<IUserLoginLogPersistence>().LogInvalidLogin(user.AccountId, Guid.Empty, user.Uid, ipAddress, user.EmailAddress, Enums.LoginAccessPoint.SSO);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII(\"Valid SAMLResponse Xml\");\n\t\t\t\t\t\t_log.DebugNoPII(samlResponse.OuterXml);\n\t\t\t\t\t\tif (!SSORepository.IsAuthenticationApplicationRequest(issuer))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tServiceLocator.GetInstance<IUserLoginLogPersistence>().Log(user.AccountId, Guid.Empty, user.Uid, ipAddress, Enums.ActionType.LogIn, user.EmailAddress, Enums.LoginAccessPoint.SSO);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.Response.Redirect(responseUrl);\n\t\t\t\t}\n\t\t\t\t//Expect Initial Request and need AuthnRequest\n\t\t\t\t//For some reason the redirect doesn't happen, need to talk to ComponentSpace\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSSOHelper.AttemptSPInitiatedSSO(context);\n\t\t\t\t\t_log.WarnNoPII($\"SSO Failed for client. Non active account. Reference Id: {errorReferenceId}\");\n\t\t\t\t\tcontext.Response.Redirect(WebUrl.Common.ErrorReferenceId(Resources.SSO.error_FailedSSO, errorReferenceId));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (System.Threading.ThreadAbortException) { }\n\t\t\tcatch (UserNotEnabledForCLMException e)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"SSO failed. DocuSign User is not enabled for CLM {errorReferenceId}\", e);\n\t\t\t\tcontext.Response.Redirect(WebUrl.Common.ErrorReferenceId(Resources.SSO.error_CLMNotEnabled, errorReferenceId, false));\n\t\t\t}\n\t\t\tcatch (UnsupportedBrowserException)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"User is trying to access Docusign CLM from an unsupported browser {errorReferenceId}\");\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"SSO Failed for client.  Reference Id: {errorReferenceId}\", e);\n\t\t\t\tif (samlResponse != null)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"SamlResponse: {samlResponse.OuterXml}\");\n\t\t\t\t}\n\t\t\t\tcontext.Response.Redirect(WebUrl.Common.ErrorReferenceId(Resources.SSO.error_FailedSSO, errorReferenceId));\n\t\t\t}\n\t\t}\n\n\t\tprotected override bool ShouldRedirect() => AshxToControllerMigrationFeatureFlag.UseSSOEndpointController;\n\n#pragma warning disable CA1822 // Member 'IsValidOAuthClient' does not access instance data and can be marked as static\n\t\tprivate bool IsValidOAuthClient(string returnUrl, out Guid clientId)\n#pragma warning restore CA1822 // Member 'IsValidOAuthClient' does not access instance data and can be marked as static\n\t\t{\n\t\t\tclientId = Guid.Empty;\n\t\t\tif (string.IsNullOrEmpty(returnUrl))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"OAuth Client validation - Relay State is empty\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"OAuth Client validation - Relay State: {returnUrl}\");\n\n\t\t\tint indexOfParams = returnUrl.IndexOf('?');\n\t\t\tstring query = indexOfParams >= 0 ? returnUrl.Substring(indexOfParams) : \"\";\n\n\t\t\tif (returnUrl.IndexOf(\"oauth/authorize\", StringComparison.OrdinalIgnoreCase) >= 0 &&\n\t\t\t\tGuid.TryParse(HttpUtility.ParseQueryString(query).Get(Constants.QueryStringParameters.ClientId), out clientId) ||\n\t\t\t\t(returnUrl.IndexOf(\"oauth\", StringComparison.OrdinalIgnoreCase) >= 0 &&\n\t\t\t\tGuid.TryParse(HttpUtility.ParseQueryString(query).Get(Constants.QueryStringParameters.ApiKey), out clientId) &&\n\t\t\t\tApplicationSettings.AllowUnsupportedBrowserClientIds.Contains(clientId)))\n\t\t\t{\n\t\t\t\tvar oAuthClient = ServiceLocator.GetInstance<IOAuthRepository>().FindByClientId(clientId);\n\t\t\t\t_log.InfoNoPII($\"OAuth client details. ClientId: {clientId}, ClientName: {oAuthClient?.ProductName}\");\n\t\t\t\treturn oAuthClient != null;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"OAuth client not found for client id: {clientId}\");\n\t\t\treturn false;\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Web.Mvc;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Web.Common;\nusing ADEXS.Web.DocExplorer.Models.PanelModels;\nusing ADEXS.Web.MVC;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.Repository.MetadataRepository;\nusing ADEXS.Core.Types;\nusing ADEXS.Web.Common.Helpers;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Translation.Utilities;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.SqlCorePersistence;\nusing ADEXS.Web.AtlasUrl;\nusing ADEXS.Web.MVC.Filters;\nusing Newtonsoft.Json;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Web.Addressbook.Controls.ContactChooser;\nusing static ADEXS.Core.Types.Constants;\nusing Newtonsoft.Json.Linq;\nusing ADEXS.Web.Addressbook.MVC.Models;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Web.Telemetry;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.Web.DocExplorer.Controllers.PanelControllers\n{\n\t[RequireAuthentication(true, true, Enums.Privileges.HasGuestRights)]\n\t[SessionState(SessionStateBehavior.ReadOnly)]\n\tpublic class AttributesController : AtlasController\n\t{\n\t\t#region Properties and Variables\n\n\t\tprotected static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(AttributesController));\n\n\t\tprivate readonly IDocumentRepository _documentRepository;\n\t\tprivate readonly IFolderRepository _folderRepository;\n\t\tprivate readonly IMetadataRepository _metadataRepository;\n\t\tprivate readonly IMetadataGroupRepository _metadataGroupRepository;\n\t\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\t\tprivate IRetrieveTranslationUtility _translationUtility;\n\t\tprivate IRetrieveTranslationUtility TranslationUtility\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_translationUtility == null)\n\t\t\t\t{\n\t\t\t\t\t_translationUtility = ServiceLocator.GetInstance<IRetrieveTranslationUtility>();\n\t\t\t\t\t_translationUtility.SetDefaultNamespace(Enums.TranslationNamespace.Attributes);\n\t\t\t\t}\n\t\t\t\treturn _translationUtility;\n\t\t\t}\n\t\t}\n\n\t\tprivate Metadatas _persistedDocMetadatas;  // make this a private variable so that it doesn't have to be passed around\n\t\tprivate HashSet<Guid> _visibleGroupUids;\n\n\t\tprivate Dictionary<string, List<string>> keys = new Dictionary<string, List<string>>();\n\n\t\t#endregion\n\n\t\t#region Constructor\n\n\t\tpublic AttributesController(\n\t\t\tIDocumentRepository documentRepository,\n\t\t\tIFolderRepository folderRepository,\n\t\t\tIMetadataRepository metadataRepository,\n\t\t\tIMetadataGroupRepository metadataGroupRepository,\n\t\t\tIServiceInstrumentation serviceInstrumentation)\n\t\t{\n\t\t\t_documentRepository = documentRepository;\n\t\t\t_folderRepository = folderRepository;\n\t\t\t_metadataRepository = metadataRepository;\n\t\t\t_metadataGroupRepository = metadataGroupRepository;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t}\n\n\t\t#endregion\n\n\t\tpublic ActionResult Index(string id, Guid docUid, Guid folderUid, int priority = 0)\n\t\t{\n\t\t\tLoadAndValidateDocument(docUid);\n\t\t\tLoadAndValidateFolder(folderUid);\n\n\t\t\tvar currentUser = SessionData.CurrentUser;\n\n\t\t\t// don't load up the whole view model here, angular will lazy load it because the Attributes panel is not the first visible panel on the page\n\t\t\tAttributesViewModel vm = new AttributesViewModel\n\t\t\t{\n\t\t\t\tAccountId = currentUser.AccountId,\n\t\t\t\tId = id,\n\t\t\t\tdocUid = docUid,\n\t\t\t\tfolderUid = folderUid,\n\t\t\t\tPriority = priority,\n\t\t\t\tGroupType = Enums.ToStringIntDictionary<Enums.GroupType>(),\n\t\t\t\tChooserUrl = WebUrl.AddressBook.GetContacts,\n\t\t\t\tCanViewAttributes =  currentUser.Account.Settings.AllowAttributes && HasSufficientRightsToView(),\n\t\t\t\tShowDocumentDetails = ShouldShowDocumentDetails(currentUser)\n\t\t\t};\n\n\t\t\treturn PartialView(\"~/Views/DocExplorer/PanelViews/_AttributesPanel.cshtml\", vm);\n\t\t}\n\n\t\t[HttpPost]\n\t\t[CompressContentAttribute]\n\t\tpublic JsonResult SaveAttributes(string attrvm)\n\t\t{\n\t\t\tusing var saveActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes));\n\t\t\tsaveActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tattrvm = WebUtility.HtmlDecode(attrvm);\n\t\t\t\tvar attributes = attrvm.ToObject<AttributesViewModel>();\n\t\t\t\tsaveActivity?.SetTag(\"docusign.document.id\", attributes.docUid);\n\n\t\t\t\tvar document = LoadAndValidateDocument(attributes.docUid);\n\n\t\t\t\tif (AttributesShouldBeReadOnly(document))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"Attributes failed to save, document is read only.\");\n\t\t\t\t}\n\n\t\t\t\t_persistedDocMetadatas = _metadataRepository.Load(SessionData.CurrentUser, document.Type, document.Uid);\n\t\t\t\tsaveActivity?.AddEvent(new ActivityEvent(\"Preparing the save\", saveActivity.StartTimeUtc.Add(stopwatch.Elapsed)));\n\n\t\t\t\t// Perform setup work before saving, compare attributes that already exist on the document vs the attributes coming in from the client.\n\t\t\t\t// If a change is found, ensure the new values are validated and then build the Metadata objects that the MetadataRepository expects for saving.\n\t\t\t\tvar result = FindMetadatasThatNeedUpdating(attributes, document);\n\t\t\t\tsaveActivity?.AddEvent(new ActivityEvent(nameof(FindMetadatasThatNeedUpdating), saveActivity.StartTimeUtc.Add(stopwatch.Elapsed)));\n\n\t\t\t\tif (result.ErrorMessages != null && result.ErrorMessages.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tstatusMessages.AddErrorMessages(result.ErrorMessages);\n\t\t\t\t}\n\t\t\t\telse if (result.UpdatingMetadatas.Count == 0 && result.DeletingMetadatas.Count == 0 && result.DeletingGroups.Count == 0)\n\t\t\t\t{\n\t\t\t\t\tstatusMessages.AddInfoMessage(Resources.Admin.DocExplorer_NoChangesNothingSaved);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tusing (new DatabaseConnectionSwitch(SessionData.CurrentUser))\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (DatabaseTransaction transaction = DatabaseConnection.ThreadConnection.BeginTransaction())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar errors = new List<string>();\n\t\t\t\t\t\t\tif (result.UpdatingMetadatas.Count > 0 || result.DeletingMetadatas.Count > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/////***** Perform the Metedata SAVE here *****/////\n\t\t\t\t\t\t\t\terrors.AddRange(_metadataRepository.Save(SessionData.CurrentUser, result.UpdatingMetadatas, document, result.DeletingMetadatas));\n\n\t\t\t\t\t\t\t\tif (errors.Count == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tServiceLocator.GetInstance<IUserActionRepository>().LogUserAction(SessionData.CurrentUser, Enums.ActionType.MetadataChanged);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (errors.Count == 0 && result.DeletingGroups.Count > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/////***** Perform the Group SAVE here *****/////\n\t\t\t\t\t\t\t\terrors.AddRange(SaveDeletedGroups(result.DeletingGroups, document));\n\n\t\t\t\t\t\t\t\tif (errors.Count == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar _userAccount = SessionData.CurrentUser;\n\t\t\t\t\t\t\t\t\tstring groups = string.Join(Resources.Atlas.js_CommaSpace, result.DeletingGroups.Select(c => c.Name));\n\t\t\t\t\t\t\t\t\tJObject dataBag = new DocumentHistoryData(_userAccount).ToJObject();\n\t\t\t\t\t\t\t\t\tdataBag.Add(Constants.HistoryData.GROUPS, new JValue(groups));\n\t\t\t\t\t\t\t\t\tServiceLocator.GetInstance<IObjectHistoryUtility>().LogDocumentAction(_userAccount, document, Enums.ActionType.MetadataChanged, dataBag, Enums.HistoryMessageIdentifiers.Deleted);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsaveActivity?.AddEvent(new ActivityEvent(nameof(SaveAttributes), saveActivity.StartTimeUtc.Add(stopwatch.Elapsed)));\n\t\t\t\t\t\t\tif (errors.Count > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatusMessages.AddErrorMessages(errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttransaction.Commit();\n\n\t\t\t\t\t\t\t\tif (SessionData.CurrentUser.Settings.EnableABACSecurity && _documentRepository.GetUpdatedDocumentSecurity(SessionData.CurrentUser, document) < Enums.Security.Write)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSessionData.Messages.AddSuccessMessage(Resources.Admin.AttributesSaved);\n\t\t\t\t\t\t\t\t\tsaveActivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\t\t\t\t\t\treturn new JsonResult\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tData = new { success = true, ReloadRequired = true }\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstatusMessages.AddSuccessMessage(Resources.Admin.AttributesSaved);\n\n\t\t\t\t\t\t\t\tAttributesViewModel vm = null;\n\t\t\t\t\t\t\t\tif (SessionData.CurrentUser.Account.Settings.EnableCreateAttributeViewModelForDocExplorer)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvm = CreateAttributesViewModel(document);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsaveActivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\t\t\t\t\treturn new JsonResult\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tData = new { success = true, messages = statusMessages, vm = vm },\n\t\t\t\t\t\t\t\t\tMaxJsonLength = int.MaxValue\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsaveActivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\treturn Json(new { success = true, messages = statusMessages });\n\t\t\t}\n\t\t\tcatch(AdexsDisplayException ex)\n\t\t\t{\n\t\t\t\tstatusMessages.AddWarningMessage(ex.Message);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t[HttpPost]\n\t\t[CompressContentAttribute]\n\t\tpublic JsonResult LoadAttributes(Guid docUid, Guid folderUid)\n\t\t{\n\t\t\tusing var loadActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\tif (!HasSufficientRightsToView())\n\t\t\t{\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Atlas.error_YouDoNotHaveTheRequiredSecurityToAccessThisPage);\n\t\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAttributesViewModel viewModel;\n\t\t\t\tif (docUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tvar document = LoadAndValidateDocument(docUid);\n\t\t\t\t\tviewModel = CreateAttributesViewModel(document);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar folder = LoadAndValidateFolder(folderUid);\n\t\t\t\t\tviewModel = CreateAttributesViewModel(folder);\n\t\t\t\t}\n\n\t\t\t\tloadActivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn new JsonResult\n\t\t\t\t{\n\t\t\t\t\tData = new { success = true, messages = statusMessages, vm = viewModel },\n\t\t\t\t\tMaxJsonLength = int.MaxValue\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t[HttpPost]\n\t\t[CompressContentAttribute]\n\t\tpublic JsonResult LoadGroupSchema(Guid groupUid, Guid docUid, Guid folderUid)\n\t\t{\n\t\t\tusing var loadGroupSchemaActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (groupUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tthrow new ArgumentException(\"Group Uid must be provided\");\n\t\t\t\t}\n\n\t\t\t\tvar group = _metadataGroupRepository.LoadByUid(groupUid);\n\t\t\t\tif (group == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new ArgumentException($\"Group {groupUid} not found\");\n\t\t\t\t}\n\n\t\t\t\tgroup.SetTranslationUtility(TranslationUtility);\n\n\t\t\t\tLoadAndValidateDocument(docUid);\n\t\t\t\tLoadAndValidateFolder(folderUid);\n\t\t\t\t_persistedDocMetadatas = new Metadatas();  // Important! to get the groups schema only, we fake having NO metadata info\n\t\t\t\tvar groupViewModel = CreateGroupViewModelWithoutMetadata(new Dictionary<Guid, MetadataGroup> { [groupUid] = group }, folderUid, docUid, false).First();\n\n\t\t\t\tloadGroupSchemaActivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn Json(new { success = true, messages = statusMessages, gvm = groupViewModel });\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t[HttpPost]\n\t\tpublic JsonResult Refresh(Guid docUid)\n\t\t{\n\t\t\tusing var refreshActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\n\t\t\tif (!HasSufficientRightsToView())\n\t\t\t{\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Atlas.error_YouDoNotHaveTheRequiredSecurityToAccessThisPage);\n\t\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAttributesViewModel viewModel;\n\t\t\t\tif (docUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tvar document = LoadAndValidateDocument(docUid);\n\t\t\t\t\tviewModel = CreateAttributesViewModel(document);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception();\n\t\t\t\t}\n\n\t\t\t\trefreshActivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn new JsonResult\n\t\t\t\t{\n\t\t\t\t\tData = new { success = true, messages = statusMessages, viewModel = viewModel.ToJson() },\n\t\t\t\t\tMaxJsonLength = int.MaxValue\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t[HttpPost]\n\t\t[CompressContentAttribute]\n\t\tpublic JsonResult LoadCascadingDropdownOptions(Guid metadataFieldUid, Guid metadataSetUid, Guid docUid, string keyPath)\n\t\t{\n\t\t\tusing var loadCascadingDropdownOptionsActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (metadataFieldUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tthrow new ArgumentException(@\"Parameter cannot be an empty guid.\", nameof(metadataFieldUid));\n\t\t\t\t}\n\n\t\t\t\tif (metadataSetUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tthrow new ArgumentException(@\"Parameter cannot be an empty guid.\", nameof(metadataSetUid));\n\t\t\t\t}\n\n\t\t\t\tif (docUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tstatusMessages.AddInfoMessage(Resources.Documents.YouMustSaveThisDocumentBeforeCascadingDropdownsCanBeLoaded);\n\t\t\t\t\treturn Json(new { success = false, messages = statusMessages});\n\t\t\t\t}\n\t\t\t\tvar keyPathList = keyPath == null ? new List<string>() : keyPath.ToObject<List<string>>();\n\n\t\t\t\tLoadAndValidateDocument(docUid);\n\n\t\t\t\tvar options = _metadataRepository.GetCascadingTypeAheadValues(metadataSetUid, metadataFieldUid, keyPathList, SessionData.CurrentAccountId);\n\n\t\t\t\tloadCascadingDropdownOptionsActivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\treturn Json(new { success = true, messages = statusMessages, options = options.Values });\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t#region Private functions\n\n\t\tpublic Document LoadAndValidateDocument(Guid docUid)\n\t\t{\n\t\t\tDocument document = null;\n\t\t\tif (docUid != Guid.Empty)\n\t\t\t{\n\t\t\t\tdocument = _documentRepository.LoadByUid(SessionData.CurrentUser, docUid);\n\t\t\t\tif (document == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"Document does not exist or current user does not have permissions to view this document.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn document;\n\t\t}\n\t\tpublic Folder LoadAndValidateFolder(Guid folderUid)\n\t\t{\n\t\t\tFolder folder = null;\n\t\t\tif (folderUid != Guid.Empty)\n\t\t\t{\n\t\t\t\tfolder = _folderRepository.LoadByUid(SessionData.CurrentUser, folderUid);\n\t\t\t\tif (folder == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"Folder does not exist or current user does not have access to this folder.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn folder;\n\t\t}\n\n\t\tprivate bool AttributesShouldBeReadOnly(Document document)\n\t\t{\n\t\t\tif(document == null)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (document.IsViewOnly(SessionData.CurrentUser))  // checked out / locked status\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!document.HasSecurity(Enums.Security.Write))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (_documentRepository.IsTrashed(SessionData.CurrentUser, document))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate bool IsGroupAvailable(MetadataGroup metadataGroup, Guid folderUid)\n\t\t{\n\t\t\tif(_visibleGroupUids == null)\n\t\t\t{\n\t\t\t\t_visibleGroupUids = _metadataGroupRepository.LoadDisplayByAccountIdAndFolderUid(SessionData.CurrentAccountId, folderUid) ?? new HashSet<Guid>();\n\t\t\t}\n\n\t\t\tif (_visibleGroupUids.Count > 0 && !_visibleGroupUids.Contains(metadataGroup.Uid))\n\t\t\t{\n\t\t\t\treturn false;  // this group is not available because the parent folder is hiding this attribute group\n\t\t\t}\n\n\t\t\treturn !metadataGroup.Hidden;\n\t\t}\n\n\t\tprivate bool HasSufficientRightsToView()\n\t\t{\n\t\t\treturn SessionData.CurrentUser.Role <= SessionData.CurrentUser.Account.Settings.AllowToViewAttributesRole;\n\t\t}\n\n\t\t// Methods used for LOADING metadata\n\t\tprivate AttributesViewModel CreateAttributesViewModel(Folder folder)\n\t\t{\n\t\t\tMetadataGroups allGroups = _metadataGroupRepository.LoadByAccountId(SessionData.CurrentAccountId);\n\t\t\t_persistedDocMetadatas = new Metadatas(); // there is no document, so there are no metadatas\n\n\t\t\t//Start building the view model for the attributes page\n\t\t\tAttributesViewModel vm = new AttributesViewModel();\n\t\t\tvm.folderUid = folder.Uid;\n\t\t\tvm.docUid = Guid.Empty;\n\t\t\tvm.ReadOnly = false; // todo: should we check if the user has permissions to create a document in this folder?\n\t\t\tvm.CanViewAttributes = HasSufficientRightsToView();\n\t\t\tvm.ShowDocumentDetails = ShouldShowDocumentDetails(SessionData.CurrentUser);\n\t\t\tvm.groups = CreateGroupViewModelWithoutMetadata(allGroups.ToDictionary(x => x.Uid, x => x), folder.Uid, Guid.Empty, vm.ReadOnly);\n\t\t\t\n\t\t\treturn vm;\n\t\t}\n\t\tprivate AttributesViewModel CreateAttributesViewModel(Document document)\n\t\t{\n\t\t\tMetadataGroups allGroups = _metadataGroupRepository.LoadByAccountId(SessionData.CurrentAccountId);\n\t\t\t_persistedDocMetadatas = _metadataRepository.Load(SessionData.CurrentUser, document.Type, document.Uid);\n\n\t\t\t//Start building the view model for the attributes page\n\t\t\tAttributesViewModel vm = new AttributesViewModel();\n\t\t\tvm.folderUid = document.FolderUid;\n\t\t\tvm.docUid = document.Uid;\n\t\t\tvm.ReadOnly = AttributesShouldBeReadOnly(document);\n\t\t\tvm.groups = CreateGroupsViewModelWithMetadata(allGroups, document.FolderUid, document.Uid, vm.ReadOnly).ToList();\n\t\t\tvm.EnableCreateAttributeViewModelForDocExplorer =\n\t\t\t\tShouldEnableCreateAttributeViewModel(SessionData.CurrentUser);\n\n\t\t\treturn vm;\n\t\t}\n\n\t\tprivate IEnumerable<AttributeGroupViewModel> CreateGroupsViewModelWithMetadata(MetadataGroups allGroups, Guid folderUid, Guid documentUid, bool docIsReadOnly)\n\t\t{\n\t\t\tvar groupsRemaining = allGroups.ToDictionary(x => x.Uid, x => x);\n\t\t\tbool isLoadingAllAttributeGroupFieldOptions =\n\t\t\t\tDocumentAttributesFeatureFlags.EnableLoadingAllAttributeGroupFieldOptions;\n\t\t\tvar groups = ProcessMetadataIntoModels(\n\t\t\t\tmetadatas: _persistedDocMetadatas,\n\t\t\t\tgroupsRemaining: groupsRemaining,\n\t\t\t\tisAttached: true,\n\t\t\t\tdocumentUid: documentUid,\n\t\t\t\tdocIsReadOnly: docIsReadOnly,\n\t\t\t\tgroupFields: new Dictionary<Guid, MetadataFields>(),\n\t\t\t\tshouldLoadAllMetadataFieldOptions: isLoadingAllAttributeGroupFieldOptions);\n\n\t\t\tgroups.AddRange(CreateGroupViewModelWithoutMetadata(groupsRemaining, folderUid, documentUid, docIsReadOnly, isLoadingAllAttributeGroupFieldOptions));\n\n\t\t\treturn groups.OrderBy(x => x.position);\n\t\t}\n\n\t\tprivate List<AttributeGroupViewModel> CreateGroupViewModelWithoutMetadata(Dictionary<Guid, MetadataGroup> allGroups, Guid folderUid, Guid documentUid, bool docIsReadOnly, bool shouldLoadAllMetadataFieldOptions = true)\n\t\t{\n\t\t\tMetadatas groupMetadatas = new Metadatas();\n\t\t\tDictionary<Guid, MetadataFields> groupFields = new Dictionary<Guid, MetadataFields>();\n\t\t\tforeach (MetadataGroup metadataGroup in allGroups.Values.Where(x => IsGroupAvailable(x, folderUid)))\n\t\t\t{\n\t\t\t\t// the group is not attached, so lets create a Metadata object that acts as a template for a field\n\t\t\t\tgroupFields[metadataGroup.Uid] =\n\t\t\t\t\t_metadataRepository.GetMetadataFieldsByMetadataGroupUid(SessionData.CurrentAccountId,\n\t\t\t\t\t\tmetadataGroup.Uid);\n\t\t\t\tforeach (MetadataField metadataField in groupFields[metadataGroup.Uid])\n\t\t\t\t{\n\t\t\t\t\tMetadata metadataTemplate = new Metadata(SessionData.CurrentAccountId, metadataField,\n\t\t\t\t\t\tmetadataField.MetadataSetNumber, Enums.ObjectType.Document, Guid.Empty, null);\n\t\t\t\t\tgroupMetadatas.Add(metadataTemplate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ProcessMetadataIntoModels(groupMetadatas, allGroups, false, documentUid, docIsReadOnly, groupFields, shouldLoadAllMetadataFieldOptions);\n\t\t}\n\n\t\tprivate List<AttributeGroupViewModel> ProcessMetadataIntoModels(Metadatas metadatas, Dictionary<Guid, MetadataGroup> groupsRemaining, bool isAttached, Guid documentUid, bool docIsReadOnly, Dictionary<Guid, MetadataFields> groupFields, bool shouldLoadAllMetadataFieldOptions = true)\n\t\t{\n\t\t\tList<AttributeGroupViewModel> groups = new List<AttributeGroupViewModel>();\n\t\t\t//_metadataRepository.LoadByDocumentUid shall be called only when allowAllAttributes == FALSE , in case of TRUE documentMetadataUids will not be used. Avoiding unnecessary in case of TRUE \n\t\t\tvar documentMetadataUids = shouldLoadAllMetadataFieldOptions ? new HashSet<Guid>() : _metadataRepository.LoadByDocumentUid(SessionData.CurrentAccountId, documentUid).Select(m => m.MetadataFieldUid).ToHashSet();\n\t\t\tGuid currentGroupUid = Guid.Empty;\n\t\t\tAttributeGroupViewModel currentGroupModel = null;\n\t\t\tAttributeGroupItemViewModel currentGroupItemModel = new AttributeGroupItemViewModel();\n\t\t\t// first process any groups that are already attached to the document\n\t\t\tforeach (Metadata metadata in metadatas)\n\t\t\t{\n\t\t\t\t// filter out protected AOM system metadata groups because these are made editable on the panel via DocumentDetailsController\n\t\t\t\t// metadata groups are retained on the folders/documents for use in search and reporting\n\t\t\t\tif (metadata.MetadataGroupName == SystemMetadataGroupNames.CLM_PARTY || metadata.MetadataGroupName == SystemMetadataGroupNames.CLM_AGREEMENT_DETAILS)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmetadata.SetTranslationUtility(TranslationUtility);\n\t\t\t\t// metadata is loaded ordered by group position and than name so all rows from the same group are naturally clustered together and when we see a new groupUid, we know we can are done with the previous group and can start processing the new one\n\t\t\t\tif (metadata.MetadataGroupUid != currentGroupUid)\n\t\t\t\t{\n\t\t\t\t\tcurrentGroupUid = metadata.MetadataGroupUid;\n\t\t\t\t\tcurrentGroupModel = new AttributeGroupViewModel\n\t\t\t\t\t{\n\t\t\t\t\t\tid = currentGroupUid.ToString(),\n\t\t\t\t\t\tname = metadata.LocalizedGroupName,\n\t\t\t\t\t\tposition = metadata.MetadataGroupPosition,\n\t\t\t\t\t\titems = new List<AttributeGroupItemViewModel>(),\n\t\t\t\t\t\tattached = isAttached,\n\t\t\t\t\t\tdefinitionHash = groupFields.ContainsKey(currentGroupUid) ? HashObject(Transform(groupFields[currentGroupUid])) : CreateMetadataGroupHash(currentGroupUid),\n\t\t\t\t\t\tisSystem = groupsRemaining[currentGroupUid].System\n\t\t\t\t\t};\n\t\t\t\t\tgroups.Add(currentGroupModel);\n\t\t\t\t\tgroupsRemaining.Remove(currentGroupUid);\n\t\t\t\t}\n\n\t\t\t\t// metadata loaded is further ordered by metadata set number and name which ensures that all metadata from the same set is clustered together\n\t\t\t\tif (metadata.MetadataSetUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tcurrentGroupItemModel = CreateAttributeGroupItemViewModelFromField(metadata);\n\t\t\t\t\tcurrentGroupModel.items.Add(currentGroupItemModel);\n\t\t\t\t}\n\t\t\t\telse if (metadata.MetadataSetUid.ToString() != currentGroupItemModel.setid || metadata.MetadataSetPosition != currentGroupItemModel.position || (metadata.MetadataSetRepeating ? metadata.MetadataSetNumber : 0) != currentGroupItemModel.number)\n\t\t\t\t{\n\t\t\t\t\tcurrentGroupItemModel = CreateSetAttributeGroupItemViewModelFromSet(metadata);\n\t\t\t\t\tcurrentGroupModel.items.Add(currentGroupItemModel);\n\t\t\t\t}\n\t\t\t\tbool populateOptions = shouldLoadAllMetadataFieldOptions || documentMetadataUids.Contains(metadata.MetadataFieldUid);\n\t\t\t\tcurrentGroupItemModel.fields.Add(CreateAttributeFieldViewModel(metadata, documentUid, docIsReadOnly, populateOptions));\n\t\t\t}\n\n\t\t\treturn groups;\n\t\t}\n\n\t\tprivate AttributeGroupItemViewModel CreateAttributeGroupItemViewModelFromField(Metadata docMetadata)\n\t\t{\n\t\t\tAttributeGroupItemViewModel groupItemVm = new AttributeGroupItemViewModel();\n\t\t\tgroupItemVm.type = \"field\";\n\t\t\tgroupItemVm.id = Guid.NewGuid().ToString();\n\t\t\tgroupItemVm.fieldid = docMetadata.MetadataFieldUid.ToString();\n\t\t\tgroupItemVm.groupid = docMetadata.MetadataGroupUid.ToString();\n\t\t\tgroupItemVm.position = docMetadata.MetadataFieldPosition;\n\t\t\tgroupItemVm.name = docMetadata.LocalizedName;\n\t\t\tgroupItemVm.number = docMetadata.Repeating ? docMetadata.MetadataSetNumber : 0;\n\t\t\tgroupItemVm.repeating = docMetadata.Repeating;\n\t\t\tgroupItemVm.fields = new List<AttributeFieldViewModel>();\n\t\t\treturn groupItemVm;\n\t\t}\n\t\tprivate AttributeGroupItemViewModel CreateSetAttributeGroupItemViewModelFromSet(Metadata docMetadata)\n\t\t{\n\t\t\tAttributeGroupItemViewModel groupItemVm = new AttributeGroupItemViewModel();\n\t\t\tgroupItemVm.type = \"set\";\n\t\t\tgroupItemVm.id = Guid.NewGuid().ToString();\n\t\t\tgroupItemVm.setid = docMetadata.MetadataSetUid.ToString();\n\t\t\tgroupItemVm.groupid = docMetadata.MetadataGroupUid.ToString();\n\t\t\tgroupItemVm.position = docMetadata.MetadataSetPosition;\n\t\t\tgroupItemVm.name = docMetadata.LocalizedSetName;\n\t\t\tgroupItemVm.number = docMetadata.MetadataSetRepeating ? docMetadata.MetadataSetNumber : 0;\n\t\t\tgroupItemVm.repeating = docMetadata.MetadataSetRepeating;\n\t\t\tgroupItemVm.fields = new List<AttributeFieldViewModel>();\n\t\t\treturn groupItemVm;\n\t\t}\n\t\tprivate AttributeFieldViewModel CreateAttributeFieldViewModel(\n\t\t\tMetadata docMetadata,\n\t\t\tGuid documentUid,\n\t\t\tbool docIsReadonly,\n\t\t\tbool populateOptions = true)\n\t\t{\n\t\t\tvar fieldvm = new AttributeFieldViewModel();\n\t\t\tfieldvm.id = Guid.NewGuid().ToString();\n\t\t\tfieldvm.metadataid = docMetadata.Uid.ToString();\n\t\t\tfieldvm.fieldid = docMetadata.MetadataFieldUid.ToString();\n\t\t\tfieldvm.name = docMetadata.LocalizedName;\n\t\t\tfieldvm.dataType = (int)docMetadata.DataType;\n\t\t\tfieldvm.value = MetadataRepository.FormatMetaValue(docMetadata.LocalizedValue, docMetadata.DataType, SessionData.CurrentCulture);\n\t\t\tfieldvm.required = docMetadata.IsRequiredAttribute;\n\t\t\tfieldvm.readOnly = docIsReadonly || docMetadata.ReadOnly;\n\t\t\tfieldvm.customErrorMessage = docMetadata.LocalizedCustomValidationErrMsg;\n\t\t\tfieldvm.validationRegEx = docMetadata.LocalizedCustomValidation;\n\t\t\tfieldvm.position = docMetadata.MetadataFieldPosition;\n\t\t\t//String datatype and isLink check\n\t\t\tfieldvm.isLink = docMetadata.DataType == Enums.DataType.String && Uri.IsWellFormedUriString(fieldvm.value, UriKind.Absolute);\n\t\t\t//docMetadata.Definition  // what is this?\n\t\t\tif (docMetadata.DataType == Enums.DataType.Number || docMetadata.DataType == Enums.DataType.Decimal)\n\t\t\t{\n\t\t\t\tfieldvm.decimalChar = SessionData.CurrentCulture.NumberFormat.NumberDecimalSeparator;\n\t\t\t\tfieldvm.groupingChar = SessionData.CurrentCulture.NumberFormat.NumberGroupSeparator;\n\t\t\t}\n\t\t\t//Special casing for various data types\n\t\t\tif (docMetadata.DataType == Enums.DataType.Date)\n\t\t\t{\n\t\t\t\tfieldvm.value = Regex.Replace(fieldvm.value, Constants.SpecialDateTimeFormatCharactersRegexPattern, string.Empty);\n\t\t\t\tfieldvm.dateFormat = \"M/d/yyyy\"; // default value\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfieldvm.dateFormat = SessionData.CurrentCulture.DateTimeFormat.ShortDatePattern;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII(\"Unable to retrieve users date pattern\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (docMetadata.DataType == Enums.DataType.DropDown || docMetadata.DataType == Enums.DataType.MagicDropDown)\n\t\t\t{\n\t\t\t\tvar options = new List<string>();\n\t\t\t\tif (populateOptions)\n\t\t\t\t{\n\t\t\t\t\toptions.AddRange(docMetadata.LocalizedAllowedDropDownValues().Distinct());\n\t\t\t\t}\n\t\t\t\t// if the value is not in the allowed values (e.g., set via workflow), add that value to the list so the field populates\n\t\t\t\tif (!string.IsNullOrEmpty(fieldvm.value) && !options.Contains(fieldvm.value))\n\t\t\t\t{\n\t\t\t\t\toptions.Add(fieldvm.value);\n\t\t\t\t}\n\n\t\t\t\tfieldvm.options = options;\n\t\t\t}\n\t\t\tif (docMetadata.DataType == Enums.DataType.Cascade)\n\t\t\t{\n\t\t\t\tstring myKey = $\"{docMetadata.MetadataSetUid}-{docMetadata.MetadataSetNumber}\";\n\t\t\t\tif (!keys.ContainsKey(myKey))\n\t\t\t\t{\n\t\t\t\t\tkeys.Add(myKey, new List<string>());\n\t\t\t\t}\n\n\t\t\t\tvar keyPath = keys[myKey];\n\t\t\t\tif (populateOptions && (keyPath.Count <= 0 || !string.IsNullOrEmpty(keyPath.Last())))\n\t\t\t\t{\n\t\t\t\t\tbool enableCascadingAttributesCacheOptimization =\n\t\t\t\t\t\tDocumentAttributesFeatureFlags.EnableCascadingAttributesCacheOptimization;\n\t\t\t\t\tSortedList<string, string> options = new SortedList<string, string>();\n\t\t\t\t\tif (enableCascadingAttributesCacheOptimization)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions = _metadataRepository.GetCascadingTypeAheadValues(docMetadata.MetadataSetUid, docMetadata.MetadataFieldUid, keyPath, docMetadata.AccountId, new Dictionary<Guid, CascadingFieldSet>());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toptions = _metadataRepository.GetCascadingTypeAheadValues(docMetadata.MetadataSetUid, docMetadata.MetadataFieldUid, keyPath, docMetadata.AccountId);\n\t\t\t\t\t}\n\n\t\t\t\t\tfieldvm.options = options.Values.ToList();\n\t\t\t\t\t\n\t\t\t\t\tif(!string.IsNullOrEmpty(fieldvm.value))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (options.ContainsKey(fieldvm.value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldvm.value = options[fieldvm.value];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!options.ContainsValue(fieldvm.value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldvm.options.Add(fieldvm.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfieldvm.options = new List<string>();\n\t\t\t\t}\n\n\t\t\t\tif(docMetadata.Value == null)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"DocMetadata value was null and added to keypath which may result in a null reference exception.\" +\n\t\t\t\t\t\t$\" DocMetadata Field Id: {docMetadata.MetadataFieldUid}, DocMetadata Field's Group Uid: {docMetadata.MetadataGroupUid}.\");\n\t\t\t\t}\n\t\t\t\tkeyPath.Add(docMetadata.Value);\n\t\t\t}\n\t\t\tif (docMetadata.DataType == Enums.DataType.Actor)\n\t\t\t{\n\t\t\t\tfieldvm.chooserDataSource = EntityDataSource.GetActorEntityDataSource(ActorAttributeRestriction.LoadFromMetadata(docMetadata.Definition, docMetadata.AccountId, docMetadata.MetadataFieldUid));\n\t\t\t}\n\t\t\treturn fieldvm;\n\t\t}\n\n\n\t\t// Methods used for SAVING metadata\n\n\t\tprivate List<string> SaveDeletedGroups(MetadataGroups deletingGroups, Document document)\n\t\t{\n\t\t\tList<string> errorMessages = new List<string>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tforeach (MetadataGroup mg in deletingGroups)\n\t\t\t\t{\n\t\t\t\t\t_metadataRepository.DeleteByMetadataGroupUid(SessionData.CurrentAccountId, mg.Uid, document.Type, document.Uid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to delete attributes from document '{document.Uid}' with group uids {string.Join(\", \", deletingGroups.Select(c => c.Uid).ToList())}.\", ex);\n\t\t\t\terrorMessages.Add(Resources.Admin.AttributesSaveGroupsFailed);\n\t\t\t}\n\t\t\treturn errorMessages;\n\t\t}\n\n\t\tprivate ChangedMetadatasResult FindMetadatasThatNeedUpdating(AttributesViewModel attributes, Document document)\n\t\t{\n\t\t\tMetadatas updateMetadatas = new Metadatas();\n\t\t\tMetadatas deleteMetadatas = new Metadatas();\n\t\t\tMetadataGroups deletingGroups = new MetadataGroups();\n\t\t\tList<string> errorMessages = new List<string>();\n\t\t\tDictionary<string, List<AttributeGroupItemViewModel>> repeatingItems = new Dictionary<string, List<AttributeGroupItemViewModel>>();\n\t\t\tforeach (AttributeGroupViewModel group in attributes.groups)\n\t\t\t{\n\t\t\t\tif (IsSystemGroup(group))\n\t\t\t\t{\n\t\t\t\t\tcontinue;  // system level groups can not get modified by end users\n\t\t\t\t}\n\n\t\t\t\tswitch (GetGroupDocState(group))\n\t\t\t\t{\n\t\t\t\t\tcase GroupDocState.GroupContinueBeingDetached:\n\t\t\t\t\t\tcontinue; // no need to process this groups items, this group is NOT attached to this document\n\t\t\t\t\tcase GroupDocState.GroupDetaching:\n\t\t\t\t\t\tdeletingGroups.Add(new MetadataGroup { Uid = Guid.Parse(group.id), Name = group.name });\n\t\t\t\t\t\tcontinue; // no need to process this groups items, they will all get deleted\n\t\t\t\t\tcase GroupDocState.GroupAttaching:\n\t\t\t\t\t\tupdateMetadatas.Add(CreateMetadataPlaceHolderForGroup(group, document));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GroupDocState.GroupContinueBeingAttached:\n\t\t\t\t\t\t// nothing special here, process items below to check for updates \n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tValidateGroup(group);\n\n\t\t\t\tforeach (AttributeGroupItemViewModel item in group.items)\n\t\t\t\t{\n\t\t\t\t\t// HANDLE REPEATING ITEMS (collect repeating fields, and process them later)\n\t\t\t\t\tif (item.repeating)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring itemTypeId = item.type == \"field\" ? item.fieldid : item.setid;\n\t\t\t\t\t\tif (!repeatingItems.ContainsKey(itemTypeId))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trepeatingItems.Add(itemTypeId, new List<AttributeGroupItemViewModel>());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trepeatingItems[itemTypeId].Add(item);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// HANDLE NON-REPEATING ITEMS\n\t\t\t\t\tforeach (AttributeFieldViewModel field in item.fields)\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid metadataUid = Guid.Parse(field.metadataid);\n\t\t\t\t\t\tMetadata persistedMetadata = metadataUid == Guid.Empty\n\t\t\t\t\t\t\t? _persistedDocMetadatas.FirstOrDefault(c => c.MetadataFieldUid == Guid.Parse(field.fieldid))\n\t\t\t\t\t\t\t: _persistedDocMetadatas.SingleOrDefault(c => c.Uid == metadataUid);\n\t\t\t\t\t\tif (persistedMetadata == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// this is a field from a GROUP that is being added to the document, retrieve the MetadataField to create a Metadata object\n\t\t\t\t\t\t\tMetadataField metaField = _metadataRepository.GetMetadataField(SessionData.CurrentAccountId, Guid.Parse(field.fieldid));\n\t\t\t\t\t\t\tmetaField.SetTranslationUtility(TranslationUtility);\n\t\t\t\t\t\t\tpersistedMetadata = new Metadata(SessionData.CurrentAccountId, metaField, document.Type, document.Uid, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tMetadataFieldResult result;\n\t\t\t\t\t\tif (IsFieldMarkedForDelete(field, item, group))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = DeleteMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (metadataUid == Guid.Empty)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = CreateMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = UpdateMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (result.Proceed && result.ResultType == MetadataFieldResultType.Update)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tupdateMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (result.Proceed && result.ResultType == MetadataFieldResultType.Delete)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdeleteMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!string.IsNullOrEmpty(result.ErrorMessage))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terrorMessages.Add(result.ErrorMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach (KeyValuePair<string, List<AttributeGroupItemViewModel>> repeatedItem in repeatingItems)\n\t\t\t{\n\t\t\t\tList<AttributeGroupItemViewModel> items = repeatedItem.Value; // items is a list of all instances of a repeated item or set\n\n\t\t\t\t// retrieve the existing persisted metadatas on the document for the repeating items\n\t\t\t\t// this does not include synthesized rows(aka fake/non-actual rows), also these values come back in a SPECIFIC ORDER)\n\t\t\t\tList<Metadata> persistedMetadatas = GetPersistedMetadatasForRepeatableItem(items[0]);\n\n\t\t\t\tAttributeGroupViewModel group = attributes.groups.First(c => c.id == items[0].groupid);\n\n\t\t\t\tint currentMaxSetNumber = persistedMetadatas.Count == 0 ? 0 : persistedMetadatas.Max(c => c.MetadataSetNumber);\n\n\t\t\t\t// handle deleting items first! Important: remove them from the persistedMetadatas collection\n\t\t\t\tMetadataFieldResult result;\n\t\t\t\tforeach (AttributeGroupItemViewModel item in items)\n\t\t\t\t{\n\t\t\t\t\tif (!IsItemMarkedForDelete( item, group))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tforeach (AttributeFieldViewModel field in item.fields)\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid metadataUid = Guid.Parse(field.metadataid);\n\t\t\t\t\t\tif (metadataUid != Guid.Empty) // empty guid would indicate that this is a field that has yet to be created (therefore do nothing, because there is nothing to delete)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMetadata persistedMetadata = persistedMetadatas.Single(c => c.Uid == metadataUid); // this has to be here, or there is nothing to delete\n\t\t\t\t\t\t\tresult = DeleteMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t\tif (result.Proceed)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdeleteMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!string.IsNullOrEmpty(result.ErrorMessage))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terrorMessages.Add(result.ErrorMessage);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpersistedMetadatas.Remove(persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// handle non-deleting items, existing metadatas will be used first so that we can preserve the clients order of the repeatable fields\n\t\t\t\tQueue<int> metadataSetNumbersQueue = new Queue<int>(persistedMetadatas.Select(c => c.MetadataSetNumber).Distinct().OrderBy(c => c));\n\t\t\t\tforeach (AttributeGroupItemViewModel item in items)\n\t\t\t\t{\n\t\t\t\t\tif (IsItemMarkedForDelete(item, group))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint metadataSetNumberToUse = metadataSetNumbersQueue.Count > 0 ? metadataSetNumbersQueue.Dequeue() : (currentMaxSetNumber += 1);\n\n\t\t\t\t\tforeach (AttributeFieldViewModel field in item.fields)\n\t\t\t\t\t{\n\t\t\t\t\t\t// DO NOT retrieve by metadatauid, we use the metadatasetnumber to preserve the ORDER the client wants\n\t\t\t\t\t\tMetadata persistedMetadata = persistedMetadatas.FirstOrDefault(c => c.MetadataSetNumber == metadataSetNumberToUse && (int)c.DataType == field.dataType && c.MetadataFieldUid == Guid.Parse(field.fieldid));\n\n\t\t\t\t\t\tif (persistedMetadata != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpersistedMetadatas.Remove(persistedMetadata);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (persistedMetadata == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpersistedMetadata = _persistedDocMetadatas.FirstOrDefault(c => c.MetadataFieldUid == Guid.Parse(field.fieldid) && c.Uid == Guid.Empty);\n\t\t\t\t\t\t\tif (persistedMetadata == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// this is a field from a GROUP that is being added to the document, retrieve the MetadataField to create a Metadata object\n\t\t\t\t\t\t\t\tMetadataField metaField = _metadataRepository.GetMetadataField(SessionData.CurrentAccountId, Guid.Parse(field.fieldid));\n\t\t\t\t\t\t\t\tmetaField.SetTranslationUtility(TranslationUtility);\n\t\t\t\t\t\t\t\tpersistedMetadata = new Metadata(SessionData.CurrentAccountId, metaField, document.Type, document.Uid, null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpersistedMetadata.MetadataSetNumber = metadataSetNumberToUse;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (IsFieldMarkedForDelete(field, item, group))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = DeleteMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (persistedMetadata.Uid == Guid.Empty)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = CreateMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = UpdateMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (result.Proceed && result.ResultType == MetadataFieldResultType.Update)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tupdateMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (result.Proceed && result.ResultType == MetadataFieldResultType.Delete)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdeleteMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!string.IsNullOrEmpty(result.ErrorMessage))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terrorMessages.Add(result.ErrorMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new ChangedMetadatasResult\n\t\t\t{\n\t\t\t\tUpdatingMetadatas = updateMetadatas,\n\t\t\t\tDeletingMetadatas = deleteMetadatas,\n\t\t\t\tDeletingGroups = deletingGroups,\n\t\t\t\tErrorMessages = errorMessages\n\t\t\t};\n\t\t}\n\n\t\tprivate Metadata CreateMetadataPlaceHolderForGroup(AttributeGroupViewModel groupvm, Document document)\n\t\t{\n\t\t\treturn new Metadata(SessionData.CurrentAccountId, Guid.Parse(groupvm.id), Guid.Empty, document.Type, document.Uid, null) {MetadataGroupName = groupvm.name};\n\t\t}\n\n\t\tprivate GroupDocState GetGroupDocState(AttributeGroupViewModel groupvm)\n\t\t{\n\t\t\t// group is marked as attached to doc, and there are NO existing metadatas on the document\n\t\t\tGuid groupUid = Guid.Parse(groupvm.id);\n\t\t\tbool hasExistingMetadatas = _persistedDocMetadatas.Any(c => c.MetadataGroupUid == groupUid);\n\t\t\tif (groupvm.attached)\n\t\t\t{\n\t\t\t\treturn hasExistingMetadatas ? GroupDocState.GroupContinueBeingAttached : GroupDocState.GroupAttaching;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn hasExistingMetadatas ? GroupDocState.GroupDetaching : GroupDocState.GroupContinueBeingDetached;\n\t\t\t}\n\t\t}\n\n\t\tpublic enum GroupDocState\n\t\t{\n\t\t\tGroupAttaching,\n\t\t\tGroupDetaching,\n\t\t\tGroupContinueBeingAttached,\n\t\t\tGroupContinueBeingDetached\n\t\t}\n\n\t\tpublic class ChangedMetadatasResult\n\t\t{\n\t\t\tpublic Metadatas UpdatingMetadatas { get; set; }\n\t\t\tpublic Metadatas DeletingMetadatas { get; set; }\n\t\t\tpublic MetadataGroups DeletingGroups { get; set; }\n\t\t\tpublic List<string> ErrorMessages { get; set; }\n\t\t}\n\n\t\tprivate MetadataFieldResult UpdateMetadataField(AttributeFieldViewModel field, AttributeGroupItemViewModel item, AttributeGroupViewModel group, Metadata persistedMetadata)\n\t\t{\n\t\t\tstring outMessage;\n\t\t\tstring value = field.value;\n\t\t\tbool isValid = MetadataRepository.ValidateTypeAndFormat(ref value, persistedMetadata, SessionData.CurrentCulture, out outMessage);\n\n\t\t\tMetadataFieldResult rslt = new MetadataFieldResult { Proceed = true, ResultType = MetadataFieldResultType.Update};\n\n\t\t\t// is the metadata allowed to change?\n\t\t\tif (persistedMetadata.ReadOnly && !persistedMetadata.IsCalculatedDataType())\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\tif (persistedMetadata.System)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\t// did anything actually change? if metadata value and order are the same, do nothing\n\t\t\tif (value == persistedMetadata.Value)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\t// are metadata changes valid?\n\t\t\tif (rslt.Proceed && string.IsNullOrEmpty(value))\n\t\t\t{\n\t\t\t\t// this 'if' condition should be impossible, empty/null field values get marked for delete, therefore they should be going to a different code path, this is just in case\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\t\t\tif (rslt.Proceed && value.Length > Metadata.LENGTH_OBJECTMETADATAVALUES_VALUE)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t\trslt.ErrorMessage = string.Format(Resources.Admin.error_AttributeTooLong, persistedMetadata.Name, Metadata.LENGTH_OBJECTMETADATAVALUES_VALUE);\n\t\t\t}\n\t\t\tif (rslt.Proceed && !isValid)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t\trslt.ErrorMessage = outMessage;\n\t\t\t}\n\t\t\t\n\n\t\t\t// if everything is good, create the updated metadata object\n\t\t\tif (rslt.Proceed) {\n\t\t\t\trslt.ResultMetadata = new Metadata(persistedMetadata, persistedMetadata.MetadataSetNumber, value) { Uid = persistedMetadata.Uid };\n\t\t\t}\n\n\t\t\treturn rslt;\n\t\t}\n\t\tprivate MetadataFieldResult CreateMetadataField(AttributeFieldViewModel field, AttributeGroupItemViewModel item, AttributeGroupViewModel group, Metadata persistedMetadata)\n\t\t{\n\t\t\tpersistedMetadata.Uid = Guid.Empty;\n\t\t\tpersistedMetadata.Value = null;\n\t\t\treturn UpdateMetadataField(field, item, group, persistedMetadata);\n\t\t}\n\t\tprivate MetadataFieldResult DeleteMetadataField(AttributeFieldViewModel field, AttributeGroupItemViewModel item, AttributeGroupViewModel group, Metadata persistedMetadata)\n\t\t{\n\t\t\tMetadataFieldResult rslt = new MetadataFieldResult {Proceed = true, ResultType = MetadataFieldResultType.Delete};\n\t\t\tif (persistedMetadata.IsRequiredAttribute && !persistedMetadata.Repeating && !persistedMetadata.MetadataSetRepeating && !persistedMetadata.ReadOnly)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t\trslt.ErrorMessage = $\"Attribute {persistedMetadata.Name} is required\";\n\t\t\t}\n\t\t\tif (persistedMetadata.ReadOnly && !persistedMetadata.IsCalculatedDataType())\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\tif (rslt.Proceed && persistedMetadata.Uid == Guid.Empty)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\t// everything is good, set the deletable metadata object\n\t\t\tif (rslt.Proceed)\n\t\t\t{\n\t\t\t\trslt.ResultMetadata = persistedMetadata;\n\t\t\t}\n\n\t\t\treturn rslt;\n\t\t}\n\n\t\tpublic class MetadataFieldResult\n\t\t{\n\t\t\tpublic bool Proceed { get; set; }\n\t\t\tpublic Metadata ResultMetadata { get; set; }\n\t\t\tpublic MetadataFieldResultType ResultType { get; set; }\n\t\t\tpublic string ErrorMessage { get; set; }\n\t\t}\n\n\t\tpublic enum MetadataFieldResultType\n\t\t{\n\t\t\tUpdate = 0,\n\t\t\tDelete = 1\n\t\t}\n\n\t\tprivate List<Metadata> GetPersistedMetadatasForRepeatableItem(AttributeGroupItemViewModel item)\n\t\t{\n\t\t\tList<Metadata> persistedMetadatas = new List<Metadata>();\n\t\t\tif (item.type == \"field\")\n\t\t\t{\n\t\t\t\tpersistedMetadatas = _persistedDocMetadatas.Where(c => c.Repeating && c.MetadataFieldUid == Guid.Parse(item.fieldid) && c.Uid != Guid.Empty).OrderBy(c => c.MetadataSetNumber).ToList();\n\t\t\t}\n\t\t\telse if (item.type == \"set\")\n\t\t\t{\n\t\t\t\tpersistedMetadatas = _persistedDocMetadatas.Where(c => c.MetadataSetRepeating && c.MetadataSetUid == Guid.Parse(item.setid) && c.Uid != Guid.Empty).ToList();\n\t\t\t}\n\n\t\t\treturn persistedMetadatas;\n\t\t}\n\n\t\tprivate bool IsItemMarkedForDelete(AttributeGroupItemViewModel item, AttributeGroupViewModel group)\n\t\t{\n\t\t\tif (!group.attached)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (item.isDeleting)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (item.fields.Count == item.fields.Count(f => string.IsNullOrEmpty(f.value) && f.dataType != (int)Enums.DataType.AutoNumber))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate bool IsFieldMarkedForDelete(AttributeFieldViewModel field, AttributeGroupItemViewModel item, AttributeGroupViewModel group)\n\t\t{\n\t\t\tif (!group.attached)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (item.isDeleting)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(field.value) && field.dataType != (int)Enums.DataType.AutoNumber)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate void ValidateGroup(AttributeGroupViewModel groupvm)\n\t\t{\n\t\t\tMetadataFields groupFields = _metadataRepository.GetMetadataFieldsByMetadataGroupUid(SessionData.CurrentAccountId, Guid.Parse(groupvm.id));\n\t\t\tstring latestDefinitionHash = HashObject(Transform(groupFields));\n#pragma warning disable CA1309 // Use ordinal stringcomparison\n\t\t\tif (!string.Equals(groupvm.definitionHash, latestDefinitionHash))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"Attributes were modified by a different process\");\n\t\t\t\tthrow new AdexsDisplayException(Resources.Admin.AttributesConfigurationModifiedMessage);\n\t\t\t}\n#pragma warning restore CA1309 // Use ordinal stringcomparison\n\t\t}\n\n\t\tprivate bool IsSystemGroup(AttributeGroupViewModel groupvm)\n\t\t{\n\t\t\tif (groupvm.isSystem)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// can't trust the groupvm because it can be modified from the client side, have to check the db to know for sure\n\t\t\tMetadataGroup group = _metadataGroupRepository.LoadByUid(SessionData.CurrentAccountId, Guid.Parse(groupvm.id));\n\t\t\treturn group != null && group.System;\n\t\t}\n\n\t\tprivate string CreateMetadataGroupHash(Guid groupUid)\n\t\t{\n\t\t\tMetadataFields groupFields = _metadataRepository.GetMetadataFieldsByMetadataGroupUid(SessionData.CurrentAccountId, groupUid);\n\t\t\treturn HashObject(Transform(groupFields));\n\t\t}\n\n\t\tprivate static IEnumerable<object> Transform(MetadataFields groupFields)\n\t\t{\n\t\t\tforeach (MetadataField f in groupFields)\n\t\t\t{\n\t\t\t\tvar transformed = new { f.Uid, f.Name, f.Position, f.DataType, f.IsRequiredAttribute, f.ReadOnly, f.Repeating, f.CustomValidationErrMsg, f.CustomValidation, f.AllowedValues };\n\t\t\t\tyield return transformed;\n\t\t\t}\n\t\t}\n\n\t\tprivate bool ShouldShowDocumentDetails(UserAccount userAccount)\n\t\t{\n\t\t\tvar accountSettings = userAccount.Account.Settings;\n\t\t\treturn (accountSettings.EnableCounterpartyManagement || !accountSettings.ShowPartyFieldsOnDocInfoPanel)\n\t\t\t\t|| accountSettings.ShowKeywords\n\t\t\t\t|| accountSettings.ShowFileNameAndFolder;\n\t\t}\n\t\tprivate bool ShouldEnableCreateAttributeViewModel(UserAccount userAccount)\n\t\t{\n\t\t\treturn userAccount.Account.Settings.EnableCreateAttributeViewModelForDocExplorer;\n\t\t}\n\n\t\t#endregion\n\n\t\tpublic string HashObject<T>(T objectToHash)\n\t\t{\n\t\t\tif (objectToHash == null)\n\t\t\t{\n\t\t\t\treturn string.Empty;\n\t\t\t}\n\n\t\t\tstring serializedObject = JsonConvert.SerializeObject(objectToHash);\n\t\t\tbyte[] serializedObjectBytes = Encoding.UTF8.GetBytes(serializedObject);\n\t\t\tbyte[] serializedObjectHashBytes = Hash.SHA1Hash(serializedObjectBytes);\n\t\t\t// Use BitConverter to convert the raw hash bytes to a hex string. We use a hex string because it is a much easier string to work with (because it has a limited character set a-f0-9); \n\t\t\t// if we had decoded the raw hash bytes using UTF8 or something like that we could end up with bizarre or non printable characters, which are more difficult to work with.\n\t\t\tstring serializedObjectHashString = BitConverter.ToString(serializedObjectHashBytes).Replace(\"-\", \"\").ToLower();  \n\t\t\treturn serializedObjectHashString;\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Ajax/UploadFiles.ashx.cs",
            "content": "\ufeffusing System.Diagnostics;\nusing System.Web;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing System;\nusing System.IO;\nusing ADEXS.Core.Domain.CacheObjects;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Web.Common;\nusing ADEXS.Web.Common.Helpers;\nusing ADEXS.Web.Controller;\nusing log4net;\nusing ADEXS.Web.AccountConversion.Helper;\n\nnamespace ADEXS.WebContent.Ajax\n{\n\tpublic class UploadFiles : IHttpHandler, IReadOnlySessionState\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(UploadFiles));\n\n\t\t/// <summary>\n\t\t/// This handler has no state, and is therefore reusable.\n\t\t/// </summary>\n\t\tpublic bool IsReusable\n\t\t{\n\t\t\tget { return true; }\n\t\t}\n\n\t\tprivate UserAccount _currentUserAccount = null;\n\t\tpublic UserAccount CurrentUserAccount\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif(null == _currentUserAccount)\n\t\t\t\t{\n\t\t\t\t\t_currentUserAccount = AtlasContext.Current.UserAccount;\n\t\t\t\t\tif(_currentUserAccount == null && ApplicationSettings.EnableSessionInWebContent)\n\t\t\t\t\t{\n\t\t\t\t\t\t_currentUserAccount = UserAccount.PublicUserAccount(SessionData.CurrentAccountId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn _currentUserAccount;\n\t\t\t}\n\t\t}\n\n\t\tpublic void ProcessRequest(HttpContext context)\n\t\t{\n\t\t\ttry\n\t\t\t{\n#if NETFRAMEWORK\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context?.ApplicationInstance?.Context);\n#else\n\t\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n#endif\n\n\t\t\t\tFileUploadInfo fileUploadInfo = null;\n\t\t\t\tstring uploadToken = context.Request.QueryString[Constants.QueryStringParameters.UploadToken];\n\n\t\t\t\tif (Constants.PublicUser == CurrentUserAccount.Uid)\n\t\t\t\t{\n\t\t\t\t\tif (string.IsNullOrWhiteSpace(uploadToken))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ApplicationException(\"Incomplete upload request.\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// One can argue that we need to validate the authorization token here. But\n\t\t\t\t\t// - This code doesn't know anything about who issued it and what it allows.\n\t\t\t\t\t// - This handler can be called multiple times in case of chunked uploads.\n\t\t\t\t\t// So I am going to let the documents be saved to temp storage, and then have\n\t\t\t\t\t// whoever is ingesting them verify the authorization.\n\t\t\t\t\t// I'll just check there's an authorization token provided. That's required for\n\t\t\t\t\t// public uploads. See further down.\n\t\t\t\t}\n\t\t\t\tActionsUsageLoggingUtil.LogActionUsage(\"UploadFile\", null);\n\t\t\t\tfileUploadInfo = ValidateRequest(uploadToken);\n\t\t\t\tif (null == fileUploadInfo)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Invalid upload request\");\n\t\t\t\t\tthrow new ApplicationException(\"Invalid upload request.\");\n\t\t\t\t}\n\n\t\t\t\tcontext.Response.Cache.SetCacheability(HttpCacheability.NoCache);\n\n\t\t\t\tFolder uploadFolder = null;\n\t\t\t\tif (Constants.PublicUser != CurrentUserAccount.Uid && RequestSelection<Folder>.Instance.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tuploadFolder = RequestSelection<Folder>.Instance[0];\n\t\t\t\t}\n\n\t\t\t\tUploadFileHelper fh = new UploadFileHelper(CurrentUserAccount);\n\t\t\t\tUploadResult uploadResult = fh.UploadFiles(new HttpRequestWrapper(context.Request), uploadFolder);\n\n\t\t\t\t// Delete Cookie if upload succeeds and resumable upload is enabled\n\t\t\t\tif (CurrentUserAccount.Account.Settings.EnableResumableUpload && uploadResult.UploadStatus == Enums.UploadStatus.Success)\n\t\t\t\t{\n\t\t\t\t\t// Adding a cookie with the same name with a past expiration date effectively deletes the cookie\n\t\t\t\t\tcontext.Response.Cookies.Add(new HttpCookie(fileUploadInfo.CookieName, string.Empty) { Expires = DateTime.UtcNow.AddDays(-1) });\n\t\t\t\t}\n\n\t\t\t\tWriteResponse(context, uploadResult.JSONString);\n\n\t\t\t\tif(Configuration.GetBooleanAppSetting(\"useResponseEndInUploadFiles\", false))\n\t\t\t\t{\n\t\t\t\t\tcontext.Response.End();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcontext.ApplicationInstance.CompleteRequest();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"Uploading request failed with error\", ex);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tprivate void WriteResponse(HttpContext context, string response)\n\t\t{\n\t\t\tif (null != context.Request.Params[\"redirect\"])\n\t\t\t{\n\t\t\t\tcontext.Response.Redirect(CurrentUserAccount.Account.Urls.Ajax.UploadResult(response));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontext.Response.Write(response);\n\t\t\t}\n\t\t}\n\n\t\tprivate FileUploadInfo ValidateRequest(string uploadToken)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Validating upload token {uploadToken}, account {CurrentUserAccount.AccountId}.\");\n\t\t\tIUploadTokenRepository uploadFileRepo = ServiceLocator.GetInstance<IUploadTokenRepository>();\n\t\t\tFileUploadInfo fileUploadInfo = uploadFileRepo.ValidateUploadTokenInfo(CurrentUserAccount.AccountId, uploadToken);\n\n\t\t\tif(null == fileUploadInfo)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Invalid upload token {uploadToken}, account {CurrentUserAccount.AccountId}.\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif(CurrentUserAccount.AccountId != fileUploadInfo.AccountId || CurrentUserAccount.Uid != fileUploadInfo.UserAccountUid)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Invalid upload request for token {uploadToken}. Expected A:{fileUploadInfo.AccountId} U:{fileUploadInfo.UserAccountUid} but got A:{CurrentUserAccount.AccountId} U:{CurrentUserAccount.Uid}.\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (Constants.PublicUser == CurrentUserAccount.Uid)\n\t\t\t{\n\t\t\t\tif(string.IsNullOrWhiteSpace(fileUploadInfo.AuthorizationToken))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"No authorization token provided with upload token {uploadToken}. Required for public uploads.\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fileUploadInfo.FileName.IndexOfAny(Path.GetInvalidFileNameChars()) >= 0)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"File name contains illegal characters.\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"Successfully validated upload token\");\n\t\t\treturn fileUploadInfo;\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.API.Allocation.Telemetry;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.API.Allocation.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.API.Allocation\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/HttpRequestAuditHelper.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Extensions;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nnamespace ADEXS.Web.CommonUI.Helpers\n{\n\tpublic abstract class HttpRequestAuditHelper\n\t{\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Duration\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Duration\", \"CLM.API\",\n\t\t///\tInstanceProperty = \"Description\",\n\t\t///\tDisplayUnit = CounterUnit.milliseconds,\n\t\t///\tRanges = new double[10] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t///\tMeasureProperty = \"Duration\",\n\t\t///\tSuccessProperty = \"Success\")]\n\t\t/// static readonly TimingEventSource apiEventSource = new TimingEventSource();\n\t\t/// </summary>\n\t\tprotected abstract TimingEventSource ApiEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Attempts\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Attempts\", \"CLM.API\", InstanceProperty = \"Description\")]\n\t\t/// static readonly SimpleEventSource attemptEventSource = new SimpleEventSource();\n\t\t/// </summary>\n\t\tprotected abstract SimpleEventSource AttemptEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the timing Stopwatch instance will be stored.\n\t\t/// Example: \"ClmApi.Stopwatch\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_StopWatch { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the the name of the counter instance will be stored.\n\t\t/// Example: \"ClmApi.InstanceName\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_CounterInstance { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which any error will be stored.\n\t\t/// Example: \"ClmApi.Error\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_Error { get; }\n\n\t\t/// <summary>\n\t\t/// Implementations are intended to be used as singletons.\n\t\t/// </summary>\n\t\tprotected HttpRequestAuditHelper()\n\t\t{\n\t\t}\n\n\t\tpublic static void SetCommonDataPoints()\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId != int.MinValue)\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, AtlasContext.Current.AccountId);\n\t\t\tif (AtlasContext.Current.UserAccountUid != Guid.Empty)\n\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\tif (AtlasContext.Current.UserAccount != null)\n\t\t\t\tServiceContext.Log(DataPoint.AccountType, Enum.GetName(typeof(Enums.AccountType), AtlasContext.Current.UserAccount.Account.AccountType));\n\t\t}\n\n\t\tpublic virtual void BeginRequest(HttpContext httpContext)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n\n\t\t\tif (httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring counterInstanceName = FormatInstanceName(httpContext);\n\t\t\tAttemptEventSource.Emit(counterInstanceName);\n\n\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\thttpContext.Items[PropName_StopWatch] = sw;\n\t\t\thttpContext.Items[PropName_CounterInstance] = counterInstanceName;\n\t\t}\n\n\t\tpublic virtual void EndRequest(HttpContext httpContext)\n\t\t{\n\t\t\tif(httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSetCommonDataPoints();\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(httpContext);\n\n\t\t\tbool isError = false;\n\t\t\tException exError = httpContext.Items[PropName_Error] as Exception;\n\t\t\tif (null != exError && !(exError is AdexsDisplayException))\n\t\t\t{\n\t\t\t\tisError = true;\n\t\t\t}\n\n\t\t\tFinalizeLogging(sw, instanceName, isError);\n\t\t}\n\n\t\tpublic virtual void SetError(HttpContext httpContext, Exception ex)\n\t\t{\n\t\t\tif(httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(null != ex)\n\t\t\t{\n\t\t\t\tex.Trace().Report();\n\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, ex.Message);\n\t\t\t\thttpContext.Items[PropName_Error] = ex;\n\t\t\t}\n\t\t}\n\n\t\tprivate (Stopwatch, string) GetStopWatchAndInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tStopwatch sw = httpContext.Items[PropName_StopWatch] as Stopwatch;\n\t\t\tif (null == sw)\n\t\t\t{\n\t\t\t\tsw = Stopwatch.StartNew();\n\t\t\t}\n\n\t\t\tstring instanceName = httpContext.Items[PropName_CounterInstance] as string;\n\t\t\tif (null == instanceName)\n\t\t\t{\n\t\t\t\tinstanceName = FormatInstanceName(httpContext);\n\t\t\t}\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n\n\t\tprotected virtual string FormatInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tvar pageName = \"_no-page_\";\n\t\t\tvar httpMethod = \"_no-verb_\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\thttpMethod = httpContext.Request.HttpMethod;\n\t\t\t\tpageName = httpContext.Request.Url.Segments.Last();\n\t\t\t}\n\t\t\tcatch(Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t\t\n\t\t\treturn FormatInstanceName(pageName, httpMethod);\n\t\t}\n\n\t\tprotected virtual string FormatInstanceName(string pageName, string httpMethod)\n\t\t{\n\t\t\treturn $\"{pageName}.{httpMethod}\";\n\t\t}\n\n\t\tprivate void FinalizeLogging(Stopwatch sw, string instanceName, bool isError)\n\t\t{\n\t\t\tTimeSpan apiRunTime = TimeSpan.MinValue;\n\t\t\tif (sw != null)\n\t\t\t{\n\t\t\t\tapiRunTime = sw.Elapsed;\n\t\t\t}\n\n\t\t\tApiEventSource.Emit(apiRunTime, !isError, instanceName);\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Filters/MvcAuditedRequestAttribute.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\n#if NETFRAMEWORK\nusing System.Web;\nusing System.Web.Mvc;\nusing System.Web.Routing;\nusing ADEXS.Web.CommonUI.Helpers;\n#else\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.AspNetCore.Http;\n#endif\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Extensions;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.DynamicSettings;\nusing DocuSign.Monitoring;\nusing ADEXS.Core.Domain.Utilities;\n\nnamespace ADEXS.Web.CommonUI.MVC.Filters\n{\n\tpublic abstract class MvcAuditedRequestAttribute : ActionFilterAttribute, IActionFilter, IExceptionFilter\n\t{\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Duration\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Duration\", \"CLM.API\",\n\t\t/// InstanceProperty = \"Description\",\n\t\t/// DisplayUnit = CounterUnit.milliseconds,\n\t\t/// Ranges = new double[10] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t/// MeasureProperty = \"Duration\",\n\t\t/// SuccessProperty = \"Success\")]\n\t\t/// static readonly TimingEventSource apiEventSource = new TimingEventSource();\n\t\t/// </summary>\n\t\tprotected abstract TimingEventSource ApiEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Attempts\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Attempts\", \"CLM.API\", InstanceProperty = \"Description\")]\n\t\t/// static readonly SimpleEventSource attemptEventSource = new SimpleEventSource();\n\t\t/// </summary>\n\t\tprotected abstract SimpleEventSource AttemptEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the timing Stopwatch instance will be stored.\n\t\t/// Example: \"ClmApi.Stopwatch\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_StopWatch { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the the name of the counter instance will be stored.\n\t\t/// Example: \"ClmApi.InstanceName\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_CounterInstance { get; }\n\n\t\tprivate static string NO_CONTROLLER_STRING = \"_no-controller_\";\n\t\tprivate static string NO_ACTION_NAME = \"_no-action_\";\n\t\tprivate static string NO_HTTP_VERB = \"_no-verb_\";\n\n\t\tpublic override void OnActionExecuting(ActionExecutingContext filterContext)\n\t\t{\n#if NETFRAMEWORK\n\t\t\tstring controllerName = filterContext.ActionDescriptor.ControllerDescriptor.ControllerName;\n\t\t\tServiceContext.Log(DataPoint.ApiController, controllerName);\n\t\t\tstring actionName = filterContext.ActionDescriptor.ActionName;\n\t\t\tServiceContext.Log(DataPoint.Action, actionName);\n#else\n\t\t\tvar controllerName = filterContext.ActionDescriptor.RouteValues[\"controller\"] ?? NO_CONTROLLER_STRING;\n\t\t\tServiceContext.Log(DataPoint.ApiController, controllerName);\n\t\t\tvar actionName = filterContext.ActionDescriptor.RouteValues[\"action\"] ?? NO_ACTION_NAME;\n\t\t\tServiceContext.Log(DataPoint.Action, actionName);\n#endif\n\n\t\t\tif (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.ControllerName] = controllerName;\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.ActionName] = actionName;\n\t\t\t}\n\n\t\t\tvar httpContext = filterContext.HttpContext;\n#if NETFRAMEWORK\n\t\t\tstring counterInstanceName = FormatInstanceName(controllerName, actionName, httpContext.Request.HttpMethod);\n#else\n\t\t\tvar counterInstanceName = FormatInstanceName(controllerName, actionName, httpContext.Request.Method);\n#endif\n\t\t\tAttemptEventSource.Emit(counterInstanceName);\n\n#if NETFRAMEWORK\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext?.ApplicationInstance?.Context);\n#else\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n#endif\n\n\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\thttpContext.Items[PropName_StopWatch] = sw;\n\t\t\thttpContext.Items[PropName_CounterInstance] = counterInstanceName;\n\n\t\t\tif (ApplicationSettings.EnableFeatureFlags && ApplicationSettings.TestFeatureFlagEvaluation)\n\t\t\t{\n\t\t\t\tint intSetting = AtlasFeatureFlags.DummyIntSetting;\n\t\t\t\tstring stringSetting = AtlasFeatureFlags.DummyStringSetting;\n\t\t\t\tServiceContext.Log(\n\t\t\t\t\tDataPoint.ApiRequestLogging,\n\t\t\t\t\t$\"intSetting: {intSetting} | stringSetting: {stringSetting}\");\n\t\t\t}\n\t\t}\n\n\t\tpublic override void OnActionExecuted(ActionExecutedContext filterContext)\n\t\t{\n\t\t\tSetCommonDataPoints();\n\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(filterContext.HttpContext);\n\t\t\tFinalizeLogging(sw, instanceName, false);\n\t\t}\n\n\t\tpublic virtual void OnException(ExceptionContext filterContext)\n\t\t{\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(filterContext.HttpContext);\n\t\t\tbool isServerError = IsServerError(filterContext.Exception);\n\t\t\tif (filterContext.Exception != null)\n\t\t\t{\n\t\t\t\tfilterContext.Exception.Trace().Report();\n\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, filterContext.Exception.Message);\n\t\t\t}\n\n\t\t\tFinalizeLogging(sw, instanceName, isServerError);\n\t\t}\n\n#if NETFRAMEWORK\n\t\tprivate (Stopwatch sw, string instanceName) GetStopWatchAndInstanceName(HttpContextBase context)\n\t\t{\n\t\t\tStopwatch sw = context.Items[PropName_StopWatch] as Stopwatch;\n\t\t\tif (null == sw)\n\t\t\t{\n\t\t\t\tsw = Stopwatch.StartNew();\n\t\t\t}\n\n\t\t\tstring instanceName = context.Items[PropName_CounterInstance] as string;\n\t\t\tif (null == instanceName)\n\t\t\t{\n\t\t\t\tinstanceName = FormatInstanceName(context);\n\t\t\t}\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n#else\n\t\tprivate (Stopwatch sw, string instanceName) GetStopWatchAndInstanceName(HttpContext context)\n\t\t{\n\t\t\tvar sw = context.Items[PropName_StopWatch] as Stopwatch ?? Stopwatch.StartNew();\n\n\t\t\tvar instanceName = context.Items[PropName_CounterInstance] as string ?? FormatInstanceName(context);\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n#endif\n\n#if NETFRAMEWORK\n\t\tprotected virtual string FormatInstanceName(HttpContextBase httpContext)\n\t\t{\n\t\t\tstring controllerName = NO_CONTROLLER_STRING;\n\t\t\tstring actionName = NO_ACTION_NAME;\n\t\t\tstring httpMethod = NO_HTTP_VERB;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tRouteData rd = httpContext.Request.RequestContext.RouteData;\n\t\t\t\tactionName = rd.GetRequiredString(\"action\");\n\t\t\t\tcontrollerName = rd.GetRequiredString(\"controller\");\n\t\t\t\thttpMethod = httpContext.Request.HttpMethod;\n\t\t\t}\n\t\t\tcatch(Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t\treturn FormatInstanceName(controllerName, actionName, httpMethod);\n\t\t}\n#else\n\t\tprotected virtual string FormatInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tobject? actionNameObj = null;\n\t\t\tobject? controllerNameObj = null;\n\t\t\tvar httpMethod = NO_HTTP_VERB;\n\t\t\ttry\n\t\t\t{\n\t\t\t\thttpContext.Request.RouteValues.TryGetValue(\"action\", out actionNameObj);\n\t\t\t\thttpContext.Request.RouteValues.TryGetValue(\"controller\", out controllerNameObj);\n\t\t\t\thttpMethod = httpContext.Request.Method;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\n\t\t\tvar controllerName = controllerNameObj as string ?? NO_CONTROLLER_STRING;\n\t\t\tvar actionName = actionNameObj as string ?? NO_ACTION_NAME;\n\t\t\treturn FormatInstanceName(controllerName, actionName, httpMethod);\n\t\t}\n#endif\n\n\t\tprotected virtual string FormatInstanceName(string controllerName, string actionName, string httpMethod)\n\t\t{\n\t\t\treturn $\"{controllerName}.{actionName}.{httpMethod}\";\n\t\t}\n\n\t\tprivate void FinalizeLogging(Stopwatch sw, string instanceName, bool isError)\n\t\t{\n\t\t\tTimeSpan apiRunTime = TimeSpan.MinValue;\n\t\t\tif (sw != null)\n\t\t\t{\n\t\t\t\tapiRunTime = sw.Elapsed;\n\t\t\t}\n\n\t\t\tApiEventSource.Emit(apiRunTime, !isError, instanceName);\n\t\t}\n\n\t\tprotected virtual bool IsServerError(Exception exception)\n\t\t{\n\t\t\tbool isError = !(exception is AdexsDisplayException);\n\n\t\t\treturn isError;\n\t\t}\n\n\n\t\tpublic static void SetCommonDataPoints()\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId != int.MinValue)\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, AtlasContext.Current.AccountId);\n\t\t\tif (AtlasContext.Current.UserAccountUid != Guid.Empty)\n\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\tif (AtlasContext.Current.UserAccount != null)\n\t\t\t\tServiceContext.Log(DataPoint.AccountType, Enum.GetName(typeof(Enums.AccountType), AtlasContext.Current.UserAccount.Account.AccountType));\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Controls/FormExtensions.cs",
            "content": "\ufeff#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq.Expressions;\n\nusing ADEXS.Core.Domain.AtlasUrl;\nusing ADEXS.Core.Domain.Repository.MetadataRepository;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.ServiceLocator;\n\n#if NETFRAMEWORK\nusing System.Web;\nusing System.Web.Mvc;\nusing System.Web.Mvc.Html;\nusing System.Web.Routing;\nusing THtml = System.Web.IHtmlString;\nusing THtmlHelper = System.Web.Mvc.HtmlHelper;\nusing TTagBuilder = System.Web.Mvc.TagBuilder;\nusing TTagRenderMode = System.Web.Mvc.TagRenderMode;\n#else\nusing Microsoft.AspNetCore.Html;\nusing Microsoft.AspNetCore.Mvc.Rendering;\nusing Microsoft.AspNetCore.Mvc.ViewFeatures;\nusing Microsoft.AspNetCore.Routing;\n\nusing ADEXS.Web.CommonUI.AspNetCore.Extensions;\nusing THtml = Microsoft.AspNetCore.Html.IHtmlContent;\nusing THtmlHelper = Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper;\nusing TTagBuilder = Microsoft.AspNetCore.Mvc.Rendering.TagBuilder;\nusing TTagRenderMode = Microsoft.AspNetCore.Mvc.Rendering.TagRenderMode;\n#endif\n\nnamespace ADEXS.Web.Common.MVC.Controls\n{\n    /// <summary>\n    /// Provides a set of dual-targeted extension methods for rendering HTML controls in both ASP.NET MVC (NetFramework) and ASP.NET Core.\n    /// The class is structured to minimize code duplication by sharing logic in private helper methods.\n    /// </summary>\n    public static partial class FormExtensions\n    {\n       private const string AtlasLabelName = \"formLabel\";\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasLabel(this HtmlHelper html, string text, string customCssClass = null, bool isRequired = false, string tagName = \"div\") =>\n          new HtmlString(BuildAtlasLabelHtml(html.Encode(text), customCssClass, isRequired, tagName));\n#elif NET\n       public static IHtmlContent AtlasLabel(this IHtmlHelper html, string text, string customCssClass = null, bool isRequired = false, string tagName = \"div\") =>\n          new HtmlString(BuildAtlasLabelHtml(html.Encode(text), customCssClass, isRequired, tagName));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasTag(this HtmlHelper html, string text, string customCssClass = null, string tagName = \"div\") =>\n          new HtmlString(BuildAtlasTagHtml(html.Encode(text), customCssClass, tagName));\n#elif NET\n       public static IHtmlContent AtlasTag(this IHtmlHelper html, string text, string customCssClass = null, string tagName = \"div\") =>\n          new HtmlString(BuildAtlasTagHtml(html.Encode(text), customCssClass, tagName));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasPageHeader(this HtmlHelper html, string text, string customCssClass = null, string tagName = \"h2\") =>\n          html.AtlasTag(text, customCssClass, tagName);\n#elif NET\n       public static IHtmlContent AtlasPageHeader(this IHtmlHelper html, string text, string customCssClass = null, string tagName = \"h2\") =>\n          html.AtlasTag(text, customCssClass, tagName);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasLink(this HtmlHelper html, string text, UrlBuilder url, string id = null, bool openNewWindow = true) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureAtlasLinkTag(tag, text, url.ToString(), id, openNewWindow));\n#elif NET\n       public static IHtmlContent AtlasLink(this IHtmlHelper html, string text, UrlBuilder url, string id = null, bool openNewWindow = true) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureAtlasLinkTag(tag, text, url.ToString(), id, openNewWindow));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasLink(this HtmlHelper html, string text, Dictionary<string, string> attributes) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureAtlasLinkTag(tag, text, attributes));\n#elif NET\n       public static IHtmlContent AtlasLink(this IHtmlHelper html, string text, Dictionary<string, string> attributes) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureAtlasLinkTag(tag, text, attributes));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasImage(this HtmlHelper html, string spriteClassName, string additionalClassName = null) =>\n            BuildAndRenderTag(\"img\", tag => ConfigureAtlasImageTag(tag, spriteClassName, additionalClassName), TTagRenderMode.SelfClosing);\n#elif NET\n       public static IHtmlContent AtlasImage(this IHtmlHelper html, string spriteClassName, string additionalClassName = null) =>\n            BuildAndRenderTag(\"img\", tag => ConfigureAtlasImageTag(tag, spriteClassName, additionalClassName), TTagRenderMode.SelfClosing);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString SpriteActionLink(this HtmlHelper html, string spriteClassName, string actionName, object routeValues = null, object attributes = null) =>\n          SpriteActionLink(html, spriteClassName, actionName, null, routeValues, attributes);\n\n       public static IHtmlString SpriteActionLink(this HtmlHelper html, string spriteClassName, string actionName, string controllerName, object routeValues = null, object attributes = null)\n       {\n          var link = html.ActionLink(\"[replaceme]\", actionName, controllerName, routeValues, attributes);\n          var image = html.AtlasImage(spriteClassName);\n          return new HtmlString(link.ToHtmlString().Replace(\"[replaceme]\", image.ToHtmlString()));\n       }\n#elif NET\n       public static IHtmlContent SpriteActionLink(this IHtmlHelper html, string spriteClassName, string actionName, object routeValues = null, object attributes = null) =>\n          SpriteActionLink(html, spriteClassName, actionName, null, routeValues, attributes);\n\n       public static IHtmlContent SpriteActionLink(this IHtmlHelper html, string spriteClassName, string actionName, string controllerName, object routeValues = null, object attributes = null)\n       {\n          var link = html.ActionLink(\"[replaceme]\", actionName, controllerName, routeValues, attributes);\n          var image = html.AtlasImage(spriteClassName);\n          var linkString = link.ConvertToString().Replace(\"[replaceme]\", image.ConvertToString());\n          return new HtmlString(linkString);\n       }\n#endif\n\n#if NETFRAMEWORK\n       public static AtlasPanel AtlasPanel(this HtmlHelper html, string headerText = null, string id = null, string css = null, bool showExpandedCaretInHeader = false) =>\n          new AtlasPanel(html, headerText, id, css, showExpandedCaretInHeader);\n#elif NET\n       public static AtlasPanel AtlasPanel(this IHtmlHelper html, string headerText = null, string id = null, string css = null, bool showExpandedCaretInHeader = false) =>\n          new AtlasPanel(html, headerText, id, css, showExpandedCaretInHeader);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString SubmitButton(this HtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"input\", tag => ConfigureSubmitButtonTag(tag, text, htmlAttributes), TTagRenderMode.SelfClosing);\n#elif NET\n       public static IHtmlContent SubmitButton(this IHtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"input\", tag => ConfigureSubmitButtonTag(tag, text, htmlAttributes), TTagRenderMode.SelfClosing);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString CloseButton(this HtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureCloseButtonTag(tag, text, htmlAttributes));\n#elif NET\n       public static IHtmlContent CloseButton(this IHtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureCloseButtonTag(tag, text, htmlAttributes));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString CloseImageButton(this HtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureCloseImageButtonTag(tag, text, htmlAttributes));\n#elif NET\n       public static IHtmlContent CloseImageButton(this IHtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureCloseImageButtonTag(tag, text, htmlAttributes));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString CheckboxWithLabel(this HtmlHelper html, string name, bool value, string displayName, object htmlAttributes = null, bool enabled = true)\n       {\n          string checkboxHtml = html.CheckBox(name, value, BuildAttributesDictionary(htmlAttributes, enabled)).ToHtmlString();\n          string labelHtml = BuildLabel(name, displayName).ToString();\n          return new MvcHtmlString(checkboxHtml + labelHtml);\n       }\n\n       public static IHtmlString CheckboxWithLabelFor<TModel>(this HtmlHelper<TModel> html, Expression<Func<TModel, bool>> expression, string name, string displayName, object htmlAttributes = null, bool enabled = true)\n       {\n          var attributes = BuildAttributesDictionary(htmlAttributes, enabled);\n          attributes.Add(\"name\", name);\n          string checkboxHtml = html.CheckBoxFor(expression, attributes).ToHtmlString();\n          string labelHtml = BuildLabel(name, displayName).ToString();\n          return new MvcHtmlString(checkboxHtml + labelHtml);\n       }\n#elif NET\n       public static IHtmlContent CheckboxWithLabel(this IHtmlHelper html, string name, bool value, string displayName, object htmlAttributes = null, bool enabled = true)\n       {\n          var checkbox = html.CheckBox(name, value, BuildAttributesDictionary(htmlAttributes, enabled));\n          var label = BuildLabel(name, displayName);\n          var builder = new HtmlContentBuilder();\n          return builder.AppendHtml(checkbox).AppendHtml(label);\n       }\n\n       public static IHtmlContent CheckboxWithLabelFor<TModel>(this IHtmlHelper<TModel> html, Expression<Func<TModel, bool>> expression, string name, string displayName, object htmlAttributes = null, bool enabled = true)\n       {\n          var attributes = BuildAttributesDictionary(htmlAttributes, enabled);\n          attributes.Add(\"name\", name);\n          var checkbox = html.CheckBoxFor(expression, attributes);\n          var label = BuildLabel(name, displayName);\n          var builder = new HtmlContentBuilder();\n          return builder.AppendHtml(checkbox).AppendHtml(label);\n       }\n#endif\n\n#if NETFRAMEWORK\n        public static IHtmlString AtlasDate(this HtmlHelper html, string name, object value = null, object htmlAttributes = null)\n        {\n            var textBox = html.TextBox(name, value, htmlAttributes);\n            var image = html.AtlasImage(\"sprite-calendar\");\n            return new HtmlString(BuildAtlasDateHtml(textBox.ToHtmlString(), image.ToHtmlString()));\n        }\n#elif NET\n        public static IHtmlContent AtlasDate(this IHtmlHelper html, string name, object value = null, object htmlAttributes = null)\n        {\n            var textBox = html.TextBox(name, value, htmlAttributes);\n            var image = html.AtlasImage(\"sprite-calendar\");\n            return new HtmlString(BuildAtlasDateHtml(textBox.ConvertToString(), image.ConvertToString()));\n        }\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasMetadataField(this HtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value = null, CultureInfo culture = null) =>\n            BuildAtlasMetadataField(html, name, fieldType, allowedValues, value, culture);\n#elif NET\n       public static IHtmlContent AtlasMetadataField(this IHtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value = null, CultureInfo culture = null) =>\n            BuildAtlasMetadataField(html, name, fieldType, allowedValues, value, culture);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasDropDownListFor<TModel,TValue>(this HtmlHelper<TModel> html,Expression<Func<TModel, TValue>> expression, string label, IEnumerable<SelectListItem> selectList ) =>\n          AtlasFieldFor(html, label, expression, () => html.DropDownListFor(expression, selectList));\n\n       public static IHtmlString AtlasTextBoxFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          AtlasFieldFor(html, label, expression, () => html.TextBoxFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n#elif NET\n       public static IHtmlContent AtlasDropDownListFor<TModel,TValue>(this IHtmlHelper<TModel> html,Expression<Func<TModel, TValue>> expression, string label, IEnumerable<SelectListItem> selectList ) =>\n          AtlasFieldFor(html, label, expression, () => html.DropDownListFor(expression, selectList));\n\n       public static IHtmlContent AtlasTextBoxFor<TModel, TValue>(this IHtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          AtlasFieldFor(html, label, expression, () => html.TextBoxFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasDateWithLabel(this HtmlHelper html, string name, string labelText, object value = null, object htmlAttributes = null) =>\n          AtlasDateWithLabelHelper(html, html.TextBox(name, value, htmlAttributes), labelText);\n\n       public static IHtmlString AtlasDateWithLabelFor<TModel>(this HtmlHelper<TModel> html, Expression<Func<TModel, DateTimeOffset>> expression, string name, string labelText, string dateFormat, object htmlAttributes = null)\n       {\n          IDictionary<string, object> attributesDictionary = BuildAttributesDictionary(htmlAttributes);\n          attributesDictionary.Add(\"name\", name);\n          MvcHtmlString textBox = html.TextBoxFor(expression, string.Format(\"{{0:{0}}}\", dateFormat), attributesDictionary);\n          return AtlasDateWithLabelHelper(html, textBox, labelText);\n       }\n#elif NET\n       public static IHtmlContent AtlasDateWithLabel(this IHtmlHelper html, string name, string labelText, object value = null, object htmlAttributes = null) =>\n          AtlasDateWithLabelHelper(html, html.TextBox(name, value, htmlAttributes), labelText);\n\n       public static IHtmlContent AtlasDateWithLabelFor<TModel>(this IHtmlHelper<TModel> html, Expression<Func<TModel, DateTimeOffset>> expression, string name, string labelText, string dateFormat, object htmlAttributes = null)\n       {\n          IDictionary<string, object> attributesDictionary = BuildAttributesDictionary(htmlAttributes);\n          attributesDictionary.Add(\"name\", name);\n          var textBox = html.TextBoxFor(expression, string.Format(\"{{0:{0}}}\", dateFormat), attributesDictionary);\n          return AtlasDateWithLabelHelper(html, textBox, labelText);\n       }\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString FaUxTextBoxFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          FaUxFieldFor(html, label, expression, () => html.TextBoxFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n\n       public static IHtmlString AtlasPasswordFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          AtlasFieldFor(html, label, expression, () => html.PasswordFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n\n       public static IHtmlString FaUxPasswordFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          FaUxFieldFor(html, label, expression, () => html.PasswordFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n#elif NET\n       public static IHtmlContent FaUxTextBoxFor<TModel, TValue>(this IHtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          FaUxFieldFor(html, label, expression, () => html.TextBoxFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n\n       public static IHtmlContent AtlasPasswordFor<TModel, TValue>(this IHtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          AtlasFieldFor(html, label, expression, () => html.PasswordFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n\n       public static IHtmlContent FaUxPasswordFor<TModel, TValue>(this IHtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          FaUxFieldFor(html, label, expression, () => html.PasswordFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasFieldFor<TModel,TValue>(this HtmlHelper<TModel> html, string label, Expression<Func<TModel,TValue>> expression, Func<IHtmlString> controlBuilder, object htmlAttributes = null)\n       {\n           var labelHtml = html.LabelFor(expression, label, new {@class=\"formLabel\"});\n           var controlHtml = controlBuilder();\n           return BuildAndRenderTag(\"div\", div => ConfigureAtlasFieldFor(div, expression, htmlAttributes, labelHtml, controlHtml));\n       }\n\n       public static IHtmlString FaUxFieldFor<TModel, TValue>(this HtmlHelper<TModel> html, string label, Expression<Func<TModel, TValue>> expression, Func<IHtmlString> controlBuilder, object htmlAttributes = null)\n       {\n           var labelHtml = html.LabelFor(expression, label, new { @class = \"input__label\" });\n           var controlHtml = controlBuilder();\n           return BuildAndRenderTag(\"div\", div => ConfigureFaUxFieldFor(div, expression, htmlAttributes, labelHtml, controlHtml));\n       }\n\n       public static MvcForm AtlasBeginForm(this HtmlHelper htmlHelper, string actionName, string controllerName, FormMethod method, object htmlAttributes, RouteValueDictionary routeValues = null)\n       {\n          var form = htmlHelper.BeginForm(actionName, controllerName, routeValues ?? new RouteValueDictionary(), method, HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes));\n          htmlHelper.ViewContext.Writer.Write(htmlHelper.AntiForgeryToken().ToHtmlString());\n          return form;\n       }\n#elif NET\n       public static IHtmlContent AtlasFieldFor<TModel,TValue>(this IHtmlHelper<TModel> html, string label, Expression<Func<TModel,TValue>> expression, Func<IHtmlContent> controlBuilder, object htmlAttributes = null)\n       {\n           var labelHtml = html.LabelFor(expression, label, new {@class=\"formLabel\"});\n           var controlHtml = controlBuilder();\n           return BuildAndRenderTag(\"div\", div => ConfigureAtlasFieldFor(div, expression, htmlAttributes, labelHtml, controlHtml));\n       }\n\n       public static IHtmlContent FaUxFieldFor<TModel, TValue>(this IHtmlHelper<TModel> html, string label, Expression<Func<TModel, TValue>> expression, Func<IHtmlContent> controlBuilder, object htmlAttributes = null)\n       {\n           var labelHtml = html.LabelFor(expression, label, new { @class = \"input__label\" });\n           var controlHtml = controlBuilder();\n           return BuildAndRenderTag(\"div\", div => ConfigureFaUxFieldFor(div, expression, htmlAttributes, labelHtml, controlHtml));\n       }\n\n       public static MvcForm AtlasBeginForm(this IHtmlHelper htmlHelper, string actionName, string controllerName, FormMethod method, object htmlAttributes, RouteValueDictionary routeValues = null)\n       {\n          var form = htmlHelper.BeginForm(\n             actionName,\n             controllerName,\n             routeValues ?? new RouteValueDictionary(),\n             method,\n             antiforgery: null,\n             htmlAttributes: htmlAttributes);\n          htmlHelper.ViewContext.Writer.Write(htmlHelper.AntiForgeryToken().ConvertToString());\n          return form;\n       }\n#endif\n\n       /// <summary>\n       /// Builds the raw HTML for an AtlasLabel. This logic is shared between both frameworks.\n       /// </summary>\n       private static string BuildAtlasLabelHtml(string encodedText, string customCssClass, bool isRequired, string tagName)\n       {\n           using var writer = new StringWriter();\n           writer.Write(\"<{0} class=\\\"{1}\\\">\", tagName, AtlasLabelName + (string.IsNullOrWhiteSpace(customCssClass) ? \"\" : \" \" + customCssClass));\n           if (isRequired)\n           {\n               writer.Write(\"<span class=\\\"requiredMark\\\">*</span>\");\n           }\n           writer.Write(encodedText);\n           writer.WriteLine(\"</{0}>\", tagName);\n           return writer.ToString();\n       }\n\n       /// <summary>\n       /// Builds the raw HTML for an AtlasTag. This logic is shared between both frameworks.\n       /// </summary>\n       private static string BuildAtlasTagHtml(string encodedText, string customCssClass, string tagName)\n       {\n           using var writer = new StringWriter();\n           writer.Write(\"<{0} class=\\\"{1}\\\">\", tagName, (string.IsNullOrWhiteSpace(customCssClass) ? \"\" : \" \" + customCssClass));\n           writer.Write(encodedText);\n           writer.WriteLine(\"</{0}>\", tagName);\n           return writer.ToString();\n       }\n\n       private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, string href, string id, bool openNewWindow)\n       {\n           tag.MergeAttribute(\"href\", href);\n           if (openNewWindow)\n           {\n               tag.MergeAttribute(\"target\", \"_blank\");\n           }\n           if (id != null)\n           {\n               tag.MergeAttribute(\"id\", id);\n           }\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, Dictionary<string, string> attributes)\n       {\n           tag.MergeAttributes(attributes);\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasImageTag(TTagBuilder tag, string spriteClassName, string additionalClassName)\n       {\n           tag.MergeAttribute(\"class\", $\"{additionalClassName ?? string.Empty} sprite {spriteClassName}\".Trim());\n           tag.MergeAttribute(\"src\", ServiceLocator.GetInstance<IUrlProvider>().BlankImage());\n       }\n\n       private static void ConfigureSubmitButtonTag(TTagBuilder tag, string text, object htmlAttributes)\n       {\n           tag.MergeAttributes(HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes), replaceExisting: true);\n           tag.MergeAttribute(\"value\", string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Save : text);\n           if (!tag.Attributes.ContainsKey(\"class\"))\n           {\n               tag.AddCssClass(\"SendButton\");\n           }\n           if (!tag.Attributes.ContainsKey(\"type\"))\n           {\n               tag.MergeAttribute(\"type\", \"submit\");\n           }\n       }\n\n       private static void ConfigureCloseButtonTag(TTagBuilder tag, string text, object htmlAttributes)\n       {\n           tag.ApplyHtmlAttributes(htmlAttributes);\n           tag.AddCssClass(\"LinkButton\");\n           SetTagContent(tag, string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Close : text);\n           if (!tag.Attributes.ContainsKey(\"onclick\"))\n           {\n               tag.Attributes.Add(\"onclick\", \"CloseWindoid();return false;\");\n           }\n       }\n\n       private static void ConfigureCloseImageButtonTag(TTagBuilder tag, string text, object htmlAttributes)\n       {\n           tag.Attributes.Add(\"onclick\", \"CloseWindoid();return false;\");\n           tag.AddCssClass(\"cursor-pointer\");\n\n           var imageHtml = BuildAndRenderTag(\"img\", imageTag =>\n           {\n               imageTag.ApplyHtmlAttributes(htmlAttributes);\n               if (!imageTag.Attributes.ContainsKey(\"src\"))\n               {\n                   imageTag.Attributes.Add(\"src\", ServiceLocator.GetInstance<IUrlProvider>().Image(\"blank.gif\"));\n               }\n               var title = string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Close : text;\n               if (!imageTag.Attributes.ContainsKey(\"title\"))\n               {\n                   imageTag.Attributes.Add(\"title\", title);\n               }\n               if (!imageTag.Attributes.ContainsKey(\"alt\"))\n               {\n                   imageTag.Attributes.Add(\"alt\", title);\n               }\n           }, TTagRenderMode.SelfClosing);\n\n           SetTagContent(tag, imageHtml);\n       }\n\n       private static THtml BuildAtlasMetadataField(THtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value, CultureInfo culture)\n       {\n           if (value != null)\n               value = MetadataRepository.FormatMetaValue(value, fieldType, culture ?? CultureInfo.CurrentCulture);\n\n           switch (fieldType)\n           {\n               case Enums.DataType.String:\n               case Enums.DataType.Number:\n               case Enums.DataType.Decimal:\n               case Enums.DataType.Cascade:\n                   return html.TextBox(name, value, new { @class = \"extrawide\" });\n               case Enums.DataType.AutoNumber:\n                   return html.Hidden(name, WebCommonUI.Resources.Common.CalculatedValueDesignation);\n               case Enums.DataType.DropDown:\n               case Enums.DataType.MagicDropDown:\n                   return html.DropDownList(name, new SelectList(allowedValues, value), new { @class = \"extrawide\" });\n               case Enums.DataType.Date:\n                   return html.AtlasDate(name, value);\n               default:\n#if NETFRAMEWORK\n                   return new HtmlString(\"\");\n#else\n                   return HtmlString.Empty;\n#endif\n           }\n       }\n\n       private static string BuildAtlasDateHtml(string textBoxHtml, string imageHtml)\n       {\n           return $\"<div class=\\\"atlasDateControl\\\">{textBoxHtml}{imageHtml}</div>\";\n       }\n\n       private static THtml AtlasDateWithLabelHelper(THtmlHelper html, THtml control, string labelText)\n       {\n           var tag = new TTagBuilder(\"div\");\n           tag.AddCssClass(\"atlasDateControl\");\n           var label = html.Label(labelText);\n           var image = html.AtlasImage(\"sprite-calendar\");\n\n#if NETFRAMEWORK\n           var writer = new StringWriter();\n           writer.Write(label.ToHtmlString());\n           writer.Write(control.ToHtmlString());\n           writer.Write(image.ToHtmlString());\n           tag.InnerHtml = writer.ToString();\n           return new HtmlString(tag.ToString());\n#else\n           tag.InnerHtml.AppendHtml(label);\n           tag.InnerHtml.AppendHtml(control);\n           tag.InnerHtml.AppendHtml(image);\n           return tag;\n#endif\n       }\n\n       private static void ConfigureAtlasFieldFor<TModel, TValue>(TTagBuilder div, Expression<Func<TModel, TValue>> expression, object htmlAttributes, THtml labelHtml, THtml controlHtml)\n       {\n           var member = (MemberExpression)expression.Body;\n           div.ApplyHtmlAttributes(htmlAttributes);\n           div.AddCssClass(\"atlasfield\");\n           div.Attributes.Add(\"id\", $\"{member.Member.Name}Field\");\n           SetTagContent(div, labelHtml, controlHtml);\n       }\n\n       private static void ConfigureFaUxFieldFor<TModel, TValue>(TTagBuilder div, Expression<Func<TModel, TValue>> expression, object htmlAttributes, THtml labelHtml, THtml controlHtml)\n       {\n           var member = (MemberExpression)expression.Body;\n           div.ApplyHtmlAttributes(htmlAttributes);\n           div.AddCssClass(\"input\");\n           div.Attributes.Add(\"id\", $\"{member.Member.Name}Field\");\n\n           var icon = BuildAndRenderTag(\"springcm-icon\", t => {\n               t.AddCssClass(\"input__message-icon\");\n               t.Attributes.Add(\"icon\", \"warning\");\n           });\n\n           var spanLine = BuildAndRenderTag(\"span\", t => {\n               t.AddCssClass(\"input__line--focus\");\n               t.AddCssClass(\"theme_primary-dark_background-color\");\n           });\n\n           SetTagContent(div, icon, controlHtml, labelHtml, spanLine);\n       }\n\n       private static TTagBuilder BuildLabel(string name, string displayName)\n       {\n           var tag = new TTagBuilder(\"label\");\n           tag.Attributes[\"for\"] = name;\n           tag.AddCssClass(AtlasLabelName);\n           SetTagContent(tag, displayName);\n           return tag;\n       }\n\n       private static IDictionary<string, object> BuildAttributesDictionary(object htmlAttributes, bool enabled = true)\n       {\n           IDictionary<string, object> attributesDictionary = new RouteValueDictionary(htmlAttributes);\n\n           if (attributesDictionary.TryGetValue(\"data_bind\", out var dataBindValue))\n           {\n               attributesDictionary[\"data-bind\"] = dataBindValue;\n               attributesDictionary.Remove(\"data_bind\");\n           }\n\n           if (!enabled && !attributesDictionary.ContainsKey(\"disabled\"))\n           {\n               attributesDictionary.Add(\"disabled\", \"disabled\");\n           }\n           return attributesDictionary;\n       }\n\n       internal static void ApplyHtmlAttributes(this TTagBuilder tag, object htmlAttributes)\n       {\n           if (htmlAttributes == null) return;\n           var attributes = HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes);\n           tag.MergeAttributes(attributes, replaceExisting: false);\n       }\n\n       /// <summary>\n       /// Centralized helper to build a TagBuilder, configure it via a lambda, and render it to the correct framework-specific HTML type.\n       /// </summary>\n       private static THtml BuildAndRenderTag(string tagName, Action<TTagBuilder> configureAction, TTagRenderMode renderMode = TTagRenderMode.Normal)\n       {\n           var tag = new TTagBuilder(tagName);\n           configureAction(tag);\n\n#if NETFRAMEWORK\n           return new HtmlString(tag.ToString(renderMode));\n#else\n           tag.TagRenderMode = renderMode;\n           return tag;\n#endif\n       }\n\n       /// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, string content)\n       {\n#if NETFRAMEWORK\n           tag.SetInnerText(content);\n#else\n           tag.InnerHtml.Append(content);\n#endif\n       }\n\n       /// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, THtml htmlContent)\n       {\n#if NETFRAMEWORK\n           tag.InnerHtml = htmlContent.ToHtmlString();\n#else\n           tag.InnerHtml.AppendHtml(htmlContent);\n#endif\n       }\n\n       /// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, params THtml[] htmlContents)\n       {\n#if NETFRAMEWORK\n           using (var writer = new StringWriter())\n           {\n               foreach (var content in htmlContents)\n               {\n                   writer.Write(content.ToHtmlString());\n               }\n               tag.InnerHtml = writer.ToString();\n           }\n#else\n           foreach (var content in htmlContents)\n           {\n               tag.InnerHtml.AppendHtml(content);\n           }\n#endif\n       }\n    }\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ProfileMiddleware.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing log4net;\n\nusing Microsoft.AspNetCore.Http;\n\nusing Microsoft.AspNetCore.Http.Features;\n\nnamespace ADEXS.Web.Common.AspNetCore.Middlewares;\n\npublic sealed class ProfileMiddleware : IDisposable\n{\n\tprivate static readonly IDiscreetLogger Log = DiscreetLogger.GetLogger(typeof(ProfileMiddleware));\n\tprivate readonly RequestDelegate _next;\n\tprivate IDisposable? _logContext;\n\n\t[EventSource(\"Session Size\", \"CLM.SessionState\")]\n\t[Counter(\n\t\t\"Session Size\",\n\t\t\"CLM.SessionState\",\n\t\tDisplayUnit = CounterUnit.kilobytes,\n\t\tRanges = new double[10] { 1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 20000 },\n\t\tMeasureProperty = \"Count\",\n\t\tInstanceProperty = \"Description\",\n\t\tShowVolume = true)]\n\tprivate static readonly CountEventSource SessionSizeEventSource = new CountEventSource();\n\n\t[EventSource(\"Session Serialization Timing\", \"CLM.SessionState\")]\n\t[Counter(\n\t\t\"Session Serialization Timing\",\n\t\t\"CLM.SessionState\",\n\t\tDisplayUnit = CounterUnit.milliseconds,\n\t\tRanges = new double[10] { 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\tMeasureProperty = \"Duration\",\n\t\tSuccessProperty = \"Success\",\n\t\tInstanceProperty = \"Description\")]\n\tprivate static readonly TimingEventSource SessionSerializationTimingEventSource = new TimingEventSource();\n\n\t[EventSource(\"Large Session\", \"CLM.SessionState\")]\n\t[Counter(\"Large Session\", \"CLM.SessionState\")]\n\tprivate static readonly PropertyBagEventSource LargeSessionEventSource = new PropertyBagEventSource();\n\n\t// Avoid using HttpContext.Session directly because it will throw an exception if the session is not available.\n\tprivate static bool HasSession(HttpContext context) =>\n\t\tcontext?.Features?.Get<ISessionFeature>() != null && context?.Session != null;\n\n\tpublic ProfileMiddleware(RequestDelegate next)\n\t{\n\t\t_next = next;\n\t}\n\n\tpublic async Task InvokeAsync(HttpContext context)\n\t{\n\t\tif (context != null)\n\t\t{\n\t\t\t// Do something with context near the beginning of request processing.\n\t\t\tOnPreRequestHandlerExecute(context);\n\n\t\t\tawait _next.Invoke(context);\n\n\t\t\t// Clean up.\n\t\t\tOnPostRequestHandlerExecute(context);\n\t\t\tOnEndRequest();\n\t\t}\n\t}\n\n\tpublic void Dispose()\n\t{\n\t\t_logContext?.Dispose();\n\t}\n\n\tprivate void OnPreRequestHandlerExecute(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tLog.DebugNoPII(\"OnPreRequestHandlerExecute called.\");\n\t\t\tAtlasContext.Reset();\n\n\t\t\t// MonitoringContext is initialized in the AbstractLogRequestHttpMiddleware on\n\t\t\t// BeginRequest. This runs before this event handler. By this time the\n\t\t\t// CorrelationToken is set. Including getting it from the X-DocuSign-CorrelationToken header if available.\n\t\t\tvar corrId = MonitoringContext.CorrelationToken ?? Guid.Empty;\n\t\t\tif (corrId == Guid.Empty)\n\t\t\t{\n\t\t\t\t// Only in extremely unlikely scenario\n\t\t\t\tif (Guid.TryParse(AtlasContext.Current.TransactionId, out corrId))\n\t\t\t\t{\n\t\t\t\t\tLog.WarnNoPII(\n\t\t\t\t\t\t\"MonitoringContext.CorrelationToken was not set, but AtlasContext.Current.TransactionId was set. Using it to set MonitoringContext.CorrelationToken.\");\n\t\t\t\t\tMonitoringContext.CorrelationToken = corrId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog.WarnNoPII(\n\t\t\t\t\t\t\"MonitoringContext.CorrelationToken was not set, and AtlasContext.Current.TransactionId was not a valid Guid. Using Guid.Empty.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"MonitoringContext.CorrelationToken set to: {corrId}\");\n\t\t\t\tAtlasContext.Current.TransactionId = corrId.ToString();\n\t\t\t}\n\n\t\t\t// Overwrite TransactionId to use Activity.Current.Id\n\t\t\tif (!string.IsNullOrWhiteSpace(Activity.Current?.Id))\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Activity.Current.Id is set to: {Activity.Current.Id}. Overwriting AtlasContext.Current.TransactionId.\");\n\t\t\t\tAtlasContext.Current.TransactionId = Activity.Current.Id;\n\t\t\t}\n\n\t\t\tLog.DebugNoPII($\"AtlasContext.Current.TransactionId set to: {AtlasContext.Current.TransactionId}\");\n\t\t\t_logContext?.Dispose();\n\t\t\t_logContext = LogContext.Set(AtlasContext.Current.TransactionId);\n\n\t\t\tif (Log.IsDebugEnabled)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"ServiceLocator:\\n{ServiceLocator.Container.WhatDoIHave(typeof(ILogContextStore))}\");\n\t\t\t}\n\n\t\t\tif (context.Connection != null)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Connection RemoteIpAddress: {context.Connection.RemoteIpAddress?.ToString()}\");\n\t\t\t\tAtlasContext.Current.ClientIpAddress = context.Connection.RemoteIpAddress?.ToString();\n\t\t\t}\n\n\t\t\tif (context.Request != null)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Request Path: {context.Request.Path}\");\n\t\t\t\tAtlasContext.Current.ClientUserAgent = context.Request.Headers?.UserAgent.ToString();\n\t\t\t}\n\n\t\t\t// Similar code exists for web services, which don't use session.\n\t\t\t// That code is in SetContextIds\n\t\t\tif (HasSession(context))\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Session Id: {context.Session.Id}\");\n\t\t\t\tvar user = CommonData.CurrentUser;\n\t\t\t\tif (user != null)\n\t\t\t\t{\n\t\t\t\t\tLog.DebugNoPII($\"User AccountId: {user.AccountId}, User Uid: {user.Uid}\");\n\t\t\t\t\tAtlasContext.Current.AccountId = user.AccountId;\n\t\t\t\t\tAtlasContext.Current.UserAccountUid = user.Uid;\n\t\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] =\n\t\t\t\t\t\tuser.AccountId == int.MinValue ? \"null\" : user.AccountId.ToString();\n\n\t\t\t\t\tvar docusignAccountId = CommonData.DocuSignAccountId;\n\t\t\t\t\tif (!string.IsNullOrEmpty(docusignAccountId))\n\t\t\t\t\t{\n\t\t\t\t\t\tLog.DebugNoPII($\"DocuSign AccountId: {docusignAccountId}\");\n\t\t\t\t\t\tAtlasContext.Current.DocuSignAccountId = docusignAccountId;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar docusignUserId = CommonData.DocuSignUserId;\n\t\t\t\t\tif (!string.IsNullOrEmpty(docusignUserId))\n\t\t\t\t\t{\n\t\t\t\t\t\tLog.DebugNoPII($\"DocuSign UserId: {docusignUserId}\");\n\t\t\t\t\t\tAtlasContext.Current.DocuSignUserId = docusignUserId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog.DebugNoPII(\"No user found in session.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog.DebugNoPII(\"No session found.\");\n\t\t\t}\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Error setting AtlasContext.Current properties.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n\n\tprivate static void OnPostRequestHandlerExecute(HttpContext context)\n\t{\n\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\tif (HasSession(context))\n\t\t{\n\t\t\tLogSessionSize(context.Session);\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Measuring session size ATL-56207\n\t/// </summary>\n\tprivate static void LogSessionSize(ISession session)\n\t{\n\t\tif (!Configuration.GetBooleanAppSetting(\"EnableSessionSizeLogging\", false))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tlong totalSessionBytes = 0;\n\t\t\tvar largestItemKey = string.Empty;\n\t\t\tlong largestItemSizeBytes = 0;\n\t\t\tvar itemCount = 0;\n\n\t\t\tusing (var sessionSerializationTimer = SessionSerializationTimingEventSource.CreateTimer())\n\t\t\t{\n\t\t\t\tforeach (var sessionKey in session.Keys)\n\t\t\t\t{\n\t\t\t\t\tif (session.TryGetValue(sessionKey, out var bytes))\n\t\t\t\t\t{\n\t\t\t\t\t\titemCount++;\n\t\t\t\t\t\tif (bytes.Length > largestItemSizeBytes)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlargestItemKey = sessionKey;\n\t\t\t\t\t\t\tlargestItemSizeBytes = bytes.Length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttotalSessionBytes += bytes.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsessionSerializationTimer.SetResult(true);\n\t\t\t}\n\n\t\t\tSessionSizeEventSource.Emit(totalSessionBytes);\n\n\t\t\t// default to 1MB\n\t\t\tif (totalSessionBytes > Configuration.GetInt64AppSetting(\"LargeSessionSizeLoggingThreshold\", 1000000))\n\t\t\t{\n\t\t\t\tvar aid = AtlasContext.Current?.AccountId.ToString();\n\t\t\t\tvar userId = AtlasContext.Current?.UserAccountUid.ToString();\n\n\t\t\t\tusing (var propertyBag = LargeSessionEventSource.CreateEventPropertyBag())\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"AccountId\", aid);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"UserAccountUid\", userId);\n\n\t\t\t\t\tif (Log.IsDebugEnabled)\n\t\t\t\t\t{\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionId\", session.Id);\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionSizeInBytes\", totalSessionBytes.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemKey\", largestItemKey);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemSizeInBytes\", largestItemSizeBytes.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TotalSessionItemCount\", itemCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ThreadId\", Environment.CurrentManagedThreadId.ToString());\n\t\t\t\t}\n\n\t\t\t\tLog.InfoNoPII(\n\t\t\t\t\t$\"Detected Large SessionState. AccountId {aid} UserAccountUid {userId} SessionId {session.Id} SessionSizeInBytes {totalSessionBytes} TotalItemCount {itemCount} Largest Item Key {largestItemKey} ({largestItemSizeBytes})\");\n\t\t\t}\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Exception occurred while attempting to measure session.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n\n\tprivate void OnEndRequest()\n\t{\n\t\ttry\n\t\t{\n\t\t\t_logContext?.Dispose();\n\t\t\t_logContext = null;\n\t\t\tLogicalThreadContext.Properties[\"accountid\"] = \"null\";\n\n\t\t\t// we are no longer looking for outstanding DB transactions here.\n\t\t\t// because the module does not have to run in the same thread as the request handler\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Trouble OnEndRequest in ProfileModule.\", ex);\n\t\t\tex.Report();\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tAtlasContext.Current.CacheClient.FlushCache();\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Could not clear the user settings on the thread for the request.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Telemetry;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.Web.Common.AspNetCore.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic abstract class ScmLogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic ScmLogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tprotected ScmLogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowScopeEvents/WorkflowScopeEventsController.Trace.cs",
            "content": "\ufeff#nullable enable\n\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.WorkflowScopeEvents;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\n// ReSharper disable CheckNamespace\n// This partial class needs to be in the same namespace as the controller.\n\nnamespace DocuSign.CLM.API.WorkflowActivities.Controllers;\n\n/// <summary>\n/// Instrumentation for <see cref=\"WorkflowScopeEventsController\"/>.\n/// </summary>\npublic partial class WorkflowScopeEventsController\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity(\n\t\tint accountId,\n\t\tGuid userAccountUid,\n\t\tGuid instanceUid = default,\n\t\tGuid activityUid = default,\n\t\tGuid revisionUid = default,\n\t\t[CallerMemberName] string name = \"\")\n\t{\n\t\treturn _serviceInstrumentation.ActivitySource\n\t\t\t.StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowActivities/WorkflowActivitiesController.Trace.cs",
            "content": "\ufeff#nullable enable\n\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.WorkflowActivities;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\n// ReSharper disable CheckNamespace\n// This partial class needs to be in the same namespace as the controller.\n\nnamespace DocuSign.CLM.API.WorkflowActivities.Controllers;\n\n/// <summary>\n/// Instrumentation for <see cref=\"WorkflowActivitiesController\"/>.\n/// </summary>\npublic partial class WorkflowActivitiesController\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity(\n\t\tint accountId,\n\t\tGuid userAccountUid,\n\t\tGuid instanceUid = default,\n\t\tGuid activityUid = default,\n\t\tGuid revisionUid = default,\n\t\t[CallerMemberName] string name = \"\")\n\t{\n\t\treturn _serviceInstrumentation.ActivitySource\n\t\t\t.StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowDefinition/WorkflowDefinitionController.Trace.cs",
            "content": "\ufeff#nullable enable\n\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.WorkflowDefinition;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\n// ReSharper disable CheckNamespace\n// This partial class needs to be in the same namespace as the controller.\n\nnamespace DocuSign.CLM.API.WorkflowActivities.Controllers;\n\n/// <summary>\n/// Instrumentation for <see cref=\"WorkflowDefinitionController\"/>.\n/// </summary>\npublic partial class WorkflowDefinitionController\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity(\n\t\tint accountId,\n\t\tGuid userAccountUid,\n\t\tGuid revisionUid = default,\n\t\t[CallerMemberName] string name = \"\")\n\t{\n\t\treturn _serviceInstrumentation.ActivitySource\n\t\t\t.StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/DocumentCreation/OpenXmlExtensions.cs",
            "content": "\ufeffusing System.Collections.Generic;\nusing System.Linq;\nusing DocumentFormat.OpenXml;\nusing DocumentFormat.OpenXml.Packaging;\nusing DocumentFormat.OpenXml.Wordprocessing;\n\nnamespace ADEXS.Core.Domain.DocumentCreation\n{\n    public static class OpenXmlExtensions\n    {\n        public static string GetTag(this SdtElement sdtElement)\n        {\n            if (sdtElement == null || \n                sdtElement.SdtProperties == null ||\n                sdtElement.SdtProperties.GetFirstChild<Tag>() == null ||\n                sdtElement.SdtProperties.GetFirstChild<Tag>().Val == null)\n            {\n                return null;\n            }\n            return sdtElement.SdtProperties.GetFirstChild<Tag>().Val.Value;\n        }\n\n        public static void SetTag(this SdtElement sdtElement, string tag)\n        {\n            if (sdtElement == null) return;\n            if (sdtElement.SdtProperties == null) sdtElement.SdtProperties = new SdtProperties();\n            if (sdtElement.SdtProperties.GetFirstChild<Tag>() == null) sdtElement.SdtProperties.AppendChild(new Tag());\n            if (sdtElement.SdtProperties.GetFirstChild<Tag>().Val == null) sdtElement.SdtProperties.GetFirstChild<Tag>().Val = new StringValue();\n\n            sdtElement.SdtProperties.GetFirstChild<Tag>().Val.Value = tag;\n        }\n\n        public static bool IsPlainTextControl(this SdtElement sdtElement)\n        {\n            if (sdtElement == null || sdtElement.SdtProperties == null) return false;\n            return sdtElement.SdtProperties.Descendants<SdtContentText>().Any();\n        }\n\n        public static bool IsMultiLinePlainTextControl(this SdtElement sdtElement)\n        {\n            if (sdtElement == null || sdtElement.SdtProperties == null) return false;\n            var plainTextProperty = sdtElement.SdtProperties.GetFirstChild<SdtContentText>();\n            return plainTextProperty != null && plainTextProperty.MultiLine != null && plainTextProperty.MultiLine.HasValue && plainTextProperty.MultiLine.Value;\n        }\n\n        public static bool IsPictureControl(this SdtElement sdtElement)\n        {\n            if (sdtElement == null || sdtElement.SdtProperties == null) return false;\n            return sdtElement.SdtProperties.GetFirstChild<SdtContentPicture>() != null;\n        }\n\n        public static void RemovePlaceholder(this SdtElement sdtElement)\n        {\n            if (sdtElement == null || sdtElement.SdtProperties == null || sdtElement.SdtProperties.GetFirstChild<ShowingPlaceholder>() == null) return;\n\n            sdtElement.SdtProperties.RemoveAllChildren<ShowingPlaceholder>();\n            var runStyles = sdtElement.Descendants<RunStyle>().Where(rs => rs.Val.Value == \"PlaceholderText\").ToList();\n            foreach (var runStyle in runStyles)\n            {\n                var parent = runStyle.Parent;\n                runStyle.Remove();\n                if(!parent.HasChildren) parent.Remove();\n            }\n        }\n\n        public static void RemoveBookmarks(this OpenXmlElement  element)\n        {\n            if (element == null) return;\n\n            var allBookmarks = new List<OpenXmlLeafElement>();\n            allBookmarks.AddRange(element.Descendants<BookmarkStart>());\n            allBookmarks.AddRange(element.Descendants<BookmarkEnd>());\n\n            foreach (var bookmark in allBookmarks)\n            {\n                bookmark.Remove();\n            }\n        }\n\n        public static void RemoveAllChildrenExceptFirst<T>(this OpenXmlElement element) where T : OpenXmlElement\n        {\n            var firstChildOfType = true;\n            foreach (var child in element.Elements().ToList())\n            {\n                if (firstChildOfType && child is T)\n                {\n                    firstChildOfType = false;\n                    continue;\n                }\n                child.Remove();\n            }\n        }\n\n\t    public static void Suppress(this SdtElement sdtElement, string value)\n\t    {\n\t\t    OpenXmlElement openXmlElement = sdtElement.Parent;\n\n\t\t    if (openXmlElement is TableCell)\n\t\t    {\n\t\t\t    var pExists = openXmlElement.ChildElements.Any(p => p.LocalName == \"p\");\n\t\t\t    if (!pExists)\n\t\t\t    {\n\t\t\t\t    openXmlElement.Append(new Paragraph());\n\t\t\t    }\n\t\t    }\n\t\t\tsdtElement.Remove();\n\t    }\n\n\t\tpublic static List<SdtElement> GetTopLevelContentControls(this SdtElement element)\n        {\n            return element.Descendants<SdtElement>().Where(\n                descendant =>\n                descendant.Ancestors<SdtElement>().First().GetTag() == element.GetTag())\n                          .ToList();\n        }\n\n        private static IEnumerable<SdtElement> ContentControlsForPart(this OpenXmlPart part)\n        {\n            return part.RootElement.Descendants<SdtElement>();\n        }\n\n        public static IEnumerable<SdtElement> ContentControls(this MainDocumentPart mainDocumentPart)\n        {\n            var contentControls = new List<SdtElement>();\n            contentControls.AddRange(mainDocumentPart.ContentControlsForPart());\n\n            foreach (var headerPart in mainDocumentPart.HeaderParts)\n            {\n                contentControls.AddRange(headerPart.ContentControlsForPart());\n            }\n            foreach (var footerPart in mainDocumentPart.FooterParts)\n            {\n                contentControls.AddRange(footerPart.ContentControlsForPart());\n            }\n            \n            if (mainDocumentPart.FootnotesPart != null)\n            {\n                contentControls.AddRange(mainDocumentPart.FootnotesPart.ContentControlsForPart());\n            }\n            if (mainDocumentPart.EndnotesPart != null)\n            {\n                contentControls.AddRange(mainDocumentPart.EndnotesPart.ContentControlsForPart());\n            }\n\n            return contentControls;\n        }\n\n        public static T GetFirstDescendant<T>(this OpenXmlElement openXmlElement) where T : OpenXmlElement\n        {\n            return openXmlElement.Descendants<T>().FirstOrDefault();\n        }\n\n\n    }\n}",
            "relevance_score": 100
          }
        ],
        "reasoning_chain": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "1. Analysis",
              "reasoning": "1. Analysis\n--------------------------------------------------\nKey requirements  ",
              "conclusion": "Key requirements  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 2,
              "description": "2. Planning",
              "reasoning": "2. Planning\n--------------------------------------------------\nBest approach  ",
              "conclusion": "Best approach  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 3,
              "description": "3. Implementation targets (selected files)",
              "reasoning": "3. Implementation targets (selected files)\n--------------------------------------------------\n1. /Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs  ",
              "conclusion": "1. /Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 4,
              "description": "4. Validation",
              "reasoning": "4. Validation\n--------------------------------------------------\n\u2022 Unit / integration tests: issue a request with a Referer header and verify the exported span contains \u201cHTTP_REFERER\u201d.  ",
              "conclusion": "\u2022 Unit / integration tests: issue a request with a Referer header and verify the exported span contains \u201cHTTP_REFERER\u201d.  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            }
          ],
          "final_conclusion": "0.74 \u2013 High likelihood that the listed files are exactly where spans are created / enriched, but final confirmation will come once the code is opened.",
          "overall_confidence": 0.8,
          "alternative_approaches": [
            "Best approach",
            "Reasonable alternative (rejected): add a brand-new middleware \u2013 but we\u2019d then have to guarantee its registration order in every host. Editing the existing central middleware is simpler and safer.",
            "\u2013 Central helper for setting tags; ideal spot to add convenience methods for the two new attributes and keep code DRY."
          ]
        }
      },
      "error": null,
      "execution_time": 14.80068302154541,
      "cache_hit": false
    },
    "patch_generation": {
      "stage_name": "patch_generation",
      "status": "StageStatus.COMPLETED",
      "result": {
        "diff": "We add two new attributes to every HTTP-request span:\n\n\u2022 HTTP_REFERER \u2013 value taken from `Request.Headers[\"Referer\"]`  \n\u2022 HTTP_RESPONSE_REDIRECT_LOCATION \u2013 value taken from `Response.Headers[\"Location\"]`\n\nTo guarantee that the tags are always attached and to keep the code DRY we introduce a small helper/extension method.  \nBoth CLM ASP-NET-Core middlewares that already wrap the request span (`LogAsyncRequestHttpMiddleware` and `ScmLogAsyncRequestHttpMiddleware`) are updated to call the helper **after** the pipeline has executed \u2013 this moment guarantees that the *response* headers are already available.\n\nNo other code paths are touched, DI registrations remain unchanged because the helper is a plain static extension method.",
        "explanation": "*** Begin Patch\n*** Add File: ADEXS.Web.Common.AspNetCore.Telemetry/ActivityHttpExtensions.cs\n+#nullable enable\n+\n+using System.Diagnostics;\n+using System.Linq;\n+\n+using Microsoft.AspNetCore.Http;\n+\n+namespace ADEXS.Web.Common.AspNetCore.Telemetry;\n+\n+/// <summary>\n+/// Helper methods for enriching HTTP-request activities with additional headers.\n+/// </summary>\n+internal static class ActivityHttpExtensions\n+{\n+    private const string HttpRefererTag                    = \"HTTP_REFERER\";\n+    private const string HttpResponseRedirectLocationTag   = \"HTTP_RESPONSE_REDIRECT_LOCATION\";\n+\n+    /// <summary>\n+    /// Adds HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION tags (if present) to the activity.\n+    /// </summary>\n+    internal static Activity? SetHttpRefererAndRedirectLocation(\n+        this Activity? activity,\n+        HttpContext httpContext)\n+    {\n+        if (activity == null || httpContext == null)\n+            return activity;\n+\n+        // \u2500\u2500\u2500\u2500\u2500 Referer \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+        var referer = httpContext.Request.Headers[\"Referer\"].FirstOrDefault();\n+        if (!string.IsNullOrEmpty(referer))\n+            activity.SetTag(HttpRefererTag, referer);\n+\n+        // \u2500\u2500\u2500\u2500\u2500 Redirect location \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+        var redirectLocation = httpContext.Response?.Headers[\"Location\"].FirstOrDefault();\n+        if (!string.IsNullOrEmpty(redirectLocation))\n+            activity.SetTag(HttpResponseRedirectLocationTag, redirectLocation);\n+\n+        return activity;\n+    }\n+}\n+\n*** End Patch\n*** End Patch",
        "selection_reasoning": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "1. Analysis",
              "reasoning": "1. Analysis\n--------------------------------------------------\nKey requirements  ",
              "conclusion": "Key requirements  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 2,
              "description": "2. Planning",
              "reasoning": "2. Planning\n--------------------------------------------------\nBest approach  ",
              "conclusion": "Best approach  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 3,
              "description": "3. Implementation targets (selected files)",
              "reasoning": "3. Implementation targets (selected files)\n--------------------------------------------------\n1. /Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs  ",
              "conclusion": "1. /Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 4,
              "description": "4. Validation",
              "reasoning": "4. Validation\n--------------------------------------------------\n\u2022 Unit / integration tests: issue a request with a Referer header and verify the exported span contains \u201cHTTP_REFERER\u201d.  ",
              "conclusion": "\u2022 Unit / integration tests: issue a request with a Referer header and verify the exported span contains \u201cHTTP_REFERER\u201d.  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            }
          ],
          "final_conclusion": "0.74 \u2013 High likelihood that the listed files are exactly where spans are created / enriched, but final confirmation will come once the code is opened.",
          "overall_confidence": 0.8,
          "alternative_approaches": [
            "Best approach",
            "Reasonable alternative (rejected): add a brand-new middleware \u2013 but we\u2019d then have to guarantee its registration order in every host. Editing the existing central middleware is simpler and safer.",
            "\u2013 Central helper for setting tags; ideal spot to add convenience methods for the two new attributes and keep code DRY."
          ]
        },
        "patch_reasoning": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "1. Analysis",
              "reasoning": "1. Analysis  \n   \u2022 Add the two required attributes (`HTTP_REFERER`, `HTTP_RESPONSE_REDIRECT_LOCATION`) to every ASP.NET\u2010integrated HTTP span.  \n   \u2022 Locate enrichment hooks:  ",
              "conclusion": "   \u2022 Locate enrichment hooks:  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 2,
              "description": "2. Implementation (auto strategy)",
              "reasoning": "2. Implementation (auto strategy)  \n   \u2022 Create a small helper class `AspNetEnrichment` that has static delegates for request/response enrichment.  \n   \u2022 In `ScmHttpApplication.ApplicationStart`, reuse the delegates instead of lambdas.  ",
              "conclusion": "   \u2022 In `ScmHttpApplication.ApplicationStart`, reuse the delegates instead of lambdas.  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            }
          ],
          "final_conclusion": "\u2022 Post\u2010processing processor \u2013 rejected: higher CPU cost and need to check every span.",
          "overall_confidence": 0.8,
          "alternative_approaches": [
            "4. Alternatives"
          ]
        },
        "selected_files": [
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web/SSO/SSOEndpoint.ashx.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Ajax/UploadFiles.ashx.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/HttpRequestAuditHelper.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Filters/MvcAuditedRequestAttribute.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Controls/FormExtensions.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ProfileMiddleware.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowScopeEvents/WorkflowScopeEventsController.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowActivities/WorkflowActivitiesController.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowDefinition/WorkflowDefinitionController.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/DocumentCreation/OpenXmlExtensions.cs"
        ]
      },
      "error": null,
      "execution_time": 42.46725106239319,
      "cache_hit": false
    },
    "validation": {
      "stage_name": "validation",
      "status": "StageStatus.COMPLETED",
      "result": {
        "overall_score": 0.6333333333333333,
        "test_results": [
          {
            "test_name": "Intent Required Fields",
            "test_type": "TestType.UNIT",
            "passed": false,
            "score": 0.5,
            "details": {
              "missing_fields": [
                "search_keywords"
              ]
            },
            "errors": [
              "Missing required field: search_keywords"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Telemetry Operation Validity",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "type": "span",
              "action": "ADD_ATTRIBUTES"
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Semantic Description Quality",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "description_length": 122,
              "quality_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Patch Format Validity",
            "test_type": "TestType.UNIT",
            "passed": false,
            "score": 0.0,
            "details": {
              "patch_length": 732
            },
            "errors": [
              "Invalid unified diff format"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Code Style Compliance",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "style_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.003
          },
          {
            "test_name": "Change Scope Appropriateness",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 0.7,
            "details": {
              "scope_score": 0.7
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Code Compilation",
            "test_type": "TestType.INTEGRATION",
            "passed": false,
            "score": 0.0,
            "details": {
              "files_count": 30
            },
            "errors": [
              "Mismatched parentheses in BaseApiHandler.cs",
              "Mismatched parentheses in AttributesController.cs"
            ],
            "warnings": [],
            "execution_time": 2.0
          },
          {
            "test_name": "OpenTelemetry Attribute Naming",
            "test_type": "TestType.COMPLIANCE",
            "passed": false,
            "score": 0.5,
            "details": {
              "attributes_count": 2
            },
            "errors": [
              "Non-compliant attribute names found"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Instrumentation Pattern Compliance",
            "test_type": "TestType.COMPLIANCE",
            "passed": true,
            "score": 1.0,
            "details": {
              "pattern_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Resource Usage Analysis",
            "test_type": "TestType.PERFORMANCE",
            "passed": true,
            "score": 0.9,
            "details": {
              "score": 0.9,
              "errors": [],
              "warnings": [
                "Consider using 'using' statements for disposable resources"
              ]
            },
            "errors": [],
            "warnings": [
              "Consider using 'using' statements for disposable resources"
            ],
            "execution_time": 0.003
          },
          {
            "test_name": "No Hardcoded Secrets",
            "test_type": "TestType.COMPLIANCE",
            "passed": true,
            "score": 1.0,
            "details": {},
            "errors": [],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Input Validation",
            "test_type": "TestType.COMPLIANCE",
            "passed": false,
            "score": 0.0,
            "details": {
              "validation_score": 0.0
            },
            "errors": [
              "Insufficient input validation"
            ],
            "warnings": [
              "Input validation could be improved"
            ],
            "execution_time": 0.002
          }
        ],
        "recommendations": [
          "Address failing tests before deployment",
          "Improve implementation for low-scoring areas",
          "Validate telemetry data collection in staging environment"
        ],
        "risk_assessment": "HIGH",
        "compliance_status": {
          "opentelemetry": false,
          "security": true,
          "style": true
        }
      },
      "error": null,
      "execution_time": 0.02838921546936035,
      "cache_hit": false
    }
  }
}