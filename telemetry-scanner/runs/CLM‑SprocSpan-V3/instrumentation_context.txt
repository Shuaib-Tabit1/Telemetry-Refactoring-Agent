using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Threading;

using ADEXS.Core.Util.Config;
using ADEXS.Core.Util.Core;
using ADEXS.Core.Util.Loggers;
using ADEXS.Core.Util.ServiceLocator;
using DocuSign.Monitoring;
using log4net;
using System.Threading.Tasks;


#if !NET
using System.ServiceProcess;
#endif

namespace ADEXS.ServiceFramework
{
	/// <summary>
	/// Base class to subclass for services.  Handles the managing of worker processes,
	/// worker groups, and remotable objects via the Register* methods.
	/// </summary>
	public abstract class ScmServicedComponent : IServicedComponent
	{
		public const int EXIT_FAIL_TO_BOOTSTRAP = 1;
		public const int EXIT_FAIL_TO_START = 2;
		public const int EXIT_FAIL_HELTH_CHECK = 3;
		public const int EXIT_FAIL_TO_BEFORE_START = 4;

		protected static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(ScmServicedComponent));
		private bool _running = false;
		protected List<AbstractServiceWorkerGroup> _groups = new List<AbstractServiceWorkerGroup>();
		protected List<AbstractServiceWorker> _workers = new List<AbstractServiceWorker>();

		public bool Join(int joinTimeout)
		{
			foreach (AbstractServiceWorker worker in _workers)
			{
				if (!worker.Join(joinTimeout)) return false;
			}
			foreach (AbstractServiceWorkerGroup group in _groups)
			{
				if (!group.Join(joinTimeout)) return false;
			}
			return true;
		}

		/// <summary>
		/// Starts the worker, and adds it to the management pool.
		/// </summary>
		public AbstractServiceWorker RegisterWorker(AbstractServiceWorker worker)
		{
			_workers.Add(worker);
			worker.Start();
			return worker;
		}
		/// <summary>
		/// Creates a worker of the specified type, and adds it to the management pool.
		/// </summary>
		/// <param name="workerType">Type must inherit from AbstractServiceWorker</param>
		public AbstractServiceWorker RegisterWorker(Type workerType)
		{
			Type baseType = typeof(AbstractServiceWorker);
			if (!workerType.IsSubclassOf(baseType)) throw new ArgumentException(string.Format("Type {0} does not subclass expected type {1}", workerType.Name, baseType.Name));
			// Construct the worker by calling the constructor that passes in our component
			ConstructorInfo constructor = workerType.GetConstructor(new Type[] { GetType() });
			if (constructor == null) throw new ArgumentException(string.Format("Type {0} does not contain a (ScmServicedComponent) constructor", workerType.Name));
			AbstractServiceWorker worker = (AbstractServiceWorker)constructor.Invoke(new object[] { this });
			return RegisterWorker(worker);
		}
		/// <summary>
		/// Creates a worker that will call the passed in delegates, and adds it to the management pool.
		/// </summary>
		/// <param name="name">Name to be used for logging purposes</param>
		/// <param name="runDelegate">Function to call when the worker is supposed to take action</param>
		/// <param name="sleepSecondsDelegate">Number of seconds the worker should sleep in between actions</param>
		public AbstractServiceWorker RegisterWorker(string name, DelegateServiceWorker.RunDelegate runDelegate, DelegateServiceWorker.SleepSecondsDelegate sleepSecondsDelegate)
		{
			DelegateServiceWorker worker = new DelegateServiceWorker(name, this, runDelegate, sleepSecondsDelegate);
			return RegisterWorker(worker);
		}

		/// <summary>
		/// Starts the workers in the group, and adds the group and workers to the management pool.
		/// </summary>
		public AbstractServiceWorkerGroup RegisterWorkerGroup(AbstractServiceWorkerGroup group)
		{
			_groups.Add(group);
			group.AdjustWorkers();
			return group;
		}
		/// <summary>
		/// Creates a worker group of the specified type, and adds it to the management pool.
		/// </summary>
		/// <param name="groupType">Type must inherit from AbstractServiceWorkerGroup</param>
		public AbstractServiceWorkerGroup RegisterWorkerGroup(Type groupType)
		{
			Type baseType = typeof(AbstractServiceWorkerGroup);
			if (!groupType.IsSubclassOf(baseType)) throw new ArgumentException(string.Format("Type {0} does not subclass expected type {1}", groupType.Name, baseType.Name));
			// Construct the worker by calling the constructor that passes in our component
			ConstructorInfo constructor = groupType.GetConstructor(new Type[] { GetType() });
			if (constructor == null) throw new ArgumentException(string.Format("Type {0} does not contain a (ScmServicedComponent) constructor", groupType.Name));
			AbstractServiceWorkerGroup group = (AbstractServiceWorkerGroup)constructor.Invoke(new object[] { this });
			return RegisterWorkerGroup(group);
		}
		/// <summary>
		/// Creates a worker group that will call the passed in delegates, and adds it to the management pool.
		/// </summary>
		/// <param name="groupName">Name of the group, to be used for logging purposes</param>
		/// <param name="workerName">Name of the workers in this group, to be used for logging purposes</param>
		/// <param name="desiredWorkerCountDelegate">Function to call to determine the desired number of workers in this group</param>
		/// <param name="runDelegate">Function to call when a worker in the group is supposed to take action</param>
		/// <param name="sleepSecondsDelegate">Number of seconds a worker in the group should sleep in between actions</param>
		public AbstractServiceWorkerGroup RegisterWorkerGroup(string groupName, string workerName, DelegateServiceWorkerGroup.DesiredWorkerCountDelegate desiredWorkerCountDelegate, DelegateServiceWorker.RunDelegate runDelegate, DelegateServiceWorker.SleepSecondsDelegate sleepSecondsDelegate)
		{
			DelegateServiceWorkerGroup group = new DelegateServiceWorkerGroup(groupName, workerName, this, desiredWorkerCountDelegate, runDelegate, sleepSecondsDelegate);
			return RegisterWorkerGroup(group);
		}

		public void UnRegisterWorkerGroup(AbstractServiceWorkerGroup group)
		{
			for (int i = 0; i < _groups.Count; i++)
			{
				if (_groups[i] == group)
				{
					_groups[i].Stop();
					_groups.RemoveAt(i);
					break;
				}
			}
		}

		/// <summary>
		/// Called by the ServiceInvocationFramework when the service is started
		/// </summary>
		public void Run()
		{
			_log.InfoNoPII($"This is {System.Diagnostics.Process.GetCurrentProcess().ProcessName} {GetType().Assembly.GetName().Version} Â© SpringCM {DateTime.UtcNow:yyyy}.");

			if (ConfigWrapper.UseOneConfig)
			{
				BootstrapServices();
			}

			try
			{
				OnBeforeRun();
			}
			catch (Exception e)
			{
				_log.FatalNoPII("OnBeforeRun failed", e);
				Exit(EXIT_FAIL_TO_BEFORE_START);
			}

			if (!ConfigWrapper.UseOneConfig)
			{
				BootstrapServices();
			}

			if (Configuration.GetBooleanAppSetting("DebugOnStartup", false))
			{
				System.Diagnostics.Debugger.Launch();
			}

			RunHealthCheck();

			_log.WarnNoPII("Starting service.");

			AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(appDomain_UnhandledException);

			_running = true;
			InitializeFeatureFlags();

			try
			{
				OnRun();
			}
			catch (Exception e)
			{
				_log.FatalNoPII("OnRun failed", e);
				Exit(EXIT_FAIL_TO_START);
			}

			StartManager();
			StartAll();
			_log.InfoNoPII($"{_workers.Count} workers and {_groups.Count} groups running.");
		}

		protected virtual List<IServiceRegistry> GetServiceRegistries()
		{
			return new List<IServiceRegistry>();
		}

		public static void appDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
		{
#pragma warning disable CA1307 // Specify StringComparison for clarity
			string senderTxt = $"{sender.GetType().FullName} ({sender})".Replace('\n', ' ').Replace("\r", "");
#pragma warning restore CA1307 // Specify StringComparison for clarity
			Exception ex;
			string msg;
			if (e.ExceptionObject is Exception)
			{
				msg = $"Unhandled exception from '{senderTxt}'. IsTerminating: {e.IsTerminating}";
				ex = (Exception)e.ExceptionObject;
			}
			else
			{
				msg = $"Unhandled exception from '{senderTxt}' with exception object '{e.ExceptionObject.GetType().FullName}'. IsTerminating: {e.IsTerminating}.";
				ex = new Exception(msg);
			}

			if(e.IsTerminating)
				_log.FatalNoPII(msg, ex);
			else
				_log.ErrorNoPII(msg, ex);
		}

		/// <summary>
		/// Is the service running?
		/// </summary>
		public bool Running
		{
			get { return _running; }
		}

		/// <summary>
		/// Called by the ServiceInvocationFramework when the service is stopped.
		/// Note that stopping the component stops all workers it controls.
		/// </summary>
		public void Stop()
		{
			_log.WarnNoPII("Stopping service.");

			if (Configuration.GetBooleanAppSetting("EnableServicesForcedShutdown", false) ||
			    Configuration.GetBooleanAppSetting($"EnableServiceForcedShutdown_{AppConfig.AppName()}", false))
			{
				int delay = Configuration.GetInt32AppSetting("ForcedShutdownDelay", 600000); // 10 min
#pragma warning disable VSTHRD110 // await async method and get results
				Task.Delay(delay).ContinueWith(x => ScmServicedComponent.ForcedShutdown(), CancellationToken.None, TaskContinuationOptions.None, TaskScheduler.Default);
#pragma warning restore VSTHRD110
			}

			try
			{
				OnBeforeStop();
			}
			catch (Exception e)
			{
				_log.ErrorNoPII("OnBeforeStop failed", e);
			}

			_running = false;
			// Stop the thread manager first, so it doesn't pick on the other stopping workers.
			StopManager();
			// Our workers may be sleeping, so we interrupt to let them wake up
			StopAll();

			try
			{
				OnStop();
			}
			catch (Exception e)
			{
				_log.ErrorNoPII("OnStop failed", e);
			}

			_log.InfoNoPII("Stopping code completed.");
		}

#if NET
		public bool IsService()
		{
			return true;
		}
#else
		private bool _isService;
		public bool IsService()
		{
			if (!_isService)
			{
				try
				{
					Assembly entryAssembly = Assembly.GetEntryAssembly();
					MethodInfo methodInfo = entryAssembly.EntryPoint;
					Type entryType = methodInfo.DeclaringType;
					_isService = typeof(ServiceBase).IsAssignableFrom(entryType);
				}
#pragma warning disable CA1031
				catch (Exception ex)
#pragma warning restore CA1031
				{
					_log.ErrorNoPII("Failed to determine if this is service execution.", ex);
				}
			}
			return _isService;
		}
#endif
		public virtual void RunHealthCheck()
		{
		}

		/// <summary>
		/// The subclass thats inheriting this class can choose to override
		/// and initialize FeatureFlags
		/// </summary>
		public virtual void InitializeFeatureFlags()
		{
		}

		/// <summary>
		/// The subclass thats inheriting this class can implement the method to run code before workers initialized.
		/// For example, it can initialize telemetry in this call.
		/// </summary>
		protected virtual void OnBeforeRun() { }

		/// <summary>
		/// The subclass thats inheriting this class must implement these methods to start
		/// workers or whatnot.
		/// </summary>
		protected abstract void OnRun();

		/// <summary>
		/// The subclass thats inheriting this class must implement these methods to do
		/// any necessary cleanup.
		/// </summary>
		protected abstract void OnStop();

		/// <summary>
		/// The subclass thats inheriting this class can implement the methods to do
		/// any necessary cleanup which should happen before component stopped.
		/// </summary>
		protected virtual void OnBeforeStop() { }

		protected virtual void Exit(int exitCode)
		{
			LogManager.Shutdown();

			// Giving some time for the above. Otherwise I've found I lose logs.
			Thread.Sleep(TimeSpan.FromSeconds(5));

			// This is not graceful. Windows sees that the service exits unexpectedely, and invokes
			// the retry policy. The service will be started at least once more, or may even
			// be restarted continuously, which is not very productive.
			// The correct way is to call ServiceBase.Stop(), but that instance is not available
			// here. ServiceInvocationFramework will need to be modified to provide it.
			Environment.Exit(exitCode);
		}
		/// <summary>
		/// Starts all workers for this component.  Workers for this component should be started
		/// when they were added, but, you never know.
		/// </summary>
		private void StartAll()
		{
			_log.DebugNoPII(string.Format("This service appears to be on a system with {0} ProcessorCount.", Environment.ProcessorCount));
			foreach (AbstractServiceWorker worker in _workers) worker.Start();
			foreach (AbstractServiceWorkerGroup group in _groups) group.Start(group.Name);
		}

		/// <summary>
		/// Stops all workers for this component.  Workers for this component should stop
		/// when the component does, but they may be sleeping, etc, and thus require
		/// interrupting.
		/// </summary>
		private void StopAll()
		{
			if (Configuration.GetBooleanAppSetting("EnableFastShutdown", true))
			{
				_log.InfoNoPII("Stopping workers.");
				Parallel.ForEach(_workers, x => x.Stop());
				_log.InfoNoPII("Stopping groups.");
				Parallel.ForEach(_groups, x => x.Stop());
			}
			else
			{
				_log.InfoNoPII("Stopping workers.");
				foreach (AbstractServiceWorker worker in _workers) worker.Stop();
				_log.InfoNoPII("Stopping groups.");
				foreach (AbstractServiceWorkerGroup group in _groups) group.Stop();
			}
		}

		/// <summary>
		/// Internal worker used to keep track of the other workers and make sure no
		/// threads exit unexpectedly, and that worker groups have the correct
		/// number of workers.
		/// </summary>
		private void StartManager()
		{
			try
			{
				foreach (AbstractServiceWorker worker in _workers)
				{
					if (worker is ThreadManagerWorker)
					{
						worker.Start();
						return;
					}
				}
				RegisterWorker(new ThreadManagerWorker(this));
			}
			catch (Exception e)
			{
				_log.ErrorNoPII($"Could not start {nameof(ThreadManagerWorker)}", e);
			}
		}

		private void StopManager()
		{
			_log.InfoNoPII("Stopping Manager.");
			try
			{
				foreach (AbstractServiceWorker worker in _workers)
				{
					if (worker is ThreadManagerWorker)
					{
						worker.Stop(); // hopefully it's just one of those
					}
				}
			}
			catch (Exception e)
			{
				_log.ErrorNoPII($"Could not stop {nameof(ThreadManagerWorker)}", e);
			}
		}

		private static void ForcedShutdown()
		{
			_log.ErrorNoPII("Forced shutdown triggered");
			Process currentProcess = Process.GetCurrentProcess();
			try
			{
				// Get the threads associated with the current process
				ProcessThreadCollection threads = currentProcess.Threads;

				// Iterate through the threads and check their state
				foreach (ProcessThread thread in threads)
				{
					// Check if the thread is running
					// The ThreadState enum has a [FlagsAttribute], so we use a bitmask to check for running state
					if (!thread.ThreadState.HasFlag(System.Diagnostics.ThreadState.Terminated))
					{
						_log.WarnNoPII($"Thread ID: {thread.Id}, State: {thread.ThreadState}");
					}
				}
			}
#pragma warning disable CA1031 // catch more specific exception
			catch (Exception e)
#pragma warning restore CA1031
			{
				_log.ErrorNoPII("Failed to get running threads", e);
			}
			currentProcess.Kill();
		}

		/// <summary>
		/// For a given worker group, returns whether AdjustWorkers() should be called. Overriding methods in derived classes should generally
		/// call this base method in addition to whatever logic they're using (return base.ShouldAdjustWorkers(group) || ...)
		/// </summary>
		/// <param name="group">The AbstractServiceWorkerGroup to check</param>
		/// <returns>True if AdjustWorkers() should be called, false otherwise</returns>
		protected virtual bool ShouldAdjustWorkers(AbstractServiceWorkerGroup group)
		{
			return group.WorkerCount != group.GetDesiredWorkerCount();
		}

		private void BootstrapServices()
		{
			try
			{
				Bootstrapper.Bootstrap(GetServiceRegistries);
			}
			catch (Exception e)
			{
				_log.FatalNoPII("Failed to bootstrap", e);
				Exit(EXIT_FAIL_TO_BOOTSTRAP);
			}
		}

		/// <summary>
		/// Loops through all the workers in the service, ensuring they're still alive when they
		/// should be.
		/// </summary>
		private class ThreadManagerWorker : AbstractServiceWorker
		{
			[EventSource("Dead Workers", "CLM.Service")]
			[Counter("Dead Workers", "CLM.Service",
				InstanceProperty = "Description",
				DisplayUnit = CounterUnit.__none,
				Ranges = new double[] { 1, 5, 10, 15, 20, 30, 50 },
				MeasureProperty = "Count")]
			private static readonly CountEventSource _deadWorkersCountEventSource = new CountEventSource();

			[EventSource("MissedHeartBeat Workers", "CLM.Service")]
			[Counter("MissedHeartBeat Workers", "CLM.Service",
				InstanceProperty = "Description",
				DisplayUnit = CounterUnit.__none,
				Ranges = new double[] { 1, 5, 10, 15, 20, 30, 50 },
				MeasureProperty = "Count")]
			private static readonly CountEventSource _noHeartBeatWorkersCountEventSource = new CountEventSource();

			public ThreadManagerWorker(ScmServicedComponent component)
				: base(component)
			{
				_scmServicedComponent = component;
			}

			private readonly ScmServicedComponent _scmServicedComponent = null;

			public override bool HasHeartBeat()
			{
				// This worker is always beating.
				return true;
			}

			public override void Run()
			{
				_log.DebugNoPII($"Checking for unresponsive workers.");
				CheckWorkersHeartBeat();
				CheckForDeadWorkerThreads();
				AdjustWorkersIfNecessary();
			}

			private void CheckWorkersHeartBeat()
			{
				foreach (AbstractServiceWorker worker in _scmServicedComponent._workers)
				{
					if (worker.MonitorHeartBeat && !worker.HasHeartBeat())
					{
						_noHeartBeatWorkersCountEventSource.Emit(1, worker.Name);
						if(worker.TerminateOnHeartBeatMissing)
						{
							worker.AbortWorkerThread();
						}
					}
				}
				foreach (AbstractServiceWorkerGroup group in _scmServicedComponent._groups)
				{
					int noBeatsCount = group.CheckWorkersHeartBeat();
					if (noBeatsCount > 0)
					{
						_noHeartBeatWorkersCountEventSource.Emit(noBeatsCount, group.Name);
					}
				}
			}

			private void CheckForDeadWorkerThreads()
			{
				// Check for dead workers and restart them.
				foreach (AbstractServiceWorker worker in _scmServicedComponent._workers)
				{
					if (worker.IsDead)
					{
						_log.WarnNoPII($"Found a dead worker: {worker.Name}. Restarting it.");
						worker.Start();
						_deadWorkersCountEventSource.Emit(1, worker.Name);
					}
				}
				foreach (AbstractServiceWorkerGroup group in _scmServicedComponent._groups)
				{
					int deadWorkers = group.RemoveDeadWorkers();

					if (deadWorkers > 0)
					{
						_deadWorkersCountEventSource.Emit(deadWorkers, group.Name);
					}
				}
			}

			private void AdjustWorkersIfNecessary()
			{
				foreach (AbstractServiceWorkerGroup group in _scmServicedComponent._groups)
				{
					if (_scmServicedComponent.ShouldAdjustWorkers(group))
					{
						_log.WarnNoPII($"Group {group.Name} should have {group.GetDesiredWorkerCount()} workers, but has {group.WorkerCount}. Adjusting.");
						group.AdjustWorkers();
					}
				}
			}

			public override int SleepSeconds()
			{
				return Configuration.GetInt32AppSetting($"ClmService_{nameof(ThreadManagerWorker)}_SleepSeconds", 30);
			}
		}
	}
}
