{
  "diff": "The common helper `ActivityEnricher.SetTagsWithCommonFields` is already invoked at the *beginning* and again at the *end* of every request across\n\u2022 ASP.NET Framework modules (ProfileModule, BaseApiHandler, \u2026)  \n\u2022 ASP.NET Core middleware (ProfileMiddleware, ScmLogAsyncRequestHttpMiddleware, etc.).\n\nBy extending this single, central method we enrich the **same incoming HTTP-request span** with the two new attributes whenever\nthey are available, without touching multiple pipelines.\n\nPath changed:\n\u2022 `src/Core.Domain/Utilities/ActivityEnricher.cs`\n\nAssumptions:\n1. Not every request will have a Referer or a redirect Location header \u2013 we only tag when a value exists.\n2. Multiple calls are harmless; already-set tags are not overwritten.",
  "explanation": "--- a/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs\n+++ b/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs\n@@\n \\t\\tSetAccountIdTag(activity);\n \\t\\tSetUserIdTag(activity);\n \\t\\tSetSessionIdTag(activity, context);\n+\\t\\tSetRequestRefererTag(activity, context);\n+\\t\\tSetResponseRedirectLocationTag(activity, context);\n \\t}\n@@\n \\t}\n \n+#region HTTP header helpers\n+\\tprivate static void SetRequestRefererTag(Activity activity, HttpContext context)\n+\\t{\n+\\t\\t// Do not overwrite if already present (method could be called twice).\n+\\t\\tif (activity.GetTagItem(\\\"HTTP_REFERER\\\") != null)\n+\\t\\t{\n+\\t\\t\\treturn;\n+\\t\\t}\n+\n+#if NETFRAMEWORK\n+\\t\\tvar referer = context?.Request?.Headers?[\\\"Referer\\\"];\n+#else\n+\\t\\tvar referer = context?.Request?.Headers[\\\"Referer\\\"].FirstOrDefault();\n+#endif\n+\\t\\tif (!string.IsNullOrEmpty(referer))\n+\\t\\t{\n+\\t\\t\\tactivity.SetTag(\\\"HTTP_REFERER\\\", referer);\n+\\t\\t}\n+\\t}\n+\n+\\tprivate static void SetResponseRedirectLocationTag(Activity activity, HttpContext context)\n+\\t{\n+\\t\\t// Do not overwrite if already present (method could be called twice).\n+\\t\\tif (activity.GetTagItem(\\\"HTTP_RESPONSE_REDIRECT_LOCATION\\\") != null)\n+\\t\\t{\n+\\t\\t\\treturn;\n+\\t\\t}\n+\n+#if NETFRAMEWORK\n+\\t\\tvar redirectLocation = context?.Response?.Headers?[\\\"Location\\\"];\n+#else\n+\\t\\tvar redirectLocation = context?.Response?.Headers[\\\"Location\\\"].FirstOrDefault();\n+#endif\n+\\t\\tif (!string.IsNullOrEmpty(redirectLocation))\n+\\t\\t{\n+\\t\\t\\tactivity.SetTag(\\\"HTTP_RESPONSE_REDIRECT_LOCATION\\\", redirectLocation);\n+\\t\\t}\n+\\t}\n+#endregion\n+\n #if NETFRAMEWORK\n \\tprivate static void SetSessionIdTag(Activity activity, HttpContext context)\n@@\n #endif\n \n }",
  "selection_reasoning": "Batch 1 (LogAsyncRequestHttpMiddleware.cs): \u2022 LogAsyncRequestHttpMiddleware sits in the ASP.NET Core request pipeline and already performs span / Activity work (it inherits from AbstractLogRequestHttpMiddleware and references DocuSign.Monitoring).  \n\u2022 Because it receives the HttpContext, it has direct access to both the incoming request headers (for \u201cReferer\u201d) and the outgoing response headers (for \u201cLocation\u201d).  \n\u2022 The middleware executes while the \u201cIncoming HTTP Request\u201d Activity created by the auto-instrumentation is still the current Activity, so we can safely call Activity.Current?.SetTag(\"HTTP_REFERER\", \u2026) and Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", \u2026).  \n\u2022 No other files are required\u2014one strategic middleware can capture both headers for every request, minimising code changes and adhering to the \u201csingle strategic file\u201d rule.\nBatch 2 (BaseApiHandler.cs): \u2022 BaseApiHandler.cs is an IHttpHandler used as the entry point for legacy \u2011> .NET 6 migration calls. It owns the ProcessRequest(HttpContext) method, giving it direct access to:\n  \u2013 HttpContext.Request.Headers (to read \u201cReferer\u201d)  \n  \u2013 HttpContext.Response.Headers (to read or set \u201cLocation\u201d when a redirect is issued).\n\n\u2022 The file already references DocuSign.Monitoring and System.Diagnostics, indicating it creates or enriches Activity/Span objects. Therefore the existing telemetry infrastructure is present and can be extended with Activity.Current?.SetTag(\u2026) (or equivalent) calls.\n\n\u2022 Because every incoming ASHX request flows through this single base handler, adding the two attributes here satisfies \u201cadd HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION headers as attributes on existing incoming HTTP request spans\u201d for the whole CLM web app without touching other files.\n\n\u2022 No other files are required; this one strategic entry-point file is sufficient and minimizes changes.\nBatch 3 (ProfileModule.cs): \u2022 ProfileModule.cs is an IHttpModule that executes for every incoming HTTP request, giving it direct access to HttpContext, Request headers (e.g., \u201cReferer\u201d) and Response headers (e.g., \u201cLocation\u201d).  \n\u2022 The file already references DocuSign.CLM.Monitoring / DocuSign.Monitoring, indicating that spans or activities are created or at least accessible during request processing.  \n\u2022 Within BeginRequest, EndRequest, or similar handlers, the code can retrieve Activity.Current (or the span object used by the monitoring SDK) and call SetTag / SetAttribute to add:  \n\u2003\u2013 HTTP_REFERER  \u2192 context.Request.Headers[\"Referer\"]  \n\u2003\u2013 HTTP_RESPONSE_REDIRECT_LOCATION \u2192 context.Response.Headers[\"Location\"]  \n\u2022 Because ProfileModule runs for every request and already participates in telemetry, it is a single strategic location that can satisfy the telemetry requirement without touching additional files.\n\nThus, modifying only ProfileModule.cs is sufficient to add the required attributes to the existing incoming HTTP request spans.\nBatch 4 (WinsService.cs): Cannot solve gap - The telemetry requirement targets normal incoming HTTP request spans and needs access to standard HTTP request/response headers (\u201cReferer\u201d and \u201cLocation\u201d).  \n\nWinsService.cs is a gRPC service implementation.  \n\u2022 Its execution context is a gRPC ServerCallContext, not a classic ASP.NET Core HTTP context.  \n\u2022 Redirect-related \u201cLocation\u201d headers do not apply to gRPC calls, and the typical HTTP \u201cReferer\u201d header is usually absent as well.  \n\u2022 Although the file references OpenTelemetry, the spans it deals with are gRPC-specific, not the HTTP spans produced by ASP.NET Core middleware.  \n\nTherefore, this file group cannot meaningfully add the required attributes to the existing incoming HTTP request spans for the CLM web application.\nBatch 5 (WinsService.Trace.cs): Cannot solve gap - The only file in this group (WinsService.Trace.cs) shows a helper that starts Activities for internal service methods (StartActivity). It does not run in the HTTP pipeline, has no access to HttpRequest or HttpResponse objects, and is unrelated to the incoming-request spans produced by ASP.NET. Therefore it cannot capture or add the HTTP_REFERER or HTTP_RESPONSE_REDIRECT_LOCATION attributes required. No files in this group are suitable for the requested instrumentation, so the gap cannot be solved here.\nBatch 6 (LogAsyncRequestHttpMiddleware.cs): \u2022 LogAsyncRequestHttpMiddleware sits in the ASP.NET Core request pipeline and already performs span / activity work for every incoming HTTP call (it inherits from AbstractLogRequestHttpMiddleware and references DocuSign-specific OpenTelemetry helpers).  \n\u2022 Because it receives the HttpContext, it can easily read Request.Headers[\"Referer\"] and Response.Headers[\"Location\"] at the same point where it currently enriches or finalizes the request span.  \n\u2022 Adding two Activity-tag (or SetTag / SetAttribute) calls inside this middleware will attach the required attributes to the existing \u201cIncoming HTTP Request Span,\u201d satisfying the telemetry requirement without touching any other file.  \n\u2022 No other files are necessary; this single strategic middleware covers every incoming request and is the canonical place the app already uses for HTTP telemetry enrichment.\nBatch 7 (LogAsyncRequestHttpMiddleware.cs): \u2022 LogAsyncRequestHttpMiddleware is an ASP.NET Core middleware that already intercepts every incoming HTTP request and has full access to HttpContext.Request and HttpContext.Response.  \n\u2022 The middleware already performs telemetry work (uses PropertyBagEventSource, inherits from AbstractLogRequestHttpMiddleware) so adding extra span attributes fits naturally here.  \n\u2022 Because this code executes both before and after the downstream pipeline (it wraps the await _next(context) call), it can read the Referer header before the call and the final Location header after the call \u2014 exactly the two values required.  \n\u2022 Activity/Span context is available via Activity.Current inside middleware; thus we can directly call Activity.Current?.SetTag(\"HTTP_REFERER\", \u2026) and Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", \u2026).  \n\u2022 No other files are needed: one strategic middleware file can satisfy the entire requirement while keeping changes minimal.\nBatch 8 (ProfileMiddleware.cs): \u2022 ProfileMiddleware.cs is an ASP.NET Core middleware that receives every incoming HTTP request (via HttpContext) and already references DocuSign.Monitoring as well as System.Diagnostics.  \n\u2022 Inside its Invoke / InvokeAsync method it can access both:\n  \u2013 Request.Headers[\"Referer\"] before calling _next()  \n  \u2013 Response.Headers[\"Location\"] after _next() completes.  \n\u2022 The current incoming request span is available as Activity.Current (created by existing ASP.NET Core / OpenTelemetry instrumentation). Adding tags to Activity.Current satisfies \u201cADD_ATTRIBUTES\u201d on the existing span.  \n\u2022 Because this single middleware sits early in the pipeline and already participates in telemetry, no additional files are required. Only ProfileMiddleware.cs needs a few extra lines:\n\n```csharp\nvar activity = Activity.Current;\nif (activity != null)\n{\n    if (context.Request.Headers.TryGetValue(\"Referer\", out var referer))\n        activity.SetTag(\"HTTP_REFERER\", referer.ToString());\n\n    await _next(context);   // continue pipeline\n\n    if (context.Response.Headers.TryGetValue(\"Location\", out var location))\n        activity.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", location.ToString());\n}\nelse\n{\n    await _next(context);\n}\n```\n\nThus the single strategic file ProfileMiddleware.cs can fully implement the telemetry requirement.\nBatch 9 (ScmLogAsyncRequestHttpMiddleware.cs): \u2022 The requirement targets incoming HTTP request spans. ScmLogAsyncRequestHttpMiddleware is the central ASP.NET Core middleware responsible for logging/telemetry of every incoming request (inherits from AbstractLogRequestHttpMiddleware and already uses IServiceInstrumentation).  \n\u2022 Being a middleware, it receives both the HttpContext.Request and HttpContext.Response objects and executes code both before and after the downstream pipeline. This provides direct access to:  \n  \u2013 Request.Headers[\"Referer\"] (needed for HTTP_REFERER)  \n  \u2013 Response.Headers[\"Location\"] (available after the next() call, needed for HTTP_RESPONSE_REDIRECT_LOCATION)  \n\u2022 The middleware already creates/updates telemetry (KazMon / Activity / Span) via IServiceInstrumentation, so adding two additional Activity/Span attributes is a small, localized change.  \n\u2022 No other files are necessary; modifying this single, strategic middleware meets the requirement while respecting the \u201cminimize file count\u201d rule.\nBatch 10 (MvcAuditedRequestAttribute.cs): \u2022 MvcAuditedRequestAttribute is an MVC ActionFilter that runs for every incoming HTTP request (OnActionExecuting / OnActionExecuted).  \n\u2022 The file already references telemetry infrastructure (DocuSign.CLM.Monitoring, DocuSign.Monitoring) and therefore has access to Activity/Span objects currently representing the \u201cIncoming HTTP Request Span\u201d.  \n\u2022 Within this filter we can reliably read:  \n  - Request.Headers[\"Referer\"] (before the action executes)  \n  - Response.Headers[\"Location\"] (after the action executes)  \n\u2022 Because Activity.Current is available inside the filter, we can call `SetTag` (or equivalent attribute-adding API) on the existing span without creating new spans.  \n\u2022 No other files are required\u2014this single, central filter runs on every request and is the minimal, strategic place to attach the two requested attributes.\nBatch 11 (HttpRequestAuditHelper.cs): \u2022 The requirement targets \u201cexisting incoming HTTP request spans.\u201d  \n\u2022 HttpRequestAuditHelper.cs already handles request-level telemetry: it imports DocuSign.CLM.Monitoring / DocuSign.Monitoring and is clearly designed to start / enrich spans or counters for every MVC request.  \n\u2022 Because this helper sits in the request pipeline and receives HttpContext (Request / Response), it can easily read:\n  \u2013 Request.Headers[\"Referer\"]  \n  \u2013 Response.Headers[\"Location\"]  \n  and then call Activity.SetTag / span.SetAttribute on the current span.  \n\u2022 Therefore, modifying this single strategic helper file is sufficient\u2014no other files need changes.\nBatch 12 (SSOEndpoint.ashx.cs): \u2022 SSOEndpoint.ashx.cs is an ASP-NET HttpHandler that directly receives an incoming HTTP request (it implements ProcessRequest on HttpContext) and constructs the HTTP response\u2014including redirects that set Response.Headers[\"Location\"].  \n\u2022 The handler already references System.Diagnostics, so Activity.Current is readily available for extending existing incoming HTTP spans generated by ASP-NET/OpenTelemetry auto-instrumentation.  \n\u2022 From this central request-handling point we can:\n  \u2013 Read the inbound Referer header via context.Request.Headers[\"Referer\"].  \n  \u2013 Inspect the outbound redirect header (context.Response.Headers[\"Location\"]) right before the response is flushed.  \n  \u2013 Add both values to the active span with Activity.Current?.SetTag(\"HTTP_REFERER\", \u2026) and Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", \u2026).  \n\u2022 Because this file fully owns the request/response lifecycle for its endpoint, no additional files or middleware need modification to satisfy the requirement for this execution path, keeping changes minimal as per prioritization rules.\nBatch 13 (UploadFiles.ashx.cs): Cannot solve gap - The requirement is to add the HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION headers as attributes on every incoming HTTP-request span in the entire CLM web application. That instrumentation should be performed at a centralized entry-point (e.g., Global.asax, an HTTP module, middleware, or another common request pipeline component) so that it uniformly affects every request.\n\nThe only file in this group, UploadFiles.ashx.cs, is a specific IHttpHandler for file uploads.  \n\u2022 It handles just one endpoint, so modifying it would not cover all incoming requests.  \n\u2022 There is no existing Activity/telemetry code here that could be simply extended.  \n\u2022 Adding instrumentation here would only address this single handler, leaving the broader requirement unmet.\n\nBecause this file cannot provide the needed application-wide instrumentation and there is no other strategic file in the group, the group cannot solve the telemetry gap.\nBatch 14 (AttributesController.cs): \u2022 The requirement is to add two tags (HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION) to the existing incoming HTTP-request span.  \n\u2022 In ASP.NET MVC, the active span for an HTTP request is available through System.Diagnostics.Activity.Current while the request is being processed inside a controller action.  \n\u2022 AttributesController.cs is an MVC controller; its action methods execute in the context of the active request Activity, so it can call Activity.Current?.SetTag(..) with the needed header values.  \n\u2022 There is no more strategic, central file (e.g., Global.asax, middleware, or a custom action filter) present in this group. Therefore the simplest, lowest-impact place to instrument is directly inside this controller (or by adding a small private helper inside the same file that runs in OnActionExecuting / OnResultExecuted overrides).  \n\u2022 No other files are needed to meet the requirement, so choosing only AttributesController.cs adheres to the \u201cminimize file count\u201d rule.\nBatch 15 (ActivityEnricher.cs): \u2022 The requirement is to add HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION attributes to the existing \u201cIncoming HTTP Request\u201d spans.  \n\u2022 ActivityEnricher.cs is already an enrichment utility that receives both the Activity (span) and the HttpContext and sets multiple custom tags using activity.SetTag(...).  \n\u2022 Because it has direct access to context.Request.Headers and context.Response.Headers, this single file can be extended to read:  \n  \u2013 context.Request.Headers[\"Referer\"] \u2192 \u201cHTTP_REFERER\u201d tag  \n  \u2013 context.Response.Headers[\"Location\"] \u2192 \u201cHTTP_RESPONSE_REDIRECT_LOCATION\u201d tag  \n\u2022 No other files are needed; the enrichment logic is centralized here, so modifying ActivityEnricher.cs satisfies the telemetry gap with minimal surface area.\nBatch 16 (ScmHttpApplication.cs): \u2022 The requirement targets incoming HTTP request spans. ScmHttpApplication.cs is the application-wide HTTP entry point (acts like Global.asax) and already wires up OpenTelemetry (see OpenTelemetry.Trace, AddAspNetInstrumentation references).  \n\u2022 Because the OpenTelemetry pipeline is configured here, we can extend it in one place:\n  \u2013 Either via AddAspNetInstrumentation(options => options.Enrich = \u2026) or  \n  \u2013 In Application_BeginRequest / Application_EndRequest by updating Activity.Current.  \n  Both approaches let us add the two headers as attributes on the existing span.\n\u2022 No other files are needed; a small enrichment block in this single strategic file meets the requirement while keeping modification scope minimal.\nBatch 17 (Global.asax.cs): \u2022 Global.asax.cs is the ASP .NET application entry point and already references OpenTelemetry.Trace.  \n\u2022 In Application_BeginRequest/EndRequest (or similar) it has access to HttpContext and Activity.Current, which corresponds to the \u201cIncoming HTTP Request Span\u201d created by ASP.NET instrumentation.  \n\u2022 From that location we can read Request.Headers[\"Referer\"] and Response.Headers[\"Location\"] and attach them to the current Activity with SetTag / SetCustomProperty.  \n\u2022 No other files are needed\u2014adding two lines in Global.asax.cs during the request lifecycle instruments every incoming span, fulfilling the requirement while keeping the change minimal.\nBatch 18 (Program.cs): \u2022 The requirement is to add two HTTP header values (Referer and Location) as attributes on the existing \u201cIncoming HTTP Request\u201d spans.  \n\u2022 Such attributes are normally added through the ASP.NET Core (or general HTTP) instrumentation enrichment delegate that is registered at application start-up.  \n\u2022 Program.cs is the single, strategic bootstrapping file that builds the WebApplication/Host, registers OpenTelemetry tracing, and configures all middleware and services. This is exactly where AddOpenTelemetryTracing / AddAspNetCoreInstrumentation is typically set up.  \n\u2022 By adding or modifying the Enrich callback in Program.cs we can read:\n  \u2013 context.Request.Headers[\"Referer\"] \u2192 set tag \u201cHTTP_REFERER\u201d  \n  \u2013 context.Response.Headers[\"Location\"] \u2192 set tag \u201cHTTP_RESPONSE_REDIRECT_LOCATION\u201d  \n  and attach them to the Activity that represents the incoming HTTP request span.  \n\u2022 No controller, middleware, or other file needs to be touched\u2014one central change in Program.cs is sufficient, satisfying the \u201cprefer single strategic files\u201d rule.\nBatch 19 (Startup.cs): Startup.cs wires up the ASP.NET Core request pipeline and already configures OpenTelemetry components through various \u201c.OpenTelemetry\u201d extension methods. That makes it the single strategic place where we can:\n\n1. Insert a small custom middleware (or register an OpenTelemetry \u201cEnrich\u201d delegate) that runs for every incoming HTTP request.\n2. Read Request.Headers[\"Referer\"] and, after the response is generated, Response.Headers[\"Location\"].\n3. Add those values as tags on the current Activity (the existing \u201cIncoming HTTP Request\u201d span created by ASP.NET Core instrumentation).\n\nBecause Startup.cs controls both service registration and middleware ordering, no other files are required to implement this telemetry enrichment.\nBatch 20 (CoreInstrumentationLifetimeService.cs): \u2022 CoreInstrumentationLifetimeService.cs is the central location where the application wires-up OpenTelemetry (adds TracerProviderBuilder, MeterProviderBuilder, etc.).  \n\u2022 Incoming HTTP request spans are automatically created by the ASP.NET Core instrumentation that is registered from this file; therefore, the file already has direct access to configure enrichment callbacks (e.g., `builder.AddAspNetCoreInstrumentation(options => { \u2026 })`).  \n\u2022 The requirement\u2014adding HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION as attributes on those spans\u2014can be met by adding an `Enrich` or `OnEndActivity`/`OnStartActivity` delegate inside this same builder configuration.  \n\u2022 No other files in the group deal with HTTP processing or OpenTelemetry configuration, so modifying just this strategic file keeps the change minimal and maintainable.\nBatch 21 (WorkflowActivitiesController.cs): Cannot solve gap - \u2022 The requirement is to add the headers as attributes on the existing \u201cincoming HTTP request\u201d span created for every request to the CLM web app.  \n\u2022 That span is started by ASP.NET Core middleware before any controller code runs and is finished after the response is sent.  \n\u2022 Capturing both the request header (\u201cReferer\u201d) and the response header (\u201cLocation\u201d) reliably therefore needs code that executes in the middleware pipeline (or a global action filter) \u2013 not only inside an individual controller action.  \n\u2022 The only file in this group, WorkflowActivitiesController.cs, is a single controller specific to workflow-activities. It cannot see or modify every request/response, and adding SetTag logic here would instrument only this controller\u2019s endpoints, leaving the rest of the app uncovered.  \n\u2022 There is no existing custom middleware or base controller in this file where a reusable instrumentation hook could be placed.  \n\u2022 Consequently, this file group, by itself, cannot implement the telemetry requirement in a correct, application-wide manner, so no file in the group is selected for modification.",
  "patch_reasoning": "ReasoningChain(strategy=<ReasoningStrategy.CHAIN_OF_THOUGHT: 'chain_of_thought'>, steps=[ReasoningStep(step_number=1, description='3. Implementation is cross-framework (#if NETFRAMEWORK vs ASP.NET Core) and requires no changes elsewhere because all existing middleware / filters already call SetTagsWithCommonFields(\u2026).', reasoning='3. Implementation is cross-framework (#if NETFRAMEWORK vs ASP.NET Core) and requires no changes elsewhere because all existing middleware / filters already call SetTagsWithCommonFields(\u2026).\\n\\nCode patch:', conclusion='Code patch:', confidence=0.8, evidence=['LLM analysis'])], final_conclusion='This single edit satisfies the requirement across the entire CLM web application because all existing middleware / filters invoke `SetTagsWithCommonFields`, ensuring every incoming HTTP request span now carries the new attributes.', overall_confidence=0.8, alternative_approaches=[])",
  "selected_files": [
    "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/Middlewares/LogAsyncRequestHttpMiddleware.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ProfileMiddleware.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Filters/MvcAuditedRequestAttribute.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/HttpRequestAuditHelper.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web/SSO/SSOEndpoint.ashx.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
    "/Users/shuaib.tabit/Documents/Atlas/internal/AtlasCustomerSupport/Global.asax.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
    "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/CoreInstrumentationLifetimeService.cs"
  ],
  "strategy_used": "direct"
}