{
  "execution_summary": {
    "total_stages": 10,
    "completed": 10,
    "failed": 0,
    "cache_hits": 0,
    "total_execution_time": 489.55440521240234
  },
  "stage_details": {
    "ticket_processing": {
      "stage_name": "ticket_processing",
      "status": "StageStatus.COMPLETED",
      "result": "## OpenTelemetry Span Attributes Missing - HTTP Redirect Tracking\n\n**Summary:** Add missing HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION attributes to CLM web application spans\n\n**Problem Description:**\nOur OpenTelemetry spans in the CLM (Contract Lifecycle Management) web application are missing critical HTTP attributes needed for debugging redirect flows and investigating user journey issues. Specifically:\n\n1. **Missing Attribute**: `HTTP_REFERER` - The referring page URL that led to the current request\n2. **Missing Attribute**: `HTTP_RESPONSE_REDIRECT_LOCATION` - The destination URL when a 302/redirect response occurs\n\n**Business Impact:**\n- Cannot trace user navigation flows through CLM application\n- Difficult to investigate redirect-related issues and errors\n- Missing context for 302 responses that redirect to error pages\n\n**Technical Details:**\n\n**Target Application:** CLM Web Application (clm-web)\n**Environment:** Demo (but affects all environments)\n**Specific Pages Affected:**\n- `/clm/Documents/BrowseDocuments.aspx`\n- `/clm/SSO/SSOEndpoint.ashx` \n- Any page that handles redirects (HTTP 302 responses)\n\n**Expected Kusto Query Results:**\nAfter fix, this query should show the missing attributes:\n```kusto\nOtlpSpanEvents\n| where Environment == \"Demo\"\n| where url_path == \"/clm/Documents/BrowseDocuments.aspx\"\n| where http_status_code > 200\n| project Timestamp, url_path, http_status_code, HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION\n```\n\n**Implementation Requirements:**\n\n1. **Add HTTP_REFERER attribute** to all incoming HTTP requests\n   - Source: `Request.Headers[\"Referer\"]` or `HttpContext.Request.Headers.Referer`\n   - Add to span as: `activity.SetTag(\"HTTP_REFERER\", refererValue)`\n\n2. **Add HTTP_RESPONSE_REDIRECT_LOCATION attribute** for redirect responses\n   - Source: `Response.Headers[\"Location\"]` when status code is 301/302/303/307/308\n   - Add to span as: `activity.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", locationValue)`\n\n**Files to Look For:**\n- CLM web application middleware or request handling code\n- ASP.NET request pipeline components\n- OpenTelemetry instrumentation configuration\n- Files containing \"ActivitySource\", \"SetTag\", or \"AddTag\" method calls\n- Middleware files that handle HTTP requests/responses\n- Look for existing telemetry code in CLM-related projects\n\n**Acceptance Criteria:**\n- [ ] HTTP_REFERER attribute captured from incoming request headers\n- [ ] HTTP_RESPONSE_REDIRECT_LOCATION attribute captured for 302+ responses  \n- [ ] Attributes visible in OtlpSpanEvents Kusto table\n- [ ] No performance degradation from additional attribute collection\n- [ ] Proper null/empty value handling for missing headers\n\n**Technical Notes:**\n- Follow existing OpenTelemetry patterns in the codebase\n- Ensure attribute names match exactly: \"HTTP_REFERER\" and \"HTTP_RESPONSE_REDIRECT_LOCATION\"\n- Add attributes to HTTP request spans, not separate spans\n- Handle edge cases where headers might be missing or empty\n",
      "error": null,
      "execution_time": 0.00047016143798828125,
      "cache_hit": false
    },
    "intent_extraction": {
      "stage_name": "intent_extraction",
      "status": "StageStatus.COMPLETED",
      "result": {
        "issue_category": "INSTRUMENTATION",
        "static_analysis_query": {
          "find_method_call": "SetTag"
        },
        "semantic_description": "Add HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION tags to existing HTTP request spans in the CLM web application.",
        "search_keywords": [
          "HTTP_REFERER",
          "HTTP_RESPONSE_REDIRECT_LOCATION",
          "Activity.SetTag",
          "AddTag",
          "ActivitySource"
        ],
        "telemetry_operation": {
          "type": "span",
          "target_name": "incoming HTTP request span",
          "action": "ADD_ATTRIBUTES",
          "attributes_to_add": [
            {
              "name": "HTTP_REFERER",
              "value_source": "Request.Headers[\"Referer\"]"
            },
            {
              "name": "HTTP_RESPONSE_REDIRECT_LOCATION",
              "value_source": "Response.Headers[\"Location\"] when status code is 3xx"
            }
          ],
          "new_span_name": null,
          "new_metric_details": {}
        },
        "confidence": "IntentConfidence.HIGH",
        "operation_type": "OperationType.MULTI_FILE",
        "complexity_score": 4,
        "estimated_files": 3,
        "validation_result": {
          "is_valid": true,
          "confidence": "IntentConfidence.HIGH",
          "issues": [],
          "suggestions": []
        },
        "sub_tasks": [
          {
            "order": 1,
            "name": "Locate OpenTelemetry Configuration & HTTP Pipeline",
            "action": "locate_configuration",
            "description": "Search the CLM-web solution for OpenTelemetry setup and existing HTTP enrichment logic.",
            "tasks": [
              "grep / ripgrep / VS \u2018Find in Files\u2019 for keywords: \"AddOpenTelemetry\", \"ActivitySource\", \"SetTag\", \"AddTag\", \".UseOpenTelemetry\"",
              "Identify the project that owns the public web entry point (likely Clm.Web, Clm.WebHost or similar)",
              "Open Startup.cs / Program.cs and any *TelemetryExtensions.cs to understand how instrumentation is added",
              "Confirm whether manual ActivitySource instrumentation or ASP.NET Core auto-instrumentation is being used"
            ],
            "expected_files": [
              "Startup.cs / Program.cs",
              "OpenTelemetryExtensions.cs",
              "TelemetryMiddleware.cs (if it exists)"
            ],
            "validation_criteria": "All configuration files and any custom middleware that already calls Activity.SetTag have been documented"
          },
          {
            "order": 2,
            "name": "Design Enrichment Hook",
            "action": "design",
            "description": "Decide the best location to enrich spans once headers are final.",
            "tasks": [
              "If custom OTEL middleware already exists, plan to extend it",
              "Otherwise design a new ASP.NET Core middleware placed AFTER routing but BEFORE exception/response compression middleware so that both request headers and final response headers are available"
            ],
            "dependencies": [
              1
            ],
            "validation_criteria": "Middleware insertion point documented and agreed on with team"
          },
          {
            "order": 3,
            "name": "Implement Middleware / Enrichment Logic",
            "action": "implement_changes",
            "description": "Add HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION tags",
            "code_snippet": "public class HttpRedirectEnrichmentMiddleware\n{\n    private readonly RequestDelegate _next;\n    private static readonly ActivitySource Source = new(\"clm-web\");\n\n    public HttpRedirectEnrichmentMiddleware(RequestDelegate next) => _next = next;\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        Activity? activity = Activity.Current;\n        string? referer = context.Request.Headers[\"Referer\"].FirstOrDefault();\n        if (!string.IsNullOrEmpty(referer))\n        {\n            activity?.SetTag(\"HTTP_REFERER\", referer);\n        }\n\n        await _next(context);\n\n        if (context.Response.StatusCode >= 300 && context.Response.StatusCode < 400)\n        {\n            string? location = context.Response.Headers[\"Location\"].FirstOrDefault();\n            if (!string.IsNullOrEmpty(location))\n            {\n                activity?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", location);\n            }\n        }\n    }\n}",
            "expected_files_modified_or_added": [
              "Middleware/HttpRedirectEnrichmentMiddleware.cs",
              "Startup.cs or Program.cs (Add middleware registration)"
            ],
            "dependencies": [
              2
            ],
            "validation_criteria": "Build succeeds and new tags compile without warnings"
          },
          {
            "order": 4,
            "name": "Unit Tests & Static Analysis",
            "action": "add_tests",
            "description": "Create or update unit tests validating tag presence.",
            "tasks": [
              "Add integration test using TestServer to simulate a 200 with referer and a 302 with Location",
              "Run static-analysis search (CI step) to verify exactly two new tag names appear"
            ],
            "dependencies": [
              3
            ],
            "validation_criteria": "Tests pass locally and on CI"
          },
          {
            "order": 5,
            "name": "Local Manual Verification with OTLP Collector",
            "action": "manual_test",
            "description": "Run CLM-web locally with OTLP exporter pointing to a Docker collector + Jaeger to inspect spans.",
            "tasks": [
              "Trigger /clm/Documents/BrowseDocuments.aspx with custom Referer header",
              "Trigger an endpoint that returns 302",
              "Verify new attributes show up in Jaeger UI or console exporter"
            ],
            "dependencies": [
              3
            ],
            "validation_criteria": "Attributes visible in span payload"
          },
          {
            "order": 6,
            "name": "Performance & Security Review",
            "action": "review",
            "description": "Ensure no PII or sensitive querystring leaks; run BenchmarkDotNet or kestrel perf tests.",
            "dependencies": [
              5
            ],
            "validation_criteria": "\u22641 % overhead and security sign-off recorded"
          },
          {
            "order": 7,
            "name": "Pull Request & Code Review",
            "action": "create_pr",
            "description": "Open PR, tag Observability and CLM owners; link to ticket; attach test screenshots.",
            "dependencies": [
              6
            ],
            "validation_criteria": "All reviewers approve; CI green"
          },
          {
            "order": 8,
            "name": "Deploy to Dev / Demo Environment",
            "action": "deploy",
            "description": "Use existing release pipeline with feature flag \u2018otel_redirect_enrichment\u2019 set to ON for Demo only.",
            "dependencies": [
              7
            ],
            "validation_criteria": "Deployment successful; site health green"
          },
          {
            "order": 9,
            "name": "Post-Deployment Validation in Demo",
            "action": "validate_in_demos",
            "description": "Run the provided Kusto query in Demo cluster.",
            "tasks": [
              "Confirm HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION columns populated",
              "Sample at least 100 spans; expect \u226595 % have referer when header present"
            ],
            "dependencies": [
              8
            ],
            "validation_criteria": "Query returns expected data; screenshot stored in ticket"
          },
          {
            "order": 10,
            "name": "Rollout to All Environments",
            "action": "deploy_to_prod",
            "description": "Gradual exposure: 10 % \u2192 50 % \u2192 100 % over 2 days with telemetry checks at each step.",
            "dependencies": [
              9
            ],
            "validation_criteria": "No error-rate or latency regression; attributes visible in Prod"
          },
          {
            "order": 11,
            "name": "Documentation & Knowledge Share",
            "action": "document",
            "description": "Update internal observability run-book, add new attributes to CLM telemetry field dictionary.",
            "dependencies": [
              10
            ],
            "validation_criteria": "Confluence page updated, link in ticket"
          },
          {
            "order": 12,
            "name": "Close Ticket",
            "action": "close_ticket",
            "description": "Mark ticket Done once acceptance criteria satisfied and validated.",
            "dependencies": [
              11
            ],
            "validation_criteria": "Ticket closed with evidence attached"
          }
        ],
        "contextual_hints": [
          "Hooking into the response after the status code and Location header are finalized so the redirect tag is always populated",
          "Guaranteeing the new enrichment runs for every request path (including static files, error pipeline, etc.) without imposing noticeable latency"
        ],
        "similar_patterns": [
          "custom HTTP server span enrichment",
          "response status-based attribute addition"
        ],
        "implementation_strategy": {
          "extend_existing": true,
          "create_new": false,
          "preferred_approach": "middleware"
        },
        "exact_requirements": {
          "attribute_names": [
            "HTTP_REFERER",
            "HTTP_RESPONSE_REDIRECT_LOCATION",
            "HTTP_REFERER",
            "HTTP_RESPONSE_REDIRECT_LOCATION"
          ],
          "patterns": [
            "kusto\nOtlpSpanEvents\n| where Environment == \"Demo\"\n| where url_path == \"/clm/Documents/BrowseDocuments.aspx\"\n| where http_status_code > 200\n| project Timestamp, url_path, http_status_code, HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION\n",
            "\n\n**Implementation Requirements:**\n\n1. **Add HTTP_REFERER attribute** to all incoming HTTP requests\n   - Source: ",
            "\n   - Add to span as: ",
            "\n\n2. **Add HTTP_RESPONSE_REDIRECT_LOCATION attribute** for redirect responses\n   - Source: ",
            " when status code is 301/302/303/307/308\n   - Add to span as: "
          ],
          "implementation_notes": [
            "SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", locationValue)`\n\n**Files to Look For:**\n- CLM web application middleware or request handling code\n- ASP",
            "NET request pipeline components\n- OpenTelemetry instrumentation configuration\n- Files containing \"ActivitySource\", \"SetTag\", or \"AddTag\" method calls\n- Middleware files that handle HTTP requests/responses\n- Look for existing telemetry code in CLM-related projects\n\n**Acceptance Criteria:**\n- [ ] HTTP_REFERER attribute captured from incoming request headers\n- [ ] HTTP_RESPONSE_REDIRECT_LOCATION attribute captured for 302+ responses  \n- [ ] Attributes visible in OtlpSpanEvents Kusto table\n- [ ] No performance degradation from additional attribute collection\n- [ ] Proper null/empty value handling for missing headers\n\n**Technical Notes:**\n- Follow existing OpenTelemetry patterns in the codebase\n- Ensure attribute names match exactly: \"HTTP_REFERER\" and \"HTTP_RESPONSE_REDIRECT_LOCATION\"\n- Add attributes to HTTP request spans, not separate spans\n- Handle edge cases where headers might be missing or empty"
          ]
        },
        "telemetry_analysis": null
      },
      "error": null,
      "execution_time": 32.777369022369385,
      "cache_hit": false
    },
    "project_parsing": {
      "stage_name": "project_parsing",
      "status": "StageStatus.COMPLETED",
      "result": [
        "/Users/shuaib.tabit/Documents/Atlas/src/ActIntegration\\ActIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdminService\\AdminService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdvancedInsightsService\\AdvancedInsightsService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdvancedInsightsService.IntegrationTests\\AdvancedInsightsService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AgreementDefinitionModel\\AdmIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.ABAC.PDP\\API.ABAC.PDP.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation.IntegrationTests/API.Allocation.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/API.Allocation.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Authentication\\API.Authentication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Common\\API.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Content\\API.Content.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Content.EndToEndTests\\API.Content.EndToEndTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal.Common\\API.DocuSignInternal.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal.IntegrationTests\\API.DocuSignInternal.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal\\API.DocuSignInternal.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper.IntegrationTests/API.GateKeeper.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper\\API.GateKeeper.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch.EndToEndTests\\API.OpenSearch.EndToEndTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch\\API.OpenSearch.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Provisioning.IntegrationTests/API.Provisioning.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Provisioning\\API.Provisioning.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI\\API.SfGenAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WebAPI\\API.WebAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities\\API.WorkflowActivities.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities.IntegrationTests\\API.WorkflowActivities.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities.Client/API.WorkflowActivities.Client.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowDesign\\API.WorkflowDesign.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowDesign.IntegrationTests\\API.WorkflowDesign.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities\\Atlas.Workflow.Activities.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Client\\Atlas.Workflow.Client.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Readers\\Atlas.Workflow.Readers.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService\\AtlasDataManipulationService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService.IntegrationTests\\AtlasDataManipulationService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthenticationApplication\\AuthenticationApplication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthenticationApplication.IntegrationTests\\AuthenticationApplication.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthMaintenanceService\\AuthMaintenanceService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthMaintenanceService.IntegrationTests\\AuthMaintenanceService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Automation.Toolkit.Tests\\Automation.Toolkit.Tests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ChatNotification\\ChatNotification.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CodeRunner\\CodeRunner.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Collaboration.Core\\Collaboration.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Collaboration.Infrastructure\\Collaboration.Infrastructure.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ConnectServiceIntegration\\ConnectServiceIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain.Testing\\Core.Domain.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain\\Core.Domain.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework\\Core.ServiceFramework.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework.Testing\\Core.ServiceFramework.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types\\Core.Types.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRules\\CustomRules.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRuleService\\CustomRuleService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRuleService.IntegrationTests\\CustomRuleService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService\\DetectTypeService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService.IntegrationTests\\DetectTypeService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocToPDFService\\DocToPDFService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocToPDFService.IntegrationTests\\DocToPDFService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentAssembly\\DocumentAssembly.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCompareService\\DocumentCompareService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCompareService.IntegrationTests\\DocumentCompareService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCreation\\DocumentCreation.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCreation.IntegrationTests\\DocumentCreation.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElasticCore\\ElasticCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElasticIndexing\\ElasticIndexing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElectronicSignature\\ElectronicSignature.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService\\ESignatureService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService.IntegrationTests\\ESignatureService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ETL\\ETL.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ExtractService\\ExtractService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ExtractService.IntegrationTests\\ExtractService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Fax\\Fax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/FormGen\\FormGen.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GenericEventProcessor\\GenericEventProcessor.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GenericEventProcessor.IntegrationTests\\GenericEventProcessor.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GraphQLCore\\GraphQLCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/HtmlService\\HtmlService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/InboundFax\\InboundFax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/InteractivePreviewCore\\InteractivePreviewCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MaintenanceService\\MaintenanceService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MenuActions\\DocumentReviewMenuActions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService\\MessageWorkerService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/NewsService\\NewsService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/NewsService.IntegrationTests\\NewsService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ObligationManagementIntegration\\ObligationManagementIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OfficeWebAppsAPI.IntegrationTests/OfficeWebAppsAPI.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OfficeWebAppsAPI\\OfficeWebAppsAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OneConfig.Testing\\OneConfig.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients\\DacDocGenApiClient\\DacDocGenApiClient.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients\\Doc2PdfApiClient\\Doc2PdfApiClient.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OrchestrationIntegration\\OrchestrationIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEmail\\OutboundEmail.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEmail.IntegrationTests\\OutboundEmail.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEvent\\OutboundEvent.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEvent.IntegrationTests\\OutboundEvent.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundFax\\OutboundFax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundHttpService\\OutboundHttpService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Packaging\\Packaging.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/PdfService\\PdfService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProcessBuilder\\ProcessBuilder.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProfileLogger\\ProfileLogger.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProxyLayer\\ProxyLayer.Core\\ProxyLayer.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProxyLayer\\ProxyLayer.Infrastructure\\ProxyLayer.Infrastructure.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ReportingService\\ReportingService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ReportingService.IntegrationTests\\ReportingService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication\\REST.Authentication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Common\\REST.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content\\REST.Content.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.WebServices\\REST.WebServices.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/RtmIntegration\\RtmIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SANitationService\\SANitationService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SForce.Core\\SForce.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SForce.Services\\SForce.Services.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SFTPServer\\SFTPServer.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SFTPServer.IntegrationTests\\SFTPServer.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SharedTemplates\\SharedTemplates.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SMTPServer\\SMTPServer.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SMTPServer.IntegrationTests\\SMTPServer.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/StructuredDocumentService\\StructuredDocumentService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/StructuredDocumentService.IntegrationTests\\StructuredDocumentService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TaskProcessor\\TaskProcessor.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TreeService\\TreeService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TreeService.IntegrationTests\\TreeService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/UserTaskList\\UserTaskList.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback\\VendorCallback.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Testing\\Web.Common.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Abstractions/Web.Common.Abstractions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Resources/Web.Common.Resources.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common\\Web.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Web.Common.AspNetCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.Abstractions\\Web.CommonUI.Abstractions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.Resources/Web.CommonUI.Resources.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI\\Web.CommonUI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.AspNetCore\\Web.CommonUI.AspNetCore\\Web.CommonUI.AspNetCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.IntegrationTests\\Web.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Testing\\Web.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web\\Web.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebNet\\WebNet.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebNet.IntegrationTests\\WebNet.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebContent\\WebContent.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebShare\\WebShare.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap\\WebSoap.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WINS.Protocol\\WINS.Protocol.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WINS\\WINS.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CLM.Search\\dirs.proj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap.EndToEndTests\\WebSoap.EndToEndTests.csproj"
      ],
      "error": null,
      "execution_time": 0.008584022521972656,
      "cache_hit": false
    },
    "graph_building": {
      "stage_name": "graph_building",
      "status": "StageStatus.COMPLETED",
      "result": {
        "projects_count": 143,
        "graph_loaded": true
      },
      "error": null,
      "execution_time": 389.6485769748688,
      "cache_hit": false
    },
    "intelligent_search": {
      "stage_name": "intelligent_search",
      "status": "StageStatus.COMPLETED",
      "result": [
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (4 occurrences); Contains method call: SetTag (4 times); Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "ActivitySource",
            "SetTag"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)",
            "?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);",
            "?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (4 occurrences); Contains method call: SetTag (4 times); Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "ActivitySource",
            "SetTag"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)",
            "?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);",
            "?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "Logger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions; Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "Pattern: Monitoring",
            "SetTag",
            "ActivitySource",
            "Pattern: Instrumentation",
            "Pattern: StartActivity",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: ActivitySource",
            "Import: DocuSign.CLM.Monitoring",
            "Import: var activity = StartActivity(task, corrToken)",
            "Pattern: OpenTelemetry",
            "Import: DocuSign.Monitoring"
          ],
          "context_snippets": [
            "ActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);",
            "parentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (9 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid), Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid); Contains method call: SetTag (9 times); Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid)",
            "SetTag",
            "ActivitySource",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Pattern: ActivitySource",
            "Import: var span = StartActivity()",
            "Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid)",
            "Pattern: OpenTelemetry"
          ],
          "context_snippets": [
            "LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));",
            "LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;",
            "private Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)",
            "?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)",
            ".SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);",
            ".SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);",
            ".SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()",
            ".SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "ActivitySource",
            "SetTag"
          ],
          "context_snippets": [
            "private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (54 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: OpenTelemetry.Trace, Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId); Contains method call: SetTag (54 times); Matches 1 keywords: AddTag",
          "matching_patterns": [
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid)",
            "Import: OpenTelemetry.Trace",
            "Pattern: AddTag",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "AddTag",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)",
            "Pattern: OpenTelemetry",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)",
            "Pattern: Instrumentation",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid)",
            "SetTag",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)",
            "Pattern: StartActivity",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)"
          ],
          "context_snippets": [
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);",
            "{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.StartParameters?.Submitter);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartRoutingApprovalWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t\treturn Task.FromResult(new SendStartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);",
            "{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "private void OnPostRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(HttpContext.Current);\n\t\t\tLogSessionSize(HttpContext.Current?.Session);\n\t\t\t_performanceLog.SetSession(HttpContext.Current?.Session);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tPopulateFeatureFlagContext(AtlasContext.Current.UserAccount, context);\n\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
          "matching_patterns": [
            "Import: var activity = StartActivity()",
            "Pattern: Monitoring",
            "SetTag",
            "Import: OpenTelemetry.Context.Propagation",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Import: var activity = StartActivity()\n\t\t\t\t?.SetStatus(ActivityStatusCode.Ok)",
            "Pattern: ActivitySource",
            "Import: DocuSign.CLM.Monitoring",
            "Import: OpenTelemetry.Instrumentation.AspNet",
            "Import: DocuSign.Monitoring"
          ],
          "context_snippets": [
            "private Activity StartActivity([CallerMemberName] string name = \"\") =>\n\t\t\tSessionStateProviderActivitySource\n\t\t\t\t.StartActivity($\"{nameof(RedisSessionStateProviderWrapper)}.{name}\")\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n\n\t\t#endregion\n\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions, Import: var activity = StartActivity()",
          "matching_patterns": [
            "Import: var activity = StartActivity()",
            "SetTag",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: StartActivity",
            "Pattern: ActivitySource",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Pattern: OpenTelemetry"
          ],
          "context_snippets": [
            "{\n\t\t\tvar result = MimeLookup.GetMimeType(filePath);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))",
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.UrlMon))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);",
            "?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.UrlMon))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n\n\tstatic class MimeLookup"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "using var stream = File.OpenRead(filePath);\n\t\t\tvar result = MimeGuesser.GuessMimeType(stream);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))",
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.MimeGuesser))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n}",
            "?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.MimeGuesser))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (5 occurrences); Contains method call: SetTag (5 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity($\"{InstrumentationNames.MediaInfo}.{name}\")\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t\t?.SetMetricName(InstrumentationNames.MediaInfo);\n\n\t\tprivate Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>",
            "private Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);",
            "private Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}",
            "activity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}",
            "?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (6 occurrences); Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "where T : IQueueTask\n\t\t=>\n\t\tactivity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);",
            "=>\n\t\tactivity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);",
            "activity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);\n\n\tpublic static Activity? SetQueueTaskResultTags<T>(this Activity? activity, T task, ProcessTaskResult result)",
            "?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);\n\n\tpublic static Activity? SetQueueTaskResultTags<T>(this Activity? activity, T task, ProcessTaskResult result)\n\t\twhere T : IQueueTask",
            "where T : IQueueTask\n\t\t=>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageResultMessage, result.Message)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageLastErrorMessage, task.LastErrorMessage);\n}\n#nullable restore",
            "=>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageResultMessage, result.Message)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageLastErrorMessage, task.LastErrorMessage);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics, Import: OpenTelemetry.Metrics",
          "matching_patterns": [
            "Import: DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics",
            "Import: OpenTelemetry.Metrics",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Config file: program.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: OpenTelemetry.Metrics",
          "matching_patterns": [
            "Import: DocuSign.CLM.Monitoring",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Monitoring",
            "Pattern: Metrics",
            "Pattern: UseOpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: ADEXS.Caching.OpenTelemetry.Extensions, Import: ADEXS.CqlCorePersistence.OpenTelemetry, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
          "matching_patterns": [
            "Import: ADEXS.Caching.OpenTelemetry.Extensions",
            "Import: ADEXS.CqlCorePersistence.OpenTelemetry",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry",
            "Import: OpenTelemetry.Exporter",
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: ConfigureServices",
            "Config file: startup.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/ICoreInstrumentationLifetimeService.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace, Pattern: OpenTelemetry",
          "matching_patterns": [
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: TracerProvider",
            "Pattern: MeterProvider",
            "Config file: icoreinstrumentationlifetimeservice.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/CoreInstrumentationLifetimeService.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: ADEXS.ServiceFramework.OpenTelemetry.Extensions, Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace",
          "matching_patterns": [
            "Import: ADEXS.ServiceFramework.OpenTelemetry.Extensions",
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: TracerProvider",
            "Pattern: MeterProvider",
            "Config file: coreinstrumentationlifetimeservice.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (15 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "using var saveActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes));\n\t\t\tsaveActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar stopwatch = Stopwatch.StartNew();",
            "?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes));\n\t\t\tsaveActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar statusMessages = new Messages();",
            "{\n\t\t\t\tattrvm = WebUtility.HtmlDecode(attrvm);\n\t\t\t\tvar attributes = attrvm.ToObject<AttributesViewModel>();\n\t\t\t\tsaveActivity?.SetTag(\"docusign.document.id\", attributes.docUid);\n\n\t\t\t\tvar document = LoadAndValidateDocument(attributes.docUid);",
            "using var loadActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\tif (!HasSufficientRightsToView())",
            "using var loadGroupSchemaActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry",
            "using var refreshActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "using var loadCascadingDropdownOptionsActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Controls/FormExtensions.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (10 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "{\n               tag.MergeAttribute(\"id\", id);\n           }\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, Dictionary<string, string> attributes)",
            "private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, Dictionary<string, string> attributes)\n       {\n           tag.MergeAttributes(attributes);\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasImageTag(TTagBuilder tag, string spriteClassName, string additionalClassName)",
            "{\n           tag.ApplyHtmlAttributes(htmlAttributes);\n           tag.AddCssClass(\"LinkButton\");\n           SetTagContent(tag, string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Close : text);\n           if (!tag.Attributes.ContainsKey(\"onclick\"))\n           {\n               tag.Attributes.Add(\"onclick\", \"CloseWindoid();return false;\");",
            "}\n           }, TTagRenderMode.SelfClosing);\n\n           SetTagContent(tag, imageHtml);\n       }\n\n       private static THtml BuildAtlasMetadataField(THtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value, CultureInfo culture)",
            "div.ApplyHtmlAttributes(htmlAttributes);\n           div.AddCssClass(\"atlasfield\");\n           div.Attributes.Add(\"id\", $\"{member.Member.Name}Field\");\n           SetTagContent(div, labelHtml, controlHtml);\n       }\n\n       private static void ConfigureFaUxFieldFor<TModel, TValue>(TTagBuilder div, Expression<Func<TModel, TValue>> expression, object htmlAttributes, THtml labelHtml, THtml controlHtml)",
            "t.AddCssClass(\"theme_primary-dark_background-color\");\n           });\n\n           SetTagContent(div, icon, controlHtml, labelHtml, spanLine);\n       }\n\n       private static TTagBuilder BuildLabel(string name, string displayName)",
            "var tag = new TTagBuilder(\"label\");\n           tag.Attributes[\"for\"] = name;\n           tag.AddCssClass(AtlasLabelName);\n           SetTagContent(tag, displayName);\n           return tag;\n       }",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, string content)\n       {\n#if NETFRAMEWORK\n           tag.SetInnerText(content);",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, THtml htmlContent)\n       {\n#if NETFRAMEWORK\n           tag.InnerHtml = htmlContent.ToHtmlString();",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, params THtml[] htmlContents)\n       {\n#if NETFRAMEWORK\n           using (var writer = new StringWriter())"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowScopeEvents/WorkflowScopeEventsController.Trace.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowActivities/WorkflowActivitiesController.Trace.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowDefinition/WorkflowDefinitionController.Trace.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (4 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (7 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "namespace ADEXS.Core.Domain.Utilities;\npublic static class ActivityEnricher\n{\n\tpublic static void SetTagsWithCommonFields(this Activity activity, HttpContext context)\n\t{\n\t\tif (activity == null)\n\t\t{",
            "{\n\t\tif (AtlasContext.Current != null && AtlasContext.Current.AccountId != 0 && AtlasContext.Current.AccountId != int.MinValue)\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, AtlasContext.Current.AccountId);\n\t\t\treturn;\n\t\t}",
            "var account = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(account))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, account);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}",
            "{\n\t\tif (AtlasContext.Current != null && !System.Guid.Empty.Equals(AtlasContext.Current.UserAccountUid))\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, AtlasContext.Current.UserAccountUid);\n\t\t\treturn;\n\t\t}",
            "var userId = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(userId))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userId);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}",
            "{\n\t\tif (!string.IsNullOrEmpty(context?.Session?.SessionID))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, context?.Session?.SessionID);\n\t\t}\n\t}\n#else",
            "var session = context == null ? null : GetSession(context);\n\t\tif (!string.IsNullOrEmpty(session?.Id))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, session?.Id);\n\t\t}\n\t}"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Constants.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 100,
          "reasoning": "file contains configuration or constants; contains telemetry symbol: ADEXS.Core.Types.Constants.Forms.EmitMetafieldInputAttribute(System.Guid); has relationship to telemetry symbol: ADEXS.Core.Types.Constants.Forms.EmitMetafieldInputAttribute(System.Guid); contains telemetry symbol: ADEXS.Core.Types.Constants.Forms.EmitMetagroupLabelElement(System.Guid); symbol is application entry point or middleware; contains HTTP-related constant: ADEXS.Core.Types.Constants.CustomHeaders; contains HTTP-related constant: ADEXS.Core.Types.Constants.DocuSignCustomHeaders; contains HTTP-related constant: ADEXS.Core.Types.Constants.ActCustomHeaders; contains HTTP-related constant: ADEXS.Core.Types.Constants.HttpContextCache; contains HTTP-related constant: ADEXS.Core.Types.Constants.HttpContextCookie; contains telemetry symbol: ADEXS.Core.Types.Constants.SystemMetadataGroupNames; contains telemetry symbol: ADEXS.Core.Types.Constants.HtmlAttributes; contains HTTP-related constant: ADEXS.Core.Types.Constants.Allocation; contains telemetry symbol: ADEXS.Core.Types.Constants.FileDataSource.UploadSourceAttribute; contains telemetry symbol: ADEXS.Core.Types.Constants.MetadataHtmlAttributes; contains telemetry symbol: ADEXS.Core.Types.Constants.AgreementDetailsImpliedMetadataGuids",
          "matching_patterns": [
            "configuration_pattern",
            "telemetry_symbol_ADEXS.Core.Types.Constants.Forms.EmitMetafieldInputAttribute(System.Guid)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Types.Constants.Forms.EmitMetagroupLabelElement(System.Guid)",
            "application_entry_point",
            "http_constant_ADEXS.Core.Types.Constants.CustomHeaders",
            "http_constant_ADEXS.Core.Types.Constants.DocuSignCustomHeaders",
            "http_constant_ADEXS.Core.Types.Constants.ActCustomHeaders",
            "http_constant_ADEXS.Core.Types.Constants.HttpContextCache",
            "http_constant_ADEXS.Core.Types.Constants.HttpContextCookie",
            "telemetry_symbol_ADEXS.Core.Types.Constants.SystemMetadataGroupNames",
            "telemetry_symbol_ADEXS.Core.Types.Constants.HtmlAttributes",
            "http_constant_ADEXS.Core.Types.Constants.Allocation",
            "telemetry_symbol_ADEXS.Core.Types.Constants.FileDataSource.UploadSourceAttribute",
            "telemetry_symbol_ADEXS.Core.Types.Constants.MetadataHtmlAttributes",
            "telemetry_symbol_ADEXS.Core.Types.Constants.AgreementDetailsImpliedMetadataGuids"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Enums.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 100,
          "reasoning": "has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool); has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool); has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool); has relationship to telemetry symbol: System.Collections.Generic.IEnumerable<System.ComponentModel.DescriptionAttribute>.FirstOrDefault<System.ComponentModel.DescriptionAttribute>(); has relationship to telemetry symbol: System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo, System.Type); has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool); has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool)",
          "matching_patterns": [
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 95,
          "reasoning": "Telemetry infrastructure: Import: Monitoring = DocuSign.Monitoring, Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar result = WINSClientLibrary.CreateNewWorkflowDefinition(user, workflowName), Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
          "matching_patterns": [
            "Import: Monitoring = DocuSign.Monitoring",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar result = WINSClientLibrary.CreateNewWorkflowDefinition(user, workflowName)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.LoadWorkItem(user, workItemUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII(string.Format(\"SubmitWorkItem: WorkItemUid {0}, output {1}\", workItemUid, PII.Encode(output)))",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IVersionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, version.Uid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IRevisionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, revision.Uid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = new Legacy2Designer(new DefinitionReaderLegacy(oldDesign)).Convert(user)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tstring jwtToken = null",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(userAccount.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(userAccount.AccountId, sourceInstanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = WINSClientLibrary.ExportWorkflowDefinition(user, workflowName, versionNumber, revisionNumber)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, workflowName, sourceVersionNumber, sourceRevisionNumber, newVersionNumber, comment)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, sourceVersionUid, sourceRevisionNumber, newVersionNumber, comment)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tbool isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(accountId, instanceUid, revisionUid, revisionCreatedDate, activityExecutionCount, out _)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tStartParameters startParameters = new StartParameters(user, xmlParam, sourceType, sourceId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tGuid result = WorkflowRepository.SendStartWorkflow(user, workflowName, sourceType, sourceId, xmlParam)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, user.Uid, workflowName, xmlParam, sourceType, sourceId, instanceUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, revisionUid, startParameters, instanceUid)",
            "Pattern: Monitoring"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/ActIntegration/Client/ActIntegrationClient.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequestV2Async(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Guid, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon, bool); has relationship to telemetry symbol: System.TimeSpan.FromSeconds(double); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequestV2(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Guid, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon, bool); has relationship to telemetry symbol: System.TimeSpan.FromSeconds(double); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequest(ADEXS.Core.Domain.Model.UserAccount, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon); has relationship to telemetry symbol: System.TimeSpan.FromSeconds(double); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.GetHttpClient(); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.GetTokenScopesForHttpMethod(System.Net.Http.HttpMethod, ADEXS.ActIntegration.ActAccountInfo); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.AddDefaultRequestHeaders(ADEXS.ActIntegration.ActAccountInfo, string, System.Net.Http.HttpClient, string, string, string)",
          "matching_patterns": [
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequestV2Async(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Guid, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon, bool)",
            "telemetry_relationship",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequestV2(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Guid, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon, bool)",
            "telemetry_relationship",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequest(ADEXS.Core.Domain.Model.UserAccount, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon)",
            "telemetry_relationship",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.GetHttpClient()",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.GetTokenScopesForHttpMethod(System.Net.Http.HttpMethod, ADEXS.ActIntegration.ActAccountInfo)",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.AddDefaultRequestHeaders(ADEXS.ActIntegration.ActAccountInfo, string, System.Net.Http.HttpClient, string, string, string)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients/DacDocGenApiClient/Api/GenApi.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.GenerateDocumentV1WithHttpInfo(string, DacDocGenApiClient.Model.GenerateDocumentRequest); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.GenerateDocumentV1WithHttpInfoAsync(string, DacDocGenApiClient.Model.GenerateDocumentRequest, System.Threading.CancellationToken); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.ParseTemplateV1WithHttpInfo(System.Guid, DacDocGenApiClient.Model.ParseTemplateRequest); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.ParseTemplateV1WithHttpInfoAsync(System.Guid, DacDocGenApiClient.Model.ParseTemplateRequest, System.Threading.CancellationToken); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.UploadTemplateV1WithHttpInfo(System.Guid, string, DacDocGenApiClient.Client.FileParameter, long?); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.UploadTemplateV1WithHttpInfoAsync(System.Guid, string, DacDocGenApiClient.Client.FileParameter, long?, System.Threading.CancellationToken)",
          "matching_patterns": [
            "http_constant_DacDocGenApiClient.Api.GenApi.GenerateDocumentV1WithHttpInfo(string, DacDocGenApiClient.Model.GenerateDocumentRequest)",
            "http_constant_DacDocGenApiClient.Api.GenApi.GenerateDocumentV1WithHttpInfoAsync(string, DacDocGenApiClient.Model.GenerateDocumentRequest, System.Threading.CancellationToken)",
            "http_constant_DacDocGenApiClient.Api.GenApi.ParseTemplateV1WithHttpInfo(System.Guid, DacDocGenApiClient.Model.ParseTemplateRequest)",
            "http_constant_DacDocGenApiClient.Api.GenApi.ParseTemplateV1WithHttpInfoAsync(System.Guid, DacDocGenApiClient.Model.ParseTemplateRequest, System.Threading.CancellationToken)",
            "http_constant_DacDocGenApiClient.Api.GenApi.UploadTemplateV1WithHttpInfo(System.Guid, string, DacDocGenApiClient.Client.FileParameter, long?)",
            "http_constant_DacDocGenApiClient.Api.GenApi.UploadTemplateV1WithHttpInfoAsync(System.Guid, string, DacDocGenApiClient.Client.FileParameter, long?, System.Threading.CancellationToken)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients/DacDocGenApiClient/Client/ApiClient.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains HTTP-related constant: DacDocGenApiClient.Client.CustomJsonCodec.Deserialize<T>(System.Net.Http.HttpResponseMessage); contains HTTP-related constant: DacDocGenApiClient.Client.CustomJsonCodec.Deserialize(System.Net.Http.HttpResponseMessage, System.Type); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.NewRequest(System.Net.Http.HttpMethod, string, DacDocGenApiClient.Client.RequestOptions, DacDocGenApiClient.Client.IReadableConfiguration); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.InterceptRequest(System.Net.Http.HttpRequestMessage); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.InterceptResponse(System.Net.Http.HttpRequestMessage, System.Net.Http.HttpResponseMessage); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.ToApiResponse<T>(System.Net.Http.HttpResponseMessage, object, System.Uri); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.Exec<T>(System.Net.Http.HttpRequestMessage, DacDocGenApiClient.Client.IReadableConfiguration); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.ExecAsync<T>(System.Net.Http.HttpRequestMessage, DacDocGenApiClient.Client.IReadableConfiguration, System.Threading.CancellationToken)",
          "matching_patterns": [
            "http_constant_DacDocGenApiClient.Client.CustomJsonCodec.Deserialize<T>(System.Net.Http.HttpResponseMessage)",
            "http_constant_DacDocGenApiClient.Client.CustomJsonCodec.Deserialize(System.Net.Http.HttpResponseMessage, System.Type)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.NewRequest(System.Net.Http.HttpMethod, string, DacDocGenApiClient.Client.RequestOptions, DacDocGenApiClient.Client.IReadableConfiguration)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.InterceptRequest(System.Net.Http.HttpRequestMessage)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.InterceptResponse(System.Net.Http.HttpRequestMessage, System.Net.Http.HttpResponseMessage)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.ToApiResponse<T>(System.Net.Http.HttpResponseMessage, object, System.Uri)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.Exec<T>(System.Net.Http.HttpRequestMessage, DacDocGenApiClient.Client.IReadableConfiguration)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.ExecAsync<T>(System.Net.Http.HttpRequestMessage, DacDocGenApiClient.Client.IReadableConfiguration, System.Threading.CancellationToken)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS.Protocol/obj/Debug/net48/docusign/workflow/wins/v1alpha1/WinsModels.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.WriteTagAndValue(ref Google.Protobuf.WriteContext, string); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag()",
          "matching_patterns": [
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS.Protocol/obj/Debug/net48/docusign/workflow/wins/v1alpha1/WinsService.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.WriteTagAndValue(ref Google.Protobuf.WriteContext, string); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag()",
          "matching_patterns": [
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Client/WorkflowDesignRepository.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); contains HTTP-related constant: ADEXS.Atlas.Workflow.Client.WorkflowDesignRepository.GetWorkflowDesignApi(int, System.Guid, System.Net.Http.HttpClient, string)",
          "matching_patterns": [
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "http_constant_ADEXS.Atlas.Workflow.Client.WorkflowDesignRepository.GetWorkflowDesignApi(int, System.Guid, System.Net.Http.HttpClient, string)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Adm/Mapping/AdmMapper.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.AgreementMapperTimeSpanUnitsResolver; contains telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.AgreementMapperTimeSpanUnitsResolver.Resolve(ADEXS.Core.Domain.Model.Agreement, DocuSign.Adm.Api.Models.AgreementCreate, ADEXS.Core.Domain.Model.AgreementPeriod, DocuSign.Adm.Api.Models.TimeSpanUnits?, AutoMapper.ResolutionContext); has relationship to telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?); has relationship to telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?); has relationship to telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?); has relationship to telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?); contains telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter; contains telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?)",
          "matching_patterns": [
            "telemetry_symbol_ADEXS.Core.Domain.Adm.Mapping.AgreementMapperTimeSpanUnitsResolver",
            "telemetry_symbol_ADEXS.Core.Domain.Adm.Mapping.AgreementMapperTimeSpanUnitsResolver.Resolve(ADEXS.Core.Domain.Model.Agreement, DocuSign.Adm.Api.Models.AgreementCreate, ADEXS.Core.Domain.Model.AgreementPeriod, DocuSign.Adm.Api.Models.TimeSpanUnits?, AutoMapper.ResolutionContext)",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter",
            "telemetry_symbol_ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AIConfiguration/ConfigurationService.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "file contains configuration or constants; has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateAOMAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.GetAttributeGroups(ADEXS.Core.Domain.Model.UserAccount); has relationship to telemetry symbol: ADEXS.Core.Domain.Repository.MetadataRepository.IMetadataGroupRepository.LoadByAccountId(int); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.SaveAttributeMapping(ADEXS.Core.Domain.Model.UserAccount, ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMapping); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateClmAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>); has relationship to telemetry symbol: ADEXS.Core.Domain.Repository.MetadataRepository.IMetadataGroupRepository.LoadByUid(int, System.Guid); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateAOMAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>); has relationship to telemetry symbol: ADEXS.Core.Domain.Repository.AgreementRepository.IAgreementFieldService.GetStandardFields(ADEXS.Core.Domain.Model.UserAccount, ADEXS.Core.Domain.Repository.AgreementRepository.Tag?); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.CreateRuleModelMappingBasicDetails(ADEXS.Core.Domain.Model.UserAccount, System.Guid, ADEXS.Core.Domain.Model.MetadataField, ADEXS.Core.Domain.Model.MetadataGroup, System.Collections.Generic.List<ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>); has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsCustomAttributeSupported(ADEXS.Core.Domain.Model.MetadataField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsStandardAttributeSupported(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); has relationship to telemetry symbol: ADEXS.Core.Domain.SmartAgreement.AIModelManagement.IAiModelManagement.GetAllowedModelItemsByAccount(ADEXS.Core.Domain.Model.Account); has relationship to telemetry symbol: ADEXS.Core.Domain.Repository.AgreementRepository.IAgreementFieldService.GetStandardFields(ADEXS.Core.Domain.Model.UserAccount, ADEXS.Core.Domain.Repository.AgreementRepository.Tag?)",
          "matching_patterns": [
            "configuration_pattern",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.GetAttributeGroups(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.SaveAttributeMapping(ADEXS.Core.Domain.Model.UserAccount, ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMapping)",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateClmAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateAOMAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.CreateRuleModelMappingBasicDetails(ADEXS.Core.Domain.Model.UserAccount, System.Guid, ADEXS.Core.Domain.Model.MetadataField, ADEXS.Core.Domain.Model.MetadataGroup, System.Collections.Generic.List<ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>)",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AIConfiguration/Utilities/DataTypeHelper.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "file contains configuration or constants; has relationship to telemetry symbol: System.Collections.Generic.Dictionary<ADEXS.Core.Types.Enums.DataType, ADEXS.Core.Types.Enums.AttributeFieldType>.GetValueOrDefault<ADEXS.Core.Types.Enums.DataType, ADEXS.Core.Types.Enums.AttributeFieldType>(ADEXS.Core.Types.Enums.DataType, ADEXS.Core.Types.Enums.AttributeFieldType); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsSupported(ADEXS.Core.Types.Enums.DataType, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsCustomAttributeSupported(ADEXS.Core.Domain.Model.MetadataField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsSupported(ADEXS.Core.Types.Enums.DataType, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsStandardAttributeSupported(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.GetStandardAttributeDataType(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.GetStandardAttributeDataType(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField)",
          "matching_patterns": [
            "configuration_pattern",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsSupported(ADEXS.Core.Types.Enums.DataType, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType)",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsCustomAttributeSupported(ADEXS.Core.Domain.Model.MetadataField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsStandardAttributeSupported(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.GetStandardAttributeDataType(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Aom/AomUtilities.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeCustomNameToDefaultDictionary(ADEXS.Core.Domain.Model.UserAccount); contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeDefaultToCustomNameDictionary(ADEXS.Core.Domain.Model.UserAccount); contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeFieldUid(ADEXS.Core.Domain.Model.UserAccount); has relationship to telemetry symbol: LanguageExt.Prelude.Optional<ADEXS.Core.Domain.Model.MetadataGroup>(ADEXS.Core.Domain.Model.MetadataGroup?); contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeFieldUid(System.Guid, ADEXS.Core.Domain.Model.MetadataFields); contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementValueFieldUid(ADEXS.Core.Domain.Model.UserAccount); has relationship to telemetry symbol: LanguageExt.Prelude.Optional<ADEXS.Core.Domain.Model.MetadataGroup>(ADEXS.Core.Domain.Model.MetadataGroup?); has relationship to telemetry symbol: LanguageExt.Prelude.Optional<ADEXS.Core.Domain.Model.MetadataGroup>(ADEXS.Core.Domain.Model.MetadataGroup?)",
          "matching_patterns": [
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeCustomNameToDefaultDictionary(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeDefaultToCustomNameDictionary(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeFieldUid(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeFieldUid(System.Guid, ADEXS.Core.Domain.Model.MetadataFields)",
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementValueFieldUid(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/AbstractServicedComponent.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 85,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: service invocation to start process,\n\t\t\t\t\t// so Assembly.EntryAssembly is not represents correct service assembly. We are\n\t\t\t\t\t// using GetType().Assembly instead, which would provide correct release version.\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: this.GetType().Assembly))\n\t\t\t\t\t\t\t.GetAwaiter().GetResult()",
          "matching_patterns": [
            "Import: DocuSign.CLM.Monitoring",
            "Import: DocuSign.Monitoring",
            "Import: service invocation to start process,\n\t\t\t\t\t// so Assembly.EntryAssembly is not represents correct service assembly. We are\n\t\t\t\t\t// using GetType().Assembly instead, which would provide correct release version.\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: this.GetType().Assembly))\n\t\t\t\t\t\t\t.GetAwaiter().GetResult()",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Monitoring",
            "Pattern: UseOpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.Provisioning/Telemetry/IServiceInstrumentation.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 77,
          "reasoning": "Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "ActivitySource"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.Provisioning/Telemetry/InstrumentationNames.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 77,
          "reasoning": "Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "ActivitySource"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/Telemetry/ServiceInstrumentation.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 77,
          "reasoning": "Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "ActivitySource"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Telemetry/IServiceInstrumentation.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 77,
          "reasoning": "Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "ActivitySource"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Telemetry/InstrumentationNames.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 77,
          "reasoning": "Matches 1 keywords: ActivitySource",
          "matching_patterns": [
            "ActivitySource"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/HtmlService/GlobalSuppressions.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 55,
          "reasoning": "Matches 1 keywords: AddTag",
          "matching_patterns": [
            "AddTag"
          ],
          "context_snippets": [],
          "confidence": 0.6
        }
      ],
      "error": null,
      "execution_time": 3.629173994064331,
      "cache_hit": false
    },
    "advanced_analysis": {
      "stage_name": "advanced_analysis",
      "status": "StageStatus.COMPLETED",
      "result": {
        "impact_analysis": {
          "direct_impact": [
            "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/ICoreInstrumentationLifetimeService.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs"
          ],
          "indirect_impact": [
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowContext.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.Authentication/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebShare/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/Workflow/InstanceVariable.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/InstanceWorker.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.ABAC.PDP/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/BaseApiHandlerSecure.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.WebAPI/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/DocumentRepository/DocumentReader.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.WebServices/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Helpers/InstanceStateChangedHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Persistence/Model/QueueStatePersistence.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/Workflow/WorkflowConversion.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/User/UserAccountRepository.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowXmlVariableHandler.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Activities/Helpers/UpdateVariablesHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/PerformanceLog.cs"
          ],
          "risk_score": 10,
          "affected_patterns": [
            "ArchitecturalPattern.SINGLETON",
            "ArchitecturalPattern.DEPENDENCY_INJECTION",
            "ArchitecturalPattern.FACTORY"
          ],
          "breaking_changes": [
            "Service registration changes may affect dependency injection",
            "Startup configuration changes may affect application boot"
          ],
          "test_requirements": [
            "Middleware pipeline integration tests",
            "Integration tests for telemetry data collection",
            "Unit tests for modified methods",
            "Service registration validation tests",
            "OpenTelemetry span validation tests"
          ]
        },
        "code_clusters": [
          {
            "name": "Cluster (14 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/Workflow/InstanceVariable.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowContext.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/InstanceWorker.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/Workflow/InstanceVariable.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/Workflow/InstanceVariable.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/Workflow/InstanceVariable.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowContext.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/Workflow/InstanceVariable.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/InstanceWorker.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs"
              ]
            },
            "architectural_patterns": [
              "ArchitecturalPattern.SINGLETON"
            ],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 14
          },
          {
            "name": "Service Layer",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/BaseApiHandlerSecure.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/BaseApiHandlerSecure.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (12 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.WebAPI/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.Authentication/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.ABAC.PDP/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WebShare/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.WebAPI/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.Authentication/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.ABAC.PDP/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WebShare/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 12
          },
          {
            "name": "Cluster (3 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 3
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs"
              ]
            },
            "architectural_patterns": [
              "ArchitecturalPattern.FACTORY"
            ],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Service Layer",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          }
        ]
      },
      "error": null,
      "execution_time": 0.004957914352416992,
      "cache_hit": false
    },
    "file_selection": {
      "stage_name": "file_selection",
      "status": "StageStatus.COMPLETED",
      "result": {
        "selected_files": [
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
            "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class DetectTypeProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
            "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class VideoInfoProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net.Mime;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.PhysicalStorage;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FileIO;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.MimeLookup;\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.ContentStorage;\n\nnamespace ADEXS.DetectTypeService\n{\n\tpublic partial class DetectTypeProcessor : CommonTaskProcessor<DetectTypeTaskPayload>\n\t{\n\t\tprivate readonly IAtlasPersistenceFactory _atlasPersistenceFactory;\n\n\t\tprivate readonly IAtlasPhysicalStorageFactory _atlasPhysicalStorageFactory;\n\n\t\tprivate readonly IMimeDetector _mimeDetector;\n\n\t\tprivate readonly IDetectTypeServiceFeaturesConfig _featuresConfig;\n\n\t\tpublic DetectTypeProcessor()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IAtlasPersistenceFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IAtlasPhysicalStorageFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IMimeDetector>(),\n\t\t\t\tServiceLocator.GetInstance<IServiceInstrumentation>(),\n\t\t\t\tServiceLocator.GetInstance<IDetectTypeServiceFeaturesConfig>())\n\t\t{\n\t\t}\n\n\t\tpublic DetectTypeProcessor(\n\t\t\tIAtlasPersistenceFactory atlasPersistenceFactory,\n\t\t\tIAtlasPhysicalStorageFactory atlasPhysicalStorageFactory,\n\t\t\tIMimeDetector mimeDetector,\n\t\t\tIServiceInstrumentation serviceInstrumentation,\n\t\t\tIDetectTypeServiceFeaturesConfig featuresConfig)\n\t\t{\n\t\t\t_atlasPersistenceFactory = atlasPersistenceFactory;\n\t\t\t_atlasPhysicalStorageFactory = atlasPhysicalStorageFactory;\n\t\t\t_mimeDetector = mimeDetector;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t\t_featuresConfig = featuresConfig;\n\t\t}\n\n\t\tpublic override ProcessTaskResult ProcessTask()\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t// get and report the status of whether Optimizely is the feature flag provider\n\t\t\tLogger.InfoNoPII($\"Verification: IsOptimizelyVerificationFlagEnabled is {_featuresConfig.IsOptimizelyVerificationFlagEnabled} for account '{Task.AccountId}' (context accountId: '{AtlasContext.Current.AccountId}')\");\n\n\t\t\tProcessTaskResult result = new ProcessTaskResult();\n\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\tvar fileDataPersistence = _atlasPersistenceFactory.Get<IFileDataPersistence>(Task.AccountId);\n\n\t\t\tFileData fd = fileDataPersistence.LoadByUid(DeserializedPayload.FileDataUid);\n\t\t\tif (fd == null)\n\t\t\t{\n\t\t\t\tLogger.WarnNoPII($\"FileDataUid {DeserializedPayload.FileDataUid} does not exist in the db; ignoring\");\n\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\tresult.Message = \"Filedata Doesn't Exist\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// first try and detect the MIME type\n\t\t\t\t\tstring mimeType;\n\t\t\t\t\tusing (TempFile temp = new TempFile(fd.Extension))\n\t\t\t\t\t{\n\t\t\t\t\t\t//We could possibly optimize this by reading the first 256 bytes and passing them to the underlying COM library urlmon.dll.\n\t\t\t\t\t\t//See https://msdn.microsoft.com/en-us/library/ms775107(v=vs.85).aspx (FindMimeFromData function)\n\t\t\t\t\t\t_atlasPhysicalStorageFactory.GetPhysicalStorage(fd.AccountId).GetFile(fd.AccountId, fd.FileName, StorageConstants.StorageFormat.Native, temp.FileName);\n\t\t\t\t\t\tmimeType = _mimeDetector.DetectMimeType(temp.FileName);\n\t\t\t\t\t}\n\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected MIME type '{0}' for fileDataUid {1}.\", mimeType, fd.FileDataUid);\n\n\t\t\t\t\t// if still not sure try to map the extension to the MIME type\n\t\t\t\t\tif (string.IsNullOrEmpty(mimeType) || (mimeType == MediaTypeNames.Application.Octet))\n\t\t\t\t\t{\n\t\t\t\t\t\tmimeType = FileUtil.GetMimeTypeByExtension(fd.Extension);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Matched extension to MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\n\t\t\t\t\t// once we have a new MIME type, save it\n\t\t\t\t\tif (!string.IsNullOrEmpty(mimeType) && mimeType != fd.MIMEType)\n\t\t\t\t\t{\n\t\t\t\t\t\tfileDataPersistence.UpdateMIMEType(fd.Uid, mimeType);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected and set MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\t\t\te.Trace();\n\t\t\t\t\tLogger.ErrorNoPII($\"Failed to process fileDataUid {fd.FileDataUid} with exception \", e);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tTask.LastErrorMessage = e.Message;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.ErrorNoPII($\"Failed to mark fileDataUid {fd.FileDataUid} as failed with exception \", e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactivity?.SetQueueTaskResultTags(Task, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.MQ;\nusing ADEXS.Core.Domain;\nusing System.Threading;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing System.IO;\nusing ADEXS.Core.Domain.Model;\nusing System.Diagnostics;\n\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.ServiceFramework;\nusing CLM.MessageDefines;\nusing CLM.MessageDefines.Constants;\nusing CLM.MessageDefines.Interfaces;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\n\nusing StructureMap;\nusing ADEXS.MqWorkers.Config.Context;\nusing ADEXS.MqWorkers.Extensions;\nusing ADEXS.MqWorkers.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.MqWorkers.Config;\n\nnamespace ADEXS.Services.MessageWorkerService\n{\n\t//Should probably make an interface that encapsulates the methods for loading and\n\t//updating the Tasks so that we don't have to be tied to MessageQueues for this type of worker\n\tpublic class DispatchedWorker<T, U> : AbstractServiceQueue<T> where T : class, IQueueTask, new() where U : class, ITaskProcessor<T>, new()\n\t{\n\t\tprivate const string DESIRED_WORKER_COUNT = \"_WorkerCount\";\n\t\tprivate const string DESIRED_WORKER_MULTIPLIER = \"_WorkerMultiplier\";\n\t\tprivate const string TASK_DISPATCHERS = \"_TaskDispatchers\";\n\t\tprivate const string DESIRED_STAND_ALONE = \"_StandAlone\";\n\t\tprivate const string DEFAULT_TASK_DISPATCHERS = \"DefaultTaskDispatchers\";\n\t\tprivate const int DEFAULT_WORKER_COUNT = 5;\n\t\tprivate const double DEAFULT_CORE_TO_WORKER_MULTIPLIER = 0;\n\t\tprivate readonly string TASKPROCESSOR = Configuration.GetStringAppSetting(PROCESSSTART_NAME, \"ADEXS.TaskProcessor.exe\");\n\t\tprivate const string PROCESSSTART_NAME = \"PROCESSSTART_NAME\";\n\t\tprivate string _typeName;\n\t\tprivate readonly TaskTypes _taskType;\n\t\tprivate bool _standAlone;\n\n\t\tprivate readonly IContainer _container;         // optionally injected DI container\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate readonly Func<U> _createProcessor;\n\t\tprivate int _fetchMod;\n\n\t\t[ThreadStatic]\n\t\tprivate static int _errorCount = 0;\n\n\t\tpublic override string Name => base.Name + TypeName;\n\n\t\t[EventSource(\"Workers\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly PropertyBagEventSource _workersEventSource = new PropertyBagEventSource();\n\n\t\t[Counter(\"Workers Count\", \"CLM.DispatchedWorker\", MeasureProperty = \"Count\", InstanceProperty = \"Description\")]\n\t\t[EventSource(\"Workers Count\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly CountEventSource _workersCountEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\")]\n\t\t[Counter(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\", InstanceProperty = \"Description\")]\n\t\tprivate static ExceptionEventSource _workerLoggingExceptionEventSource = new ExceptionEventSource();\n\n\t\tstatic DispatchedWorker()\n\t\t{\n\t\t\t// Kazmon emits from a generic type do not work without this call\n\t\t\tMonitoringRuntime.RegisterGenericType(typeof(DispatchedWorker<T, U>));\n\t\t}\n\n\t\tpublic string TypeName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\t_typeName ??= _taskType.ToString();\n\t\t\t\treturn _typeName;\n\t\t\t}\n\t\t}\n\n\t\tpublic IMessageQueueWrapperFactory MessageQueueWrapperFactory { get; set; }\n\n\t\t/// <summary>\n\t\t/// Legacy Constructor -- delegates to the new overload; passes DI container extracted from ServiceLocator.\n\t\t/// This method will be deprecated in the future -- prefer the (IServicedComponent, IContainer) overload.\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this dispatched worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\tpublic DispatchedWorker(IServicedComponent component, TaskTypes taskType, IWatchedSingletonConfig<ISiteConfig> siteConfig) : this(component, taskType, ServiceLocator.Container, Activator.CreateInstance<U>, siteConfig)\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor overload that accepts a DI container (stepping stone to moving away from SL pattern).\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\t/// <param name=\"container\">the DI container for service discovery and IOC</param>\n\t\tinternal DispatchedWorker(IServicedComponent component, TaskTypes taskType, IContainer container, Func<U> processorFactory, IWatchedSingletonConfig<ISiteConfig> siteConfig) : base(component)\n\t\t{\n\t\t\t_container = container;\n\t\t\t_createProcessor = processorFactory ?? (() => new U());\n\t\t\tServiceLocator.BuildUp(this);\n\t\t\t_taskType = taskType;\n\t\t\t//This is here to prevent a regression following ATL-81324\n\t\t\tif (TypeName != typeof(T).Name)\n\t\t\t\tthrow new ArgumentException($\"Failed to initialize DispatchedWorker: Task Name ({typeof(T).Name}) must match task type ({TypeName})\");\n\t\t\t_waitOnNoItems = false;\n\t\t\t_standAlone = Configuration.GetBooleanAppSetting(TypeName + DESIRED_STAND_ALONE, false);\n\t\t\tif (_standAlone) _log.DebugNoPII($\"Worker running in StandAlone mode for {TypeName}\");\n\t\t\t_siteConfig = siteConfig;\n\t\t}\n\n\t\tprivate ProcessTaskResult RunExternalTaskProcessor(ProcessTaskRequest taskRequest)\n\t\t{\n\t\t\tvar accountId = taskRequest.Task.AccountId;\n\t\t\tbool useAnonymousPipes = TasksManagementFeatureFlags.UseAnonymousPipeForExternalTaskProcessors &&\n\t\t\t                         Configuration.GetBooleanAppSetting(\n\t\t\t\t                         $\"{accountId}_UseAnonymousPipeForExternalTaskProcessors\", true);\n\t\t\t_log.InfoNoPII(useAnonymousPipes\n\t\t\t\t? \"Worker using Anonymous Pipes for Request and Results\"\n\t\t\t\t: \"Worker using Temp Files for Request and Results\");\n\t\t\tExternalTaskWorker externalTaskWorker = ExternalTaskWorkerFactory.GetExternalTaskWorker(useAnonymousPipes);\n\t\t\treturn externalTaskWorker.RunExternalProcessor(taskRequest,TASKPROCESSOR);\n\t\t}\n\n\t\tprotected override int MaxQueueDepth()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_WorkerMaxQueueDepth\", Configuration.GetInt32AppSetting(TypeName + WORKER_MAXSET, WORKER_MAXSET_DEFAULT)) * DesiredWorkerCount();\n\t\t}\n\n\t\tprotected override IList<T> Fetch(int fetchCount)\n\t\t{\n\t\t\tList<T> tasks = new List<T>();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPeriodicPulse();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not pulse for ''{TypeName}''.\", ex);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttasks = FetchFromQueues(fetchCount);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not load the items for the queue: {TypeName}\", ex);\n\t\t\t\t_lastFetchDate = DateTime.UtcNow;\n\t\t\t}\n\n\t\t\tAttemptRestorePropertiesFromPayload(tasks);\n\n\t\t\treturn tasks;\n\t\t}\n\n\t\tprivate List<T> FetchFromQueues(int fetchCount)\n\t\t{\n\t\t\tvar queuePaths = DefaultQueue.GetWorkerMqPaths(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\n\t\t\t// keep incrementing to pull from a different queue on each fetch, fetching from all queues seems to have an adverse effect on the channels\n\t\t\t_fetchMod %= queuePaths.Length;\n\t\t\tvar queuePath = queuePaths[_fetchMod];\n\t\t\t_fetchMod++;\n\n\t\t\treturn FetchSingleQueue(fetchCount, queuePath);\n\t\t}\n\n\t\tprivate List<T> FetchSingleQueue(int fetchCount, string path)\n\t\t{\n\t\t\tbool isMainPath = path == DefaultQueue.GetWorkerMqPath(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\t\t\tint waitTime = isMainPath ? TaskUtilities.InitialReceiveWaitMS(TypeName) : Configuration.GetInt32AppSetting(\"InitialReceiveWaitAdditionalQueueMS\", 20);\n\t\t\tusing (IMessageQueueWrapper pdfMQ = MessageQueueWrapperFactory.CreateReceiveInstance(Configuration.GetStringAppSetting(TypeName + \"_WorkerMQPath\", path)))\n\t\t\t{\n\t\t\t\treturn pdfMQ.ReceiveMultiple<T>(waitTime, MQApplicationSettings.DefaultExtraReceiveWaitMS, fetchCount);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Restore the task type properties from the payload. This will only live temporarily as we move\n\t\t/// all tasks toward using the CommonTask payload. If we fail to restore from properties we should log to kazmon\n\t\t/// but we should not not block tasks from getting processed. We are also logging when we find a task\n\t\t/// without a payload set.\n\t\t/// </summary>\n\t\tprivate void AttemptRestorePropertiesFromPayload(List<T> tasks)\n\t\t{\n\t\t\t// App Setting to disable this behavior just in case of issues\n\t\t\tvar restoreFromPayload = Configuration.GetBooleanAppSetting($\"RestoreTaskFromPayload_All\", true) &&\n\t\t\t\tConfiguration.GetBooleanAppSetting($\"RestoreTaskFromPayload_{TypeName}\", true);\n\n\t\t\tforeach (var task in tasks)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (task is CommonTask cTask)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string.IsNullOrEmpty(cTask.Payload))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Log to kazmon to ensure that we don't miss any tasks\n\t\t\t\t\t\t\tCommonTaskPayloadHelper.CommonTaskPayloadMissingEventSource.Emit(1, cTask.Label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (restoreFromPayload)\n\t\t\t\t\t\t\t\tcTask.RestorePropertiesFromPayload();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tCommonTaskPayloadHelper.PayloadRestoreExceptionEventSource.Emit(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate QueueItemType _lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\tpublic override void AdjustWorkers()\n\t\t{\n\t\t\tbase.AdjustWorkers();\n\n\t\t\tint desiredWorkerCount = DesiredWorkerCount(out double multiplier);\n\t\t\tSetEnabled(desiredWorkerCount > 0);\n\t\t\tQueueItemType currentQueueStatus = (desiredWorkerCount > 0) ? QueueItemType.QueueStarted : QueueItemType.QueueStopped;\n\t\t\tif (currentQueueStatus == _lastSentQueueStatus) return;\n\n\t\t\tEmitWorkerConfiguration(currentQueueStatus, desiredWorkerCount, multiplier);\n\t\t\tstring adminQueuePath = \"Unset\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tT startTask = new T\n\t\t\t\t{\n\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\tQueueItemType = currentQueueStatus,\n\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t};\n\n\t\t\t\tif (!_standAlone)\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueuePath = GetAdminQueuePath(machine);\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(adminQueuePath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(startTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = currentQueueStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:AdjustWorkers - Could not contact the administration queue: \" + adminQueuePath, ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitWorkerConfiguration(QueueItemType queueItemtype, int desiredWorkerCount, double multiplier)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_workersCountEventSource.Emit(desiredWorkerCount, TypeName);\n\n\t\t\t\tusing (var propertyBag = _workersEventSource.CreateEventPropertyBag(queueItemtype.ToString()))\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TaskType\", TypeName);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"DesiredWorkerCount\", desiredWorkerCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"Multiplier\", multiplier.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ProcessorCount\", Environment.ProcessorCount.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_workerLoggingExceptionEventSource.Emit(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetMachineName() => System.Net.Dns.GetHostName();\n\t\tprivate string GetTaskTypeName() => typeof(T).FullName;\n\n\t\tprivate static int _queueStateTouchIntervalMin = 60;\n\t\tprivate DateTime _nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\n\t\tprotected virtual void PeriodicPulse()\n\t\t{\n\t\t\tif (_nextStateTouchTime < DateTime.UtcNow)\n\t\t\t{\n\t\t\t\tQueueStatePersistence.AuthenticationInstance.Touch(GetMachineName(), GetTaskTypeName());\n\t\t\t\t_nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Blast the local queue back to the dispatcher so that it can be\n\t\t/// dispatched to another worker.\n\t\t///\n\t\t/// Also sends a disable me message\n\t\t/// </summary>\n\t\tpublic override void Stop()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//Try to do a prelim kill before the stop of the workers\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch\n\t\t\t{\n\t\t\t\t_log.DebugNoPII(\"Didn't kill processes first time\");\n\t\t\t}\n\n\t\t\tbase.Stop();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSetEnabled(false);\n\t\t\t\tif (!_standAlone && (_lastSentQueueStatus != QueueItemType.QueueStopped))\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tT stopTask = new T\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\t\t\tQueueItemType = QueueItemType.QueueStopped,\n\t\t\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(machine)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(stopTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\t\t\t}\n\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:Stop - Exception generated during stop:\", ex);\n\t\t\t}\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStopped, 0, 0);\n\t\t}\n\n\t\tprivate void KillTaskProcessors()\n\t\t{\n\t\t\tvar nestedContainer = CreateNestedContainer(null);\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);  // necessary to determine if processor would run out-of-process\n\t\t\t// attempt to kill any active out-of-process processors\n\t\t\tif (processor.RunInSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t\t\tstring processName = Path.GetFileNameWithoutExtension(TASKPROCESSOR);\n\t\t\t\tProcess[] tokill = System.Diagnostics.Process.GetProcessesByName(processName);\n\t\t\t\tif (tokill.Length > 0)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"Killing {processName} processes.\");\n\t\t\t\t\tforeach (Process p in tokill)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Failed to kill process with pid: {p.Id}\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void SetEnabled(bool enable)\n\t\t{\n\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\t\t\tbool alreadySet = false;\n\t\t\tstring taskTypeName = GetTaskTypeName();\n\t\t\t_log.DebugNoPII($\"Task type: {taskTypeName}, enable set to {enable}\");\n\n\t\t\tforeach (QueueState state in QueueStatePersistence.AuthenticationInstance.LoadAll())\n\t\t\t{\n\t\t\t\tif (state.MachineName.Equals(GetMachineName(), StringComparison.InvariantCultureIgnoreCase)\n\t\t\t\t\t&& state.TaskTypeName == taskTypeName)\n\t\t\t\t{\n\t\t\t\t\tif (enable)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine already exists for task type {taskTypeName}, attempting to enable it\");\n\t\t\t\t\t\tRegisterQueueState(state);\n\t\t\t\t\t\talreadySet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine exists for task type {taskTypeName}, attempting to disable it\");\n\t\t\t\t\t\tstate.Enabled = false;\n\t\t\t\t\t\tQueueStatePersistence.AuthenticationInstance.Save(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (enable && !alreadySet)\n\t\t\t{\n\t\t\t\t// must be a new entry in the queuestate table\n\t\t\t\t_log.DebugNoPII($\"Machine does not already exist for task type {taskTypeName}, attempting to create it\");\n\t\t\t\tRegisterQueueState(null);\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// This will either create the queuestate or update\n\t\t/// it as enabled.\n\t\t/// </summary>\n\t\tprivate void RegisterQueueState(QueueState queueState)\n\t\t{\n\t\t\tif (queueState == null)\n\t\t\t{\n\t\t\t\tqueueState = new QueueState();\n\t\t\t\tType taskType = typeof(T);\n\t\t\t\tqueueState.MachineName = GetMachineName();\n\t\t\t\tqueueState.TaskAssemblyName = taskType.Assembly.GetName().Name;\n\t\t\t\tqueueState.TaskTypeName = GetTaskTypeName();\n\t\t\t\t_log.DebugNoPII($\"Creating new entry in QueueState for tasktype: {queueState.TaskTypeName}\");\n\t\t\t}\n\n\t\t\tqueueState.Enabled = true;\n\t\t\tqueueState.WorkerCount = DesiredWorkerCount(out double multiplier);\n\n\t\t\t_log.DebugNoPII($\"Saving QueueState for task type: {queueState.TaskTypeName} with properties - machine name: {queueState.MachineName},\" +\n\t\t\t\t$\"assembly name: {queueState.TaskAssemblyName} enabled: {queueState.Enabled}, worker count: {queueState.WorkerCount}\");\n\n\t\t\tQueueStatePersistence.AuthenticationInstance.Save(queueState);\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStarted, queueState.WorkerCount, multiplier);\n\t\t}\n\n\t\tprotected override TaskResult Process(T task, out string message)\n\t\t{\n\t\t\tmessage = null;\n\n\t\t\tAtlasContext.Current.AccountId = task.AccountId;\n\t\t\tAtlasContext.Current.TransactionId = task.CorrelationId;\n\t\t\tif (task is IUserTask usrTask)\n\t\t\t{\n\t\t\t\tAtlasContext.Current.UserAccountUid = usrTask.UserAccountUid;\n\t\t\t}\n\n\t\t\tGuid corrToken;\n\t\t\tGuid.TryParse(task.CorrelationId, out corrToken);\n\n\t\t\tusing var activity = StartActivity(task, corrToken);\n\n\t\t\tstring telemetryLabel = task.Label;\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\tusing (var logger = new TaskServiceRequestEventLogger(corrToken, telemetryLabel))\n\t\t\t{\n\t\t\t\t// introduces request-scoped container for user context state (and any other future per-request DI state)\n\t\t\t\tusing var nestedContainer = CreateNestedContainer(AtlasContext.Current);\n\n\t\t\t\t// The DataPoint enum is defined in DocuSign sources. Trying to use some, hopefully with close enough semantics.\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, task.AccountId);\n\t\t\t\tServiceContext.Log(DataPoint.QueueItemId, task.UniqueId);\n\t\t\t\tServiceContext.Log(DataPoint.TimeQueued, $\"{task.CreatedDate:yyyy-MM-dd HH:mm:ss.fff}\");\n\t\t\t\tif (Guid.Empty != AtlasContext.Current.UserAccountUid)\n\t\t\t\t{\n\t\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The nugget inside the monitoring wrapper.\n\t\t\t\t\tTaskResult taskResult = ProcessTask(task, nestedContainer, out message, activity);\n\n\t\t\t\t\tServiceContext.Log(DataPoint.ApiStatus, $\"{taskResult}\");\n\t\t\t\t\tlogger.Success = (taskResult != TaskResult.Failure);\n\t\t\t\t\tactivity?.SetStatusFromTask(taskResult);\n\t\t\t\t\treturn taskResult;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tex.Trace().Report();\n\t\t\t\t\tthrow;\n \t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (!logger.Success && null != message)\n\t\t\t\t\t{\n\t\t\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate TaskResult ProcessTask(T task, IContainer nestedContainer, out string message, Activity activity)\n\t\t{\n\t\t\tProcessTaskResult result = new ProcessTaskResult() { Message = \"Context Set\" };\n\n\t\t\tif (TaskUtilities.CheckSuspendedTaskTypeForAccount(TypeName, task.AccountId))\n\t\t\t{\n\t\t\t\tmessage = $\"task failed because Aid {task.AccountId} is in the suspended account list for {TypeName}\";\n\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\ttask.ErrorCount = int.MaxValue;\n\t\t\t\treturn TaskResult.Failure;\n\t\t\t}\n\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);\n\n\t\t\tAtlasContext.Current.ActionType = processor.ActionType;\n\n\t\t\tif (processor.RunInSeparateProcess && !processor.HandleSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t \t\tProcessTaskRequest taskRequest = new ProcessTaskRequest()\n\t\t\t\t{\n\t\t\t\t\tAccountId = AtlasContext.Current.AccountId,\n\t\t\t\t\tUserAccountUid = AtlasContext.Current.UserAccountUid,\n\t\t\t\t\tActionType = AtlasContext.Current.ActionType,\n\t\t\t\t\tProcessorTypeName = processor.GetType().AssemblyQualifiedName,\n\t\t\t\t\tTask = task,\n\t\t\t\t\tTaskType = _taskType,\n\t\t\t\t\tCorrelationToken = MonitoringContext.CorrelationToken ?? Guid.Empty\n\t\t\t\t};\n\t\t\t\tresult = RunExternalTaskProcessor(taskRequest);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprocessor.Task = task;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tprocessor.PreProcess();\n\t\t\t\t\tresult = processor.ProcessTask();\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tprocessor.PostProcess();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = result.Message;\n\n\t\t\tactivity?.SetQueueTaskResultTags(task, new MqWorkers.DispatchedWorker.ProcessTaskResult { Message = message });\n\n\t\t\treturn result.TaskResult;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an instance of the ITaskProcessor that should be used when processing a request.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This method takes into account whether we are using a scoped DI container, and if so, will\n\t\t/// attempt to get the task processor from there to ensure that other scoped DI services (eg user context)\n\t\t/// are also correctly set up. If the supplied `container` parameter is null we create a non-scoped\n\t\t/// processor instance, otherwise we demand it from the container (which may throw if none is registered).\n\t\t/// </remarks>\n\t\t/// <param name=\"container\">Optional (nullable) DI container from which we acquire scoped processors</param>\n\t\t/// <returns>An instance of ITaskProcessor{T} that can process the task.</returns>\n\t\tprivate U CreateTaskProcessor(IContainer container)\n\t\t{\n\t\t\t// NOTE: If we have a nested DI container, defer to it for the ITaskProcessor instance.\n\t\t\t//       If there is no nested container, or it doesn't have a ITaskProcessor registered,\n\t\t\t//       instantiate one one locally.\n\t\t\treturn container?.GetInstance<U>() ?? _createProcessor.Invoke();\n\t\t}\n\n\t\tprotected override void UpdateFailure(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//this will requeue it if needed\n\t\t\t\ttask.QueueItemType = QueueItemType.Ack;\n\t\t\t}, () =>\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Again errors should pause the movement of the items.\n\t\t\t\t * For this worker.\n\t\t\t\t */\n\t\t\t\tif (_errorCount++ % Configuration.GetInt32AppSetting(\"ErrorCountSleepMod\", 100) == 0)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(SleepMilliSeconds());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateUnlock(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//task will requeue it\n\t\t\t\ttask.QueueItemType = QueueItemType.Task;\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateSuccess(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.QueueItemType = QueueItemType.Completed;\n\t\t\t});\n\t\t}\n\n\t\tprivate void SendTaskStatusUpdate(T task, Action beforeSend, Action afterSend = null)\n\t\t{\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\t{\n\t\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\n\t\t\t\tbeforeSend();\n\n\t\t\t\tstring sendMachine = task.SendMachine; // Send() changes the SendMachine property, so store it here in case we need to restore it after an exception.\n\n\t\t\t\tusing (IMessageQueueWrapper adminQueue = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(task.SendMachine)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueue.Send(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Detected IOException.  Will retry once.\", ioe);\n\n\t\t\t\t\t\tadminQueue.ReSend(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Restore original SendMachine, for the sake of the UpdateFailure() call from AbstractServiceQueue.\n\t\t\t\t\t\ttask.SendMachine = sendMachine;\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (afterSend != null)\n\t\t\t\t{\n\t\t\t\t\tafterSend();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Crate a nested DI container for the user context (and potentially other request-scoped DI state).\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// Introduced as part of ATL-72998 to add support for feature flag integration, which requires access to\n\t\t/// the request-scoped Account/User identity for flag resolution decisions.\n\t\t/// </remarks>\n\t\t/// <param name=\"atlasContext\">Atlas request context for this request/task</param>\n\t\t/// <returns>Disposable DI container for this request-scoped state</returns>\n\t\tprivate IContainer CreateNestedContainer(IAtlasContext atlasContext)\n\t\t{\n\t\t\tvar nestedContainer = _container.GetNestedContainer();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (atlasContext != null)\n\t\t\t\t{\n\t\t\t\t\tvar userContextSetter = nestedContainer.TryGetInstance<IUserContextSetter>();\n\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tuserContextSetter.AccountId = atlasContext.AccountId;\n\t\t\t\t\t\tuserContextSetter.UserId = atlasContext.UserAccountUid; // this may be null, but that's ok\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Should we have a specific OT telemetry event for this condition? It's most like incorrectly configured DI setup, but may not be a defect.\n\t\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire IUserContextSetter - transactionId {atlasContext.TransactionId} will proceed without scoped user context.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar taskContextSetter = nestedContainer.TryGetInstance<ITaskTypeContextSetter>();\n\n\t\t\t\tif (taskContextSetter != null)\n\t\t\t\t{\n\t\t\t\t\ttaskContextSetter.TaskType = _taskType;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire ITaskTypeContextSetter - {TypeName} will proceed without scoped task type context.\");\n\t\t\t\t}\n\n\t\t\t\treturn nestedContainer;\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\tnestedContainer?.Dispose();  // avoid leaking nested container\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic virtual int StandardSleepSeconds => 5;\n\t\tprotected override int SleepSeconds()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_SleepSeconds\", StandardSleepSeconds);\n\t\t}\n\n\t\tpublic virtual int StandardWorkerCount => DEFAULT_WORKER_COUNT;\n\n\t\tpublic override int DesiredWorkerCount()\n\t\t{\n\t\t\treturn DesiredWorkerCount(out _);\n\t\t}\n\n\t\tprivate int DesiredWorkerCount(out double multiplier)\n\t\t{\n\t\t\tmultiplier = 0;\n\t\t\tint count = -1;\n\t\t\tif (IsOneConfigEnabledForWorkerCount())\n\t\t\t{\n\t\t\t\tvar mqTasksconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IMqTasksConfig>>()?.Value;\n\t\t\t\tvar taskConfigs = mqTasksconfigs?.TaskConfigs;\n\t\t\t\tif (taskConfigs != null && taskConfigs.TryGetValue(TypeName, out var taskConfig))\n\t\t\t\t{\n\t\t\t\t\tcount = taskConfig.WorkerCount;\n\t\t\t\t\tmultiplier = taskConfig.WorkerMultiplier;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Failed to retrieve task configuration from INI file for TaskName: {TypeName}. Falling back to legacy processing.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count < 0)\n\t\t\t{\n\t\t\t\t// Rely on appsetting if oneConfig is disabled or if it cannot retrive from oneconfig\n\t\t\t\tcount = Configuration.GetInt32AppSetting(TypeName + DESIRED_WORKER_COUNT, StandardWorkerCount);\n\t\t\t\tmultiplier = Configuration.GetDoubleAppSetting(TypeName + DESIRED_WORKER_MULTIPLIER, DEAFULT_CORE_TO_WORKER_MULTIPLIER);\n\t\t\t}\n\n\t\t\t// we still want to be able to force the count to zero in order to turn off a worker group effectively\n\t\t\t// let's check the worker count based on the number of logical cores and a configured multiplier\n\t\t\tif (count != 0 && multiplier > 0)\n\t\t\t{\n\t\t\t\t// use the number of logical cores and a multiplier to determine a good worker count number.\n\t\t\t\tint numCores = Environment.ProcessorCount;\n\t\t\t\tcount = Math.Max((int)(numCores * multiplier), 1);  // we really never want a > 0 multiplier to cause a zero worker count\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tprivate bool IsOneConfigEnabledForWorkerCount()\n\t\t{\n\t\t\tbool isOneConfigEnabled = false;\n\t\t\tif(ConfigWrapper.UseOneConfigMqTasksConfig)\n\t\t\t{\n\t\t\t\tvar appconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOneConfigMqTasks_\" + appconfigs?.AppName, true))\n\t\t\t\t{\n\t\t\t\t\tisOneConfigEnabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isOneConfigEnabled;\n\t\t}\n\n\t\tprivate IEnumerable<string> DispatcherMachines()\n\t\t{\n\t\t\treturn StringUtil.Split('|', Configuration.GetStringAppSetting(TypeName + TASK_DISPATCHERS, Configuration.GetStringAppSetting(DEFAULT_TASK_DISPATCHERS, GetMachineName())));\n\t\t}\n\n\t\tprivate string GetAdminQueuePath(string machine)\n\t\t{\n\t\t\treturn string.Format(Configuration.GetStringAppSetting(TypeName + \"_EventMQPathFormat\", DefaultQueue.GetAdminMqPathFormat(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName))), machine ?? GetMachineName());\n\t\t}\n\n\t\tprivate Activity StartActivity(T task, Guid correlationToken) =>\n\t\t\tServiceInstrumentation.ActivitySource\n\t\t\t\t?.StartActivity(\n\t\t\t\t\ttask.Label ?? $\"{nameof(ADEXS.Services.MessageWorkerService)}\",\n\t\t\t\t\tActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
            "content": "#if NET\n#nullable enable\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService\n{\n    private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore\n#endif\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.API.GateKeeper.Telemetry;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.API.GateKeeper.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.API.GateKeeper\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
            "relevance_score": 0.85
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
            "content": "using System.Collections.Generic;\n\nusing ADEXS.Atlas.Workflow.Activities;\nusing ADEXS.Atlas.Workflow.Readers;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.DocuSignUrl;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow;\nusing ADEXS.ElectronicSignature;\nusing ADEXS.Etl;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.MQ;\nusing ADEXS.OrchestrationIntegration;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.SForce.Core;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.API.WorkflowActivities;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Filters;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Filters.SwaggerDoc;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.IoC;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters;\n\nusing DocuSign.CLM.SmallBenClient;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\n\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.IdentityModel.Logging;\nusing Microsoft.IdentityModel.Tokens;\nusing Microsoft.OpenApi.Models;\n\nusing OpenTelemetry.Metrics;\n\nvar builder = ScmWebApplication.CreateScmWebService(args);\n\nbuilder.ConfigureDefaultScmWebService(\n\targs,\n\t() => new List<IServiceRegistry>\n\t{\n\t\tnew CoreServiceRegistry(),\n\t\tnew CoreWorkflowRegistry(),\n\t\tnew AtlasWorkflowReadersRegistry(),\n\t\tnew MessageQueueRegistry(),\n\t\tnew SmallBenClientRegistry(),\n\t\tnew CoreDomainRegistry(),\n\t\tnew EtlRegistry(),\n\t\tnew ESignatureRegistry(),\n\t\tnew SalesForceRegistry(),\n\t\tnew MergeEngineServiceRegistry(),\n\t\tnew AtlasWorkflowActivitiesRegistry(),\n\t\tnew OrchestrationIntegrationRegistry()\n\t},\n\tWorkflowActivitiesConstants.ServiceName,\n\tconfigureMeter: options =>\n\t{\n\t\toptions.AddView(instrumentName: \"workflowactivities.api.duration\",\n\t\t\tnew ExplicitBucketHistogramConfiguration\n\t\t\t{\n\t\t\t\tBoundaries = new double[] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 }\n\t\t\t});\n\t},\n\tappConfigFileName: \"WorkflowActivitiesApiConfig.ini\");\n\nbuilder.Services.AddWebCoreBasedConfigProviders();\n\n// We only enable JwtAuth when on-prem due to MSF -> onprem communication\nif (ApplicationSettings.EnvironmentType == EnvironmentType.OnPrem)\n{\n\tbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n\t.AddJwtBearer(options =>\n\t{\n\t\toptions.RequireHttpsMetadata = builder.Configuration.GetValue<bool>(\"Jwt_PublicKeyRequireHttps\", true);\n\t\toptions.Authority = new DocuSignAccountsServerUrl().AuthorityUrl();\n#pragma warning disable CA5404 // Do not disable token validation checks\n\t\toptions.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false };\n#pragma warning restore CA5404 // Do not disable token validation checks\n\t});\n\tbuilder.Services.AddAuthorization(options =>\n\t{\n\t\toptions.AddPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopePolicyName, policy =>\n\t\t\tpolicy.RequireClaim(\n\t\t\t\tADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopeClaimKey,\n\t\t\t\tADEXS.Core.Types.Constants.DocuSignAuthenticationScopes.ClmActivitiesExecute));\n\t\toptions.DefaultPolicy = options.GetPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopePolicyName);\n\t});\n}\nelse\n{\n\tbuilder.Services.AddAuthentication();\n\tbuilder.Services.AddAuthorization(options =>\n\t{\n\t\toptions.AddPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.AllowAllPolicyName, policy =>\n\t\t\tpolicy.Requirements.Add(new AllowAnonymousRequirement()));\n\t\toptions.DefaultPolicy = options.GetPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.AllowAllPolicyName);\n\t});\n\tbuilder.Services.AddSingleton<IAuthorizationHandler, AllowAnonymousHandler>();\n}\n\nbuilder.Services.AddWorkflowActivitiesServices();\n\nbuilder.Services.AddMvc(options =>\n{\n\toptions.Filters.Add(new GlobalActionFilter());\n\toptions.Filters.Add(new AuditedRequestAttribute());\n\toptions.Filters.Add(new WorkflowActivitiesExceptionFilterAttribute());\n});\n\n// Do not remove -- this is required for proper deserialization of InstanceVariables\nbuilder.Services.AddControllers().AddNewtonsoftJson();\nbuilder.Services.AddEndpointsApiExplorer();\n\nbuilder.Services.AddSwaggerGen(options =>\n{\n\toptions.CustomOperationIds(c => $\"{c.ActionDescriptor.RouteValues[\"action\"]}\");\n\toptions.SupportNonNullableReferenceTypes();\n\toptions.UseAllOfForInheritance();\n\toptions.SwaggerDoc(WorkflowActivitiesConstants.ServiceVersion, new OpenApiInfo\n\t{\n\t\tTitle = WorkflowActivitiesConstants.ServiceName,\n\t\tVersion = WorkflowActivitiesConstants.ServiceVersion\n\t});\n\toptions.DocumentFilter<PathFormatDocumentFilter>();\n\toptions.SchemaFilter<EnumNameSchemaFilter>();\n});\n\nbuilder.Services.AddSwaggerGenNewtonsoftSupport();\n\nbuilder.Services.AddSingleton<IMetricsEmitter, WorkflowActivitiesMetricsEmitter>();\n\nbuilder.Services.AddHttpClient();\n\nbuilder.Services.AddComponentsInstrumentation();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n\tIdentityModelEventSource.ShowPII = true;\n}\n\napp.UseCommonScmServices();\n\napp.UseMiddleware<LogRequestHttpMiddleware>();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.UseStaticFiles();\napp.UseStaticFiles($\"/{WorkflowActivitiesConstants.ServiceUrlPrefixNoTrailingSlash}\");\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{WorkflowActivitiesConstants.ServiceUrlPrefix}version\");\napp.MapVersionEndpoint($\"{WorkflowActivitiesConstants.ServiceVersion}/version\");\napp.MapControllers();\n\napp.RunScmWebService();\n",
            "relevance_score": 0.85
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Activities.HumanActivities;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.ActivityProperties;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.ExpressionService.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Config;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\nusing ADEXS.WINS.Interfaces;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\n\nusing Platform.Common;\n\nusing SCMAppenders;\n\nusing static ADEXS.Atlas.Workflow.Activities.Handlers.InstanceHandler;\n\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing InstanceVariable = ADEXS.Core.Domain.Model.Workflow.InstanceVariable;\nusing LoggingHelper = ADEXS.Atlas.Workflow.Activities.Infrastructure.LoggingHelper;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing UserAccount = ADEXS.Core.Domain.Model.UserAccount;\n\nnamespace ADEXS.WINS.Engine\n{\n\t/// <summary>\n\t/// An instance of a workflow -- a specific example of a definition.\n\t/// This class contains methods for controlling it, but all such calls should actually be fed through\n\t/// WorkflowManager so they can be queued, etc.\n\t/// </summary>\n\tpublic class WorkflowInstance : IWINSControlInstance\n    {\n        public const int SQL_SEVERITY_LEVEL_TRANSIENT = 12;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowInstance));\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IInstanceVariableGovernance _instanceVariableGovernance;\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepository;\n\t\tprivate IGovernor _governor;\n\t\tprivate IInstanceHandler _instanceHandler;\n\t\tprivate IServiceInstrumentation _serviceInstrumentation;\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> _workflowClientConfig;\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate ICacheRepository _cacheRepository;\n\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => (_instanceVariableGovernance ?? (_instanceVariableGovernance = ServiceLocator.GetInstance<IInstanceVariableGovernance>()));\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository ?? (_workflowSettingRepository = ServiceLocator.GetInstance<IWorkflowSettingRepository>());\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\t\tprivate IInstanceHandler InstanceHandler => _instanceHandler ?? (_instanceHandler = ServiceLocator.GetInstance<IInstanceHandler>());\n\n\n\t\tprivate IServiceInstrumentation ServiceInstrumentation => _serviceInstrumentation ?? (_serviceInstrumentation = ServiceLocator.GetInstance<IServiceInstrumentation>());\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> WorkflowClientConfig => _workflowClientConfig ?? (_workflowClientConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>());\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> SiteConfig => _siteConfig ?? (_siteConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>());\n\t\tprivate ICacheRepository CacheRepository => _cacheRepository ?? (_cacheRepository = ServiceLocator.GetInstance<ICacheRepository>());\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig ?? (_workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\n\t\t/// <summary>\n\t\t/// Loads (and locks) an existing instance.  Fails if the instance doesn't exist or can't be locked.\n\t\t/// </summary>\n\t\tpublic static WorkflowInstance LoadExisting(int accountId, Guid instanceUid, IWINSDataStore data)\n        {\n\t        DateTime lockExpirationDate;\n            InstancePersistence.LockResult lockResult = data.LockInstance(accountId, instanceUid, out lockExpirationDate);\n            switch (lockResult)\n            {\n                case InstancePersistence.LockResult.AlreadyCompleted:\n                    throw new InstanceAlreadyCompletedException(string.Format(\"InstanceUid {0} is already completed\", instanceUid));\n                case InstancePersistence.LockResult.DoesNotExist:\n                    throw new ApplicationException(string.Format(\"Invalid instanceUid {0}\", instanceUid));\n                case InstancePersistence.LockResult.LockedByOther:\n                    throw new InstanceLockedException(string.Format(\"InstanceUid {0} is locked by another process\", instanceUid));\n                case InstancePersistence.LockResult.Locked:\n                    // This is our success condition\n                    break;\n                default:\n                    throw new ApplicationException(string.Format(\"Unhandled lockResult for instanceUid {0}: {1}\", instanceUid, lockResult));\n            }\n            Instance instance = data.LoadInstanceByUid(accountId, Constants.WorkflowUser, instanceUid);\n            if (instance == null) throw new ApplicationException(string.Format(\"Failed to load workflow instanceUid {1} for account {0}.\", accountId, instanceUid));\n\n\t\t\ttry\n            {\n                if (instance.ScopeUid != Guid.Empty)\n                {\n                    Scope scope = ServiceLocator.GetInstance<IDocumentScopeRepository>().GetScopeByUid(accountId, instance.ScopeUid);\n                    if (scope != null)\n                        instance.ScopeName = scope.Name;\n                }\n            }\n            catch (Exception ex)\n            {\n                // the failure to load the scope should not cause the failure to load the instance, log it and move on\n                _log.WarnNoPII(string.Format(\"Could not load the scope '{0}' for workflow instance '{1}'.\", instance.ScopeUid, instanceUid), ex);\n            }\n\n\t\t\tRevision revision = data.LoadRevisionByUid(accountId, Constants.WorkflowUser, instance.RevisionUid);\n            if (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, instance.RevisionUid));\n            // ATL-68146: Populate RevisionCreatedDate here, because LoadInstanceByUid() doesn't populate it.\n            instance.RevisionCreatedDate = revision.CreatedDate;\n            WorkflowMap workflowMap = null;\n            instance.DefinitionUid = revision.DefinitionUid;\n\n\t\t\ttry\n            {\n\t            workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n            }\n            catch (InvalidDesignDefinitionException ex)\n            {\n\t            try\n\t            {\n\t\t            new WorkflowInstance(instance, data).Abort(UserAccount.WorkflowUserAccount(accountId), ex.Message);\n\t            }\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Error aborting workflow instance '{instanceUid}' with invalid definition\", e);\n\t\t\t\t}\n\n\t            throw;\n            }\n\n            var workflowInstance = new WorkflowInstance(instance, workflowMap, data);\n\t        workflowInstance.LockExpirationDate = lockExpirationDate;\n\t        return workflowInstance;\n\n        }\n\n        private readonly IWINSDataStore _data;\n        private readonly WorkflowMap _workflowMap;\n        private Instance _instance;\n\n        // The count of the activities that have been generated by this particular in-memory instance.  This doesn't get persisted anywhere, so is\n        // cleared whenever this WorkflowInstance gets unloaded (eg, when it enters into a Waiting state).\n        // It's use is to detect runaway workflows.\n        public const int MAX_IN_MEMORY_ACTIVITY_COUNT = 5000;\n        private int _inMemoryActivityCount = 0;\n\t\tprivate int _activityExecutionCountEnforcedLimit = 0;\n\t\tprivate Guid _revisionUid = Guid.Empty;\n\t\tprivate Guid _definitionUid = Guid.Empty;\n\t\tprivate DateTime _revisionCreatedDate = DateTime.MinValue;\n\t\tprivate bool _isActivityExecutionLimitReached = false;\n\n\t\tprivate readonly object _lockObject = new object();\n        private readonly IDictionary<Guid, InstanceActivity> _unfinishedActivities = new Dictionary<Guid, InstanceActivity>();\n        private readonly Queue<Event> _queuedControlEvents = new Queue<Event>();\n        private readonly Queue<Event> _queuedEvents = new Queue<Event>();\n\n        private readonly Dictionary<string, ContentDefinition> _contentDefinitions = new Dictionary<string, ContentDefinition>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, InstanceVariable> _variables = new Dictionary<string, InstanceVariable>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, IXmlVariableDefinition> _xmlVariableDefinitions = new Dictionary<string, IXmlVariableDefinition>(StringComparer.InvariantCultureIgnoreCase);\n\n        private readonly TimedLock _lock;\n\n        // Kind of a hack -- this is kept around so that if we end the instance without reaching the End step, we have an activity that we can\n        // log the message to.\n        private Guid _lastActivityUid;\n\n        private WorkflowInstance(Instance instance, IWINSDataStore data)\n        {\n\t        _data = data;\n\t        _lock = new TimedLock(instance.Uid.ToString());\n\t        _instance = instance;\n\t\t\t_revisionUid = _instance.RevisionUid;\n\t\t\t_revisionCreatedDate = instance.RevisionCreatedDate;\n\t        LastProcessDate = DateTime.UtcNow;\n\t\t\t_definitionUid = _instance.DefinitionUid;\n\t\t}\n\n\t\tpublic WorkflowInstance(Instance instance, WorkflowMap workflowMap, IWINSDataStore data) : this(instance, data)\n        {\n            _workflowMap = workflowMap;\n            // Load up any incomplete activities.  This is pointless to do for a new workflow, but it's not expensive either,\n            // so we simply avoid trying to figure that out and simply do it.\n            QueueIncompleteActivities();\n        }\n\n        /// <summary>\n        /// The AccountId this instance is running in.\n        /// </summary>\n        public int AccountId { get { return _instance.AccountId; } }\n\n        public Dictionary<string, ContentDefinition> ContentDefinitions { get { return _contentDefinitions; } }\n\n        public IWINSDataStore DataStore { get { return _data; } }\n\n        public TimedLock ThreadLock { get { return _lock; } }\n\n        /// <summary>\n        /// An in-memory, non-persisted value -- this is used when workers are finding instances to do work on.\n        /// It acts to make the WorkflowManager more FIFO, so that some workflows don't continually get ignored in favor of\n        /// newer work coming in.\n        /// </summary>\n        public DateTime LastProcessDate { get; private set; }\n\n        /// <summary>\n        /// The model Instance object; I didn't call this Instance because I didn't want it confused with a singleton pattern, and because\n        /// I didn't like seeing \"instance.Instance\".\n        /// </summary>\n        public Instance Model { get { return _instance; } }\n\n\t\tpublic DateTime LockExpirationDate { get; set; }\n\n\t\t/// <summary>\n\t\t/// The instance's Uid.  Primary key.\n\t\t/// </summary>\n\t\tpublic Guid Uid { get { return _instance.Uid; } }\n\n        public Dictionary<string, InstanceVariable> Variables { get { return _variables; } }\n\n        public Dictionary<string, IXmlVariableDefinition> XmlVariableDefinitions { get { return _xmlVariableDefinitions; } }\n\n        public Enums.WorkflowStepStatus Status => _instance.Status;\n\n        public bool HasQueuedWork\n        {\n            get { return _queuedEvents.Count > 0 || _queuedControlEvents.Count > 0; }\n        }\n\n        public bool HasUnfinishedActivities\n        {\n            get { return _unfinishedActivities.Count > 0; }\n        }\n\n        public void QueueActivity(InstanceActivity instanceActivity)\n        {\n            lock (_lockObject)\n            {\n                _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            }\n        }\n\n\t\tpublic int ActivityExecutionCount { get; set; }\n\n\t\tpublic int ActivityExecutionCountEnforcedLimit => _activityExecutionCountEnforcedLimit;\n\n\t\tpublic bool IsActivityExecutionLimitReached => _isActivityExecutionLimitReached;\n\n\t\tpublic Guid RevisionUid => _revisionUid;\n\n\t\tpublic Guid DefinitionUid => _definitionUid;\n\n\t\tpublic DateTime RevisionCreatedDate => _revisionCreatedDate;\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\t/// <param name=\"previousActivity\"></param>\n\t\t/// <param name=\"linkName\"></param>\n\t\t/// <param name=\"localContextId\"></param>\n\t\t/// <param name=\"followEmptyPathByDefault\"></param>\n\t\t/// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n\t\tpublic void QueueActivitiesByLink(InstanceActivity previousActivity, string linkName, int localContextId = 0, bool followEmptyPathByDefault = true, bool useLinkName = false)\n        {\n            IEnumerable<WorkflowMap.Link> links;\n            bool found = false;\n            if (_workflowMap.TryGetLinks(previousActivity.Name, linkName, out links))\n            {\n                foreach (WorkflowMap.Link link in links)\n                {\n                    QueueActivityByName(previousActivity, link.ToName, localContextId, linkName, useLinkName);\n                    found = true;\n                }\n            }\n            // If we got no matches, try to go for the default (empty) output.\n            if (followEmptyPathByDefault && !found && !string.IsNullOrEmpty(linkName)) QueueActivitiesByLink(previousActivity, string.Empty, localContextId);\n        }\n\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"previousActivity\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"localContextId\"></param>\n        /// <param name=\"linkName\"></param>\n        /// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n        public void QueueActivityByName(InstanceActivity previousActivity, string name, int localContextId = 0, string linkName = null, bool useLinkName = false)\n        {\n            IWINSActivity activity;\n            if (!_workflowMap.TryGetActivity(name, out activity)) throw new ApplicationException(string.Format(\"InstanceUid {0}: Tried to execute invalid activity '{1}'\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, name)));\n\n            if (localContextId <= 0) localContextId = (previousActivity == null ? int.MinValue : previousActivity.LocalContextId);\n\n            // Create a new activity\n            InstanceActivity instanceActivity = new InstanceActivity\n            {\n                AccountId = _instance.AccountId,\n                InstanceUid = _instance.Uid,\n                Name = name,\n                ActivityTypeName = activity.LegacyElementName(),\n                Status = Enums.WorkflowStepStatus.Pending,\n                InputActivityOutput = useLinkName ? linkName : (previousActivity == null ? string.Empty : previousActivity.Output),\n                InputActivityUid = (previousActivity == null ? Guid.Empty : previousActivity.Uid),\n                LocalContextId = localContextId,\n                IsWinsActivity = true,\n                CreatedDate = DateTime.UtcNow //make sure that the in memory copy has a value\n            };\n\n            try\n            {\n                _data.CreateActivity(instanceActivity);\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorWithPII($\"Failed to queue activity {{0}} for instance {_instance?.Uid} in account {_instance?.AccountId}\", ex, name);\n                _data.ActivityFailure(_instance, instanceActivity);\n            }\n\n            _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            QueueActivity(instanceActivity);\n        }\n\n        public void QueueEvent(Event e)\n        {\n            if (_instance.Status != Enums.WorkflowStepStatus.Failed && _instance.Status != Enums.WorkflowStepStatus.Aborted)\n            {\n                lock (_lockObject)\n                {\n                    Queue<Event> queue = (e.IsControlEvent ? _queuedControlEvents : _queuedEvents);\n                    if (e.Uid != Guid.Empty)\n                    {\n                        // Ensure this item isn't already in the list\n                        if (queue.Any(e2 => e2.Uid == e.Uid)) return;\n                    }\n                    queue.Enqueue(e);\n                    WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventQueued\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n                    wrk.Log();\n\t            }\n            }\n        }\n\n        public void QueueIncompleteActivities()\n        {\n            InstanceActivities activities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n            if (activities == null || activities.Count == 0) return;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in activities) _unfinishedActivities[activity.Uid] = activity;\n            }\n\n        }\n\n        public bool CheckActivityForCompletion(InstanceActivity instanceActivity)\n        {\n            // We only care about Waiting steps.\n            if (instanceActivity.Status != Enums.WorkflowStepStatus.Waiting) return false;\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.DebugNoPII($\"CheckActivityForCompletion called for ActivityUid {instanceActivity.Uid} ({instanceActivity.Name}).\");\n\t            try\n\t            {\n\t\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\t\t            ctx.CheckForCompletion();\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t            _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n\t\t\t            SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            return true;\n\t\t            }\n                    _log.DebugWithPII($\"CheckActivityForCompletion completed for Activity ({{0}}) in status: {instanceActivity.Status}.\", instanceActivity.Name);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n                    _log.ErrorNoPII($\"CheckActivityForCompletion failed.\", e);\n\t            }\n            }\n            return false;\n        }\n\n        public bool DoNextTask()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t        CheckAndHandleInstanceStateChanges();\n\n\t\t\t// If we're in a non-processing state, we want to respond only to control events.\n\t\t\t// If we have no control events, we can just skip everything else.\n\t\t\tif (!_ShouldProcessEvent())\n\t        {\n\t\t        return _ExecuteFirstEvent(controlOnly: true);\n\t        }\n\n\t        // If we have any queued events, do one of those.\n\t        if (_ExecuteFirstEvent(controlOnly: false)) return true;\n\n\t        if (!_ShouldProcess()) return false;\n\n\t        // Otherwise, check to see if any activities need to be executed; if so, do those.\n\t        if (_ExecuteFirstActivity()) return true;\n\n\t        // If we get here, it might be that we have some unfinished activities in the database that for some reason weren't loaded into memory.\n\t        // Check for that, and, if so, load them now.\n\t        QueueIncompleteActivities();\n\t        // Try to execute an activity again -- we may have just loaded some\n\t        if (_ExecuteFirstActivity()) return true;\n\t        // If we can complete a waiting activity, do that.\n\t        if (_CheckWaitingActivities()) return true;\n\n\t        // Otherwise, we've got nothing to do and can quit.\n\t        if (!HasQueuedWork && !HasUnfinishedActivities)\n\t        {\n\t\t        _MarkCompleted();\n\t\t\t\t// If we processed nothing (the activity count is 0) we don't want to mark ourselves as waiting.  This is mostly because\n\t\t\t\t// we don't want to update our UpdatedDate (see ATL-20570).  This case occurs when our workflow is already waiting and has been\n\t\t\t\t// picked up for the day and each activity checked to see if it's done waiting.  We don't want this to trigger an update if\n\t\t\t\t// nothing has actually changed.\n\t        }\n\t        else if (_inMemoryActivityCount > 0 || _instance.Status != Enums.WorkflowStepStatus.Waiting)\n\t        {\n\t\t\t\tvar workflowConfig = WorkflowConfig(_instance.AccountId);\n\t\t\t\tvar enableSmallBenRateLimits = workflowConfig?.EnableSmallBenRateLimits ?? false;\n\n\t\t\t\tif (_instance.Status == Enums.WorkflowStepStatus.Paused\n\t\t\t\t    && ((string.Equals(ADEXS.Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.EnableExpressionApiRateLimit, \"live\", StringComparison.OrdinalIgnoreCase)\n\t\t\t\t         && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit)\n\t\t\t\t\t|| (enableSmallBenRateLimits && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit)))\n\t\t\t\t{\n\t\t\t\t\t// keep throttled workflows in paused status\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_MarkWaiting();\n\t\t\t}\n\n\t\t    return false;\n        }\n\n        public void ExecuteActivity(InstanceActivity instanceActivity)\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteActivity called for Activity ({{0}}).\", instanceActivity.Name);\n\t            IWINSWorkflowContext ctx = null;\n\t            Stopwatch sw = Stopwatch.StartNew();\n\t            try\n\t            {\n\t\t            _lastActivityUid = instanceActivity.Uid;\n\n\t\t\t\t\tif (!_ShouldProcess()) throw new ApplicationException(string.Format(\"InstanceUid {0} is in an invalid state to execute activity {1}\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, instanceActivity.Name)));\n\n\t\t            // Check for runaway workflows.\n\t\t            if (++_inMemoryActivityCount >= MAX_IN_MEMORY_ACTIVITY_COUNT)\n\t\t            {\n\t\t\t            _log.WarnNoPII(string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t\t            throw new PublicException(PublicException.FailReason.InvalidState, string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t            }\n\n\t\t\t\t\t// Governance, check if activity execution limit has been reached\n\t\t\t\t\tif (PauseWhenActivityExecutionLimitReached())\n\t\t\t\t\t{\n\t\t\t\t\t\t// In this case, the workflow is paused, purge date is set and an e-mail has been sent to support team.\n\t\t\t\t\t\t// The current activity will not be executed, unless the limits are increased and the workflow resumed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_data.ActivityExecuting(_instance, instanceActivity);\n\n\t\t            ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\t\tif (!ShouldUseScopeEventHandler() && IsTrackItActivity(activity))\n\t\t\t\t\t{\n\t\t\t\t\t\tFireWorkflowScopeEvent(null, ScopeEventType.StepInitiated, activity, ctx);\n\t\t\t\t\t}\n\n\t\t\t\t\tactivity.Execute(ctx);\n\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n\t\t\t\t\tif (e is ArgumentNullException && ctx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar message =\n\t\t\t\t            string.Format(Resources.WINSResources.ActionFailed_ReferenceID_0, Guid.NewGuid()) +\n\t\t\t\t            $\". Inst: {instanceActivity.AccountId} '{instanceActivity.InstanceUid}'.\";\n\t\t\t            _log.ErrorNoPII(message, e);\n\t\t\t\t\t\t_data.CreateInstanceHistory(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, message, true);\n\t\t            }\n\n\t\t\t\t\t// Oh my...\n\t\t\t\t\t// Look at this catch block.\n\t\t\t\t\tbool isTransient = e is TransientException;\n\t\t            bool useFailureOutput = ctx != null && activity.HasFailureOutput;\n\n\t\t            if (isTransient) throw new TransientException(e);\n\t\t            if (useFailureOutput)\n\t\t            {\n\t\t\t\t\t\tctx.ActivityVariables.Set(\"Failure\", e.Message);\n\t\t\t\t\t\tctx.MarkAsCompleted(AbstractActivity.OUTPUT_FAILURE);\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.ActivityFailure(_instance, instanceActivity);\n\t\t\t            if (ctx == null) ctx = _CreateContext(activity, instanceActivity);\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\ttry\n\t\t\t            {\n\t\t\t\t            if (_instance.Status == Enums.WorkflowStepStatus.Failed)\n\t\t\t\t            {\n\t\t\t\t\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInstanceHandler.Fail(ctx, activity, GetUnfinishedWINSWorkflowContextsWINSActivities(instanceActivity.EndDate));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAccountId = ctx.AccountId,\n\t\t\t\t\t\t\t\t\t\tScopeUid = ctx.ScopeUid,\n\t\t\t\t\t\t\t\t\t\tScopeName = ctx.ScopeName,\n\t\t\t\t\t\t\t\t\t\tStepName = instanceActivity.Name,\n\t\t\t\t\t\t\t\t\t\tStepDisplayName = GetActivityDisplayName(activity, ctx),\n\t\t\t\t\t\t\t\t\t\tStepTypeName = instanceActivity.ActivityTypeName,\n\t\t\t\t\t\t\t\t\t\tStepUid = instanceActivity.Uid,\n\t\t\t\t\t\t\t\t\t\tPeriodStart = instanceActivity.EndDate,\n\t\t\t\t\t\t\t\t\t\tEventType = (int)ScopeEventType.WorkflowFailed,\n\t\t\t\t\t\t\t\t\t\tOutput = instanceActivity.Output,\n\t\t\t\t\t\t\t\t\t\tWorkflowUid = ctx.WorkflowInstanceUid,\n\t\t\t\t\t\t\t\t\t\tWorkflowName = ctx.WorkflowName\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tEventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n\n\t\t\t\t\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Failed, instanceActivity.EndDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t            }\n\t\t\t            catch (Exception ex)\n\t\t\t            {\n\t\t\t\t        _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.WorkflowFailed}\", ex);\n\t\t\t            }\n\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n\t\t            }\n\t            }\n\t            finally\n\t            {\n\t\t            ActivityExecutionCount++;\n\t            }\n\t\t\t}\n        }\n\n        public void ExecuteCallback(InstanceActivity instanceActivity, string name, object value)\n        {\n            LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteCallback called for Activity ({{0}}) with callback {name}.\", instanceActivity.Name);\n\n\t            if (!(_ShouldProcess(instanceActivity) && _ShouldProcessEvent()))\n\t            {\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoWithPII($\"ExecuteCallback did not complete because the activity was already completed. Activity {{0}} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}. Instance status: {Model.Status}\", instanceActivity.Name);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _log.ErrorWithPII($\"InstanceUid {Uid} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}.  Instance status: {Model.Status}\");\n\t\t\t\t\t}\n\t\t            return;\n\t\t\t\t}\n\n\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\ttry\n\t\t        {\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t            activity.ExecuteCallback(ctx, name, value);\n\n\t\t            if (_instance.Status != Enums.WorkflowStepStatus.Aborted)\n\t\t            {\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\n\t\t\t\t\t// Throw so that the calling method will handle re-queuing the failed event\n\t\t\t\t\t// When resumed we will retry the recurring reminder callback\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t            catch (Exception e)\n\t            {\n\t\t\t\t\t// Note that we don't fail the workflow here -- see ATL-21019\n\t\t\t\t\tif (instanceActivity.Status == Enums.WorkflowStepStatus.Completed ||\n\t\t                Model.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoNoPII($\"The callback is unnecessary: workflow activity '{instanceActivity.Uid}' [{instanceActivity.Status}] or instance '{instanceActivity.InstanceUid}' [{Model.Status}] has already completed.\");\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t\t\t\tvar pe = e as PublicException;\n\t\t\t\t\t\t_log.ErrorNoPII($\"ExecuteCallback failed.\", pe?.InnerException ?? e);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void ExecuteEvent(Event e, bool queueOnFailure = true)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            if (e == null) return;\n\n            using var span = StartActivity();\n\n            using (ScmNDC.Push(BuildNDCTags(e)))\n            {\n\t            // If we have Uid but the lock expired we don't want to process the event as it was persisted and some other worker probably has already picked it.\n\t            if (e.Uid != Guid.Empty && e.LockExpirationDate <= LastProcessDate)\n\t            {\n\t\t            _log.InfoNoPII($\"Aborting event execution - ExecuteEvent called with an event that has an expired lock ({e.LockExpirationDate}) for callback {e.CallbackName}.\");\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t\t            return;\n\t            }\n\n\t            _log.InfoNoPII($\"ExecuteEvent called with callback {e.CallbackName}.\");\n\t            try\n\t            {\n\t\t            Stopwatch sw = Stopwatch.StartNew();\n\t\t            if (e.ActivityUid == Guid.Empty)\n\t\t            {\n\t\t\t            // We expect these to be control codes\n\t\t\t            string comment = (e.CallbackObject == null ? \"\" : e.CallbackObject.ToString());\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            case Event.ControlNames.Abort:\n\t\t\t\t\t            Abort(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForAccountCancel:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tSetPurgeDateForAccountCancel();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForRevisionSuspended:\n\t\t\t\t\t\t\t\tPauseForRevisionSuspended(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.ResumeForSuspendedRevision:\n\t\t\t\t\t\t\t\t ResumeForSuspendedRevision(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.Pause:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t            case Event.ControlNames.Resume:\n\t\t\t\t\t            Resume(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.ResumeFromError:\n\t\t\t\t\t            ResumeFromError(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.StartActivity:\n\t\t\t\t\t            QueueActivityByName(null, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            default:\n\t\t\t\t\t            throw new ApplicationException(string.Format(\"Unhandled event {0}\", e.CallbackName));\n\t\t\t            }\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            // These *may* be control codes.  If they're not control codes, then\n\t\t\t            // we expect them to be a callback to an activity.\n\t\t\t            InstanceActivity activity;\n\t\t\t            if (!_unfinishedActivities.TryGetValue(e.ActivityUid, out activity)) activity = _data.LoadActivityByUid(_instance.AccountId, Constants.WorkflowUser, e.ActivityUid);\n\t\t\t            if (activity == null || activity.InstanceUid != e.InstanceUid) throw new ApplicationException(string.Format(\"Invalid ActivityUid {0} for InstanceUid {1}\", e.ActivityUid, e.InstanceUid));\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            // TODO: Start specific steps, fire specific outputs, complete specific steps, etc.\n\t\t\t\t            default:\n\t\t\t\t\t            ExecuteCallback(activity, e.CallbackName, e.CallbackObject);\n\t\t\t\t\t            break;\n\t\t\t            }\n\t\t            }\n\t\t            if (e.Uid != Guid.Empty) _data.EventSuccess(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventExecuted\")\n\t\t\t\t\t{\n\t\t\t\t\t\tTotalMs = sw.ElapsedMilliseconds,\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid, WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t            wrk.Log();\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t            catch (Exception excp)\n\t            {\n\t\t            _log.ErrorNoPII($\"Error processing eventUid {e.Uid} ({e.CallbackName}).\", excp);\n\t\t            if (!queueOnFailure) throw;\n\t\t            if (e.Uid == Guid.Empty)\n\t\t            {\n\t\t\t            e.NextProcessDate = _data.NextProcessDate();\n\t\t\t            e.ErrorCount = 1;\n\t\t\t            e.LastErrorMessage = excp.Message;\n\t\t\t            _data.CreateEvent(e);\n\t\t\t            WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnExecuteException\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t\t};\n\t\t\t            wrk.Log();\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.EventFailure(e.AccountId, e.Uid, _data.NextProcessDate(), excp.Message);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void Abort(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in _unfinishedActivities.Values)\n                {\n\t                try\n\t                {\n\t\t                IWINSActivity winsActivity = _SafeGetActivity(activity);\n\t\t                IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n\t\t                winsActivity.OnActivityAborted(ctx);\n\t                }\n\t                catch (Exception ex)\n\t                {\n\t\t                _log.ErrorNoPII(string.Format(\"Failed OnActivityAborted AccountId {0}, ActivityUid {1}\", user.AccountId, activity.Uid), ex);\n\t\t\t\t\t}\n                }\n                new WorkflowControlInstance(Model).Abort(user, comment);\n\n\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t{\n\t\t\t\t\tInstanceHandler.Abort(_instance, user, GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime.UtcNow));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Aborted, DateTime.UtcNow);\n\t\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowAborted);\n\t\t\t\t}\n\n\t\t\t\t_ForceReload();\n            }\n        }\n\n        public int SetPurgeDateForAccountCancel()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        var daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForAccountCancel();\n\t\t        _ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t        }\n        }\n\n        public void ClearPurgeDate()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        new WorkflowControlInstance(Model).ClearPurgeDate();\n\t\t        _ForceReload();\n\t        }\n        }\n\n\t\tpublic void Pause(UserAccount user, string comment)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Pause - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).Pause);\n\t\t}\n\n\t\tpublic void PauseForRevisionSuspended(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status == Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - No action taken, instance already paused\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).PauseForRevisionSuspended);\n\t\t}\n\n\t\tpublic void ResumeForSuspendedRevision(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status != Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, instance not paused. Status:{Model.Status}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if instance UpdatedBy has changed since the PauseForRevisionSuspended was invoked, if it has we do not want to do anything.\n\t\t\tif (Model.UpdatedBy != WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, UpdatedBy is not {WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - Resuming\");\n\t\t\tResume(user, comment);\n\t\t\tClearPurgeDate();\n\t\t}\n\n\t\tpublic bool PauseWhenActivityExecutionLimitReached()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Governance, check whether the number of executed activities exceeded the configured limit\n\t\t\t\t_isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(AccountId, Uid, _instance.RevisionUid, _instance.RevisionCreatedDate, ActivityExecutionCount, out _activityExecutionCountEnforcedLimit);\n\n\t\t\t\tif (_isActivityExecutionLimitReached)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum limit (Actual={ActivityExecutionCount}, EnforcedLimit={_activityExecutionCountEnforcedLimit}) and will be paused.\");\n\n\t\t\t\t\tPause(UserAccount.WorkflowUserAccount(AccountId), \"Workflow activity execution limit reached.\");\n\n\t\t\t\t\tTrySendActivityExecutionLimitExceedNotification(SetPurgeDateForAccountCancel());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' activity execution limit\", e);\n\t\t\t}\n\n\t\t\treturn _isActivityExecutionLimitReached;\n\t\t}\n\n\t\tpublic void PauseWhenThrottled(InstanceActivity activity, WorkflowApiRequestThrottledException exception)\n\t\t{\n\t\t\tRequires.NotNull(activity, nameof(InstanceActivity));\n\t\t\tRequires.NotNull(exception, nameof(WorkflowApiRequestThrottledException));\n\n\t\t\tif (exception.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.NotThrottled)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' is not throttled and will not be paused.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tactivity.Status = Enums.WorkflowStepStatus.Paused;\n\t\t\t\tvar throttledByApi = exception.ThrottledApiAsString();\n\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum {throttledByApi} request limit and will be paused. Message: {exception.Message}\");\n\n\t\t\t\tPauseInstance(UserAccount.WorkflowUserAccount(AccountId), $\"{throttledByApi} requests limit reached.\", new WorkflowControlInstance(Model).PauseForWorkflowRateLimitExceed);\n\n\t\t\t\t// Send notification\n\t\t\t\tswitch (exception.WorkflowThrottledStatus)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit:\n\t\t\t\t\t\tTrySendExpressionRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit:\n\t\t\t\t\t\tTrySendSmallBenRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_log.WarnNoPII(\"No notifications sent for unsupported throttle status\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mark instance as throttled for current workflow run session, WorkflowThrottledStatus property is not persisted and refreshed on reload\n\t\t\t\t_instance.WorkflowThrottledStatus = exception.WorkflowThrottledStatus;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception e)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' rate limit request limit with status {exception?.WorkflowThrottledStatus}\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublic int SetPurgeDateForWorkflowRateLimit()\n\t\t{\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tvar daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForWorkflowRateLimit();\n\t\t\t\t_ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid GetAdvancedWorkflowNotificationUserAccountUid()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while retrieving AdvancedWorkflowNotificationUserAccountUid for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\t\t}\n\n\t\tpublic void TrySendSmallBenRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\t// Send notification - pending ATL-90622\n\t\t}\n\n\t\tpublic void TrySendExpressionRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\tif (!ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetEnableWorkflowLimitNotifications(AccountId))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"EnableWorkflowLimitNotifications disabled for account {AccountId}, not sending expression rate limit exceeded notification\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (advancedWorkflowNotificationUserAccountUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {advancedWorkflowNotificationUserAccountUid} to receive expression rate limit exceeded notification\");\n\t\t\t\tUserAccount notificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, advancedWorkflowNotificationUserAccountUid);\n\n\t\t\t\tif (string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"AdvancedWorkflowNotificationUser '{advancedWorkflowNotificationUserAccountUid}' not found or missing email address. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar emailRecipients = new List<string>() { notificationUser.EmailAddress };\n\n\t\t\t\t_log.InfoNoPII($\"Sending expression rate limit exceeded notification to user '{advancedWorkflowNotificationUserAccountUid}' for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseExpressionRateLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowInstanceId = _instance.Id,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Resume(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).Resume(user, comment);\n                _ForceReload();\n            }\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Resume(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n        }\n\n        public void ResumeFromError(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).ResumeFromError(user, comment);\n                _ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.ResumeFromError(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n\t\t}\n\n        public void SaveToDatabase()\n        {\n            // We may have in-memory events that need to be saved to the db.\n\t\t\tPersistEvents();\n            _PersistVariables();\n        }\n\n        public void SaveEventsToDatabase()\n        {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPersistEvents();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save unsaved events for instance {Uid} to db\", e);\n\t\t\t}\n\t\t}\n\n\t    public void ArchiveVariables()\n        {\n            var incompleteActivities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, _instance.Uid);\n            // don't archive if there are any incomplete activites besides the one that has triggered this\n            if (incompleteActivities != null && incompleteActivities.Count > 1)\n            {\n                return;\n            }\n            _data.ArchiveVariables(AccountId, Constants.WorkflowUser, Uid);\n        }\n\n\t    public bool HasExistingLockExpired()\n\t    {\n\t\t    return LockExpirationDate < DateTime.UtcNow;\n\t    }\n\n\n        /// <summary>\n        /// Replaces variables provided in the dictionary returning replaced variables\n        /// </summary>\n        public void SetVariables(\n\t        InstanceActivity instanceActivity,\n\t        Dictionary<string, object> variables,\n\t        out List<InstanceVariable> oldVariables,\n\t        out bool areVariablesOverTotalSizeLimit,\n\t        out int totalVariablesSizeBytes,\n\t        out int totalVariablesSizeLimitBytes,\n\t\t\tout Dictionary<string, int> oversizedVariables,\n\t        out int variableValueSizeLimitBytes)\n        {\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            _log.DebugWithPII($\"SetVariables called for ActivityUid {instanceActivity.Uid} ({{0}}).\", instanceActivity.Name);\n\n            // We create the context so that the variable dictionaries get populated\n            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n            oldVariables = new List<InstanceVariable>();\n            var newVariables = UpdateVariablesHelper.PopulateContextVariables(ctx, this.Model, variables);\n\n            // Only set variables that are under the size limit\n\t\t\toversizedVariables = InstanceVariableGovernance.GetOversizedVariables(ctx.AccountId, newVariables, ctx.SubmittedDate, out variableValueSizeLimitBytes);\n\t\t\tforeach (InstanceVariable variable in newVariables)\n\t\t\t{\n\t\t\t\tif (!oversizedVariables.ContainsKey(variable.Name))\n\t\t\t\t{\n\t\t\t\t\toldVariables.Add(Variables[variable.Name]);\n\t\t\t\t\t// we could do \"ctx.Variables.Set(variable.Key, variable.Value);\" but that would log as the instanceActivity and we don't want that...\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Undo setting the variables, if the instance's total variable size exceeds the limit\n\t\t\tareVariablesOverTotalSizeLimit = InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(ctx.AccountId,\n\t\t\t\tVariables.Select(x => x.Value), ctx.SubmittedDate, activityConfiguration: null, out totalVariablesSizeBytes, out totalVariablesSizeLimitBytes);\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tforeach (InstanceVariable variable in oldVariables)\n\t\t\t\t{\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n        }\n\n        public DateTime GetLastAbortNotificationDate()\n        {\n\t        if (!_contextInitialized)\n\t        {\n\t\t        _LoadVariables();\n            }\n\n\t        if (_variables.TryGetValue(WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE, out InstanceVariable lastNotificationDate) &&\n\t            DateTime.TryParse(lastNotificationDate.Value.ToString(), out DateTime dateTime))\n\t        {\n\t\t        return dateTime;\n\t        }\n\n            return DateTime.MinValue;\n        }\n\n        public void SaveLastAbortNotificationDate(int accountId, Guid workflowInstanceUid, DateTime lastAbortNotificationDate)\n        {\n            var variable = InstanceVariable.CreateFromValue(\n\t            accountId,\n\t            workflowInstanceUid,\n\t            WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE,\n\t            Enums.WorkflowVariableType.Date,\n\t            lastAbortNotificationDate);\n\n            ServiceLocator.GetInstance<IInstanceVariablePersistence>().Save(Constants.WorkflowUser, variable);\n\n        }\n\n        /// <summary>\n        /// Called when we've finished work on an activity -- either executing it or performing a callback on it.\n        /// </summary>\n        private void _ActivityWorkCompleted(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx, Stopwatch sw)\n        {\n\t        // If it's flagged as completed, update in the db, queue up any next activities, and remove it from our list.\n            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n            {\n                _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n                SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t\tlock (_unfinishedActivities)\n                {\n                    if (_unfinishedActivities.ContainsKey(instanceActivity.Uid)) _unfinishedActivities.Remove(instanceActivity.Uid);\n                }\n            }\n            else\n            {\n                // Otherwise, it's still running.  Flag it as waiting so it doesn't get processed again.\n                instanceActivity.Status = Enums.WorkflowStepStatus.Waiting;\n                _data.SaveInstanceActivity(instanceActivity);\n            }\n\n            _log.InfoWithPII($\"_ActivityWorkCompleted done for Activity ({{0}}) in status: {instanceActivity.Status} ({sw.ElapsedMilliseconds} ms).\", instanceActivity.Name);\n\n\n            // log workload data\n            try\n            {\n                WorkflowWorkload ww = new WorkflowWorkload();\n                ww.Add(ctx);\n                ww.TotalMs = sw.ElapsedMilliseconds;\n\t\t\t\tww.StartTime = DateTime.UtcNow.AddMilliseconds(-ww.TotalMs);\n                ww.Status = instanceActivity.Status.ToString();\n                ww.Output = instanceActivity.Output;\n                ww.ActivityCreatedDate = instanceActivity.CreatedDate;\n                ww.ActivityStartDate = instanceActivity.StartDate;\n                if (DateTime.MinValue < instanceActivity.EndDate && instanceActivity.EndDate < DateTime.MaxValue)\n                    ww.ActivityEndDate = instanceActivity.EndDate;\n                if (DateTime.MinValue < _instance.CreatedDate && _instance.CreatedDate < DateTime.MaxValue)\n\t                ww.InstanceCreatedDate = _instance.CreatedDate;\n                ww.ActivityKind = activity.Kind.ToString();\n                ww.RevisionUid = _instance.RevisionUid.ToString();\n\t\t\t\tww.DefinitionUid = _instance.DefinitionUid.ToString();\n\t\t\t\tww.WorkflowDB = DataStore.GetDbNameForAccount(instanceActivity.AccountId);\n\n\t\t\t\tww.Log();\n            }\n            catch (Exception ex)\n            {\n                _log.WarnNoPII(\"Failed to log workload.\", ex);\n            }\n        }\n\n\t\tprivate void CompleteScopeStep(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n            try\n            {\n                if (IsTrackItActivity(activity))\n                {\n                    Documents documents = null;\n                    if (ctx.TrackActivity())\n                    {\n                        documents = ((ITrackItActivity)activity).GetDocuments(ctx);\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, instanceActivity.Uid,\n                            documents, instanceActivity.Output, instanceActivity.Status,\n                            instanceActivity.EndDate);\n                    }\n\n                    WorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n                    {\n                        AccountId = ctx.AccountId,\n                        Documents = documents?.Select(d => new WorkflowScopeEvent.DocumentDetail() { Uid = d.Uid, Name = d.Name }).ToList(),\n                        ScopeUid = ctx.ScopeUid,\n                        ScopeName = ctx.ScopeName,\n                        StepName = instanceActivity.Name,\n                        StepDisplayName = GetActivityDisplayName(activity, ctx),\n                        StepTypeName = instanceActivity.ActivityTypeName,\n                        StepUid = instanceActivity.Uid,\n                        PeriodStart = instanceActivity.EndDate,\n                        EventType = (int)ScopeEventType.StepFinished,\n                        Output = instanceActivity.Output,\n                        WorkflowUid = ctx.WorkflowInstanceUid,\n                        WorkflowName = ctx.WorkflowName\n                    };\n                    WorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n                    {\n                        EventData = scopeEventData\n                    };\n                    EventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.StepFinished}\", ex);\n            }\n        }\n\n        private void SaveInstanceActivityVariables(InstanceActivity instanceActivity, IWINSWorkflowContext ctx)\n        {\n\t        if (ctx.WorkflowUserAccount.Account.Settings.EnableWorkflowVariableHistory)\n\t        {\n\t\t        var instanceVariableRepository = ServiceLocator.GetInstance<IInstanceVariableRepository>();\n\t\t        instanceVariableRepository.SaveVariableHistory(instanceActivity.AccountId, ctx.WorkflowUserAccount.Uid,\n\t\t\t        instanceActivity.InstanceUid, instanceActivity.Uid, ctx.Variables.GetAllVariables());\n\t        }\n        }\n\n        private List<WINSWorkflowContextWINSActivity> GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime endDate)\n        {\n\t\t\tvar list = new List<WINSWorkflowContextWINSActivity>();\n\n\t\t\tif (!HasUnfinishedActivities) return list;\n\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values);\n            }\n\n            IWINSWorkflowContext ctx = null;\n            foreach (var activity in activities)\n            {\n                var winsActivity = _SafeGetActivity(activity);\n                ctx = _CreateContext(winsActivity, activity);\n\n                if (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n                {\n\t\t\t\t\tlist.Add(new WINSWorkflowContextWINSActivity { EndDate = endDate, WINSActivity = winsActivity, WINSWorkflowContext = ctx });\n\t\t\t\t}\n            }\n\n\t\t\treturn list;\n        }\n\n\t\tprivate void AbortOrFailScopeStep(Enums.WorkflowStepStatus status, DateTime endDate)\n\t\t{\n\t\t\tif (!HasUnfinishedActivities) return;\n\n\t\t\tList<InstanceActivity> activities;\n\t\t\tlock (_unfinishedActivities)\n\t\t\t{\n\t\t\t\tactivities = new List<InstanceActivity>(_unfinishedActivities.Values);\n\t\t\t}\n\t\t\tIWINSWorkflowContext ctx = null;\n\t\t\tforeach (var activity in activities)\n\t\t\t{\n\t\t\t\tvar winsActivity = _SafeGetActivity(activity);\n\t\t\t\tctx = _CreateContext(winsActivity, activity);\n\n\t\t\t\tif (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n\t\t\t\t{\n\t\t\t\t\tvar documents = ((ITrackItActivity)winsActivity).GetDocuments(ctx);\n\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, activity.Uid, documents, null, status, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool _CheckWaitingActivities()\n        {\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values.Where(n => n.Status == Enums.WorkflowStepStatus.Waiting));\n            }\n            bool success = false;\n            foreach (InstanceActivity activity in activities)\n            {\n                if (CheckActivityForCompletion(activity)) success = true;\n            }\n            return success;\n        }\n\n        private bool _contextInitialized = false;\n        private IWINSWorkflowContext _CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n            IWINSWorkflowContext ctx = CreateContext(activity, instanceActivity);\n            AtlasContext.Current.UserAccount = ctx.WorkflowUserAccount;\n            // Only do this once.  If it's been done, it's done.\n            if (_contextInitialized) return ctx;\n\n            // This all depends on the properties for the Start step.  We always want a Start step for normal processing;\n            // however, we don't necessarily have a Start step for our tests.\n            StartActivity start = _workflowMap.StartActivity;\n            if (start == null)\n            {\n                if (_data.IsTest) return ctx;\n                throw new ApplicationException(string.Format(\"Cannot find StartActivity for InstanceUid {0}\", _instance.Uid));\n            }\n\n            // Contents\n            string[][] contents = start.DefinedContents;\n            if (contents != null && contents.Length > 0)\n            {\n                foreach (string[] t in contents)\n                {\n                    ContentDefinition definition = new ContentDefinition(t);\n                    if (!_contentDefinitions.ContainsKey(definition.Name)) _contentDefinitions[definition.Name] = definition;\n                }\n            }\n\n            _LoadVariables();\n\n            // XML Variables\n            // Because XmlVariables have dependencies on the variables as well, it's easier to feed this through the xml variable handler\n            // rather than replicate the code.\n            List<IXmlVariableDefinition> definitions = start.DefinedXmlVariables;\n            if (definitions != null && definitions.Count > 0)\n            {\n                foreach (IXmlVariableDefinition definition in definitions)\n                {\n                    if (!_xmlVariableDefinitions.ContainsKey(definition.Name)) ctx.XmlVariables.Declare(definition, logMessage: false);\n                }\n            }\n\n            _contextInitialized = true;\n            return ctx;\n\t\t}\n\n        public IWINSWorkflowContext CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowContextFactory>().CreateWorkflowContext(this, activity, instanceActivity);\n        }\n\n\t\tprivate void _LoadVariables()\n        {\n\t        // Variables\n\t        Dictionary<string, InstanceVariable> variables = _data.LoadVariablesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n\t        foreach (InstanceVariable variable in variables.Values)\n\t        {\n\t\t        if (!_variables.ContainsKey(variable.Name)) _variables[variable.Name] = variable;\n\t        }\n        }\n\n        private bool _ExecuteFirstActivity()\n        {\n            InstanceActivity activity = null;\n            lock (_unfinishedActivities)\n            {\n                if (_unfinishedActivities.Count > 0) activity = _unfinishedActivities.Values.FirstOrDefault(n => n.Status == Enums.WorkflowStepStatus.Pending || n.Status == Enums.WorkflowStepStatus.Executing);\n            }\n            if (activity == null) return false;\n            ExecuteActivity(activity);\n            return true;\n        }\n\n        private bool _ExecuteFirstEvent(bool controlOnly = false)\n        {\n            // We always try to execute control events first.\n            Event e = null;\n            lock (_queuedControlEvents)\n            {\n                if (_queuedControlEvents.Count > 0) e = _queuedControlEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            // If we're only caring about control events, we can quit now.\n            if (controlOnly) return false;\n\n            // Otherwise, we do the same thing with the rest of the events.\n            lock (_queuedEvents)\n            {\n                if (_queuedEvents.Count > 0) e = _queuedEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            return false;\n        }\n\n        private void _ForceReload()\n        {\n            // Reload the object to get new state -- we do this inside the lock so that there's no race condition\n            // between this and a worker who may be working on the object\n            lock (_lockObject)\n            {\n                Guid instanceUid = Uid;\n                _instance = _data.LoadInstanceByUid(AccountId, Constants.WorkflowUser, instanceUid);\n                if (_instance == null) throw new ApplicationException(string.Format(\"Failed to reload instanceUid: {0}\", instanceUid));\n            }\n        }\n\n        private void _MarkCompleted()\n        {\n\t        if (_instance.IsCompleted)\n\t        {\n\t\t        _log.InfoNoPII($\"Instance {_instance.Uid} is already complete with status {_instance.Status}\");\n\t\t        return;\n\t        }\n\n            _PersistVariables();\n            bool endActivityFailure = _workflowMap.HasEndActivity() && !_instance.EndActivityReached;\n            Enums.WorkflowStepStatus endStatus = endActivityFailure ? Enums.WorkflowStepStatus.Failed : Enums.WorkflowStepStatus.Completed;\n            _data.SaveInstance(_instance);\n            _data.InstanceCompleted(_instance, endStatus);\n\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Complete(_instance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventType = _instance.Status == Enums.WorkflowStepStatus.Failed ? ScopeEventType.WorkflowFailed : ScopeEventType.WorkflowFinished;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t{\n\t\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\t\tPeriodStart = _instance.EndDate,\n\t\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\t\tWorkflowName = _instance.Name\n\t\t\t\t\t};\n\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t\t{\n\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t};\n\t\t\t\t\tEventRepo.FireEvent(_instance.AccountId, scopeEvent);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event {_instance.ScopeUid} for eventtype {eventType}\", ex);\n\t\t\t\t}\n\t\t\t}\n\n            if (endActivityFailure && _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                if (_lastActivityUid == Guid.Empty)\n                {\n                    _log.WarnNoPII($\"No activities for workflow.\");\n                }\n                else\n                {\n                    InstanceActivity activity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, _lastActivityUid);\n                    IWINSActivity winsActivity = _SafeGetActivity(activity);\n                    IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n                    LoggingHelper.LogActivityErrorNoPII(ctx, Resources.WINSResources.WorkflowExitedWithoutReachingTheEndActivity);\n                }\n\n            }\n            if (_instance.Status == Enums.WorkflowStepStatus.Completed || _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n            }\n        }\n\n        private void _MarkWaiting()\n        {\n            _PersistVariables();\n            _instance.Status = Enums.WorkflowStepStatus.Waiting;\n            _data.SaveInstance(_instance);\n        }\n\n        private void _PersistVariables()\n        {\n            InstanceVariables variables = new InstanceVariables();\n            foreach (InstanceVariable variable in _variables.Values) if (variable.IsModified) variables.Add(variable);\n            _data.SaveInstanceVariables(AccountId, Constants.WorkflowUser, variables);\n        }\n\n        private void PersistEvents()\n\t\t{\n\t\t\tlock (_queuedControlEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedControlEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedControlEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlock (_queuedEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        private void PersistEvent(Event e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_data.CreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_data.UnlockEvent(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventUnlockedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save event {e.Uid}, for instance {e.InstanceUid}, activity {e.ActivityUid}, and callback name {e.CallbackName} to db\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate IWINSActivity _SafeGetActivity(InstanceActivity instanceActivity)\n        {\n            try\n            {\n                IWINSActivity activity;\n                if (_workflowMap.TryGetActivity(instanceActivity.Name, out activity)) return activity;\n                // There is a problem with old MWF workflow data where the name of the activity is really the type name.\n                // Don't ask.  It's a stupid and boring story.\n                // But we still should handle it, at least for awhile.  So: if we get here because we didn't match name, we should see\n                // if we match type name.\n                // This whole thing is a huge hack that should get removed when it can.\n                InstanceActivity inputActivity = null;\n                if (instanceActivity.InputActivityUid != Guid.Empty) inputActivity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, instanceActivity.InputActivityUid);\n                if (_workflowMap.LegacyTryGetActivityByTypeName(instanceActivity.Name, inputActivity == null ? \"\" : inputActivity.Name, instanceActivity.InputActivityOutput ?? \"\", out activity))\n                {\n                    // Rename it so we get one less instance of this in the future\n                    instanceActivity.Name = activity.Name;\n                    return activity;\n                }\n                throw new ApplicationException(string.Format(\"Invalid activity name '{0}' for instanceUid '{1}'.\", instanceActivity.Name, instanceActivity.InstanceUid));\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"_SafeGetActivity failed.\", e);\n                return null;\n            }\n        }\n\n        private bool _ShouldProcess(InstanceActivity instanceActivity)\n        {\n            switch (instanceActivity.Status)\n            {\n                case Enums.WorkflowStepStatus.Executing:\n                case Enums.WorkflowStepStatus.Pending:\n                case Enums.WorkflowStepStatus.Waiting:\n                case Enums.WorkflowStepStatus.Aborted:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool _ShouldProcess()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        private bool _ShouldProcessEvent()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                    case Enums.WorkflowStepStatus.Aborted:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        //ITrackItActivity interface is implemented by activities whose data is tracked in DocumentScope and ScopeEvent tables.\n        private bool IsTrackItActivity(IWINSActivity activity)\n        {\n            return activity is ITrackItActivity;\n        }\n\n\t\tprivate void FireWorkflowScopeEvent(UserAccount user, ScopeEventType eventType, IWINSActivity activity = null, IWINSWorkflowContext ctx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo\n\t\t\t\t{\n\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\tPeriodStart = DateTime.UtcNow,\n\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\tWorkflowName = _instance.Name,\n\t\t\t\t\tEventBy = user == null ? null : new WorkflowScopeEvent.Assignee() { Email = user.EmailAddress, Name = user.FriendlyName, Uid = user.Uid }\n\t\t\t\t};\n\n\t\t\t\tif (activity != null && ctx != null)\n\t\t\t\t{\n\t\t\t\t\tscopeEventData.StepName = ctx.ActivityName;\n\t\t\t\t\tscopeEventData.StepDisplayName = GetActivityDisplayName(activity, ctx);\n\t\t\t\t\tscopeEventData.StepTypeName = ctx.ActivityTypeName;\n\t\t\t\t\tscopeEventData.StepUid = ctx.ActivityUid;\n\t\t\t\t}\n\n\t\t\t\tEventRepo.FireEvent(_instance.AccountId, new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t{\n\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event scopeUid: {_instance.ScopeUid}, instanceUid: {_instance.Uid} eventType: {eventType}\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void RemoveProperties(InstanceActivity instanceActivity, IWINSActivity activity)\n\t    {\n\t\t    // We need to delete properties if this is not a human activity or WaitForNextStepAfterCompletion is not set\n\t\t    if (activity is AbstractHumanActivity && ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetWaitForNextStepAfterCompletion(instanceActivity.AccountId))\n\t\t    {\n\t\t\t\t_data.DeleteActivityPropertiesWithExclusion(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, new List<string> { nameof(AbstractHumanActivity.WaitForNextStep) });\n\t\t\t\t_log.InfoNoPII(\"Removing activity properties except WaitForNextStep\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    _data.DeleteActivityProperties(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid);\n\t\t\t    _log.InfoNoPII(\"Removing activity properties\");\n\t\t    }\n\t    }\n\n\t\tprivate string[] BuildNDCTags(InstanceActivity instanceActivity) => instanceActivity != null ? new[] { $\"ActivityId:{instanceActivity.Uid}\",$\"W:{instanceActivity.InstanceUid}\" } : new string[] { };\n\t    private string[] BuildNDCTags(Event e) => e != null ? new[] { $\"ActivityId:{e.ActivityUid}\", $\"W:{e.InstanceUid}\" } : new string[] { };\n\n\t\t/// <summary>\n\t\t/// Try to send an e-mail to support when a workflow instance activity execution account exceeds configured threshold.\n\t\t/// </summary>\n\t\t/// <param name=\"pausedPurgeDays\">Number of days to purge workflow related data</param>\n\t\t/// <returns>\n\t\t/// True\t-> Success.\n\t\t/// False\t-> Fail to send email.\n\t\t/// </returns>\n\t\tprivate bool TrySendActivityExecutionLimitExceedNotification(int pausedPurgeDays)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\t// Support should get the email\n\t\t\t\tvar supportEmailAddress = WorkflowSettingRepository.GetSupportNotificationEmailAddress(AccountId);\n\t\t\t\tif (!string.IsNullOrEmpty(supportEmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(supportEmailAddress);\n\t\t\t\t}\n\n\t\t\t\t// Also send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive activity execution limit exceeded notification\");\n\t\t\t\t\tnotificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, notificationUserUid);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Email support address setting is empty, and there is no AdvancedWorkflowNotificationUser configured. Thus, not sending activity execution limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Sending activity execution limit exceeded notification to {emailRecipients.Count} {(emailRecipients.Count > 1 ? \"recipients\" : \"recipient\")} for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseActivityExecutionLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowRevisionUid = _instance.RevisionUid,\n\t\t\t\t\tNumberOfActivitiesExecuted = ActivityExecutionCount,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetActivityDisplayName(IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n\t\t\treturn activity is AbstractHumanActivity abstractHumanActivity\n\t\t\t\t? abstractHumanActivity.ActivityDisplayName.Evaluate(ctx)\n\t\t\t\t: null;\n\t\t}\n\n\t\tprivate bool ShouldUseScopeEventHandler() => WorkflowFeatureFlags.UseScopeEventHandler &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t Model?.EngineVersion == Core.Workflow.Constants.EngineVersionV2;\n\n\t\tprivate void PauseInstance(UserAccount user, string comment, Action<UserAccount, string> pauseMethod)\n\t\t{\n\t\t\tRequires.NotNull(pauseMethod, nameof(pauseMethod));\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tpauseMethod(user, comment);\n\t\t\t\t_ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Pause(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowPaused);\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{\n\t\t\tvar environmentType = SiteConfig?.Value?.EnvironmentType;\n\t\t\tvar isGrpcEnabled = WorkflowClientConfig?.Value?.IsGrpcClientEnabled == true;\n\n\t\t\tvar isRunningOnCloudWithGrpcEnabled = environmentType == Core.Util.Config.EnvironmentType.Cloud && isGrpcEnabled;\n\n\t\t\tif (isRunningOnCloudWithGrpcEnabled && InstanceStateChangedHelper.IsInstanceStateChanged(_instance.Uid, ActivityExecutionCount, CacheRepository, WorkflowSettingRepository))\n\t\t\t{\n\t\t\t\t_ForceReload();\n\t\t\t\tInstanceStateChangedHelper.RemoveInstanceStateChanged(_instance.Uid, CacheRepository);\n\t\t\t}\n\t\t}\n    }\n}\n",
            "relevance_score": 0.85
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs",
            "content": "\ufeffusing System;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing DocuSign.Monitoring;\n\nnamespace ADEXS.Atlas.Workflow.Activities.Telemetry\n{\n\tpublic class WorkflowEventWorkload : Workload\n\t{\n\t\tprivate static readonly IDiscreetLogger _mqWorkloadLog = DiscreetLogger.GetLogger(\"WorkloadWorkflowEvent\");\n\t\t[EventSource(\"workflowevent\", \"ScmWorkload\")]\n\t\tprivate static readonly SimplePropertyBagEventSource _simplePropBagEventSource = new SimplePropertyBagEventSource();\n\n\t\tprotected override IDiscreetLogger WorkloadLogger => _mqWorkloadLog;\n\t\tprotected override SimplePropertyBagEventSource KazmonEventSource => ApplicationSettings.GetBooleanAppSetting(\"Kazmon_EnableWorkload_workflowevent\", true) ? _simplePropBagEventSource : null;\n\n\t\tpublic WorkflowEventWorkload(Core.Domain.Model.Workflow.Event wfEvent, string action)\n\t\t{\n\t\t\tAccountId = wfEvent.AccountId;\n\t\t\tAction = action;\n\t\t\tTotalMs = -1;\n\n\t\t\tUid = wfEvent.Uid.ToString();\n\t\t\tInstanceUid = wfEvent.InstanceUid;\n\t\t\tActivityUid = wfEvent.ActivityUid;\n\t\t\tBPMUserUid = wfEvent.BPMUserUid;\n\t\t\tCallbackName = wfEvent.CallbackName;\n\t\t\tIsControlEvent = wfEvent.IsControlEvent;\n\t\t\tErrorCount = wfEvent.ErrorCount;\n\t\t\tLockExpirationDate = wfEvent.LockExpirationDate;\n\t\t\tLockOwner = wfEvent.LockOwner;\n\t\t\tNextProcessDate = wfEvent.NextProcessDate;\n\t\t}\n\n\t\tpublic WorkflowEventWorkload(int accountId, string action)\n\t\t{\n\t\t\tAccountId = accountId;\n\t\t\tAction = action;\n\t\t\tTotalMs = -1;\n\t\t}\n\n\t\tpublic string Action { get; }\n\t\tpublic Guid  InstanceUid { get; set; }\n\t\tpublic Guid  ActivityUid { get; set; }\n\t\tpublic Guid  BPMUserUid { get; set; }\n\t\tpublic string  CallbackName { get; set; }\n\t\tpublic bool IsControlEvent { get; set; }\n\t\tpublic int  ErrorCount { get; set; }\n\t\tpublic DateTime  LockExpirationDate { get; set; }\n\t\tpublic string  LockOwner { get; set; }\n\t\tpublic DateTime  NextProcessDate { get; set; }\n\t\tpublic Guid RevisionUid { get; set; }\n\t\tpublic string WorkflowDB { get; set; }\n\n\t\tpublic override void Log()\n\t\t{\n\t\t\t// We should try setting the revision uid where it is easily available but if it is not this should do it.\n\t\t\tif (RevisionUid == Guid.Empty && InstanceUid != Guid.Empty)\n\t\t\t{\n\t\t\t\tvar instance = ServiceLocator.GetInstance<IWorkflowRepository>().LoadInstanceById(AccountId, Constants.WorkflowUser, InstanceUid);\n\t\t\t\tif (instance != null)\n\t\t\t\t{\n\t\t\t\t\tRevisionUid = instance.RevisionUid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase.Log();\n\t\t}\n\t}\n}\n",
            "relevance_score": 0.7
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs",
            "content": "using System.Collections.Generic;\nusing System.Web.Http;\nusing System.Web.Http.Dispatcher;\n\nusing ADEXS.ChatNotification;\nusing ADEXS.Collaboration.Infrastructure.IoC;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.FeatureFlags;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow;\nusing ADEXS.ElasticCore;\nusing ADEXS.MQ;\nusing ADEXS.RtmIntegration.IoC;\nusing ADEXS.SForce.Core;\nusing ADEXS.Web.Common;\nusing ADEXS.Web.Common.WarmUp;\n\nusing Microsoft.Extensions.DependencyInjection;\n\nusing StructureMap;\nusing ADEXS.ProxyLayer.Infrastructure.IoC;\n\nnamespace ADEXS.API.DocuSignInternal\n{\n\tpublic class WebApiApplication : ScmHttpApplication\n\t{\n\t\tprivate static readonly IDiscreetLogger Log = DiscreetLogger.GetLogger(typeof(WebApiApplication));\n\t\tprivate static readonly IServiceCollection Services = new ServiceCollection();\n\n\t\tprotected void Application_Start()\n\t\t{\n\t\t\tApplicationStart();\n\n\t\t\tInitializeFeatureFlags();\n\n\t\t\tGlobalConfiguration.Configure(WebApiConfig.Register);\n\t\t\tGlobalConfiguration.Configure(SwaggerConfig.Register);\n\t\t\tFilterConfig.RegisterGlobalFilters(GlobalConfiguration.Configuration.Filters);\n\t\t\tLog.InfoNoPII($\"{ApplicationInfo.Name} {ApplicationInfo.Version} ready.\");\n\t\t\tGlobalConfiguration.Configuration.Services.Replace(typeof(IHttpControllerActivator), new WarmUpServiceActivator());\n\t\t\tServiceLocator.GetContainer().Populate(Services);\n\t\t}\n\n\t\tprotected override void Bootstrap()\n\t\t{\n\t\t\tBootstrapper.Bootstrap(\n\t\t\t\t() =>\n\t\t\t\t\tnew List<IServiceRegistry>\n\t\t\t\t\t{\n\t\t\t\t\t\tnew ApiRegistry(),\n\t\t\t\t\t\tnew WebCommonRegistry(),\n\t\t\t\t\t\tnew Api.Common.ApiCommonRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\t\t\tnew Api.Common.ApiRegistry(),\n\t\t\t\t\t\tnew WebCoreDomainRegistry(),\n\t\t\t\t\t\tnew MessageQueueRegistry(),\n\t\t\t\t\t\tnew SalesForceRegistry(),\n\t\t\t\t\t\tnew CollaborationRegistry(),\n\t\t\t\t\t\tnew ChatNotificationRegistry(),\n\t\t\t\t\t\tnew RtmIntegrationRegistry(),\n\t\t\t\t\t\tnew CoreWorkflowRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\t\t\tnew ElasticCoreRegistry(),\n\t\t\t\t\t\tnew FeatureFlagRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\t\t\tnew OneConfigServiceRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\t\t\tnew ServiceConfigServiceRegistry(WebCoreDomainRegistry.OneConfigPath, \"API.DocuSignInternal.ini\"),\n\t\t\t\t\t\tnew ProxyLayerRegistry()\n\t\t\t\t\t},\n\t\t\t\tforce: true);\n\t\t}\n\t}\n}\n",
            "relevance_score": 0.7
          }
        ],
        "reasoning_chain": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "Step-by-step analysis and decision",
              "reasoning": "Step-by-step analysis and decision\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
              "conclusion": "\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 2,
              "description": "1. Analysis",
              "reasoning": "1. Analysis\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 Requirement: Add two new span attributes (HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION) to the *existing incoming HTTP request span* for the CLM web application.   ",
              "conclusion": "\u2022 Requirement: Add two new span attributes (HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION) to the *existing incoming HTTP request span* for the CLM web application.   ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 3,
              "description": "2. Planning",
              "reasoning": "2. Planning\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nApproach",
              "conclusion": "Approach",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 4,
              "description": "3. Implementation",
              "reasoning": "3. Implementation\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFiles to modify",
              "conclusion": "Files to modify",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 5,
              "description": "4. Validation",
              "reasoning": "4. Validation\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 Run local application with OpenTelemetry exporter (console / Jaeger).  ",
              "conclusion": "\u2022 Run local application with OpenTelemetry exporter (console / Jaeger).  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            }
          ],
          "final_conclusion": "Confidence the selected files are the correct insertion points: 0.85",
          "overall_confidence": 0.8,
          "alternative_approaches": [
            "Alternative considered: editing generated *.Trace.cs classes, but they do not have direct access to HttpContext so they are sub-optimal.",
            "Approach"
          ]
        }
      },
      "error": null,
      "execution_time": 10.441260814666748,
      "cache_hit": false
    },
    "patch_generation": {
      "stage_name": "patch_generation",
      "status": "StageStatus.COMPLETED",
      "result": {
        "diff": "Added enrichment for the current HTTP-request span inside\n`API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs`.\n\nChanges:\n1. Captures request header `Referer` and, when present, adds it as span\n   attribute `HTTP_REFERER`.\n2. After the downstream pipeline runs, if the response status code is in\n   the 3xx range, captures the `Location` header (if any) and records it as\n   span attribute `HTTP_RESPONSE_REDIRECT_LOCATION`.\n3. Keeps the change minimal\u2014no new files or registrations required.",
        "explanation": "--- a/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs\n+++ b/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs\n@@\n \\tpublic override async Task Invoke(HttpContext context)\n \\t{\n \\t\\tvar activity = Activity.Current;\n \n \\t\\ttry\n \\t\\t{\n+\\t\\t\\t// ------------------------------------------------------------------------------\n+\\t\\t\\t// Enrich span with incoming referer (if supplied)\n+\\t\\t\\t// ------------------------------------------------------------------------------\n+\\t\\t\\tvar referer = context.Request.Headers[\\\"Referer\\\"].ToString();\n+\\t\\t\\tif (!string.IsNullOrEmpty(referer))\n+\\t\\t\\t{\n+\\t\\t\\t\\tactivity?.SetTag(\\\"HTTP_REFERER\\\", referer);\n+\\t\\t\\t}\n+\n \\t\\t\\tcontext.AddKazMonServerVariables();\n \\t\\t\\tactivity?.SetTagsWithCommonFields(context);\n \\t\\t\\tawait base.Invoke(context);\n+\n+\\t\\t\\t// ------------------------------------------------------------------------------\n+\\t\\t\\t// Enrich span with redirect target when response is a redirect (3xx)\n+\\t\\t\\t// ------------------------------------------------------------------------------\n+\\t\\t\\tif (context.Response.StatusCode >= 300 && context.Response.StatusCode < 400)\n+\\t\\t\\t{\n+\\t\\t\\t\\tvar redirectLocation = context.Response.Headers[\\\"Location\\\"].ToString();\n+\\t\\t\\t\\tif (!string.IsNullOrEmpty(redirectLocation))\n+\\t\\t\\t\\t{\n+\\t\\t\\t\\t\\tactivity?.SetTag(\\\"HTTP_RESPONSE_REDIRECT_LOCATION\\\", redirectLocation);\n+\\t\\t\\t\\t}\n+\\t\\t\\t}\n+\n \\t\\t\\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n \\t\\t}\n \\t\\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n \\t\\t{\n \\t\\t\\tthrow;",
        "selection_reasoning": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "Step-by-step analysis and decision",
              "reasoning": "Step-by-step analysis and decision\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
              "conclusion": "\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 2,
              "description": "1. Analysis",
              "reasoning": "1. Analysis\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 Requirement: Add two new span attributes (HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION) to the *existing incoming HTTP request span* for the CLM web application.   ",
              "conclusion": "\u2022 Requirement: Add two new span attributes (HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION) to the *existing incoming HTTP request span* for the CLM web application.   ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 3,
              "description": "2. Planning",
              "reasoning": "2. Planning\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nApproach",
              "conclusion": "Approach",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 4,
              "description": "3. Implementation",
              "reasoning": "3. Implementation\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nFiles to modify",
              "conclusion": "Files to modify",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 5,
              "description": "4. Validation",
              "reasoning": "4. Validation\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2022 Run local application with OpenTelemetry exporter (console / Jaeger).  ",
              "conclusion": "\u2022 Run local application with OpenTelemetry exporter (console / Jaeger).  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            }
          ],
          "final_conclusion": "Confidence the selected files are the correct insertion points: 0.85",
          "overall_confidence": 0.8,
          "alternative_approaches": [
            "Alternative considered: editing generated *.Trace.cs classes, but they do not have direct access to HttpContext so they are sub-optimal.",
            "Approach"
          ]
        },
        "patch_reasoning": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "1. Analysis",
              "reasoning": "1. Analysis  \n   \u2022 Requirement: enrich *existing incoming HTTP request* spans with two new tags:  \n     \u2013 HTTP_REFERER  \u2190 value from Request.Headers[\"Referer\"]  ",
              "conclusion": "     \u2013 HTTP_REFERER  \u2190 value from Request.Headers[\"Referer\"]  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 2,
              "description": "2. Planning",
              "reasoning": "2. Planning  \n   \u2022 Extend `Invoke` in `LogAsyncRequestHttpMiddleware`:  \n     \u2013 Immediately after retrieving `activity`, set HTTP_REFERER tag if header present.  ",
              "conclusion": "     \u2013 Immediately after retrieving `activity`, set HTTP_REFERER tag if header present.  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 3,
              "description": "3. Implementation (code patch)",
              "reasoning": "3. Implementation (code patch)  \n```diff\n--- a/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
              "conclusion": "--- a/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 4,
              "description": "4. Validation",
              "reasoning": "4. Validation  \n   \u2022 Unit / integration tests: simulate HTTP requests with and without \u201cReferer\u201d header; verify `Activity.Current.GetTagItem(\"HTTP_REFERER\")` populated appropriately.  \n   \u2022 Simulate downstream producing a 302 response with \u201cLocation\u201d \u2192 assert `Activity` contains \u201cHTTP_RESPONSE_REDIRECT_LOCATION\u201d.  ",
              "conclusion": "   \u2022 Simulate downstream producing a 302 response with \u201cLocation\u201d \u2192 assert `Activity` contains \u201cHTTP_RESPONSE_REDIRECT_LOCATION\u201d.  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            }
          ],
          "final_conclusion": "Overall: 0.79 \u2013 change is confined to a single well-known middleware that processes every request, meeting telemetry requirement across the GateKeeper web API.",
          "overall_confidence": 0.8,
          "alternative_approaches": [
            "\u2022 Central code path: ASP-NET Core middleware `LogAsyncRequestHttpMiddleware` already has a reference to the current `Activity` for every request (see method `Invoke`)."
          ]
        },
        "selected_files": [
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs"
        ]
      },
      "error": null,
      "execution_time": 53.03352117538452,
      "cache_hit": false
    },
    "validation": {
      "stage_name": "validation",
      "status": "StageStatus.COMPLETED",
      "result": {
        "overall_score": 0.7166666666666667,
        "test_results": [
          {
            "test_name": "Intent Required Fields",
            "test_type": "TestType.UNIT",
            "passed": false,
            "score": 0.5,
            "details": {
              "missing_fields": [
                "search_keywords"
              ]
            },
            "errors": [
              "Missing required field: search_keywords"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Telemetry Operation Validity",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "type": "span",
              "action": "ADD_ATTRIBUTES"
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Semantic Description Quality",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "description_length": 116,
              "quality_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Patch Format Validity",
            "test_type": "TestType.UNIT",
            "passed": false,
            "score": 0.0,
            "details": {
              "patch_length": 501
            },
            "errors": [
              "Invalid unified diff format"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Code Style Compliance",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "style_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.003
          },
          {
            "test_name": "Change Scope Appropriateness",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 0.7,
            "details": {
              "scope_score": 0.7
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Code Compilation",
            "test_type": "TestType.INTEGRATION",
            "passed": true,
            "score": 1.0,
            "details": {
              "files_count": 10
            },
            "errors": [],
            "warnings": [],
            "execution_time": 2.0
          },
          {
            "test_name": "OpenTelemetry Attribute Naming",
            "test_type": "TestType.COMPLIANCE",
            "passed": false,
            "score": 0.5,
            "details": {
              "attributes_count": 2
            },
            "errors": [
              "Non-compliant attribute names found"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Instrumentation Pattern Compliance",
            "test_type": "TestType.COMPLIANCE",
            "passed": true,
            "score": 1.0,
            "details": {
              "pattern_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Resource Usage Analysis",
            "test_type": "TestType.PERFORMANCE",
            "passed": true,
            "score": 0.9,
            "details": {
              "score": 0.9,
              "errors": [],
              "warnings": [
                "Consider using 'using' statements for disposable resources"
              ]
            },
            "errors": [],
            "warnings": [
              "Consider using 'using' statements for disposable resources"
            ],
            "execution_time": 0.003
          },
          {
            "test_name": "No Hardcoded Secrets",
            "test_type": "TestType.COMPLIANCE",
            "passed": true,
            "score": 1.0,
            "details": {},
            "errors": [],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Input Validation",
            "test_type": "TestType.COMPLIANCE",
            "passed": false,
            "score": 0.0,
            "details": {
              "validation_score": 0.0
            },
            "errors": [
              "Insufficient input validation"
            ],
            "warnings": [
              "Input validation could be improved"
            ],
            "execution_time": 0.002
          }
        ],
        "recommendations": [
          "Address failing tests before deployment",
          "Improve implementation for low-scoring areas",
          "Validate telemetry data collection in staging environment"
        ],
        "risk_assessment": "HIGH",
        "compliance_status": {
          "opentelemetry": false,
          "security": true,
          "style": true
        }
      },
      "error": null,
      "execution_time": 0.009986162185668945,
      "cache_hit": false
    },
    "report_generation": {
      "stage_name": "report_generation",
      "status": "StageStatus.COMPLETED",
      "result": {
        "report_type": "comprehensive",
        "report_length": 4846
      },
      "error": null,
      "execution_time": 0.0005049705505371094,
      "cache_hit": false
    }
  }
}