{
  "selected_files": [
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Activities.HumanActivities;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.ActivityProperties;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.ExpressionService.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Config;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\nusing ADEXS.WINS.Interfaces;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\n\nusing Platform.Common;\n\nusing SCMAppenders;\n\nusing static ADEXS.Atlas.Workflow.Activities.Handlers.InstanceHandler;\n\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing InstanceVariable = ADEXS.Core.Domain.Model.Workflow.InstanceVariable;\nusing LoggingHelper = ADEXS.Atlas.Workflow.Activities.Infrastructure.LoggingHelper;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing UserAccount = ADEXS.Core.Domain.Model.UserAccount;\n\nnamespace ADEXS.WINS.Engine\n{\n\t/// <summary>\n\t/// An instance of a workflow -- a specific example of a definition.\n\t/// This class contains methods for controlling it, but all such calls should actually be fed through\n\t/// WorkflowManager so they can be queued, etc.\n\t/// </summary>\n\tpublic class WorkflowInstance : IWINSControlInstance\n    {\n        public const int SQL_SEVERITY_LEVEL_TRANSIENT = 12;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowInstance));\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IInstanceVariableGovernance _instanceVariableGovernance;\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepository;\n\t\tprivate IGovernor _governor;\n\t\tprivate IInstanceHandler _instanceHandler;\n\t\tprivate IServiceInstrumentation _serviceInstrumentation;\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> _workflowClientConfig;\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate ICacheRepository _cacheRepository;\n\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => (_instanceVariableGovernance ?? (_instanceVariableGovernance = ServiceLocator.GetInstance<IInstanceVariableGovernance>()));\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository ?? (_workflowSettingRepository = ServiceLocator.GetInstance<IWorkflowSettingRepository>());\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\t\tprivate IInstanceHandler InstanceHandler => _instanceHandler ?? (_instanceHandler = ServiceLocator.GetInstance<IInstanceHandler>());\n\n\n\t\tprivate IServiceInstrumentation ServiceInstrumentation => _serviceInstrumentation ?? (_serviceInstrumentation = ServiceLocator.GetInstance<IServiceInstrumentation>());\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> WorkflowClientConfig => _workflowClientConfig ?? (_workflowClientConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>());\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> SiteConfig => _siteConfig ?? (_siteConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>());\n\t\tprivate ICacheRepository CacheRepository => _cacheRepository ?? (_cacheRepository = ServiceLocator.GetInstance<ICacheRepository>());\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig ?? (_workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\n\t\t/// <summary>\n\t\t/// Loads (and locks) an existing instance.  Fails if the instance doesn't exist or can't be locked.\n\t\t/// </summary>\n\t\tpublic static WorkflowInstance LoadExisting(int accountId, Guid instanceUid, IWINSDataStore data)\n        {\n\t        DateTime lockExpirationDate;\n            InstancePersistence.LockResult lockResult = data.LockInstance(accountId, instanceUid, out lockExpirationDate);\n            switch (lockResult)\n            {\n                case InstancePersistence.LockResult.AlreadyCompleted:\n                    throw new InstanceAlreadyCompletedException(string.Format(\"InstanceUid {0} is already completed\", instanceUid));\n                case InstancePersistence.LockResult.DoesNotExist:\n                    throw new ApplicationException(string.Format(\"Invalid instanceUid {0}\", instanceUid));\n                case InstancePersistence.LockResult.LockedByOther:\n                    throw new InstanceLockedException(string.Format(\"InstanceUid {0} is locked by another process\", instanceUid));\n                case InstancePersistence.LockResult.Locked:\n                    // This is our success condition\n                    break;\n                default:\n                    throw new ApplicationException(string.Format(\"Unhandled lockResult for instanceUid {0}: {1}\", instanceUid, lockResult));\n            }\n            Instance instance = data.LoadInstanceByUid(accountId, Constants.WorkflowUser, instanceUid);\n            if (instance == null) throw new ApplicationException(string.Format(\"Failed to load workflow instanceUid {1} for account {0}.\", accountId, instanceUid));\n\n\t\t\ttry\n            {\n                if (instance.ScopeUid != Guid.Empty)\n                {\n                    Scope scope = ServiceLocator.GetInstance<IDocumentScopeRepository>().GetScopeByUid(accountId, instance.ScopeUid);\n                    if (scope != null)\n                        instance.ScopeName = scope.Name;\n                }\n            }\n            catch (Exception ex)\n            {\n                // the failure to load the scope should not cause the failure to load the instance, log it and move on\n                _log.WarnNoPII(string.Format(\"Could not load the scope '{0}' for workflow instance '{1}'.\", instance.ScopeUid, instanceUid), ex);\n            }\n\n\t\t\tRevision revision = data.LoadRevisionByUid(accountId, Constants.WorkflowUser, instance.RevisionUid);\n            if (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, instance.RevisionUid));\n            // ATL-68146: Populate RevisionCreatedDate here, because LoadInstanceByUid() doesn't populate it.\n            instance.RevisionCreatedDate = revision.CreatedDate;\n            WorkflowMap workflowMap = null;\n            instance.DefinitionUid = revision.DefinitionUid;\n\n\t\t\ttry\n            {\n\t            workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n            }\n            catch (InvalidDesignDefinitionException ex)\n            {\n\t            try\n\t            {\n\t\t            new WorkflowInstance(instance, data).Abort(UserAccount.WorkflowUserAccount(accountId), ex.Message);\n\t            }\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Error aborting workflow instance '{instanceUid}' with invalid definition\", e);\n\t\t\t\t}\n\n\t            throw;\n            }\n\n            var workflowInstance = new WorkflowInstance(instance, workflowMap, data);\n\t        workflowInstance.LockExpirationDate = lockExpirationDate;\n\t        return workflowInstance;\n\n        }\n\n        private readonly IWINSDataStore _data;\n        private readonly WorkflowMap _workflowMap;\n        private Instance _instance;\n\n        // The count of the activities that have been generated by this particular in-memory instance.  This doesn't get persisted anywhere, so is\n        // cleared whenever this WorkflowInstance gets unloaded (eg, when it enters into a Waiting state).\n        // It's use is to detect runaway workflows.\n        public const int MAX_IN_MEMORY_ACTIVITY_COUNT = 5000;\n        private int _inMemoryActivityCount = 0;\n\t\tprivate int _activityExecutionCountEnforcedLimit = 0;\n\t\tprivate Guid _revisionUid = Guid.Empty;\n\t\tprivate Guid _definitionUid = Guid.Empty;\n\t\tprivate DateTime _revisionCreatedDate = DateTime.MinValue;\n\t\tprivate bool _isActivityExecutionLimitReached = false;\n\n\t\tprivate readonly object _lockObject = new object();\n        private readonly IDictionary<Guid, InstanceActivity> _unfinishedActivities = new Dictionary<Guid, InstanceActivity>();\n        private readonly Queue<Event> _queuedControlEvents = new Queue<Event>();\n        private readonly Queue<Event> _queuedEvents = new Queue<Event>();\n\n        private readonly Dictionary<string, ContentDefinition> _contentDefinitions = new Dictionary<string, ContentDefinition>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, InstanceVariable> _variables = new Dictionary<string, InstanceVariable>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, IXmlVariableDefinition> _xmlVariableDefinitions = new Dictionary<string, IXmlVariableDefinition>(StringComparer.InvariantCultureIgnoreCase);\n\n        private readonly TimedLock _lock;\n\n        // Kind of a hack -- this is kept around so that if we end the instance without reaching the End step, we have an activity that we can\n        // log the message to.\n        private Guid _lastActivityUid;\n\n        private WorkflowInstance(Instance instance, IWINSDataStore data)\n        {\n\t        _data = data;\n\t        _lock = new TimedLock(instance.Uid.ToString());\n\t        _instance = instance;\n\t\t\t_revisionUid = _instance.RevisionUid;\n\t\t\t_revisionCreatedDate = instance.RevisionCreatedDate;\n\t        LastProcessDate = DateTime.UtcNow;\n\t\t\t_definitionUid = _instance.DefinitionUid;\n\t\t}\n\n\t\tpublic WorkflowInstance(Instance instance, WorkflowMap workflowMap, IWINSDataStore data) : this(instance, data)\n        {\n            _workflowMap = workflowMap;\n            // Load up any incomplete activities.  This is pointless to do for a new workflow, but it's not expensive either,\n            // so we simply avoid trying to figure that out and simply do it.\n            QueueIncompleteActivities();\n        }\n\n        /// <summary>\n        /// The AccountId this instance is running in.\n        /// </summary>\n        public int AccountId { get { return _instance.AccountId; } }\n\n        public Dictionary<string, ContentDefinition> ContentDefinitions { get { return _contentDefinitions; } }\n\n        public IWINSDataStore DataStore { get { return _data; } }\n\n        public TimedLock ThreadLock { get { return _lock; } }\n\n        /// <summary>\n        /// An in-memory, non-persisted value -- this is used when workers are finding instances to do work on.\n        /// It acts to make the WorkflowManager more FIFO, so that some workflows don't continually get ignored in favor of\n        /// newer work coming in.\n        /// </summary>\n        public DateTime LastProcessDate { get; private set; }\n\n        /// <summary>\n        /// The model Instance object; I didn't call this Instance because I didn't want it confused with a singleton pattern, and because\n        /// I didn't like seeing \"instance.Instance\".\n        /// </summary>\n        public Instance Model { get { return _instance; } }\n\n\t\tpublic DateTime LockExpirationDate { get; set; }\n\n\t\t/// <summary>\n\t\t/// The instance's Uid.  Primary key.\n\t\t/// </summary>\n\t\tpublic Guid Uid { get { return _instance.Uid; } }\n\n        public Dictionary<string, InstanceVariable> Variables { get { return _variables; } }\n\n        public Dictionary<string, IXmlVariableDefinition> XmlVariableDefinitions { get { return _xmlVariableDefinitions; } }\n\n        public Enums.WorkflowStepStatus Status => _instance.Status;\n\n        public bool HasQueuedWork\n        {\n            get { return _queuedEvents.Count > 0 || _queuedControlEvents.Count > 0; }\n        }\n\n        public bool HasUnfinishedActivities\n        {\n            get { return _unfinishedActivities.Count > 0; }\n        }\n\n        public void QueueActivity(InstanceActivity instanceActivity)\n        {\n            lock (_lockObject)\n            {\n                _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            }\n        }\n\n\t\tpublic int ActivityExecutionCount { get; set; }\n\n\t\tpublic int ActivityExecutionCountEnforcedLimit => _activityExecutionCountEnforcedLimit;\n\n\t\tpublic bool IsActivityExecutionLimitReached => _isActivityExecutionLimitReached;\n\n\t\tpublic Guid RevisionUid => _revisionUid;\n\n\t\tpublic Guid DefinitionUid => _definitionUid;\n\n\t\tpublic DateTime RevisionCreatedDate => _revisionCreatedDate;\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\t/// <param name=\"previousActivity\"></param>\n\t\t/// <param name=\"linkName\"></param>\n\t\t/// <param name=\"localContextId\"></param>\n\t\t/// <param name=\"followEmptyPathByDefault\"></param>\n\t\t/// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n\t\tpublic void QueueActivitiesByLink(InstanceActivity previousActivity, string linkName, int localContextId = 0, bool followEmptyPathByDefault = true, bool useLinkName = false)\n        {\n            IEnumerable<WorkflowMap.Link> links;\n            bool found = false;\n            if (_workflowMap.TryGetLinks(previousActivity.Name, linkName, out links))\n            {\n                foreach (WorkflowMap.Link link in links)\n                {\n                    QueueActivityByName(previousActivity, link.ToName, localContextId, linkName, useLinkName);\n                    found = true;\n                }\n            }\n            // If we got no matches, try to go for the default (empty) output.\n            if (followEmptyPathByDefault && !found && !string.IsNullOrEmpty(linkName)) QueueActivitiesByLink(previousActivity, string.Empty, localContextId);\n        }\n\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"previousActivity\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"localContextId\"></param>\n        /// <param name=\"linkName\"></param>\n        /// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n        public void QueueActivityByName(InstanceActivity previousActivity, string name, int localContextId = 0, string linkName = null, bool useLinkName = false)\n        {\n            IWINSActivity activity;\n            if (!_workflowMap.TryGetActivity(name, out activity)) throw new ApplicationException(string.Format(\"InstanceUid {0}: Tried to execute invalid activity '{1}'\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, name)));\n\n            if (localContextId <= 0) localContextId = (previousActivity == null ? int.MinValue : previousActivity.LocalContextId);\n\n            // Create a new activity\n            InstanceActivity instanceActivity = new InstanceActivity\n            {\n                AccountId = _instance.AccountId,\n                InstanceUid = _instance.Uid,\n                Name = name,\n                ActivityTypeName = activity.LegacyElementName(),\n                Status = Enums.WorkflowStepStatus.Pending,\n                InputActivityOutput = useLinkName ? linkName : (previousActivity == null ? string.Empty : previousActivity.Output),\n                InputActivityUid = (previousActivity == null ? Guid.Empty : previousActivity.Uid),\n                LocalContextId = localContextId,\n                IsWinsActivity = true,\n                CreatedDate = DateTime.UtcNow //make sure that the in memory copy has a value\n            };\n\n            try\n            {\n                _data.CreateActivity(instanceActivity);\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorWithPII($\"Failed to queue activity {{0}} for instance {_instance?.Uid} in account {_instance?.AccountId}\", ex, name);\n                _data.ActivityFailure(_instance, instanceActivity);\n            }\n\n            _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            QueueActivity(instanceActivity);\n        }\n\n        public void QueueEvent(Event e)\n        {\n            if (_instance.Status != Enums.WorkflowStepStatus.Failed && _instance.Status != Enums.WorkflowStepStatus.Aborted)\n            {\n                lock (_lockObject)\n                {\n                    Queue<Event> queue = (e.IsControlEvent ? _queuedControlEvents : _queuedEvents);\n                    if (e.Uid != Guid.Empty)\n                    {\n                        // Ensure this item isn't already in the list\n                        if (queue.Any(e2 => e2.Uid == e.Uid)) return;\n                    }\n                    queue.Enqueue(e);\n                    WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventQueued\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n                    wrk.Log();\n\t            }\n            }\n        }\n\n        public void QueueIncompleteActivities()\n        {\n            InstanceActivities activities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n            if (activities == null || activities.Count == 0) return;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in activities) _unfinishedActivities[activity.Uid] = activity;\n            }\n\n        }\n\n        public bool CheckActivityForCompletion(InstanceActivity instanceActivity)\n        {\n            // We only care about Waiting steps.\n            if (instanceActivity.Status != Enums.WorkflowStepStatus.Waiting) return false;\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.DebugNoPII($\"CheckActivityForCompletion called for ActivityUid {instanceActivity.Uid} ({instanceActivity.Name}).\");\n\t            try\n\t            {\n\t\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\t\t            ctx.CheckForCompletion();\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t            _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n\t\t\t            SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            return true;\n\t\t            }\n                    _log.DebugWithPII($\"CheckActivityForCompletion completed for Activity ({{0}}) in status: {instanceActivity.Status}.\", instanceActivity.Name);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n                    _log.ErrorNoPII($\"CheckActivityForCompletion failed.\", e);\n\t            }\n            }\n            return false;\n        }\n\n        public bool DoNextTask()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t        CheckAndHandleInstanceStateChanges();\n\n\t\t\t// If we're in a non-processing state, we want to respond only to control events.\n\t\t\t// If we have no control events, we can just skip everything else.\n\t\t\tif (!_ShouldProcessEvent())\n\t        {\n\t\t        return _ExecuteFirstEvent(controlOnly: true);\n\t        }\n\n\t        // If we have any queued events, do one of those.\n\t        if (_ExecuteFirstEvent(controlOnly: false)) return true;\n\n\t        if (!_ShouldProcess()) return false;\n\n\t        // Otherwise, check to see if any activities need to be executed; if so, do those.\n\t        if (_ExecuteFirstActivity()) return true;\n\n\t        // If we get here, it might be that we have some unfinished activities in the database that for some reason weren't loaded into memory.\n\t        // Check for that, and, if so, load them now.\n\t        QueueIncompleteActivities();\n\t        // Try to execute an activity again -- we may have just loaded some\n\t        if (_ExecuteFirstActivity()) return true;\n\t        // If we can complete a waiting activity, do that.\n\t        if (_CheckWaitingActivities()) return true;\n\n\t        // Otherwise, we've got nothing to do and can quit.\n\t        if (!HasQueuedWork && !HasUnfinishedActivities)\n\t        {\n\t\t        _MarkCompleted();\n\t\t\t\t// If we processed nothing (the activity count is 0) we don't want to mark ourselves as waiting.  This is mostly because\n\t\t\t\t// we don't want to update our UpdatedDate (see ATL-20570).  This case occurs when our workflow is already waiting and has been\n\t\t\t\t// picked up for the day and each activity checked to see if it's done waiting.  We don't want this to trigger an update if\n\t\t\t\t// nothing has actually changed.\n\t        }\n\t        else if (_inMemoryActivityCount > 0 || _instance.Status != Enums.WorkflowStepStatus.Waiting)\n\t        {\n\t\t\t\tvar workflowConfig = WorkflowConfig(_instance.AccountId);\n\t\t\t\tvar enableSmallBenRateLimits = workflowConfig?.EnableSmallBenRateLimits ?? false;\n\n\t\t\t\tif (_instance.Status == Enums.WorkflowStepStatus.Paused\n\t\t\t\t    && ((string.Equals(ADEXS.Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.EnableExpressionApiRateLimit, \"live\", StringComparison.OrdinalIgnoreCase)\n\t\t\t\t         && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit)\n\t\t\t\t\t|| (enableSmallBenRateLimits && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit)))\n\t\t\t\t{\n\t\t\t\t\t// keep throttled workflows in paused status\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_MarkWaiting();\n\t\t\t}\n\n\t\t    return false;\n        }\n\n        public void ExecuteActivity(InstanceActivity instanceActivity)\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteActivity called for Activity ({{0}}).\", instanceActivity.Name);\n\t            IWINSWorkflowContext ctx = null;\n\t            Stopwatch sw = Stopwatch.StartNew();\n\t            try\n\t            {\n\t\t            _lastActivityUid = instanceActivity.Uid;\n\n\t\t\t\t\tif (!_ShouldProcess()) throw new ApplicationException(string.Format(\"InstanceUid {0} is in an invalid state to execute activity {1}\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, instanceActivity.Name)));\n\n\t\t            // Check for runaway workflows.\n\t\t            if (++_inMemoryActivityCount >= MAX_IN_MEMORY_ACTIVITY_COUNT)\n\t\t            {\n\t\t\t            _log.WarnNoPII(string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t\t            throw new PublicException(PublicException.FailReason.InvalidState, string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t            }\n\n\t\t\t\t\t// Governance, check if activity execution limit has been reached\n\t\t\t\t\tif (PauseWhenActivityExecutionLimitReached())\n\t\t\t\t\t{\n\t\t\t\t\t\t// In this case, the workflow is paused, purge date is set and an e-mail has been sent to support team.\n\t\t\t\t\t\t// The current activity will not be executed, unless the limits are increased and the workflow resumed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_data.ActivityExecuting(_instance, instanceActivity);\n\n\t\t            ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\t\tif (!ShouldUseScopeEventHandler() && IsTrackItActivity(activity))\n\t\t\t\t\t{\n\t\t\t\t\t\tFireWorkflowScopeEvent(null, ScopeEventType.StepInitiated, activity, ctx);\n\t\t\t\t\t}\n\n\t\t\t\t\tactivity.Execute(ctx);\n\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n\t\t\t\t\tif (e is ArgumentNullException && ctx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar message =\n\t\t\t\t            string.Format(Resources.WINSResources.ActionFailed_ReferenceID_0, Guid.NewGuid()) +\n\t\t\t\t            $\". Inst: {instanceActivity.AccountId} '{instanceActivity.InstanceUid}'.\";\n\t\t\t            _log.ErrorNoPII(message, e);\n\t\t\t\t\t\t_data.CreateInstanceHistory(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, message, true);\n\t\t            }\n\n\t\t\t\t\t// Oh my...\n\t\t\t\t\t// Look at this catch block.\n\t\t\t\t\tbool isTransient = e is TransientException;\n\t\t            bool useFailureOutput = ctx != null && activity.HasFailureOutput;\n\n\t\t            if (isTransient) throw new TransientException(e);\n\t\t            if (useFailureOutput)\n\t\t            {\n\t\t\t\t\t\tctx.ActivityVariables.Set(\"Failure\", e.Message);\n\t\t\t\t\t\tctx.MarkAsCompleted(AbstractActivity.OUTPUT_FAILURE);\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.ActivityFailure(_instance, instanceActivity);\n\t\t\t            if (ctx == null) ctx = _CreateContext(activity, instanceActivity);\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\ttry\n\t\t\t            {\n\t\t\t\t            if (_instance.Status == Enums.WorkflowStepStatus.Failed)\n\t\t\t\t            {\n\t\t\t\t\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInstanceHandler.Fail(ctx, activity, GetUnfinishedWINSWorkflowContextsWINSActivities(instanceActivity.EndDate));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAccountId = ctx.AccountId,\n\t\t\t\t\t\t\t\t\t\tScopeUid = ctx.ScopeUid,\n\t\t\t\t\t\t\t\t\t\tScopeName = ctx.ScopeName,\n\t\t\t\t\t\t\t\t\t\tStepName = instanceActivity.Name,\n\t\t\t\t\t\t\t\t\t\tStepDisplayName = GetActivityDisplayName(activity, ctx),\n\t\t\t\t\t\t\t\t\t\tStepTypeName = instanceActivity.ActivityTypeName,\n\t\t\t\t\t\t\t\t\t\tStepUid = instanceActivity.Uid,\n\t\t\t\t\t\t\t\t\t\tPeriodStart = instanceActivity.EndDate,\n\t\t\t\t\t\t\t\t\t\tEventType = (int)ScopeEventType.WorkflowFailed,\n\t\t\t\t\t\t\t\t\t\tOutput = instanceActivity.Output,\n\t\t\t\t\t\t\t\t\t\tWorkflowUid = ctx.WorkflowInstanceUid,\n\t\t\t\t\t\t\t\t\t\tWorkflowName = ctx.WorkflowName\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tEventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n\n\t\t\t\t\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Failed, instanceActivity.EndDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t            }\n\t\t\t            catch (Exception ex)\n\t\t\t            {\n\t\t\t\t        _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.WorkflowFailed}\", ex);\n\t\t\t            }\n\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n\t\t            }\n\t            }\n\t            finally\n\t            {\n\t\t            ActivityExecutionCount++;\n\t            }\n\t\t\t}\n        }\n\n        public void ExecuteCallback(InstanceActivity instanceActivity, string name, object value)\n        {\n            LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteCallback called for Activity ({{0}}) with callback {name}.\", instanceActivity.Name);\n\n\t            if (!(_ShouldProcess(instanceActivity) && _ShouldProcessEvent()))\n\t            {\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoWithPII($\"ExecuteCallback did not complete because the activity was already completed. Activity {{0}} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}. Instance status: {Model.Status}\", instanceActivity.Name);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _log.ErrorWithPII($\"InstanceUid {Uid} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}.  Instance status: {Model.Status}\");\n\t\t\t\t\t}\n\t\t            return;\n\t\t\t\t}\n\n\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\ttry\n\t\t        {\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t            activity.ExecuteCallback(ctx, name, value);\n\n\t\t            if (_instance.Status != Enums.WorkflowStepStatus.Aborted)\n\t\t            {\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\n\t\t\t\t\t// Throw so that the calling method will handle re-queuing the failed event\n\t\t\t\t\t// When resumed we will retry the recurring reminder callback\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t            catch (Exception e)\n\t            {\n\t\t\t\t\t// Note that we don't fail the workflow here -- see ATL-21019\n\t\t\t\t\tif (instanceActivity.Status == Enums.WorkflowStepStatus.Completed ||\n\t\t                Model.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoNoPII($\"The callback is unnecessary: workflow activity '{instanceActivity.Uid}' [{instanceActivity.Status}] or instance '{instanceActivity.InstanceUid}' [{Model.Status}] has already completed.\");\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t\t\t\tvar pe = e as PublicException;\n\t\t\t\t\t\t_log.ErrorNoPII($\"ExecuteCallback failed.\", pe?.InnerException ?? e);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void ExecuteEvent(Event e, bool queueOnFailure = true)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            if (e == null) return;\n\n            using var span = StartActivity();\n\n            using (ScmNDC.Push(BuildNDCTags(e)))\n            {\n\t            // If we have Uid but the lock expired we don't want to process the event as it was persisted and some other worker probably has already picked it.\n\t            if (e.Uid != Guid.Empty && e.LockExpirationDate <= LastProcessDate)\n\t            {\n\t\t            _log.InfoNoPII($\"Aborting event execution - ExecuteEvent called with an event that has an expired lock ({e.LockExpirationDate}) for callback {e.CallbackName}.\");\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t\t            return;\n\t            }\n\n\t            _log.InfoNoPII($\"ExecuteEvent called with callback {e.CallbackName}.\");\n\t            try\n\t            {\n\t\t            Stopwatch sw = Stopwatch.StartNew();\n\t\t            if (e.ActivityUid == Guid.Empty)\n\t\t            {\n\t\t\t            // We expect these to be control codes\n\t\t\t            string comment = (e.CallbackObject == null ? \"\" : e.CallbackObject.ToString());\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            case Event.ControlNames.Abort:\n\t\t\t\t\t            Abort(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForAccountCancel:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tSetPurgeDateForAccountCancel();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForRevisionSuspended:\n\t\t\t\t\t\t\t\tPauseForRevisionSuspended(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.ResumeForSuspendedRevision:\n\t\t\t\t\t\t\t\t ResumeForSuspendedRevision(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.Pause:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t            case Event.ControlNames.Resume:\n\t\t\t\t\t            Resume(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.ResumeFromError:\n\t\t\t\t\t            ResumeFromError(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.StartActivity:\n\t\t\t\t\t            QueueActivityByName(null, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            default:\n\t\t\t\t\t            throw new ApplicationException(string.Format(\"Unhandled event {0}\", e.CallbackName));\n\t\t\t            }\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            // These *may* be control codes.  If they're not control codes, then\n\t\t\t            // we expect them to be a callback to an activity.\n\t\t\t            InstanceActivity activity;\n\t\t\t            if (!_unfinishedActivities.TryGetValue(e.ActivityUid, out activity)) activity = _data.LoadActivityByUid(_instance.AccountId, Constants.WorkflowUser, e.ActivityUid);\n\t\t\t            if (activity == null || activity.InstanceUid != e.InstanceUid) throw new ApplicationException(string.Format(\"Invalid ActivityUid {0} for InstanceUid {1}\", e.ActivityUid, e.InstanceUid));\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            // TODO: Start specific steps, fire specific outputs, complete specific steps, etc.\n\t\t\t\t            default:\n\t\t\t\t\t            ExecuteCallback(activity, e.CallbackName, e.CallbackObject);\n\t\t\t\t\t            break;\n\t\t\t            }\n\t\t            }\n\t\t            if (e.Uid != Guid.Empty) _data.EventSuccess(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventExecuted\")\n\t\t\t\t\t{\n\t\t\t\t\t\tTotalMs = sw.ElapsedMilliseconds,\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid, WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t            wrk.Log();\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t            catch (Exception excp)\n\t            {\n\t\t            _log.ErrorNoPII($\"Error processing eventUid {e.Uid} ({e.CallbackName}).\", excp);\n\t\t            if (!queueOnFailure) throw;\n\t\t            if (e.Uid == Guid.Empty)\n\t\t            {\n\t\t\t            e.NextProcessDate = _data.NextProcessDate();\n\t\t\t            e.ErrorCount = 1;\n\t\t\t            e.LastErrorMessage = excp.Message;\n\t\t\t            _data.CreateEvent(e);\n\t\t\t            WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnExecuteException\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t\t};\n\t\t\t            wrk.Log();\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.EventFailure(e.AccountId, e.Uid, _data.NextProcessDate(), excp.Message);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void Abort(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in _unfinishedActivities.Values)\n                {\n\t                try\n\t                {\n\t\t                IWINSActivity winsActivity = _SafeGetActivity(activity);\n\t\t                IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n\t\t                winsActivity.OnActivityAborted(ctx);\n\t                }\n\t                catch (Exception ex)\n\t                {\n\t\t                _log.ErrorNoPII(string.Format(\"Failed OnActivityAborted AccountId {0}, ActivityUid {1}\", user.AccountId, activity.Uid), ex);\n\t\t\t\t\t}\n                }\n                new WorkflowControlInstance(Model).Abort(user, comment);\n\n\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t{\n\t\t\t\t\tInstanceHandler.Abort(_instance, user, GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime.UtcNow));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Aborted, DateTime.UtcNow);\n\t\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowAborted);\n\t\t\t\t}\n\n\t\t\t\t_ForceReload();\n            }\n        }\n\n        public int SetPurgeDateForAccountCancel()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        var daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForAccountCancel();\n\t\t        _ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t        }\n        }\n\n        public void ClearPurgeDate()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        new WorkflowControlInstance(Model).ClearPurgeDate();\n\t\t        _ForceReload();\n\t        }\n        }\n\n\t\tpublic void Pause(UserAccount user, string comment)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Pause - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).Pause);\n\t\t}\n\n\t\tpublic void PauseForRevisionSuspended(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status == Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - No action taken, instance already paused\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).PauseForRevisionSuspended);\n\t\t}\n\n\t\tpublic void ResumeForSuspendedRevision(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status != Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, instance not paused. Status:{Model.Status}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if instance UpdatedBy has changed since the PauseForRevisionSuspended was invoked, if it has we do not want to do anything.\n\t\t\tif (Model.UpdatedBy != WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, UpdatedBy is not {WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - Resuming\");\n\t\t\tResume(user, comment);\n\t\t\tClearPurgeDate();\n\t\t}\n\n\t\tpublic bool PauseWhenActivityExecutionLimitReached()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Governance, check whether the number of executed activities exceeded the configured limit\n\t\t\t\t_isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(AccountId, Uid, _instance.RevisionUid, _instance.RevisionCreatedDate, ActivityExecutionCount, out _activityExecutionCountEnforcedLimit);\n\n\t\t\t\tif (_isActivityExecutionLimitReached)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum limit (Actual={ActivityExecutionCount}, EnforcedLimit={_activityExecutionCountEnforcedLimit}) and will be paused.\");\n\n\t\t\t\t\tPause(UserAccount.WorkflowUserAccount(AccountId), \"Workflow activity execution limit reached.\");\n\n\t\t\t\t\tTrySendActivityExecutionLimitExceedNotification(SetPurgeDateForAccountCancel());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' activity execution limit\", e);\n\t\t\t}\n\n\t\t\treturn _isActivityExecutionLimitReached;\n\t\t}\n\n\t\tpublic void PauseWhenThrottled(InstanceActivity activity, WorkflowApiRequestThrottledException exception)\n\t\t{\n\t\t\tRequires.NotNull(activity, nameof(InstanceActivity));\n\t\t\tRequires.NotNull(exception, nameof(WorkflowApiRequestThrottledException));\n\n\t\t\tif (exception.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.NotThrottled)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' is not throttled and will not be paused.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tactivity.Status = Enums.WorkflowStepStatus.Paused;\n\t\t\t\tvar throttledByApi = exception.ThrottledApiAsString();\n\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum {throttledByApi} request limit and will be paused. Message: {exception.Message}\");\n\n\t\t\t\tPauseInstance(UserAccount.WorkflowUserAccount(AccountId), $\"{throttledByApi} requests limit reached.\", new WorkflowControlInstance(Model).PauseForWorkflowRateLimitExceed);\n\n\t\t\t\t// Send notification\n\t\t\t\tswitch (exception.WorkflowThrottledStatus)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit:\n\t\t\t\t\t\tTrySendExpressionRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit:\n\t\t\t\t\t\tTrySendSmallBenRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_log.WarnNoPII(\"No notifications sent for unsupported throttle status\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mark instance as throttled for current workflow run session, WorkflowThrottledStatus property is not persisted and refreshed on reload\n\t\t\t\t_instance.WorkflowThrottledStatus = exception.WorkflowThrottledStatus;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception e)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' rate limit request limit with status {exception?.WorkflowThrottledStatus}\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublic int SetPurgeDateForWorkflowRateLimit()\n\t\t{\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tvar daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForWorkflowRateLimit();\n\t\t\t\t_ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid GetAdvancedWorkflowNotificationUserAccountUid()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while retrieving AdvancedWorkflowNotificationUserAccountUid for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\t\t}\n\n\t\tpublic void TrySendSmallBenRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\t// Send notification - pending ATL-90622\n\t\t}\n\n\t\tpublic void TrySendExpressionRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\tif (!ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetEnableWorkflowLimitNotifications(AccountId))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"EnableWorkflowLimitNotifications disabled for account {AccountId}, not sending expression rate limit exceeded notification\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (advancedWorkflowNotificationUserAccountUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {advancedWorkflowNotificationUserAccountUid} to receive expression rate limit exceeded notification\");\n\t\t\t\tUserAccount notificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, advancedWorkflowNotificationUserAccountUid);\n\n\t\t\t\tif (string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"AdvancedWorkflowNotificationUser '{advancedWorkflowNotificationUserAccountUid}' not found or missing email address. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar emailRecipients = new List<string>() { notificationUser.EmailAddress };\n\n\t\t\t\t_log.InfoNoPII($\"Sending expression rate limit exceeded notification to user '{advancedWorkflowNotificationUserAccountUid}' for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseExpressionRateLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowInstanceId = _instance.Id,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Resume(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).Resume(user, comment);\n                _ForceReload();\n            }\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Resume(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n        }\n\n        public void ResumeFromError(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).ResumeFromError(user, comment);\n                _ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.ResumeFromError(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n\t\t}\n\n        public void SaveToDatabase()\n        {\n            // We may have in-memory events that need to be saved to the db.\n\t\t\tPersistEvents();\n            _PersistVariables();\n        }\n\n        public void SaveEventsToDatabase()\n        {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPersistEvents();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save unsaved events for instance {Uid} to db\", e);\n\t\t\t}\n\t\t}\n\n\t    public void ArchiveVariables()\n        {\n            var incompleteActivities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, _instance.Uid);\n            // don't archive if there are any incomplete activites besides the one that has triggered this\n            if (incompleteActivities != null && incompleteActivities.Count > 1)\n            {\n                return;\n            }\n            _data.ArchiveVariables(AccountId, Constants.WorkflowUser, Uid);\n        }\n\n\t    public bool HasExistingLockExpired()\n\t    {\n\t\t    return LockExpirationDate < DateTime.UtcNow;\n\t    }\n\n\n        /// <summary>\n        /// Replaces variables provided in the dictionary returning replaced variables\n        /// </summary>\n        public void SetVariables(\n\t        InstanceActivity instanceActivity,\n\t        Dictionary<string, object> variables,\n\t        out List<InstanceVariable> oldVariables,\n\t        out bool areVariablesOverTotalSizeLimit,\n\t        out int totalVariablesSizeBytes,\n\t        out int totalVariablesSizeLimitBytes,\n\t\t\tout Dictionary<string, int> oversizedVariables,\n\t        out int variableValueSizeLimitBytes)\n        {\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            _log.DebugWithPII($\"SetVariables called for ActivityUid {instanceActivity.Uid} ({{0}}).\", instanceActivity.Name);\n\n            // We create the context so that the variable dictionaries get populated\n            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n            oldVariables = new List<InstanceVariable>();\n            var newVariables = UpdateVariablesHelper.PopulateContextVariables(ctx, this.Model, variables);\n\n            // Only set variables that are under the size limit\n\t\t\toversizedVariables = InstanceVariableGovernance.GetOversizedVariables(ctx.AccountId, newVariables, ctx.SubmittedDate, out variableValueSizeLimitBytes);\n\t\t\tforeach (InstanceVariable variable in newVariables)\n\t\t\t{\n\t\t\t\tif (!oversizedVariables.ContainsKey(variable.Name))\n\t\t\t\t{\n\t\t\t\t\toldVariables.Add(Variables[variable.Name]);\n\t\t\t\t\t// we could do \"ctx.Variables.Set(variable.Key, variable.Value);\" but that would log as the instanceActivity and we don't want that...\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Undo setting the variables, if the instance's total variable size exceeds the limit\n\t\t\tareVariablesOverTotalSizeLimit = InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(ctx.AccountId,\n\t\t\t\tVariables.Select(x => x.Value), ctx.SubmittedDate, activityConfiguration: null, out totalVariablesSizeBytes, out totalVariablesSizeLimitBytes);\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tforeach (InstanceVariable variable in oldVariables)\n\t\t\t\t{\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n        }\n\n        public DateTime GetLastAbortNotificationDate()\n        {\n\t        if (!_contextInitialized)\n\t        {\n\t\t        _LoadVariables();\n            }\n\n\t        if (_variables.TryGetValue(WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE, out InstanceVariable lastNotificationDate) &&\n\t            DateTime.TryParse(lastNotificationDate.Value.ToString(), out DateTime dateTime))\n\t        {\n\t\t        return dateTime;\n\t        }\n\n            return DateTime.MinValue;\n        }\n\n        public void SaveLastAbortNotificationDate(int accountId, Guid workflowInstanceUid, DateTime lastAbortNotificationDate)\n        {\n            var variable = InstanceVariable.CreateFromValue(\n\t            accountId,\n\t            workflowInstanceUid,\n\t            WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE,\n\t            Enums.WorkflowVariableType.Date,\n\t            lastAbortNotificationDate);\n\n            ServiceLocator.GetInstance<IInstanceVariablePersistence>().Save(Constants.WorkflowUser, variable);\n\n        }\n\n        /// <summary>\n        /// Called when we've finished work on an activity -- either executing it or performing a callback on it.\n        /// </summary>\n        private void _ActivityWorkCompleted(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx, Stopwatch sw)\n        {\n\t        // If it's flagged as completed, update in the db, queue up any next activities, and remove it from our list.\n            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n            {\n                _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n                SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t\tlock (_unfinishedActivities)\n                {\n                    if (_unfinishedActivities.ContainsKey(instanceActivity.Uid)) _unfinishedActivities.Remove(instanceActivity.Uid);\n                }\n            }\n            else\n            {\n                // Otherwise, it's still running.  Flag it as waiting so it doesn't get processed again.\n                instanceActivity.Status = Enums.WorkflowStepStatus.Waiting;\n                _data.SaveInstanceActivity(instanceActivity);\n            }\n\n            _log.InfoWithPII($\"_ActivityWorkCompleted done for Activity ({{0}}) in status: {instanceActivity.Status} ({sw.ElapsedMilliseconds} ms).\", instanceActivity.Name);\n\n\n            // log workload data\n            try\n            {\n                WorkflowWorkload ww = new WorkflowWorkload();\n                ww.Add(ctx);\n                ww.TotalMs = sw.ElapsedMilliseconds;\n\t\t\t\tww.StartTime = DateTime.UtcNow.AddMilliseconds(-ww.TotalMs);\n                ww.Status = instanceActivity.Status.ToString();\n                ww.Output = instanceActivity.Output;\n                ww.ActivityCreatedDate = instanceActivity.CreatedDate;\n                ww.ActivityStartDate = instanceActivity.StartDate;\n                if (DateTime.MinValue < instanceActivity.EndDate && instanceActivity.EndDate < DateTime.MaxValue)\n                    ww.ActivityEndDate = instanceActivity.EndDate;\n                if (DateTime.MinValue < _instance.CreatedDate && _instance.CreatedDate < DateTime.MaxValue)\n\t                ww.InstanceCreatedDate = _instance.CreatedDate;\n                ww.ActivityKind = activity.Kind.ToString();\n                ww.RevisionUid = _instance.RevisionUid.ToString();\n\t\t\t\tww.DefinitionUid = _instance.DefinitionUid.ToString();\n\t\t\t\tww.WorkflowDB = DataStore.GetDbNameForAccount(instanceActivity.AccountId);\n\n\t\t\t\tww.Log();\n            }\n            catch (Exception ex)\n            {\n                _log.WarnNoPII(\"Failed to log workload.\", ex);\n            }\n        }\n\n\t\tprivate void CompleteScopeStep(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n            try\n            {\n                if (IsTrackItActivity(activity))\n                {\n                    Documents documents = null;\n                    if (ctx.TrackActivity())\n                    {\n                        documents = ((ITrackItActivity)activity).GetDocuments(ctx);\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, instanceActivity.Uid,\n                            documents, instanceActivity.Output, instanceActivity.Status,\n                            instanceActivity.EndDate);\n                    }\n\n                    WorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n                    {\n                        AccountId = ctx.AccountId,\n                        Documents = documents?.Select(d => new WorkflowScopeEvent.DocumentDetail() { Uid = d.Uid, Name = d.Name }).ToList(),\n                        ScopeUid = ctx.ScopeUid,\n                        ScopeName = ctx.ScopeName,\n                        StepName = instanceActivity.Name,\n                        StepDisplayName = GetActivityDisplayName(activity, ctx),\n                        StepTypeName = instanceActivity.ActivityTypeName,\n                        StepUid = instanceActivity.Uid,\n                        PeriodStart = instanceActivity.EndDate,\n                        EventType = (int)ScopeEventType.StepFinished,\n                        Output = instanceActivity.Output,\n                        WorkflowUid = ctx.WorkflowInstanceUid,\n                        WorkflowName = ctx.WorkflowName\n                    };\n                    WorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n                    {\n                        EventData = scopeEventData\n                    };\n                    EventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.StepFinished}\", ex);\n            }\n        }\n\n        private void SaveInstanceActivityVariables(InstanceActivity instanceActivity, IWINSWorkflowContext ctx)\n        {\n\t        if (ctx.WorkflowUserAccount.Account.Settings.EnableWorkflowVariableHistory)\n\t        {\n\t\t        var instanceVariableRepository = ServiceLocator.GetInstance<IInstanceVariableRepository>();\n\t\t        instanceVariableRepository.SaveVariableHistory(instanceActivity.AccountId, ctx.WorkflowUserAccount.Uid,\n\t\t\t        instanceActivity.InstanceUid, instanceActivity.Uid, ctx.Variables.GetAllVariables());\n\t        }\n        }\n\n        private List<WINSWorkflowContextWINSActivity> GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime endDate)\n        {\n\t\t\tvar list = new List<WINSWorkflowContextWINSActivity>();\n\n\t\t\tif (!HasUnfinishedActivities) return list;\n\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values);\n            }\n\n            IWINSWorkflowContext ctx = null;\n            foreach (var activity in activities)\n            {\n                var winsActivity = _SafeGetActivity(activity);\n                ctx = _CreateContext(winsActivity, activity);\n\n                if (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n                {\n\t\t\t\t\tlist.Add(new WINSWorkflowContextWINSActivity { EndDate = endDate, WINSActivity = winsActivity, WINSWorkflowContext = ctx });\n\t\t\t\t}\n            }\n\n\t\t\treturn list;\n        }\n\n\t\tprivate void AbortOrFailScopeStep(Enums.WorkflowStepStatus status, DateTime endDate)\n\t\t{\n\t\t\tif (!HasUnfinishedActivities) return;\n\n\t\t\tList<InstanceActivity> activities;\n\t\t\tlock (_unfinishedActivities)\n\t\t\t{\n\t\t\t\tactivities = new List<InstanceActivity>(_unfinishedActivities.Values);\n\t\t\t}\n\t\t\tIWINSWorkflowContext ctx = null;\n\t\t\tforeach (var activity in activities)\n\t\t\t{\n\t\t\t\tvar winsActivity = _SafeGetActivity(activity);\n\t\t\t\tctx = _CreateContext(winsActivity, activity);\n\n\t\t\t\tif (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n\t\t\t\t{\n\t\t\t\t\tvar documents = ((ITrackItActivity)winsActivity).GetDocuments(ctx);\n\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, activity.Uid, documents, null, status, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool _CheckWaitingActivities()\n        {\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values.Where(n => n.Status == Enums.WorkflowStepStatus.Waiting));\n            }\n            bool success = false;\n            foreach (InstanceActivity activity in activities)\n            {\n                if (CheckActivityForCompletion(activity)) success = true;\n            }\n            return success;\n        }\n\n        private bool _contextInitialized = false;\n        private IWINSWorkflowContext _CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n            IWINSWorkflowContext ctx = CreateContext(activity, instanceActivity);\n            AtlasContext.Current.UserAccount = ctx.WorkflowUserAccount;\n            // Only do this once.  If it's been done, it's done.\n            if (_contextInitialized) return ctx;\n\n            // This all depends on the properties for the Start step.  We always want a Start step for normal processing;\n            // however, we don't necessarily have a Start step for our tests.\n            StartActivity start = _workflowMap.StartActivity;\n            if (start == null)\n            {\n                if (_data.IsTest) return ctx;\n                throw new ApplicationException(string.Format(\"Cannot find StartActivity for InstanceUid {0}\", _instance.Uid));\n            }\n\n            // Contents\n            string[][] contents = start.DefinedContents;\n            if (contents != null && contents.Length > 0)\n            {\n                foreach (string[] t in contents)\n                {\n                    ContentDefinition definition = new ContentDefinition(t);\n                    if (!_contentDefinitions.ContainsKey(definition.Name)) _contentDefinitions[definition.Name] = definition;\n                }\n            }\n\n            _LoadVariables();\n\n            // XML Variables\n            // Because XmlVariables have dependencies on the variables as well, it's easier to feed this through the xml variable handler\n            // rather than replicate the code.\n            List<IXmlVariableDefinition> definitions = start.DefinedXmlVariables;\n            if (definitions != null && definitions.Count > 0)\n            {\n                foreach (IXmlVariableDefinition definition in definitions)\n                {\n                    if (!_xmlVariableDefinitions.ContainsKey(definition.Name)) ctx.XmlVariables.Declare(definition, logMessage: false);\n                }\n            }\n\n            _contextInitialized = true;\n            return ctx;\n\t\t}\n\n        public IWINSWorkflowContext CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowContextFactory>().CreateWorkflowContext(this, activity, instanceActivity);\n        }\n\n\t\tprivate void _LoadVariables()\n        {\n\t        // Variables\n\t        Dictionary<string, InstanceVariable> variables = _data.LoadVariablesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n\t        foreach (InstanceVariable variable in variables.Values)\n\t        {\n\t\t        if (!_variables.ContainsKey(variable.Name)) _variables[variable.Name] = variable;\n\t        }\n        }\n\n        private bool _ExecuteFirstActivity()\n        {\n            InstanceActivity activity = null;\n            lock (_unfinishedActivities)\n            {\n                if (_unfinishedActivities.Count > 0) activity = _unfinishedActivities.Values.FirstOrDefault(n => n.Status == Enums.WorkflowStepStatus.Pending || n.Status == Enums.WorkflowStepStatus.Executing);\n            }\n            if (activity == null) return false;\n            ExecuteActivity(activity);\n            return true;\n        }\n\n        private bool _ExecuteFirstEvent(bool controlOnly = false)\n        {\n            // We always try to execute control events first.\n            Event e = null;\n            lock (_queuedControlEvents)\n            {\n                if (_queuedControlEvents.Count > 0) e = _queuedControlEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            // If we're only caring about control events, we can quit now.\n            if (controlOnly) return false;\n\n            // Otherwise, we do the same thing with the rest of the events.\n            lock (_queuedEvents)\n            {\n                if (_queuedEvents.Count > 0) e = _queuedEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            return false;\n        }\n\n        private void _ForceReload()\n        {\n            // Reload the object to get new state -- we do this inside the lock so that there's no race condition\n            // between this and a worker who may be working on the object\n            lock (_lockObject)\n            {\n                Guid instanceUid = Uid;\n                _instance = _data.LoadInstanceByUid(AccountId, Constants.WorkflowUser, instanceUid);\n                if (_instance == null) throw new ApplicationException(string.Format(\"Failed to reload instanceUid: {0}\", instanceUid));\n            }\n        }\n\n        private void _MarkCompleted()\n        {\n\t        if (_instance.IsCompleted)\n\t        {\n\t\t        _log.InfoNoPII($\"Instance {_instance.Uid} is already complete with status {_instance.Status}\");\n\t\t        return;\n\t        }\n\n            _PersistVariables();\n            bool endActivityFailure = _workflowMap.HasEndActivity() && !_instance.EndActivityReached;\n            Enums.WorkflowStepStatus endStatus = endActivityFailure ? Enums.WorkflowStepStatus.Failed : Enums.WorkflowStepStatus.Completed;\n            _data.SaveInstance(_instance);\n            _data.InstanceCompleted(_instance, endStatus);\n\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Complete(_instance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventType = _instance.Status == Enums.WorkflowStepStatus.Failed ? ScopeEventType.WorkflowFailed : ScopeEventType.WorkflowFinished;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t{\n\t\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\t\tPeriodStart = _instance.EndDate,\n\t\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\t\tWorkflowName = _instance.Name\n\t\t\t\t\t};\n\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t\t{\n\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t};\n\t\t\t\t\tEventRepo.FireEvent(_instance.AccountId, scopeEvent);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event {_instance.ScopeUid} for eventtype {eventType}\", ex);\n\t\t\t\t}\n\t\t\t}\n\n            if (endActivityFailure && _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                if (_lastActivityUid == Guid.Empty)\n                {\n                    _log.WarnNoPII($\"No activities for workflow.\");\n                }\n                else\n                {\n                    InstanceActivity activity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, _lastActivityUid);\n                    IWINSActivity winsActivity = _SafeGetActivity(activity);\n                    IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n                    LoggingHelper.LogActivityErrorNoPII(ctx, Resources.WINSResources.WorkflowExitedWithoutReachingTheEndActivity);\n                }\n\n            }\n            if (_instance.Status == Enums.WorkflowStepStatus.Completed || _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n            }\n        }\n\n        private void _MarkWaiting()\n        {\n            _PersistVariables();\n            _instance.Status = Enums.WorkflowStepStatus.Waiting;\n            _data.SaveInstance(_instance);\n        }\n\n        private void _PersistVariables()\n        {\n            InstanceVariables variables = new InstanceVariables();\n            foreach (InstanceVariable variable in _variables.Values) if (variable.IsModified) variables.Add(variable);\n            _data.SaveInstanceVariables(AccountId, Constants.WorkflowUser, variables);\n        }\n\n        private void PersistEvents()\n\t\t{\n\t\t\tlock (_queuedControlEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedControlEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedControlEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlock (_queuedEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        private void PersistEvent(Event e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_data.CreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_data.UnlockEvent(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventUnlockedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save event {e.Uid}, for instance {e.InstanceUid}, activity {e.ActivityUid}, and callback name {e.CallbackName} to db\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate IWINSActivity _SafeGetActivity(InstanceActivity instanceActivity)\n        {\n            try\n            {\n                IWINSActivity activity;\n                if (_workflowMap.TryGetActivity(instanceActivity.Name, out activity)) return activity;\n                // There is a problem with old MWF workflow data where the name of the activity is really the type name.\n                // Don't ask.  It's a stupid and boring story.\n                // But we still should handle it, at least for awhile.  So: if we get here because we didn't match name, we should see\n                // if we match type name.\n                // This whole thing is a huge hack that should get removed when it can.\n                InstanceActivity inputActivity = null;\n                if (instanceActivity.InputActivityUid != Guid.Empty) inputActivity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, instanceActivity.InputActivityUid);\n                if (_workflowMap.LegacyTryGetActivityByTypeName(instanceActivity.Name, inputActivity == null ? \"\" : inputActivity.Name, instanceActivity.InputActivityOutput ?? \"\", out activity))\n                {\n                    // Rename it so we get one less instance of this in the future\n                    instanceActivity.Name = activity.Name;\n                    return activity;\n                }\n                throw new ApplicationException(string.Format(\"Invalid activity name '{0}' for instanceUid '{1}'.\", instanceActivity.Name, instanceActivity.InstanceUid));\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"_SafeGetActivity failed.\", e);\n                return null;\n            }\n        }\n\n        private bool _ShouldProcess(InstanceActivity instanceActivity)\n        {\n            switch (instanceActivity.Status)\n            {\n                case Enums.WorkflowStepStatus.Executing:\n                case Enums.WorkflowStepStatus.Pending:\n                case Enums.WorkflowStepStatus.Waiting:\n                case Enums.WorkflowStepStatus.Aborted:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool _ShouldProcess()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        private bool _ShouldProcessEvent()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                    case Enums.WorkflowStepStatus.Aborted:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        //ITrackItActivity interface is implemented by activities whose data is tracked in DocumentScope and ScopeEvent tables.\n        private bool IsTrackItActivity(IWINSActivity activity)\n        {\n            return activity is ITrackItActivity;\n        }\n\n\t\tprivate void FireWorkflowScopeEvent(UserAccount user, ScopeEventType eventType, IWINSActivity activity = null, IWINSWorkflowContext ctx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo\n\t\t\t\t{\n\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\tPeriodStart = DateTime.UtcNow,\n\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\tWorkflowName = _instance.Name,\n\t\t\t\t\tEventBy = user == null ? null : new WorkflowScopeEvent.Assignee() { Email = user.EmailAddress, Name = user.FriendlyName, Uid = user.Uid }\n\t\t\t\t};\n\n\t\t\t\tif (activity != null && ctx != null)\n\t\t\t\t{\n\t\t\t\t\tscopeEventData.StepName = ctx.ActivityName;\n\t\t\t\t\tscopeEventData.StepDisplayName = GetActivityDisplayName(activity, ctx);\n\t\t\t\t\tscopeEventData.StepTypeName = ctx.ActivityTypeName;\n\t\t\t\t\tscopeEventData.StepUid = ctx.ActivityUid;\n\t\t\t\t}\n\n\t\t\t\tEventRepo.FireEvent(_instance.AccountId, new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t{\n\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event scopeUid: {_instance.ScopeUid}, instanceUid: {_instance.Uid} eventType: {eventType}\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void RemoveProperties(InstanceActivity instanceActivity, IWINSActivity activity)\n\t    {\n\t\t    // We need to delete properties if this is not a human activity or WaitForNextStepAfterCompletion is not set\n\t\t    if (activity is AbstractHumanActivity && ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetWaitForNextStepAfterCompletion(instanceActivity.AccountId))\n\t\t    {\n\t\t\t\t_data.DeleteActivityPropertiesWithExclusion(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, new List<string> { nameof(AbstractHumanActivity.WaitForNextStep) });\n\t\t\t\t_log.InfoNoPII(\"Removing activity properties except WaitForNextStep\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    _data.DeleteActivityProperties(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid);\n\t\t\t    _log.InfoNoPII(\"Removing activity properties\");\n\t\t    }\n\t    }\n\n\t\tprivate string[] BuildNDCTags(InstanceActivity instanceActivity) => instanceActivity != null ? new[] { $\"ActivityId:{instanceActivity.Uid}\",$\"W:{instanceActivity.InstanceUid}\" } : new string[] { };\n\t    private string[] BuildNDCTags(Event e) => e != null ? new[] { $\"ActivityId:{e.ActivityUid}\", $\"W:{e.InstanceUid}\" } : new string[] { };\n\n\t\t/// <summary>\n\t\t/// Try to send an e-mail to support when a workflow instance activity execution account exceeds configured threshold.\n\t\t/// </summary>\n\t\t/// <param name=\"pausedPurgeDays\">Number of days to purge workflow related data</param>\n\t\t/// <returns>\n\t\t/// True\t-> Success.\n\t\t/// False\t-> Fail to send email.\n\t\t/// </returns>\n\t\tprivate bool TrySendActivityExecutionLimitExceedNotification(int pausedPurgeDays)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\t// Support should get the email\n\t\t\t\tvar supportEmailAddress = WorkflowSettingRepository.GetSupportNotificationEmailAddress(AccountId);\n\t\t\t\tif (!string.IsNullOrEmpty(supportEmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(supportEmailAddress);\n\t\t\t\t}\n\n\t\t\t\t// Also send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive activity execution limit exceeded notification\");\n\t\t\t\t\tnotificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, notificationUserUid);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Email support address setting is empty, and there is no AdvancedWorkflowNotificationUser configured. Thus, not sending activity execution limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Sending activity execution limit exceeded notification to {emailRecipients.Count} {(emailRecipients.Count > 1 ? \"recipients\" : \"recipient\")} for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseActivityExecutionLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowRevisionUid = _instance.RevisionUid,\n\t\t\t\t\tNumberOfActivitiesExecuted = ActivityExecutionCount,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetActivityDisplayName(IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n\t\t\treturn activity is AbstractHumanActivity abstractHumanActivity\n\t\t\t\t? abstractHumanActivity.ActivityDisplayName.Evaluate(ctx)\n\t\t\t\t: null;\n\t\t}\n\n\t\tprivate bool ShouldUseScopeEventHandler() => WorkflowFeatureFlags.UseScopeEventHandler &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t Model?.EngineVersion == Core.Workflow.Constants.EngineVersionV2;\n\n\t\tprivate void PauseInstance(UserAccount user, string comment, Action<UserAccount, string> pauseMethod)\n\t\t{\n\t\t\tRequires.NotNull(pauseMethod, nameof(pauseMethod));\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tpauseMethod(user, comment);\n\t\t\t\t_ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Pause(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowPaused);\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{\n\t\t\tvar environmentType = SiteConfig?.Value?.EnvironmentType;\n\t\t\tvar isGrpcEnabled = WorkflowClientConfig?.Value?.IsGrpcClientEnabled == true;\n\n\t\t\tvar isRunningOnCloudWithGrpcEnabled = environmentType == Core.Util.Config.EnvironmentType.Cloud && isGrpcEnabled;\n\n\t\t\tif (isRunningOnCloudWithGrpcEnabled && InstanceStateChangedHelper.IsInstanceStateChanged(_instance.Uid, ActivityExecutionCount, CacheRepository, WorkflowSettingRepository))\n\t\t\t{\n\t\t\t\t_ForceReload();\n\t\t\t\tInstanceStateChangedHelper.RemoveInstanceStateChanged(_instance.Uid, CacheRepository);\n\t\t\t}\n\t\t}\n    }\n}\n",
      "relevance_score": 0.9
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/AbstractServicedComponent.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Net;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.HealthChecks;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.FeatureFlags;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.CqlCorePersistence;\nusing ADEXS.ElasticCore;\nusing ADEXS.FeatureFlags;\nusing ADEXS.HealthCheck;\nusing ADEXS.MQ;\nusing ADEXS.MqWorkers;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing log4net;\n\nusing Newtonsoft.Json;\n\nusing ApplicationInfo = ADEXS.Core.Domain.Utilities.ApplicationInfo;\n\nnamespace ADEXS.Core.ServiceFramework\n{\n\t/// <summary>\n\t/// Base class to subclass for services.  Handles the managing of worker processes,\n\t/// worker groups, and remotable objects via the Register* methods.\n\t/// </summary>\n\tpublic abstract class AbstractServicedComponent : ScmServicedComponent\n\t{\n\t\t// We query for this in our alerts, do not change this without updating alerts.\n\t\tprivate const string HealthCheckFailedPrefix = \"Health check failed\";\n\n\t\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\t\tprotected override List<IServiceRegistry> GetServiceRegistries()\n\t\t{\n\t\t\treturn new List<IServiceRegistry> {\n\t\t\t\tnew CoreServiceFrameworkRegistry(),\n\t\t\t\tnew CoreDomainRegistry(),\n\t\t\t\tnew MessageQueueRegistry(),\n\t\t\t\tnew ElasticCoreRegistry(),\n\t\t\t\tnew FeatureFlagRegistry()\n\t\t\t};\n\t\t}\n\n\t\tprotected override void OnBeforeRun()\n\t\t{\n\t\t\t// Use MSF specific env variable, fallback to app settings.\n\t\t\tvar application = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? ApplicationInfo.Name;\n\t\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? Configuration.GetStringAppSetting(\"Environment\", \"Unknown\");\n\t\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\t\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\n\t\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\t\tapplicationName: application,\n\t\t\t\tappVersion: GetType().Assembly.GetName().Version.ToString(),\n\t\t\t\tenvironmentName: environment,\n\t\t\t\tsiteName: site,\n\t\t\t\tpartitionName: partition,\n\t\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\t\tshouldEnableLogFileListener: () => ApplicationSettings.KazmonEnableLogFileListener);\n\n\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t\t{\n\t\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t\t{\n\t\t\t\t\t// Run synchronously.\n\t\t\t\t\t// For service framework, we are using service invocation to start process,\n\t\t\t\t\t// so Assembly.EntryAssembly is not represents correct service assembly. We are\n\t\t\t\t\t// using GetType().Assembly instead, which would provide correct release version.\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: this.GetType().Assembly))\n\t\t\t\t\t\t\t.GetAwaiter().GetResult();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add custom connection limit if defined.\n\t\t\tstring ServicePointConnectionLimitSettingName = $\"{application}_{Constants.ApplicationSettings.ServicePointConnectionLimit}\";\n\t\t\tint servicePointConnectionLimitSetting = Configuration.GetInt32AppSetting(ServicePointConnectionLimitSettingName, 0);\n\t\t\tif (0 < servicePointConnectionLimitSetting)\n\t\t\t{\n\t\t\t\tServicePointManager.DefaultConnectionLimit = servicePointConnectionLimitSetting;\n\t\t\t}\n\n\t\t\tbase.OnBeforeRun();\n\t\t}\n\n\t\tprotected override void OnStop()\n\t\t{\n\t\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t\t}\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t\t}\n\n\t\t\tKazmonMonitoring.ShutdownKazmon();\n\t\t}\n\n\t\tpublic override void RunHealthCheck()\n\t\t{\n\t\t\tif (!Configuration.GetBooleanAppSetting(\"HealthCheckEnabled\", true))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!IsService())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the CorrelationToken to make log tracing easier.\n\t\t\tMonitoringContext.CorrelationToken ??= Guid.NewGuid();\n\n\t\t\tHealthCheckResult result = RunSelfCheck();\n\n\t\t\tif (result.Pass)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"Health check passed.\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// App-specific override takes precedence over system-wide setting\n\t\t\t\tvar continueOnFailure = Configuration.GetOptionalBooleanAppSetting($\"HealthCheckContinueOnFailure_{ApplicationInfo.Name}\", null)\n\t\t\t\t\t\t\t\t\t\t?? Configuration.GetBooleanAppSetting(\"HealthCheckContinueOnFailure\", false);\n\n\t\t\t\tif (continueOnFailure)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"{HealthCheckFailedPrefix}, but will continue running.\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.FatalNoPII($\"{HealthCheckFailedPrefix}. Exiting.\");\n\t\t\t\t\tExit(EXIT_FAIL_HELTH_CHECK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic override void InitializeFeatureFlags()\n\t\t{\n\t\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t\t}\n\t\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// This method is to be used only as an entry point for an external\n\t\t/// tool to invoke a self health check on the service.\n\t\t/// </summary>\n\t\t/// <returns>Json health report</returns>\n\t\tpublic string ExternalRunServiceHealthCheck()\n\t\t{\n\t\t\tif (IsService())\n\t\t\t{\n\t\t\t\treturn \"\";\n\t\t\t}\n\n\t\t\tif (ConfigWrapper.UseOneConfig)\n\t\t\t{\n\t\t\t\tBootstrapper.Bootstrap(GetServiceRegistries);\n\t\t\t}\n\n\t\t\t// Since this is called from an external process some things need initializing\n\n\t\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\t\tapplicationName: ApplicationInfo.Name,\n\t\t\t\tappVersion: GetType().Assembly.GetName().Version.ToString(),\n\t\t\t\tenvironmentName: Configuration.GetStringAppSetting(\"Environment\", \"Unknown\"),\n\t\t\t\tsiteName: ApplicationSettings.Site,\n\t\t\t\tshouldEnableKazmon: () => true,\n\t\t\t\tshouldEnableSmartMon: () => true\n\t\t\t\t);\n\n#if NETFRAMEWORK\n\t\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n#else\n\t\t\tFileInfo logConfigFileInfo = new FileInfo(System.Configuration.ConfigurationManager.OpenExeConfiguration(System.Configuration.ConfigurationUserLevel.None).FilePath);\n#endif\n\n\t\t\tlog4net.Config.XmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\t\tif (!ConfigWrapper.UseOneConfig)\n\t\t\t{\n\t\t\t\tBootstrapper.Bootstrap(GetServiceRegistries);\n\t\t\t}\n\n\t\t\tHealthCheckResult selfCheck = RunSelfCheck();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tLogManager.Shutdown();\n\t\t\t\tKazmonMonitoring.ShutdownKazmon();\n\t\t\t}\n\t\t\tcatch { }\n\n\t\t\treturn selfCheck.Report;\n\t\t}\n\n\t\tprivate HealthCheckResult RunSelfCheck()\n\t\t{\n\t\t\t_log.InfoNoPII(\"Running health check.\");\n\t\t\tIList<IHealthCheckItem> defaultChecks = new List<IHealthCheckItem>()\n\t\t\t{\n\t\t\t\tnew HealthCheckAuthDbAccess(),\n\t\t\t\tnew HealthCheckCassandraStorage(ServiceLocator.GetInstance<IAtlasCassandraCluster>(), new string[] { \"atlas\" }),\n\t\t\t\tnew HealthCheckTempStorage(),\n\t\t\t\tnew HealthCheckSwiftStorage(),\n\t\t\t\tnew HealthCheckRedis(), // Remove this check when the RedisWithWrite is no longer log-only\n\t\t\t\tnew HealthCheckRedis(doWriteCheck: true) { IsLogOnly = true },\n\t\t\t\tnew OptimizelyHealthCheck() { IsLogOnly = true },\n\t\t\t\tnew HealthCheckMessageQueue(Types.Constants.HealthCheckRMQPath, string.Empty),\n\t\t\t\tnew HealthCheckJIT(),\n\t\t\t\tnew HealthCheckEmailTemplates()\n\t\t\t};\n\n\t\t\tIList<IHealthCheckItem> healthChecks = GetHealthChecksChain(defaultChecks);\n\n\t\t\t// Wait some \"random\" time before running checks, so that we don't generate\n\t\t\t// too many requests at the same time for our load sensitive services\n#pragma warning disable CA5394, CA1307\n\t\t\tThread.Sleep(new Random(GetType().Name.GetHashCode() ^ (int)DateTime.UtcNow.Ticks).Next(70, 700));\n#pragma warning restore CA5394, CA1307\n\n\t\t\treturn HealthCheckRunner.RunHealthChecks(healthChecks);\n\t\t}\n\n\t\tpublic virtual IList<IHealthCheckItem> GetHealthChecksChain(IList<IHealthCheckItem> defaultChecks)\n\t\t{\n\t\t\treturn defaultChecks;\n\t\t}\n\n\t\tprivate static readonly IDiscreetLogger _healthReportLog = DiscreetLogger.GetLogger(\"HealthCheck\");\n\t\tpublic virtual string LogHealthReport(HealthReport hreport)\n\t\t{\n\t\t\tstring jsonReport = JsonConvert.SerializeObject(hreport, Formatting.Indented);\n\t\t\tif (hreport.Pass)\n\t\t\t\t_healthReportLog.InfoNoPII(jsonReport);\n\t\t\telse\n\t\t\t\t_healthReportLog.WarnNoPII(jsonReport);\n\n\t\t\treturn jsonReport;\n\t\t}\n\n\t}\n}\n",
      "relevance_score": 0.9
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing DocuSign.CLM.ContentStorage;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing MediaInfo;\n\nnamespace ADEXS.DetectTypeService.VideoInfo\n{\n\tpublic class VideoInfo : IVideoInfo\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(VideoInfo));\n\n\t\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\t\tpublic VideoInfo(IServiceInstrumentation serviceInstrumentation)\n\t\t{\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t}\n\n\t\tpublic VideoInfoModel GetVideoInformation(Document document)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t//Test if version of DLL is compatible : 3rd argument is \"version of DLL tested;Your application name;Your application version\"\n\n\t\t\tMediaInfo.MediaInfo mediaInfo = new MediaInfo.MediaInfo();\n\n\t\t\tstring output = mediaInfo.Option(\"Info_Version\", \"0.7.0.0;MediaInfoDLL_Example_CS;0.7.0.0\");\n\t\t\tif (string.IsNullOrEmpty(output))\n\t\t\t{\n\t\t\t\tthrow new ApplicationException(\"MediaInfo.Dll: this version of the DLL is not compatible\").Trace();\n\t\t\t}\n\n\t\t\tSystemDocumentReader docReader = new SystemDocumentReader(document);\n\t\t\tlong length = docReader.GetContentLength(StorageConstants.StorageFormat.Native);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tmediaInfo.OpenBufferInit(length, 0);\n\n\t\t\t\tbyte[] mngdBuffer = new byte[81920];\n\t\t\t\tusing (var stream = docReader.OpenNativeStream())\n\t\t\t\t{\n\t\t\t\t\tint totalBytesSent = 0;\n\t\t\t\t\tint continueResult = 5; // initialize to 5, because that is what is returned when MediaInfo wants more bytes\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\t\t\tIntPtr ptrBuffer = default(IntPtr);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tptrBuffer = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)) * mngdBuffer.Length);\n\t\t\t\t\t\tint read;\n\t\t\t\t\t\twhile ((read = stream.Read(mngdBuffer, 0, mngdBuffer.Length)) > 0 && continueResult == 5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMarshal.Copy(mngdBuffer, 0, ptrBuffer, read); // Copy the array to unmanaged memory.\n\t\t\t\t\t\t\tcontinueResult = (int)mediaInfo.OpenBufferContinue(ptrBuffer, (IntPtr)read);\n\t\t\t\t\t\t\ttotalBytesSent += read;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_log.DebugNoPII(\n\t\t\t\t\t\t\t$\"Stopped sending bytes to MediaInfo in {sw.ElapsedMilliseconds} ms. Last chunk sent result: {continueResult}, total bytes sent: {totalBytesSent} of {length}\");\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptrBuffer != default(IntPtr))\n\t\t\t\t\t\t\tMarshal.FreeHGlobal(ptrBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmediaInfo.OpenBufferFinalize();\n\n\t\t\t\tint height;\n\t\t\t\tint width;\n\t\t\t\tlong durationMs;\n\t\t\t\tif (!int.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Height\"), out height)) height = 0;\n\t\t\t\tif (!int.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Width\"), out width)) width = 0;\n\t\t\t\tif (!long.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Duration\"), out durationMs)) durationMs = 0;\n\t\t\t\tstring codec = mediaInfo.Get(StreamKind.General, 0, \"CodecID\") ?? string.Empty;\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\tvar videoInfoModel = new VideoInfoModel { Height = height, Width = width, Codec = codec, Duration = durationMs };\n\n\t\t\t\tSetVideoInfoTags(activity, videoInfoModel);\n\n\t\t\t\treturn videoInfoModel;\n\t\t\t}\n\t\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t\t{\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmediaInfo.Close();\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") =>\n\t\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity($\"{InstrumentationNames.MediaInfo}.{name}\")\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t\t?.SetMetricName(InstrumentationNames.MediaInfo);\n\n\t\tprivate Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}\n",
      "relevance_score": 0.9
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
      "content": "#if NET\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Domain.Repository.Workflow.Mappers;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Workflow.Model;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing Google.Protobuf.WellKnownTypes;\nusing Google.Rpc;\n\nusing Grpc.Core;\n\nusing Microsoft.Extensions.Logging;\n\nusing OpenTelemetry.Trace;\n\nusing Definition = ADEXS.Core.Domain.Model.Workflow.Definition;\nusing Design = DocuSign.CLM.Workflow.Core.Persistence.Model.Design;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing StartParameters = ADEXS.Core.Domain.Model.Workflow.StartParameters;\nusing Status = Grpc.Core.Status;\nusing StatusCode = Grpc.Core.StatusCode;\nusing ValueExpressionOneOfCase = ADEXS.WINS.V1.VariableUpdate.ValueExpressionOneofCase;\nusing VariableUpdate = ADEXS.Core.Domain.Repository.Workflow.Types.VariableUpdate;\nusing Version = ADEXS.Core.Domain.Model.Workflow.Version;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService : WINS.V1.WinsService.WinsServiceBase\n{\n\tprivate static readonly Status StatusInvalidArgumentInstanceUid = new(StatusCode.InvalidArgument, \"InstanceUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentActivityUid = new(StatusCode.InvalidArgument, \"ActivityUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentVersionUid = new(StatusCode.InvalidArgument, \"VersionUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentRevisionUid = new(StatusCode.InvalidArgument, \"RevisionUid is malformed\");\n\n\tprivate readonly ILogger _logger;\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate readonly IUserAccountRepository _userAccountRepository;\n\n\tprivate readonly IWorkflowClient _workflowClient;\n\n\tprivate readonly IWorkflowV1GrpcMapper _workflowV1GrpcMapper;\n\n\tpublic WinsService(\n\t\tIWorkflowClient workflowClient,\n\t\tIUserAccountRepository userAccountRepository,\n\t\tIWorkflowV1GrpcMapper workflowV1GrpcMapper,\n\t\tIServiceInstrumentation serviceInstrumentation,\n\t\tILogger<WinsService> logger)\n\t{\n\t\t_workflowClient = workflowClient;\n\t\t_userAccountRepository = userAccountRepository;\n\t\t_workflowV1GrpcMapper = workflowV1GrpcMapper;\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t_logger = logger;\n\t}\n\n\tpublic override Task<CreateNewWorkflowDefinitionResponse> CreateNewWorkflowDefinition(\n\t\t[NotNull] CreateNewWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.CreateNewWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar definitionModel = _workflowClient.CreateNewWorkflowDefinition(userAccount, request.WorkflowName);\n\n\t\t\tvar definition = _workflowV1GrpcMapper.Map<Definition, WINS.V1.Definition>(definitionModel);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new CreateNewWorkflowDefinitionResponse {Definition = definition});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ExportWorkflowDefinitionResponse> ExportWorkflowDefinition(\n\t\t[NotNull] ExportWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ExportWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar definitionXml = _workflowClient.ExportWorkflowDefinition(userAccount, request.WorkflowName);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ExportWorkflowDefinitionResponse {DefinitionXml = definitionXml});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ImportWorkflowDefinitionResponse> ImportWorkflowDefinition(\n\t\t[NotNull] ImportWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ImportWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revisionModel = _workflowClient.ImportWorkflowDefinition(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.DefinitionXml,\n\t\t\t\trequest.OverwriteExistingWorkflow,\n\t\t\t\trequest.Comment,\n\t\t\t\trequest.TemplateId,\n\t\t\t\trequest.TemplateVersion);\n\n\t\t\tvar revision = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revisionModel);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ImportWorkflowDefinitionResponse {Revision = revision});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PublishWorkflowResponse> PublishWorkflow(\n\t\t[NotNull] PublishWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))\n\t\t{\n\t\t\tLogger.PublishWorkflowInvalidArgument(_logger, request.User.AccountId, ex: null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentVersionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PublishWorkflow(_logger, request.User.AccountId, request.VersionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowClient.PublishWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\tversionUid,\n\t\t\t\trequest.RevisionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar revisionResponse = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revision);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PublishWorkflowResponse {Revision = revisionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PublishWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PublishWorkflowByNameResponse> PublishWorkflowByName(\n\t\t[NotNull] PublishWorkflowByNameRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PublishWorkflowByName(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowClient.PublishWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.VersionNumber,\n\t\t\t\trequest.RevisionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar revisionResponse = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revision);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PublishWorkflowByNameResponse {Revision = revisionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<VersionWorkflowResponse> VersionWorkflow(\n\t\t[NotNull] VersionWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))\n\t\t{\n\t\t\tLogger.VersionWorkflowInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentVersionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.VersionWorkflow(_logger, request.User.AccountId, request.SourceVersionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowClient.VersionWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\tsourceVersionUid,\n\t\t\t\trequest.SourceRevisionNumber,\n\t\t\t\trequest.NewVersionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar versionResponse = _workflowV1GrpcMapper.Map<Version, WINS.V1.Version>(version);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new VersionWorkflowResponse {Version = versionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.VersionWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<VersionWorkflowByNameResponse> VersionWorkflowByName(\n\t\t[NotNull] VersionWorkflowByNameRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.VersionWorkflowByName(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowClient.VersionWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceVersionNumber,\n\t\t\t\trequest.SourceRevisionNumber,\n\t\t\t\trequest.NewVersionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar versionResponse = _workflowV1GrpcMapper.Map<Version, WINS.V1.Version>(version);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new VersionWorkflowByNameResponse {Version = versionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<KillWorkflowResponse> KillWorkflow(KillWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.KillWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.KillWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.KillWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new KillWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.KillWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.KillWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.KillWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PauseWorkflowResponse> PauseWorkflow(PauseWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.PauseWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PauseWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.PauseWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PauseWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PauseWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PauseWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PauseWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ResumeWorkflowResponse> ResumeWorkflow(\n\t\tResumeWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.ResumeWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.ResumeWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.ResumeWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ResumeWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ResumeWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ResumeWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ResumeWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ResumeFailedWorkflowResponse> ResumeFailedWorkflow(\n\t\tResumeFailedWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.ResumeFailedWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.ResumeFailedWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ResumeFailedWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SystemCallbackResponse> SystemCallback(\n\t\t[NotNull] SystemCallbackRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(request.CallbackName))\n\t\t{\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(StatusCode.InvalidArgument, $\"{nameof(request.CallbackName)} is null or empty\"));\n\t\t}\n\n\t\tLogger.SystemCallback(\n\t\t\t_logger,\n\t\t\trequest.AccountId,\n\t\t\trequest.InstanceUid,\n\t\t\trequest.ActivityUid,\n\t\t\trequest.CallbackName);\n\n\t\ttry\n\t\t{\n\t\t\t_workflowClient.SystemCallback(\n\t\t\t\trequest.AccountId,\n\t\t\t\tinstanceUid,\n\t\t\t\tactivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\trequest.CallbackData);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new SystemCallbackResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SystemCallbackInvalidArgument(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\targEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SystemCallbackFailed(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\tpublicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SystemCallbackFailed(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\tex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowResponse> StartWorkflow(StartWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.StartWorkflow(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.StartWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowFromSourceResponse> StartWorkflowFromSource(\n\t\tStartWorkflowFromSourceRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.StartWorkflowFromSource(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar newInstanceUid = _workflowClient.StartWorkflowFromSource(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam,\n\t\t\t\tinstanceUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.AddTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, newInstanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowFromSourceResponse {InstanceUid = newInstanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowWithParametersResponse> StartWorkflowWithParameters(\n\t\tStartWorkflowWithParametersRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\t\tValidateUser(request?.StartParameters?.Submitter);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tValidateAndParseUserUid(request.StartParameters!.Submitter.Uid, request.StartParameters.Submitter.AccountId, out var submitterUserAccountUid);\n\n\t\tLogger.StartWorkflowWithParameters(_logger, request.User.AccountId, request.InstanceUid, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar submitterUserAccount = LoadUserAccountSafe(request.StartParameters.Submitter.AccountId, submitterUserAccountUid);\n\n\t\t\tvar startParameters = new StartParameters(submitterUserAccount, null, null, null);\n\t\t\t_workflowV1GrpcMapper.Map(request.StartParameters, startParameters);\n\n\t\t\tvar newInstanceUid = _workflowClient.StartWorkflowWithParameters(\n\t\t\t\tuserAccount,\n\t\t\t\trevisionUid,\n\t\t\t\tstartParameters,\n\t\t\t\tinstanceUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.AddTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, newInstanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowWithParametersResponse {InstanceUid = newInstanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartRoutingApprovalWorkflowResponse> StartRoutingApprovalWorkflow(\n\t\tStartRoutingApprovalWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.StartRoutingApprovalWorkflow(_logger, request.User.AccountId, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.StartRoutingApprovalWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trevisionUid,\n\t\t\t\trequest.RoutingApprovalName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartRoutingApprovalWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SendStartWorkflowResponse> SendStartWorkflow(\n\t\tSendStartWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.SendStartWorkflow(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.SendStartWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t\treturn Task.FromResult(new SendStartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SendStartWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SendStartWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SendStartWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SubmitWorkItemResponse> SubmitWorkItem(\n\t\tSubmitWorkItemRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))\n\t\t{\n\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, ex: null);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"WorkItemUid is malformed\"));\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.SubmitWorkItem(_logger, request.User.AccountId, request.WorkItemUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables = new Dictionary<string, object>();\n\n\t\t\tforeach (var wireVariable in request.UpdatedVariables)\n\t\t\t{\n\t\t\t\tvar workflowVariableType =\n\t\t\t\t\t_workflowV1GrpcMapper.Map<WorkflowVariableType, Enums.WorkflowVariableType>(wireVariable.Type);\n\n\t\t\t\tif (!WorkflowConversion.TryParseVariableValue(\n\t\t\t\t\t    request.User.AccountId,\n\t\t\t\t\t    workflowVariableType,\n\t\t\t\t\t    wireVariable.Value.ToStringUtf8(),\n\t\t\t\t\t    out var outputValue))\n\t\t\t\t{\n\t\t\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, null);\n\t\t\t\t\tthrow new RpcException(\n\t\t\t\t\t\tnew Status(StatusCode.InvalidArgument, \"Unable to parse one of updated variables\"));\n\t\t\t\t}\n\n\t\t\t\tupdatedVariables[wireVariable.Name] = outputValue;\n\t\t\t}\n\n\t\t\t_workflowClient.SubmitWorkItem(\n\t\t\t\tuserAccount,\n\t\t\t\tworkItemUid,\n\t\t\t\trequest.Output,\n\t\t\t\trequest.Comments,\n\t\t\t\trequest.ActivityMessages,\n\t\t\t\tupdatedVariables);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new SubmitWorkItemResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SubmitWorkItemFailed(_logger, request.User.AccountId, request.WorkItemUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SubmitWorkItemFailed(_logger, request.User.AccountId, request.WorkItemUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<LoadDesignResponse> LoadDesign(LoadDesignRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.LoadDesign(_logger, request.User.AccountId, request.Version.Uid, request.Version.DefinitionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowV1GrpcMapper.Map<WINS.V1.Version, Version>(request.Version);\n\n\t\t\tvar design = _workflowClient.LoadDesign(userAccount, version);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(design);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new LoadDesignResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.LoadDesignInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.LoadDesignFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.LoadDesignFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<LoadDesignByRevisionResponse> LoadDesignByRevision(\n\t\tLoadDesignByRevisionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.LoadDesignByRevision(_logger, request.User.AccountId, request.Revision.Uid, request.Revision.VersionUid, request.Revision.DefinitionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowV1GrpcMapper.Map<WINS.V1.Revision, Revision>(request.Revision);\n\n\t\t\tvar design = _workflowClient.LoadDesign(userAccount, revision);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(design);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new LoadDesignByRevisionResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ConvertLegacyDefinitionResponse> ConvertLegacyDefinition(\n\t\tConvertLegacyDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ConvertLegacyDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar oldDesign = _workflowV1GrpcMapper.Map<WINS.V1.Design, Design>(request.OldDesign);\n\n\t\t\tvar newDesign = _workflowClient.ConvertLegacyDefinition(userAccount, oldDesign);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(newDesign);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ConvertLegacyDefinitionResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<CompileExpressionBuilderExpressionResponse> CompileExpressionBuilderExpression(\n\t\tCompileExpressionBuilderExpressionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (string.IsNullOrWhiteSpace(request.Code))\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"Code is null or empty\"));\n\t\t}\n\n\t\tLogger.CompileExpressionBuilderExpression(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar output = _workflowClient.CompileExpressionBuilderExpression(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.Code,\n\t\t\t\trequest.AdditionalCode,\n\t\t\t\trequest.ReturnType);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new CompileExpressionBuilderExpressionResponse {Output = output});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<UpdateVariablesResponse> UpdateVariables(\n\t\tUpdateVariablesRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceInstanceUid, out var sourceInstanceUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceActivityUid, out var sourceActivityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tLogger.UpdateVariables(_logger, request.User.AccountId, request.ActivityUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables =\n\t\t\t\t_workflowV1GrpcMapper\n\t\t\t\t\t.Map<List<ADEXS.WINS.V1.VariableUpdate>, List<VariableUpdate>>(\n\t\t\t\t\t\trequest.VariableUpdates.ToList());\n\n\t\t\tvar result = _workflowClient.UpdateVariables(\n\t\t\t\tuserAccount,\n\t\t\t\tactivityUid,\n\t\t\t\tupdatedVariables,\n\t\t\t\tsourceInstanceUid,\n\t\t\t\tsourceActivityUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new UpdateVariablesResponse {Result = result});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.UpdateVariablesFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<UpdateVariablesWithResultResponse> UpdateVariablesWithResult(\n\t\tUpdateVariablesWithResultRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceInstanceUid, out var sourceInstanceUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceActivityUid, out var sourceActivityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tLogger.UpdateVariablesWithResult(_logger, request.User.AccountId, request.ActivityUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables =\n\t\t\t\t_workflowV1GrpcMapper\n\t\t\t\t\t.Map<List<ADEXS.WINS.V1.VariableUpdate>, List<VariableUpdate>>(\n\t\t\t\t\t\trequest.VariableUpdates.ToList());\n\n\t\t\tvar result = _workflowClient.UpdateVariablesWithResult(\n\t\t\t\tuserAccount,\n\t\t\t\tactivityUid,\n\t\t\t\tupdatedVariables,\n\t\t\t\tsourceInstanceUid,\n\t\t\t\tsourceActivityUid);\n\n\t\t\tvar resultResponse = _workflowV1GrpcMapper\n\t\t\t\t.Map<WorkflowEnums.UpdateParentVariableResult, UpdateParentVariableResult>(result);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new UpdateVariablesWithResultResponse {Result = resultResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<IsActivityExecutionLimitReachedResponse> IsActivityExecutionLimitReached(\n\t\t[NotNull] IsActivityExecutionLimitReachedRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tLogger.IsActivityExecutionLimitReached(_logger, request.AccountId, request.InstanceUid, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar revisionCreatedDate = _workflowV1GrpcMapper.Map<Timestamp, DateTime>(request.RevisionCreatedDate);\n\n\t\t\tvar isLimitReached = _workflowClient.IsActivityExecutionLimitReached(\n\t\t\t\trequest!.AccountId,\n\t\t\t\tinstanceUid,\n\t\t\t\trevisionUid,\n\t\t\t\trevisionCreatedDate,\n\t\t\t\trequest.ActivityExecutionCount);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new IsActivityExecutionLimitReachedResponse {IsLimitReached = isLimitReached});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedFailed(_logger, request.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedFailed(_logger, request.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tprivate static RpcException HandleArgumentException(Activity? activity, ArgumentException argEx)\n\t{\n\t\tactivity?.AddException(argEx);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)StatusCode.InvalidArgument,\n\t\t\tMessage = string.Empty,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(argEx.ToRpcDebugInfo())\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static RpcException HandleUnknownException(Activity? activity, Exception ex)\n\t{\n\t\tactivity?.AddException(ex);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)StatusCode.Internal,\n\t\t\tMessage = string.Empty,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(ex.ToRpcDebugInfo())\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static RpcException HandlePublicException(Activity? activity, PublicException ex)\n\t{\n\t\tactivity?.AddException(ex);\n\t\tvar statusCode = GetStatusCodeFromFailReason(ex.Reason);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)statusCode,\n\t\t\tMessage = ex.Message,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(ex.ToRpcDebugInfo()),\n\t\t\t\tAny.Pack(new ErrorInfo\n\t\t\t\t{\n\t\t\t\t\tDomain = nameof(PublicException),\n\t\t\t\t\tReason = ex.Reason.ToString(),\n\t\t\t\t\tMetadata =\n\t\t\t\t\t{\n\t\t\t\t\t\t{ nameof(ex.Message), ex.Message },\n\t\t\t\t\t\t{ nameof(ex.InternalMessage), ex.InternalMessage }\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static StatusCode GetStatusCodeFromFailReason(PublicException.FailReason failReason)\n\t{\n\t\treturn failReason switch\n\t\t{\n\t\t\tPublicException.FailReason.NonexistentObject => StatusCode.NotFound,\n\t\t\tPublicException.FailReason.InvalidArgument => StatusCode.InvalidArgument,\n\t\t\tPublicException.FailReason.InvalidState => StatusCode.FailedPrecondition,\n\t\t\tPublicException.FailReason.InternalError => StatusCode.Internal,\n\t\t\tPublicException.FailReason.TemporarilyUnavailable => StatusCode.Unavailable,\n\t\t\tPublicException.FailReason.PermissionDenied => StatusCode.PermissionDenied,\n\t\t\tPublicException.FailReason.ObjectAlreadyExists => StatusCode.AlreadyExists,\n\t\t\t_ => StatusCode.Internal, // Default case\n\t\t};\n\t}\n\n\tprivate static void ValidateUser(UserAccount? user)\n\t{\n\t\tif (user == null)\n\t\t{\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"User is null\"));\n\t\t}\n\t}\n\n\tprivate void ValidateAndParseUserUid(string userUid, int accountId, out Guid userAccountUid)\n\t{\n\t\tif (!Guid.TryParse(userUid, out userAccountUid))\n\t\t{\n\t\t\tLogger.UserUidFormatError(_logger, userUid, accountId);\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(\n\t\t\t\t\tStatusCode.InvalidArgument,\n\t\t\t\t\t\"User.Uid is malformed\"));\n\t\t}\n\t}\n\n\tprivate void ValidateWorkflowName(string workflowName)\n\t{\n\t\tif (string.IsNullOrEmpty(workflowName))\n\t\t{\n\t\t\tLogger.WorkflowFormatError(_logger);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"WorkflowName is null or empty\"));\n\t\t}\n\t}\n\n\tprivate Core.Domain.Model.UserAccount? LoadUserAccountSafe(int accountId, Guid userAccountUid)\n\t{\n\t\tvar userAccount = _userAccountRepository.LoadByUid(accountId, userAccountUid);\n\n\t\tif (userAccount == null)\n\t\t{\n\t\t\tLogger.UserAccountNotFound(_logger, userAccountUid, accountId);\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(\n\t\t\t\t\tStatusCode.NotFound,\n\t\t\t\t\t$\"User {userAccountUid} not found in account {accountId}\"));\n\t\t}\n\n\t\treturn userAccount;\n\t}\n}\n\n#nullable restore\n#endif\n",
      "relevance_score": 0.9
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class DetectTypeProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore\n",
      "relevance_score": 0.9
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/CustomRules/DocumentRules/DocumentRuleAnalyzer.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Repository.CustomRuleRepository;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.CustomRules.Actions;\nusing ADEXS.CustomRules.Filters;\n\nnamespace ADEXS.CustomRules.DocumentRules\n{\n\tpublic class DocumentRuleAnalyzer : IRuleAnalyzer\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(DocumentRuleAnalyzer));\n\t\tprivate readonly DocumentRule _rule;\n\t\tprivate readonly List<string> _msg = new List<string>();\n\n\t\tpublic DocumentRuleAnalyzer(DocumentRule rule)\n\t\t{\n\t\t\tif (null == rule)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"Rule is null\");\n\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidArgument, Resources.CustomRules.error_InvalidRule);\n\t\t\t}\n\t\t\t_rule = rule;\n\t\t}\n\n\t\tpublic List<string> Suggestions\n\t\t{\n\t\t\tget { return _msg; }\n\t\t}\n\n\t\tpublic void Analyze()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tList<AbstractCustomRuleFilter> lst;\n\t\t\t\tif (!_rule.IsScheduled)\n\t\t\t\t{\n\t\t\t\t\tlst = Find(Enums.CustomRuleFilterType.InFolder);\n\t\t\t\t\tif (lst.Count < 1)\n\t\t\t\t\t\t_msg.Add(string.Format(Resources.CustomRules.analyze_AddInFolderFilter, GetName(Enums.CustomRuleFilterType.InFolder)));\n\t\t\t\t}\n\n\t\t\t\tif (Enums.CustomRuleEventType.AttributeGroupAssigned == _rule.EventType)\n\t\t\t\t{\n\t\t\t\t\tlst = Find(Enums.CustomRuleFilterType.AssignedGroup);\n\t\t\t\t\tif (lst.Count < 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t_msg.Add(string.Format(Resources.CustomRules.analyze_AddAssignedGroup,\n\t\t\t\t\t\t\t\t\t\t\t\tGetName(Enums.CustomRuleFilterType.AssignedGroup),\n\t\t\t\t\t\t\t\t\t\t\t\tGetName(Enums.CustomRuleEventType.AttributeGroupAssigned)));\n\n\t\t\t\t\t\tlst = Find(Enums.CustomRuleFilterType.HasAttributeGroup);\n\t\t\t\t\t\tif (lst.Count < 1)\n\t\t\t\t\t\t\t_msg.Add(string.Format(Resources.CustomRules.analyze_AddHasAttributeGroup,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGetName(Enums.CustomRuleFilterType.HasAttributeGroup),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGetName(Enums.CustomRuleEventType.AttributeGroupAssigned)));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (Enums.CustomRuleEventType.AttributeValueChanged == _rule.EventType)\n\t\t\t\t{\n\t\t\t\t\tlst = Find(Enums.CustomRuleFilterType.ChangedAttributeField);\n\t\t\t\t\tif (lst.Count < 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlst = Find(Enums.CustomRuleFilterType.HasAttributeValue);\n\t\t\t\t\t\tif (lst.Count < 1)\n\t\t\t\t\t\t\t_msg.Add(string.Format(Resources.CustomRules.analyze_AddAttributeFilter,\n\t\t\t\t\t\t\t\t\t\t\t\t\tGetName(Enums.CustomRuleFilterType.HasAttributeValue),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGetName(Enums.CustomRuleFilterType.ChangedAttributeField),\n\t\t\t\t\t\t\t\t\t\t\t\t\tGetName(Enums.CustomRuleEventType.AttributeValueChanged)));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tList<AbstractCustomRuleAction> alst = Find(Enums.CustomRuleActionType.MoveDocument);\n\t\t\t\tif (alst.Count > 1)\n\t\t\t\t\t_msg.Add(string.Format(Resources.CustomRules.analyze_MultiveMoves,\n\t\t\t\t\t\t\t\t\t\t\tGetName(Enums.CustomRuleActionType.MoveDocument)));\n\n\t\t\t\tList<AbstractCustomRuleFilter> flst = Find(Enums.CustomRuleFilterType.InFolder);\n\t\t\t\tbool enough = false;\n\t\t\t\tforeach (MoveDocument moveAct in alst)\n\t\t\t\t{\n\t\t\t\t\tforeach (InFolder folderFilt in flst)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (moveAct.FolderUid == folderFilt.FolderUid)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_msg.Add(Resources.CustomRules.analyze_NoNeedToMove);\n\t\t\t\t\t\t\tenough = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(enough) break;\n\t\t\t\t}\n\n\t\t\t\talst = Find(Enums.CustomRuleActionType.SetAttributeGroup);\n\t\t\t\tflst = Find(Enums.CustomRuleFilterType.HasAttributeGroup);\n\t\t\t\tenough = false;\n\t\t\t\tforeach (SetAttributeGroup grpAct in alst)\n\t\t\t\t{\n\t\t\t\t\tforeach (HasAttributeGroup hasGrp in flst)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (grpAct.AttributeGroupUid == hasGrp.AttributeGroupUid)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_msg.Add(Resources.CustomRules.analyze_NoNeedToAssignGroup);\n\t\t\t\t\t\t\tenough = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (enough) break;\n\t\t\t\t}\n\n\t\t\t\talst = Find(Enums.CustomRuleActionType.SetAttributeValue);\n\t\t\t\tflst = Find(Enums.CustomRuleFilterType.HasAttributeValue);\n\t\t\t\tenough = false;\n\t\t\t\tforeach (SetAttributeValue fldAct in alst)\n\t\t\t\t{\n\t\t\t\t\tforeach (HasAttributeValue hasFld in flst)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fldAct.AttributeFieldUid == hasFld.AttributeFieldUid && fldAct.AttributeValue == hasFld.AttributeValue)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_msg.Add(Resources.CustomRules.analyze_NoNeedToAssignField);\n\t\t\t\t\t\t\tenough = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (enough) break;\n\t\t\t\t}\n\n\t\t\t\talst = Find(Enums.CustomRuleActionType.BulkMetadataImport);\n\t\t\t\tif (alst.Count > 0)\n\t\t\t\t{\n\t\t\t\t\t_msg.Add(string.Format(Resources.CustomRules.analyze_BulkMetaImport, GetName(Enums.CustomRuleActionType.BulkMetadataImport)));\n\t\t\t\t}\n\n\t\t\t\tCheckMetadataUpdateSequence();\n\n                if (_rule.RequiresInitiator)\n                {\n                    _msg.Add(Resources.CustomRules.analyze_RequireInitiatorWillForceNonUserActionsToNotFire);\n                }\n\t\t\t}\n\t\t\tcatch(Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Analyzing failed with exception\", ex);\n\t\t\t\t_msg.Add(Resources.CustomRules.analyze_GenericError);\n\t\t\t}\n\t\t}\n\n\t\tprivate void CheckMetadataUpdateSequence()\n\t\t{\n\t\t\tbool sequenceEnded = false;\n\t\t\tbool prevActionUpdatesMeta = false;\n\t\t\tforeach (AbstractCustomRuleAction action in _rule.Actions)\n\t\t\t{\n\t\t\t\tif(sequenceEnded)\n\t\t\t\t{\n\t\t\t\t\tif(!prevActionUpdatesMeta && action.UpdatesMetadata())\n\t\t\t\t\t{\n\t\t\t\t\t\t_msg.Add(Resources.CustomRules.analyze_GroupAttributeUpdates);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (prevActionUpdatesMeta && !action.UpdatesMetadata())\n\t\t\t\t\t\tsequenceEnded = true;\n\t\t\t\t}\n\n\t\t\t\tprevActionUpdatesMeta = action.UpdatesMetadata();\n\t\t\t}\n\t\t}\n\n\n\t\tprivate List<AbstractCustomRuleFilter> Find(Enums.CustomRuleFilterType filtType)\n\t\t{\n\t\t\tList<AbstractCustomRuleFilter> lst = new List<AbstractCustomRuleFilter>();\n\t\t\tforeach (AbstractCustomRuleFilter filter in _rule.Filters)\n\t\t\t\tif (filtType == filter.FilterType || (filtType == Enums.CustomRuleFilterType.InFolder && filter.FilterType == Enums.CustomRuleFilterType.InSubfolder))\n\t\t\t\t\tlst.Add(filter);\n\n\t\t\treturn lst;\n\t\t}\n\n\t\tprivate List<AbstractCustomRuleAction> Find(Enums.CustomRuleActionType actionType)\n\t\t{\n\t\t\tList<AbstractCustomRuleAction> lst = new List<AbstractCustomRuleAction>();\n\t\t\tforeach (AbstractCustomRuleAction action in _rule.Actions)\n\t\t\t\tif (actionType == action.ActionType)\n\t\t\t\t\tlst.Add(action);\n\n\t\t\treturn lst;\n\t\t}\n\n\t\tprivate string GetName(Enums.CustomRuleEventType eventType)\n\t\t{\n\t\t\treturn Enums.GetLocalizedName(eventType, Resources.CustomRules.ResourceManager);\n\t\t}\n\t\tprivate string GetName(Enums.CustomRuleFilterType filterType)\n\t\t{\n\t\t\treturn Enums.GetLocalizedName(filterType, Resources.CustomRules.ResourceManager);\n\t\t}\n\t\tprivate string GetName(Enums.CustomRuleActionType actionType)\n\t\t{\n\t\t\treturn Enums.GetLocalizedName(actionType, Resources.CustomRules.ResourceManager);\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService/ESignatureComponent.cs",
      "content": "\ufeffusing System.Collections.Generic;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.ElectronicSignature;\nusing ADEXS.HealthCheck;\nusing ADEXS.MQ;\nusing ADEXS.MqWorkers;\nusing ADEXS.ServiceFramework;\nusing ADEXS.Services.MessageWorkerService;\n\nusing CLM.MessageDefines.Interfaces;\nusing CLM.MessageDefines.Tasks;\n\nusing StructureMap;\n\nnamespace ADEXS.ESignatureService\n{\n    public class ESignatureComponent\n#if NET\n\t\t: ScmServicedComponent\n#else\n\t\t: AbstractServicedComponent\n#endif\n\t{\n\t\tprotected override void OnRun()\n\t\t{\n\t\t\tvar container = ServiceLocator.Container;\n\n\t\t\tExplicitArgsExpression CreateFactory() => container.With(typeof(IServicedComponent), this);\n\n\t\t\tAbstractServiceWorkerGroup CreateWorker<TTask, TProcessor>(TaskTypes taskTypes)\n\t\t\t\twhere TTask : class, IQueueTask, new() where TProcessor : class, ITaskProcessor<TTask>, new() =>\n\t\t\t\tCreateFactory().With(typeof(TaskTypes), taskTypes).GetInstance<DispatchedWorker<TTask, TProcessor>>();\n\n\t\t\tRegisterWorkerGroup(CreateWorker<ElectronicSignatureTask, ESignatureTaskProcessor>(TaskTypes.ElectronicSignatureTask));\n\t\t\tRegisterWorkerGroup(CreateWorker<ElectronicSignatureUserTask, ESignatureUserTaskProcessor>(TaskTypes.ElectronicSignatureUserTask));\n\t\t}\n\n#if NET\n\t\tprotected override void OnStop()\n\t\t{\n\t\t}\n#endif\n\n\t\tprotected override List<IServiceRegistry> GetServiceRegistries()\n\t\t{\n\t\t\tvar registries = base.GetServiceRegistries();\n\t\t\tvar configFileName = \"ESignatureService.ini\";\n\n#if NET\n\t\t\tregistries.Add(new CoreDomainRegistry());\n\t\t\tregistries.Add(new MessageQueueRegistry());\n#else\n\t\t\tregistries.Add(new OneConfigServiceRegistry());\n\t\t\tregistries.Add(new ServiceConfigServiceRegistry(configFileName));\n#endif\n\n\t\t\tregistries.Add(new ESignatureRegistry());\n\t\t\tregistries.Add(new MqWorkersRegistry(configFileName));\n\n\t\t\treturn registries;\n\t\t}\n\n#if NETFRAMEWORK\n\t\tpublic override IList<IHealthCheckItem> GetHealthChecksChain(IList<IHealthCheckItem> defaultChecks)\n\t\t{\n\t\t\tvar checks = new List<IHealthCheckItem>(defaultChecks)\n\t\t\t{\n\t\t\t\tnew HealthCheckRMQ(Core.Types.Constants.HealthCheckRMQPath),\n\t\t\t};\n\n\t\t\treturn checks;\n\t\t}\n#endif\n\n\t\tvoid RegisterDispatchedWorker<TTask, TProcessor>(IContainer container, IServicedComponent serviceComponent, TaskTypes taskType)\n\t\t\twhere TTask : class, IQueueTask, new()\n\t\t\twhere TProcessor : class, ITaskProcessor<TTask>, new()\n\t\t{\n\t\t\tvar worker = container.With(typeof(IServicedComponent), serviceComponent).With(typeof(TaskTypes), taskType).GetInstance<DispatchedWorker<TTask, TProcessor>>();\n\n\t\t\tRegisterWorkerGroup(worker);\n\t\t}\n\n\t\tpublic static IList<IServiceRegistry> GetComponentServiceRegistries()\n\t\t{\n\t\t\treturn new ESignatureComponent().GetServiceRegistries();\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/AgreementRepository/AgreementRepository.cs",
      "content": "\ufeffusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing ADEXS.Core.Domain.Aom;\nusing ADEXS.Core.Domain.Attributes;\nusing ADEXS.Core.Domain.Repository.CounterpartyRepository;\nusing ADEXS.Core.Domain.Repository.EventRepository;\nusing ADEXS.Core.Domain.Repository.MetadataRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Util.Core;\n\nusing CLM.MessageDefines;\n\nusing Platform.Common;\nusing CLM.MessageDefines.Event;\n\nusing Newtonsoft.Json.Linq;\n\nnamespace ADEXS.Core.Domain.Repository.AgreementRepository\n{\n\tpublic interface IAgreementRepository\n\t{\n\t\t//Any Load methods in this repository need to call the SetAgreementType method to set the Agreement type display name (alias)\n\t\tAgreement LoadById(UserAccount userAccount, Guid agreementId);\n\t\tAgreement LoadByExternalId(UserAccount userAccount, string externalId);\n\t\tList<Agreement> LoadByExternalIds(UserAccount userAccount, List<string> externalIds);\n\t\tList<Agreement> LoadByPartyId(UserAccount userAccount, Guid counterpartyUid, bool filterVisibleAgreements = true, List<string> expand = null);\n\t\tPartyAgreementTrees LoadPartyAgreementTrees(UserAccount userAccount, Guid partyUid);\n\t\tAgreementNode LoadAgreementTreeByAgreementId(UserAccount userAccount, Guid agreementUid);\n\t\tAgreementNode LoadAgreementTreeByAgreement(UserAccount userAccount, Agreement agreement);\n\t\tAgreement LoadByDocumentUid(UserAccount currentUser, Guid documentUid, bool convertDatesToAccountTimeZone = true);\n\t\tList<AgreementRelationship> LoadRelationshipsByAgreementId(UserAccount userAccount, Guid agreementId);\n\t\tAgreement Create(UserAccount userAccount, Agreement agreement, List<Agreement> relatedAgreements);\n\t\tAgreement Create(UserAccount userAccount, Agreement agreement, Guid? parentAgreementId);\n\t\tAgreement Update(UserAccount userAccount, Agreement agreement, List<Agreement> relatedAgreements, bool isPartial = false);\n\t\tAgreement UpdateV2(UserAccount userAccount, Agreement agreement, Guid? parentAgreementId, bool isPartial = false);\n\t\tbool Delete(UserAccount userAccount, Guid agreementId);\n\t\tGuid GetPartyFolder(UserAccount userAccount, Guid partyId);\n\t\tList<string> GetChildDocumentTypes();\n\t\tbool IsChildDocumentType(string type);\n\t\tGuid GetAgreementIdByDocumentUid(UserAccount currentUser, Guid documentUid);\n\t\tList<KeyValuePair<int, string>> GetTimeUnitsAndLocalizedName();\n\t\tAgreement SaveSummary(UserAccount userAccount, Guid agreementUid, string summary);\n\t}\n\n\tpublic class AgreementRepository : IAgreementRepository\n\t{\n\t\tprivate readonly IDocumentRepository _documentRepository;\n\t\tprivate readonly IDocumentHistoryRepository _documentHistoryRepository;\n\t\tprivate readonly IUserActionRepository _userActionRepository;\n\t\tprivate readonly IFolderRepository _folderRepository;\n\t\tprivate readonly IAgreementPersistence _agreementPersistence;\n\t\tprivate readonly IAgreementRelationshipPersistence _relationshipPersistence;\n\t\tprivate readonly IAttributesManagementFramework _attributesManagementFramework;\n\t\tprivate readonly AgreementRelationshipHelper _agreementRelationshipHelper;\n\t\tprivate readonly AgreementMetadataHelper _agreementMetadataHelper;\n\t\tprivate readonly PartyMetadataHelper _partyMetadataHelper;\n\t\tprivate readonly IEventRepository _eventRepository;\n\t\tprivate readonly ICounterpartyRepository _counterpartyRepository;\n\t\tinternal Dictionary<string, DocumentType> _agreementTypesDictionary = null;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(AgreementRepository));\n\n\t\tpublic AgreementRepository(ICounterpartyRepository counterpartyRepository,\n\t\t\tIDocumentRepository documentRepository,\n\t\t\tIFolderRepository folderRepository,\n\t\t\tIMetadataGroupRepository metadataGroupRepository,\n\t\t\tIAgreementPersistence agreementPersistence,\n\t\t\tIMetadataFieldRepository metadataFieldRepository,\n\t\t\tIMetadataRepository metadataRepository,\n\t\t\tIAgreementRelationshipPersistence relationshipPersistence,\n\t\t\tIAttributesManagementFramework attributesManagementFramework,\n\t\t\tIEventRepository eventRepository,\n\t\t\tIDocumentHistoryRepository documentHistoryRepository,\n\t\t\tIUserActionRepository userActionRepository)\n\t\t{\n\t\t\t_documentRepository = documentRepository;\n\t\t\t_documentHistoryRepository = documentHistoryRepository;\n\t\t\t_folderRepository = folderRepository;\n\t\t\t_eventRepository = eventRepository;\n\t\t\t_counterpartyRepository = counterpartyRepository;\n\t\t\t_agreementPersistence = agreementPersistence;\n\t\t\t_relationshipPersistence = relationshipPersistence;\n\t\t\t_attributesManagementFramework = attributesManagementFramework;\n\t\t\t_agreementRelationshipHelper = new AgreementRelationshipHelper(this, relationshipPersistence);\n\t\t\t_agreementMetadataHelper = new AgreementMetadataHelper(documentRepository, metadataGroupRepository, metadataFieldRepository, metadataRepository, counterpartyRepository, attributesManagementFramework);\n\t\t\t_partyMetadataHelper = new PartyMetadataHelper(folderRepository, metadataGroupRepository, metadataFieldRepository, metadataRepository, documentRepository);\n\t\t\t_userActionRepository = userActionRepository;\n\t\t}\n\n\t\tpublic Agreement Create(UserAccount userAccount, Agreement agreement, List<Agreement> relatedAgreements)\n\t\t{\n\t\t\tValidateAgreementDoesNotExist(userAccount, agreement);\n\t\t\tif (!agreement.IsValid(out List<string> errors))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Agreement did not meet validation. Will not create, Reasons: {string.Join(\", \", errors)}\");\n\t\t\t\tthrow new Exception(Resources.Parties.AgreementValAgreementInvalid);\n\t\t\t}\n\t\t\t_agreementRelationshipHelper.ValidateAgreementRelationships(userAccount, agreement, relatedAgreements);\n\t\t\tDocument document = null;\n\t\t\tif (!string.IsNullOrEmpty(agreement.ExternalId) && Guid.TryParse(agreement.ExternalId, out Guid documentUid))\n\t\t\t{\n\t\t\t\t// We are deliberately calling LoadByUid here since LoadByAgreement could return null if the\n\t\t\t\t// Agreement would not be not visible to the user due to ABAC security policies. This allows users\n\t\t\t\t// to create agreements & documents that they will not be able to see after creation\n\t\t\t\tdocument = _documentRepository.LoadByUid(userAccount, documentUid);\n\t\t\t\tagreement.CreatedBy = document.CreatedBy;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tagreement.CreatedBy = AomUtilities.GetActorName(userAccount);\n\t\t\t}\n\t\t\tagreement.UpdatedBy = AomUtilities.GetActorName(userAccount);\n\t\t\tagreement.UpdateEffectiveAndExpirationDate();\n\t\t\tAgreement agreementResult = _agreementPersistence.Create(userAccount, agreement);\n\t\t\tif (agreementResult != null)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Successfully created post request for agreement id {agreementResult.Id} with document uid {agreementResult.ExternalId}\");\n\t\t\t\t_agreementRelationshipHelper.CreateRelationships(userAccount, agreementResult, relatedAgreements, null);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unsuccessful post request for agreement with document uid: {agreement.ExternalId}\");\n\t\t\t}\n\t\t\t_agreementMetadataHelper.SaveAgreementSystemMetadata(userAccount, agreementResult ?? agreement, document);\n\t\t\treturn SetAgreementType(agreementResult, userAccount);\n\t\t}\n\n\t\tpublic Agreement Create(UserAccount userAccount, Agreement agreement, Guid? parentAgreementId)\n\t\t{\n\t\t\tValidateAgreementDoesNotExist(userAccount, agreement);\n\n\t\t\tDocument document = null;\n\t\t\tif (!string.IsNullOrEmpty(agreement.ExternalId))\n\t\t\t{\n\t\t\t\t// In general when loading a document from an agreement LoadByAgreement method should be used\n\t\t\t\t// this is an exception because we are creating an agreement and the user should be able to create any agreement they want without security checks\n\t\t\t\t// in this case LoadByUid will fail to load agreements from ADM and so the default creator security will apply. \n\t\t\t\tdocument = _documentRepository.LoadByUid(userAccount, Guid.Parse(agreement.ExternalId));\n\t\t\t\tagreement.CreatedBy = document.CreatedBy;\n\t\t\t}\n\n\t\t\tPartyAgreementTrees partyAgreementTrees = agreement.PartyId == null ? new PartyAgreementTrees(userAccount, null, new List<Agreement>(), _attributesManagementFramework) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLoadPartyAgreementTrees(userAccount, agreement.Party.Id);\n\t\t\tAgreementNode createdNode = partyAgreementTrees.CreateAgreement(userAccount, agreement, parentAgreementId, document);\n\t\t\treturn Save(userAccount, createdNode);\n\t\t}\n\n\t\tpublic Agreement Update(UserAccount userAccount, Agreement agreement, List<Agreement> relatedAgreements, bool isPartial = false)\n\t\t{\n\t\t\tif (agreement == null || agreement.Id == Guid.Empty)\n\t\t\t{\n\t\t\t\tthrow new ArgumentException(\"Agreement is either null or agreement id is empty\");\n\t\t\t}\n\t\t\tAgreement existingAgreement = LoadById(userAccount, agreement.Id);\n\t\t\t// Get all agreement relationships in one list\n\t\t\tList<AgreementRelationship> existingAgreementRelationships = LoadRelationshipsByAgreementId(userAccount, agreement.Id) ?? new List<AgreementRelationship>();\n\t\t\tif (existingAgreement.Id != agreement.Id)\n\t\t\t{\n\t\t\t\tthrow new Exception($\"AOM update failed - Different agreement exists for document. New agreement ID: {agreement.Id}, Old agreement ID: {existingAgreement.Id}, External Id {agreement.ExternalId}\");\n\t\t\t}\n\n\t\t\tif (agreement.ExternalId != existingAgreement.ExternalId)\n\t\t\t{\n\t\t\t\tthrow new Exception($@\"EXTERNAL_ID_MISMATCH - Attempting to update an agreement that has a different externalId than the original existing agreement. \n\t\t\t\t\t\t\t\t\tAgreement.Id: {agreement.Id}, Agreement.ExternalId: {agreement.ExternalId}, \n\t\t\t\t\t\t\t\t\tExistingAgreement.Id: {existingAgreement.Id}, ExistingAgreement.ExternalId: {existingAgreement.ExternalId}.\");\n\t\t\t}\n\n\t\t\tif (isPartial)\n\t\t\t{\n\t\t\t\tMergeAgreementFields(agreement, existingAgreement);\n\t\t\t\trelatedAgreements = relatedAgreements\n\t\t\t\t\t.Append(existingAgreementRelationships.Select(ar => LoadById(userAccount, ar.RelatedAgreement.Id)))\n\t\t\t\t\t.Where(a => a != null)\n\t\t\t\t\t.Distinct(a => a.Id)\n\t\t\t\t\t.ToList();\n\t\t\t}\n\t\t\tagreement.UpdateEffectiveAndExpirationDate();\n\t\t\tif (!agreement.IsValid(out List<string> errors))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Agreement did not meet validation. Will not update, Reasons: {string.Join(\", \", errors)}\");\n\t\t\t\tthrow new Exception(Resources.Parties.AgreementValAgreementInvalid);\n\t\t\t}\n\t\t\t_agreementRelationshipHelper.ValidateAgreementRelationships(userAccount, agreement, relatedAgreements);\n\t\t\tagreement.CreatedBy = existingAgreement.CreatedBy;\n\t\t\tagreement.UpdatedBy = AomUtilities.GetActorName(userAccount);\n\t\t\t_agreementRelationshipHelper.DeleteExcludedRelationships(userAccount, agreement, relatedAgreements, existingAgreementRelationships);\n\t\t\tAgreement agreementResult = isPartial ? _agreementPersistence.Patch(userAccount, agreement) : _agreementPersistence.Update(userAccount, agreement);\n\t\t\tif (agreementResult != null)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\n\t\t\t\t\t$\"Successfully created post request for updating agreement id {agreementResult.Id} with document uid {agreementResult.ExternalId}\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\n\t\t\t\t\t$\"Unsuccessful post request for updating agreement with agreement id {agreement.Id} with document uid: {agreement.ExternalId}\");\n\t\t\t}\n\t\t\t_agreementRelationshipHelper.CreateRelationships(userAccount, agreement, relatedAgreements, existingAgreementRelationships);\n\t\t\t_agreementMetadataHelper.SaveAgreementSystemMetadata(userAccount, agreementResult ?? agreement);\n\t\t\t_agreementRelationshipHelper.UpdateRelatedAgreementsParty(userAccount, agreementResult);\n\t\t\tvar updatedAgreement = SetAgreementType(agreementResult, userAccount);\n\t\t\tFireMetadataUpdatedEvent(userAccount, updatedAgreement);\n\n\t\t\treturn updatedAgreement;\n\t\t}\n\n\t\tpublic Agreement UpdateV2(UserAccount userAccount, Agreement agreement, Guid? parentAgreementId, bool isPartial = false)\n\t\t{\n\t\t\tif (agreement == null || agreement.Id == Guid.Empty)\n\t\t\t{\n\t\t\t\tthrow new ArgumentException(\"Agreement is either null or agreement id is empty\");\n\t\t\t}\n\n\t\t\tAgreement existingAgreement = LoadById(userAccount, agreement.Id);\n\t\t\tif (existingAgreement == null)\n\t\t\t{\n\t\t\t\tthrow new Exception($\"Unable to load agreement. AgreementId: {agreement.Id}\");\n\t\t\t}\n\n\t\t\tif (agreement.ExternalId != existingAgreement.ExternalId)\n\t\t\t{\n\t\t\t\tthrow new Exception($@\"EXTERNAL_ID_MISMATCH - Attempting to update an agreement that has a different externalId than the original existing agreement. \n\t\t\t\t\t\t\t\t\tAgreement.Id: {agreement.Id}, Agreement.ExternalId: {agreement.ExternalId}, \n\t\t\t\t\t\t\t\t\tExistingAgreement.Id: {existingAgreement.Id}, ExistingAgreement.ExternalId: {existingAgreement.ExternalId}.\");\n\t\t\t}\n\n\t\t\tif (isPartial)\n\t\t\t{\n\t\t\t\tMergeAgreementFields(agreement, existingAgreement);\n\t\t\t}\n\n\t\t\t// Load the party agreement trees of the new party so on party change it can import the new node.\n\t\t\tPartyAgreementTrees agreementTrees =  agreement.PartyId == null ? InitializeAgreementTreesWithoutParty(userAccount, existingAgreement) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLoadPartyAgreementTrees(userAccount, agreement.Party.Id);\n\n\t\t\tif (agreement.PartyId != existingAgreement.PartyId)\n\t\t\t{\n\t\t\t\t// When a party is changed: Load existing agreement node and update the agreement's and all of it's descendants party\n\t\t\t\tAgreementNode existingAgreementNode = LoadAgreementTreeByAgreementId(userAccount, existingAgreement.Id);\n\t\t\t\tagreementTrees.ImportAgreementNode(existingAgreementNode);\n\t\t\t}\n\n\t\t\tAgreementNode updatedNode = agreementTrees.UpdateAgreement(userAccount, agreement, parentAgreementId, isPartial);\n\t\t\tvar updatedAgreement = Save(userAccount, updatedNode, isPartial);\n\n\t\t\tFireMetadataUpdatedEvent(userAccount, updatedAgreement);\n\n\t\t\treturn updatedAgreement;\n\t\t}\n\n\t\tpublic bool Delete(UserAccount userAccount, Guid agreementId)\n\t\t{\n\t\t\tif (!_agreementPersistence.Delete(userAccount, agreementId))\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not delete agreement with agreementId: {agreementId}\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbool success = true;\n\t\t\tList<AgreementRelationship> existingRelationships = LoadRelationshipsByAgreementId(userAccount, agreementId);\n\t\t\tif (existingRelationships == null) return false;\n\n\t\t\tforeach (AgreementRelationship agreementRelationship in existingRelationships)\n\t\t\t{\n\t\t\t\t_agreementRelationshipHelper.DeleteRelationship(userAccount, agreementId, agreementRelationship.RelatedAgreement.Id);\n\t\t\t}\n\t\t\t_agreementMetadataHelper.DeleteMetadataFieldValues(userAccount, agreementId);\n\t\t\treturn success;\n\t\t}\n\n\t\tpublic List<Agreement> LoadByPartyId(UserAccount userAccount, Guid counterpartyUid, bool filterVisibleAgreements = true, List<string> expand = null)\n\t\t{\n\t\t\tList<Agreement> agreementList = _agreementPersistence.LoadByPartyId(userAccount, counterpartyUid, expand).ToList();\n\n\t\t\tif (filterVisibleAgreements)\n\t\t\t{\n\t\t\t\tagreementList = FilterOnlyVisibleAgreements(userAccount, agreementList);\n\t\t\t}\n\n\t\t\treturn agreementList.Select(a => SetAgreementType(a, userAccount)).ToList();\n\t\t}\n\n\t\tpublic PartyAgreementTrees LoadPartyAgreementTrees(UserAccount userAccount, Guid partyUid)\n\t\t{\n\t\t\tif (partyUid == Guid.Empty)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException($\"{nameof(partyUid)} is required\");\n\t\t\t}\n\n\t\t\tList<Agreement> agreements;\n\t\t\t\n\t\t\t// When the toggle is Off let LoadByPartyId filter agreements by security otherwise users will be able to see agreements they don't have access to\n\t\t\tif (!userAccount.Settings.EnableExtendedAgreementHierarchy)\n\t\t\t{\n\t\t\t\tagreements = LoadByPartyId(userAccount, partyUid, expand: new List<string> { nameof(Agreement.AgreementRelationships) });\n\t\t\t\treturn new PartyAgreementTrees(userAccount, partyUid, agreements, _attributesManagementFramework);\n\t\t\t}\n\n\t\t\t// To build the tree correctly load all the agreements even if the user might not have access to some and just filter out trashed ones\n\t\t\t// Security will be calculated based on the documents loaded\n\t\t\tagreements = LoadByPartyId(userAccount, partyUid, false, new List<string> { nameof(Agreement.AgreementRelationships) });\n\t\t\treturn new PartyAgreementTrees(userAccount, partyUid, agreements, _attributesManagementFramework);\n\t\t}\n\n\t\tpublic AgreementNode LoadAgreementTreeByAgreementId(UserAccount userAccount, Guid agreementUid)\n\t\t{\n\t\t\tAgreement agreement = null;\n\t\t\tif (agreementUid != Guid.Empty)\n\t\t\t{\n\t\t\t\tagreement = LoadById(userAccount, agreementUid);\n\t\t\t}\n\n\t\t\treturn LoadAgreementTreeByAgreement(userAccount, agreement);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Takes a list of agreements, and assumes the external id of the agreement is the document Uid,\n\t\t/// Then returns all agreements who's documents are not in the trash folder\n\t\t/// </summary>\n\t\tinternal List<Agreement> FilterOnlyVisibleAgreements(UserAccount userAccount, List<Agreement> agreementList)\n\t\t{\n\t\t\tvar dictionary = new Dictionary<string, Guid>();\n\t\t\tforeach(Agreement agreement in agreementList)\n\t\t\t{\n\t\t\t\tif (agreement.ExternalId == null)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($@\"ExternalId of Agreement is null. This is likely caused by two agreements pointing to the same document \n\t\t\t\t\t\t\t\t\tand then migrated to ADM where the second agreement's external Id will be null in such a case. Offending Agreement Id: {agreement.Id}\");\n\t\t\t\t}\n\n\t\t\t\tif (dictionary.ContainsKey(agreement.ExternalId ?? \"\"))\n\t\t\t\t{\n\t\t\t\t\tGuid firstDuplicateId = dictionary[agreement.ExternalId];\n\t\t\t\t\t_log.WarnWithPII(\n\t\t\t\t\t\t$\"Agreement with Id {firstDuplicateId} already has an externalId of {{0}}.\" +\n\t\t\t\t\t\t$\" This is likely an accidental duplicate agreement with agreement Id {agreement.Id} and should be reviewed for removal\", agreement.ExternalId);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdictionary.Add(agreement.ExternalId, agreement.Id);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create a list of tuples<Guid, Agreement> where the agreements external id parses into a guid.\n\t\t\tList<Tuple<Guid, Agreement>> externalIdAgreementMap = agreementList.Select(a =>\n\t\t\t\t Guid.TryParse(a.ExternalId, out Guid externalIdGuid) ?\n\t\t\t\t\t new Tuple<Guid, Agreement>(externalIdGuid, a) :\n\t\t\t\t\t new Tuple<Guid, Agreement>(Guid.Empty, null)\n\t\t\t).Filter(g => Guid.Empty != g.Item1).ToList();\n\n\t\t\t// Take the list of guids and ask to filter out all trashed items\n\t\t\tList<Guid> visibleDocumentUids = _documentRepository.FilterDocumentUidsByTrashAndSecurityFromAgreements(userAccount, agreementList);\n\n\t\t\treturn externalIdAgreementMap.Filter(g => visibleDocumentUids.Contains(g.Item1)).Select(g => g.Item2).ToList();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns the folder uid associated with the party only if the user requesting it has create permissions.\n\t\t/// If one does not exist or was trashed, it creates a folder and return the new Guid.\n\t\t/// </summary>\n\t\t/// <param name=\"userAccount\">User Account</param>\n\t\t/// <param name=\"partyId\">PartyId associated with the requested folder</param>\n\t\tpublic Guid GetPartyFolder(UserAccount userAccount, Guid partyId)\n\t\t{\n\t\t\tif (userAccount == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"User Account is missing.\");\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\n\t\t\tvar folder = RemovePartyIdMetadataOnTrashedPartyFolders(userAccount, partyId);\n\n\t\t\tif (folder != null)\n\t\t\t{\n\t\t\t\t// In order to create into a party, user must have Create permission and be at least a full subscriber.\n\t\t\t\tvar hasCreatePermissions = folder.HasSecurity(Enums.Security.Create) &&\n\t\t\t\t\t\t\t\t\t\t   userAccount.Privileges.HasPublisherRights;\n\t\t\t\t_log.WarnNoPII(\n\t\t\t\t\t$\"The folder for the party: {partyId} is available - folder Uid: {folder.Uid}. User {(hasCreatePermissions ? \"has\" : \"doesn't have\")} create permissions.\");\n\t\t\t\treturn hasCreatePermissions ? folder.Uid : Guid.Empty;\n\t\t\t}\n\n\t\t\tif (userAccount.Privileges.HasPublisherRights)\n\t\t\t{\n\t\t\t\treturn CreateMissingPartyFolder(userAccount, partyId);\n\t\t\t}\n\n\t\t\t_log.WarnNoPII(\n\t\t\t\t\"The party folder is missing or the user doesn't have publisher rights to create one.\");\n\t\t\treturn Guid.Empty;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Find and remove all trashed folders that has a party id metadata\n\t\t/// </summary>\n\t\t/// <param name=\"userAccount\"></param>\n\t\t/// <param name=\"partyId\"></param>\n\t\t/// <returns>The party folder that is not in the trash or null if there's no party folder</returns>\n\t\tprotected Folder RemovePartyIdMetadataOnTrashedPartyFolders(UserAccount userAccount, Guid partyId)\n\t\t{\n\t\t\tif (userAccount == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"User Account is missing.\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Only users who have publisher rights can clear party Ids\n\t\t\tif (!userAccount.Privileges.HasPublisherRights)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"User doesn't have the right to remove partyId metadata\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Set a limit on  the maximum trashed folders' partyID metadata could be deleted at a time to avoid forever loop\n\t\t\tvar trashedFolderRemovalLimit = 5;\n\t\t\tvar folder = _folderRepository.LoadByMetadataValue(userAccount, partyId.ToString());\n\t\t\t// Remove all trashed party folders' partyID metadata associated with the party\n\t\t\twhile (folder != null && _folderRepository.IsTrashed(userAccount.AccountId, folder.Uid) &&\n\t\t\t       trashedFolderRemovalLimit > 0)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\n\t\t\t\t\t$\"The folder for the party: {partyId} is in the Trash folder, we're removing party Id metadata from the folder: {folder.Uid}\");\n\t\t\t\t_partyMetadataHelper.DeleteTrashedFolderMetadataFieldValues(userAccount, partyId);\n\t\t\t\tfolder = _folderRepository.LoadByMetadataValue(userAccount, partyId.ToString());\n\t\t\t\ttrashedFolderRemovalLimit--;\n\t\t\t}\n\n\t\t\treturn folder;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create missing a party folder\n\t\t/// </summary>\n\t\t/// <param name=\"userAccount\"></param>\n\t\t/// <param name=\"partyId\"></param>\n\t\t/// <returns>The newly created party folder Uid or an empty Guid if there's an error</returns>\n\t\tprotected Guid CreateMissingPartyFolder(UserAccount userAccount, Guid partyId)\n\t\t{\n\t\t\tif (userAccount == null)\n\t\t\t{\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\n\t\t\tvar party = _counterpartyRepository.Load(userAccount, partyId);\n\t\t\tvar folder = _partyMetadataHelper.CreatePartyFolderWithMetadata(userAccount, party);\n\t\t\tif (folder != null)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\n\t\t\t\t\t$\"The party folder is missing, so the application has successfully created one for the party: {partyId}- New party folder: {folder.Uid}.\");\n\t\t\t\treturn folder.Uid;\n\t\t\t}\n\n\t\t\t_log.WarnNoPII(\n\t\t\t\t$\"The party folder is missing, so the application has attempted to create it for the party: {partyId}, but unsuccessfully.\");\n\t\t\treturn Guid.Empty;\n\t\t}\n\n\t\tpublic Agreement LoadById(UserAccount userAccount, Guid agreementId)\n\t\t{\n\t\t\treturn SetAgreementType(_agreementPersistence.LoadById(userAccount, agreementId), userAccount);\n\t\t}\n\n\t\tpublic List<string> GetChildDocumentTypes()\n\t\t{\n\t\t\tList<string> childDocTypeList = new List<string>()\n\t\t\t{\n\t\t\t\tAomConstants.AgreementTypeKeys.Addendum,\n\t\t\t\tAomConstants.AgreementTypeKeys.Amendment,\n\t\t\t\tAomConstants.AgreementTypeKeys.ChangeOrder\n\t\t\t};\n\t\t\treturn childDocTypeList;\n\t\t}\n\n\t\tpublic bool IsChildDocumentType(string type)\n\t\t{\n\t\t\treturn GetChildDocumentTypes().Contains(type);\n\t\t}\n\n\t\tpublic Agreement LoadByDocumentUid(UserAccount currentUser, Guid documentUid, bool convertDatesToAccountTimeZone = true)\n\t\t{\n\t\t\tif (convertDatesToAccountTimeZone)\n\t\t\t{\n\t\t\t\treturn LoadByExternalId(currentUser, documentUid.ToString());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn LoadByExternalId(currentUser, documentUid.ToString());\n\t\t\t}\n\t\t}\n\n\t\tpublic List<AgreementRelationship> LoadRelationshipsByAgreementId(UserAccount userAccount, Guid agreementId)\n\t\t{\n\t\t\tList<AgreementRelationship> relationships = _relationshipPersistence.LoadByAgreementId(userAccount, agreementId);\n\t\t\tif (relationships == null)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Unable to load relationships for agreement id {agreementId} and account {userAccount.AccountId}\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trelationships.ForEach(r => r.RelatedAgreement = SetAgreementType(r.RelatedAgreement, userAccount));\n\t\t\t}\n\n\t\t\treturn relationships;\n\t\t}\n\n\t\tpublic Guid GetAgreementIdByDocumentUid(UserAccount currentUser, Guid documentUid)\n\t\t{\n\t\t\treturn LoadByDocumentUid(currentUser, documentUid)?.Id ?? Guid.Empty;\n\t\t}\n\n\t\tpublic Agreement LoadByExternalId(UserAccount userAccount, string externalId)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tList<Agreement> agreements = _agreementPersistence.LoadByExternalId(userAccount, externalId) ?? new List<Agreement>();\n\t\t\t\tif (agreements.Count > 1)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Loaded {agreements.Count} agreements for externalId {externalId} in account {userAccount.AccountId}. Will take first.\", new Exception(\"EXTERNAL_ID_MISMATCH\"));\n\t\t\t\t}\n\n\t\t\t\tAgreement result = agreements.Select(a => SetAgreementType(a, userAccount)).FirstOrDefault();\n\t\t\t\tif (result != null)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loaded agreement {result.Id} for externalId {externalId}\");\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Exception occured while loading the document by ExternalId :{externalId}:{ex.Message}\", ex);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tpublic List<Agreement> LoadByExternalIds(UserAccount userAccount, List<string> externalIds)\n\t\t{\n\t\t\tint maxPageSize = Configuration.GetInt32AppSetting(\"GetAgreementsByExternalIdsMaxCount\", 100);\n\t\t\tList<Agreement> result = new List<Agreement>(externalIds.Count);\n\t\t\tif (externalIds.Count < maxPageSize)\n\t\t\t{\n\t\t\t\tresult.AddRange(_agreementPersistence.LoadByExternalIds(userAccount, externalIds));\n\t\t\t\treturn result.Select(a => SetAgreementType(a, userAccount)).ToList();\n\t\t\t}\n\n\t\t\tList<string> batch = new List<string>(maxPageSize);\n\t\t\tforeach (string externalId in externalIds)\n\t\t\t{\n\t\t\t\tbatch.Add(externalId);\n\t\t\t\tif (batch.Count >= maxPageSize)\n\t\t\t\t{\n\t\t\t\t\tresult.AddRange( _agreementPersistence.LoadByExternalIds(userAccount, batch));\n\t\t\t\t\tbatch.Clear();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (batch.Count > 0)\n\t\t\t{\n\t\t\t\tresult.AddRange( _agreementPersistence.LoadByExternalIds(userAccount, batch));\n\t\t\t}\n\n\t\t\treturn result.Select(a => SetAgreementType(a, userAccount)).ToList();\n\t\t}\n\n\t\tpublic List<KeyValuePair<int, string>> GetTimeUnitsAndLocalizedName() =>\n\t\t\tEnum.GetNames(typeof(Enums.TimeUnit))\n\t\t\t\t.Select(timeUnit =>\n\t\t\t\t\t\tnew KeyValuePair<int, string>(\n\t\t\t\t\t\t(int)Enum.Parse(typeof(Enums.TimeUnit), timeUnit),\n\t\t\t\t\t\tEnums.GetLocalizedName((Enums.TimeUnit)Enum.Parse(typeof(Enums.TimeUnit), timeUnit), Resources.Parties.ResourceManager)\n\t\t\t\t\t)\n\t\t\t\t).ToList();\n\n\t\tpublic Agreement SaveSummary(UserAccount userAccount, Guid agreementUid, string summary)\n\t\t{\n\t\t\tif (userAccount == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(userAccount));\n\t\t\t}\n\n\t\t\tif (!userAccount.Settings.EnableAIAgreementSummary)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"Agreement Summary is not enabled for the account.\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar existingAgreement = LoadById(userAccount, agreementUid);\n\t\t\tif (existingAgreement == null)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Unable to save Agreement Summary. Agreement does not exist. AgreementId: {agreementUid}\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar oldSummary = existingAgreement.Summary;\n\t\t\tvar agreementToUpdate = existingAgreement;\n\t\t\tagreementToUpdate.Summary = summary?.Trim() ?? string.Empty;\n\t\t\tagreementToUpdate.UpdatedBy = AomUtilities.GetActorName(userAccount);\n\t\t\tagreementToUpdate.UpdatedDate = DateTime.UtcNow;\n\n\t\t\tif (!string.IsNullOrEmpty(agreementToUpdate.Summary)\n\t\t\t\t&& (agreementToUpdate.Summary.Length > userAccount.Settings.AgreementSummaryMaxLength || !agreementToUpdate.IsAgreementSummaryValid))\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Unable to save Agreement Summary. Total characters exceeds allowed length. \" +\n\t\t\t\t\t\t\t   $\"Total characters: {agreementToUpdate.Summary.Length}, Allowed Max. length: {userAccount.Settings.AgreementSummaryMaxLength}\");\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"Saving Agreement Summary for AgreementId: {agreementToUpdate.Id}\");\n\t\t\tvar updatedAgreement = _agreementPersistence.Patch(userAccount, agreementToUpdate);\n\n\t\t\t_log.InfoNoPII($\"Saving Agreement Summary changed history for AgreementId: {agreementToUpdate.Id}\");\n\t\t\tSaveSummaryChangedHistory(userAccount, updatedAgreement, oldSummary);\n\n\t\t\treturn updatedAgreement;\n\t\t}\n\n\t\tprivate void SaveSummaryChangedHistory(UserAccount userAccount, Agreement agreement, string oldSummary)\n\t\t{\n\t\t\tif (agreement == null)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Unable to save summary changed history since agreement is null\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tDocument document = _documentRepository.LoadByAgreement(userAccount, agreement);\n\t\t\tif (document == null)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Unable to save summary changed history since document is null\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tJObject dataBag = new DocumentHistoryData(userAccount).ToJObject();\n\t\t\tdataBag.Add(Constants.HistoryData.OLD_SUMMARY, new JValue(oldSummary));\n\t\t\t_documentHistoryRepository.LogDocumentAction(userAccount, document, Enums.ActionType.SummaryChanged, dataBag);\n\t\t\t_userActionRepository.LogUserAction(userAccount, Enums.ActionType.SummaryChanged);\n\n\t\t\t_log.InfoNoPII($\"Summary changed history saved successfully\");\n\t\t}\n\n\t\tprivate Agreement Save(UserAccount userAccount, AgreementNode agreementNode, bool isPartial = false)\n\t\t{\n\t\t\tDeleteRelationships(userAccount, agreementNode);\n\t\t\t\n\t\t\tif (!SaveAgreement(userAccount, agreementNode, isPartial))\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tCreateRelationships(userAccount, agreementNode);\n\t\t\tagreementNode.ClearChanges();\n\n\t\t\t// If there was a party change, update the party on the descendant nodes.\n\t\t\tforeach (var descendant in agreementNode.Descendants.Where(d => d.HasChanges))\n\t\t\t{\n\t\t\t\tSaveAgreement(userAccount, descendant, isPartial);\n\t\t\t\tdescendant.ClearChanges();\n\t\t\t}\n\n\t\t\treturn SetAgreementType(agreementNode.Data, userAccount);\n\t\t}\n\n\t\tprivate bool SaveAgreement(UserAccount userAccount, AgreementNode agreementNode, bool isPartial = false)\n\t\t{\n\t\t\tAgreement agreementResult;\n\t\t\tAgreementEvent agreementEvent = agreementNode.GetChanges<AgreementEvent>().FirstOrDefault();\n\t\t\t\n\t\t\tswitch (agreementEvent)\n\t\t\t{\n\t\t\t\tcase AgreementCreatedEvent _:\n\t\t\t\t\tagreementResult = _agreementPersistence.Create(userAccount, agreementEvent.Value);\n\t\t\t\t\tif (agreementResult == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Unsuccessful post request for creating agreement with document uid: {agreementEvent.Value.ExternalId}\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.InfoNoPII($\"Successfully created post request for creating agreement id {agreementResult.Id} with document uid {agreementResult.ExternalId}\");\n\t\t\t\t\t_agreementMetadataHelper.SaveAgreementSystemMetadata(userAccount, agreementResult);\n\t\t\t\t\tagreementNode.SetAgreement(agreementResult);\n\t\t\t\t\t_log.InfoNoPII($\"Document saved successfully. Action: Create DocType : {{ DocumentId:{agreementResult.Id}, DocumentType: {agreementResult.Type} }}\" );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AgreementUpdatedEvent _:\n\t\t\t\t\tagreementResult = isPartial ? _agreementPersistence.Patch(userAccount, agreementEvent.Value) : _agreementPersistence.Update(userAccount, agreementEvent.Value);\n\t\t\t\t\tif (agreementResult == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Unsuccessful post request for updating agreement with agreement id {agreementEvent.Value.Id} with document uid: {agreementEvent.Value.ExternalId}\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.InfoNoPII($\"Successfully created post request for updating agreement id {agreementResult.Id} with document uid {agreementResult.ExternalId}\");\n\t\t\t\t\t_agreementMetadataHelper.SaveAgreementSystemMetadata(userAccount, agreementResult);\n\t\t\t\t\t_log.InfoNoPII($\"Document saved successfully. Action: Update DocType : {{ DocumentId:{agreementResult.Id}, DocumentType:{agreementResult.Type} }}\" );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AgreementDeletedEvent _:\n\t\t\t\t\tif (!_agreementPersistence.Delete(userAccount, agreementEvent.Value.Id))\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Could not delete agreement with agreement id: {agreementEvent.Value.Id}\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t_log.InfoNoPII($\"Successfully deleted agreement id {agreementEvent.Value.Id}\");\n\t\t\t\t\t_agreementMetadataHelper.DeleteMetadataFieldValues(userAccount, agreementEvent.Value.Id);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate void DeleteRelationships(UserAccount userAccount, AgreementNode agreementNode)\n\t\t{\n\t\t\tforeach (var deletedRelationshipEvent in agreementNode.GetChanges<AgreementRelationshipDeletedEvent>())\n\t\t\t{\n\t\t\t\t_agreementRelationshipHelper.DeleteRelationship(userAccount, agreementNode.Id, deletedRelationshipEvent.Value.RelatedAgreement.Id);\n\t\t\t}\n\t\t}\n\n\t\tprivate void CreateRelationships(UserAccount userAccount, AgreementNode agreementNode)\n\t\t{\n\t\t\tforeach (var createdRelationship in agreementNode.GetChanges<AgreementRelationshipCreatedEvent>())\n\t\t\t{\n\t\t\t\tif (_relationshipPersistence.Create(userAccount, agreementNode.Id, createdRelationship.Value) == null)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Unable to create relationship between agreement ids {agreementNode.Id} and {createdRelationship.Value.RelatedAgreement.Id} for account {userAccount.AccountId}\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t_log.InfoNoPII($\"Created relationship between agreement ids {agreementNode.Id} and {createdRelationship.Value.RelatedAgreement.Id} for account {userAccount.AccountId}\");\n\t\t\t}\n\t\t}\n\n\t\tprivate void ValidateAgreementDoesNotExist(UserAccount userAccount, Agreement agreement)\n\t\t{\n\t\t\tif (agreement == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(agreement));\n\t\t\t}\n\t\t\tif (agreement.Id != Guid.Empty && LoadById(userAccount, agreement.Id) != null)\n\t\t\t{\n\t\t\t\tthrow new Exception($\"AOM Create failed - Agreement already exists with ID {agreement.Id}\");\n\t\t\t}\n\t\t\tif (Guid.TryParse(agreement.ExternalId, out Guid documentUid) && LoadByDocumentUid(userAccount, documentUid) != null)\n\t\t\t{\n\t\t\t\tthrow new Exception($\"EXTERNAL_ID_MISMATCH - AOM Create failed - Agreement already exists for external ID {agreement.ExternalId}\");\n\t\t\t}\n\t\t}\n\n\t\tprivate PartyAgreementTrees LoadAgreementTrees(UserAccount userAccount, Agreement agreement)\n\t\t{\n\t\t\tif (agreement.Party == null || agreement.Party.Id == Guid.Empty)\n\t\t\t{\n\t\t\t\treturn InitializeAgreementTreesWithoutParty(userAccount, agreement);\n\t\t\t}\n\t\t\treturn LoadPartyAgreementTrees(userAccount, agreement.Party.Id);\n\t\t}\n\n\t\tprivate PartyAgreementTrees InitializeAgreementTreesWithoutParty(UserAccount userAccount, Agreement agreement)\n\t\t{\n\t\t\treturn new PartyAgreementTrees(userAccount, null, new List<Agreement>{agreement}, _attributesManagementFramework);\n\t\t}\n\n\t\tpublic void MergeAgreementFields(Agreement agreement, Agreement existingAgreement)\n\t\t{\n\t\t\tagreement.EffectiveDate = agreement.EffectiveDate ?? existingAgreement.EffectiveDate;\n\t\t\tagreement.ExpirationDate = agreement.ExpirationDate ?? existingAgreement.ExpirationDate;\n\t\t\tagreement.IsSigned = agreement.IsSigned ?? existingAgreement.IsSigned;\n\t\t\tagreement.IsInWorkflow = agreement.IsInWorkflow ?? existingAgreement.IsInWorkflow;\n\t\t\tagreement.Party = agreement.Party ?? existingAgreement.Party;\n\t\t\tagreement.Requestor = agreement.Requestor ?? existingAgreement.Requestor;\n\t\t\tagreement.Type = agreement.Type ?? existingAgreement.Type;\n\t\t\tagreement.Value = agreement.Value ?? existingAgreement.Value;\n\t\t\tagreement.NoticePeriod = agreement.NoticePeriod ?? existingAgreement.NoticePeriod;\n\t\t\tagreement.RenewalTerm = agreement.RenewalTerm ?? existingAgreement.RenewalTerm;\n\t\t\tagreement.Indemnity = agreement.Indemnity ?? existingAgreement.Indemnity;\n\t\t\tagreement.PaymentLateFees = agreement.PaymentLateFees ?? existingAgreement.PaymentLateFees;\n\t\t\tagreement.PaymentTerms = agreement.PaymentTerms ?? existingAgreement.PaymentTerms;\n\t\t\tagreement.TerminationConvenience = agreement.TerminationConvenience ?? existingAgreement.TerminationConvenience;\n\t\t\tagreement.LimitationOfLiability = agreement.LimitationOfLiability ?? existingAgreement.LimitationOfLiability;\n\t\t\tagreement.TerminationCause = agreement.TerminationCause ?? existingAgreement.TerminationCause;\n\t\t\tagreement.Assignable = agreement.Assignable ?? existingAgreement.Assignable;\n\t\t\tagreement.ChangeOfControl = agreement.ChangeOfControl ?? existingAgreement.ChangeOfControl;\n\t\t\tagreement.PaymentEarlyDiscount = agreement.PaymentEarlyDiscount ?? existingAgreement.PaymentEarlyDiscount;\n\t\t\tagreement.ForceMajeure = agreement.ForceMajeure ?? existingAgreement.ForceMajeure;\n\t\t}\n\n\t\tpublic AgreementNode LoadAgreementTreeByAgreement(UserAccount userAccount, Agreement agreement)\n\t\t{\n\t\t\tif (agreement == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tSetAgreementType(agreement, userAccount);\n\n\t\t\tvar directRelationships = LoadRelationshipsByAgreementId(userAccount, agreement.Id);\n\n\t\t\t// If there aren't any relationships, construct a tree with only the single agreement\n\t\t\t// so we don't calculate security for the entire party's tree\n\t\t\tPartyAgreementTrees partyAgreementTrees = directRelationships == null || !directRelationships.Any()\n\t\t\t\t? InitializeAgreementTreesWithoutParty(userAccount, agreement)\n\t\t\t\t: LoadAgreementTrees(userAccount, agreement);\n\n\t\t\treturn partyAgreementTrees.GetAgreementNode(agreement.Id, true);\n\t\t}\n\n\t\tinternal Agreement SetAgreementType(Agreement agreement, UserAccount userAccount)\n\t\t{\n\t\t\tif(_agreementTypesDictionary == null)\n\t\t\t{\n\t\t\t\t_agreementTypesDictionary = AomUtilities.AgreementTypesDictionary(userAccount);\n\t\t\t}\n\n\t\t\tif (agreement == null)\n\t\t\t\treturn null;\n\n\t\t\tbool dictionaryResult = _agreementTypesDictionary.TryGetValue(agreement.Type ?? string.Empty, out DocumentType documentType);\n\t\t\tagreement.AgreementType = new KeyValuePair<string, string>(agreement.Type, dictionaryResult ? documentType.DisplayName : agreement.Type);\n\t\t\treturn agreement;\n\t\t}\n\n\t\tprivate void FireMetadataUpdatedEvent(UserAccount userAccount, Agreement updatedAgreement)\n\t\t{\n\t\t\tif (userAccount.Settings.EnablePublishAgreementUpdatedEvent && updatedAgreement != null)\n\t\t\t{\n\t\t\t\tvar document = _documentRepository.LoadByAgreement(userAccount, updatedAgreement);\n\t\t\t\t//Fire event from here\n\t\t\t\tCommonEvent fireEvent = new MetadataUpdatedEvent\n\t\t\t\t{\n\t\t\t\t\tAccountId = userAccount.AccountId,\n\t\t\t\t\tDocumentUid = document.Uid,\n\t\t\t\t\tFileDataUid = document.FileDataUid,\n\t\t\t\t\tAttributeType = AttributeType.Standard\n\t\t\t\t};\n\t\t\t\t_eventRepository.FireEvent(userAccount, fireEvent);\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/SecurityTable.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Linq;\nusing ADEXS.Core.Types;\nusing System.Runtime.Serialization;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing System.Security.Permissions;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Domain.SecurityFiltering.Interfaces;\nusing ADEXS.Core.Domain.SecurityFiltering.JustInTime;\n\nnamespace ADEXS.Core.Domain.Model\n{\n\t/// <summary>\n\t/// SecurityTable defines a table of security records for a specific object.  Each security record applies to\n\t/// either a role, group or user, and upon initial load reflects the currently-effective permissions.  After\n\t/// initial load, the table tracks changes for later application to the database.\n\t/// </summary>\n\t[Serializable]\n\tpublic sealed class SecurityTable : DataTable, ISerializable\n\t{\n\t\t#region Constants & Enums\n\n\t\tpublic const string TABLE_NAME = \"Security\";\n\n\t\tpublic const string COLUMN_ROW_ID = \"RowId\";\n\t\tpublic const string COLUMN_SORT = \"Sort\";\n\t\tpublic const string COLUMN_REQUIRED_ROLE = \"RequiredRole\";\n\t\t//public const string COLUMN_DISTRIBUTION_GROUP_ID = \"DistributionGroupId\"; deprecated\n\t\tpublic const string COLUMN_SECURITY_GROUP_UID = \"SecurityGroupUid\";\n\t\tpublic const string COLUMN_DISTRIBUTION_GROUP_NAME = \"GroupName\";\n\t\tpublic const string COLUMN_USER_ID = \"UserAccountUid\";\n\t\tpublic const string COLUMN_USER_EMAIL = \"UserEmail\";\n\t\tpublic const string COLUMN_USER_LAST_NAME = \"UserLastName\";\n\t\tpublic const string COLUMN_USER_FIRST_NAME = \"UserFirstName\";\n\t\tpublic const string COLUMN_USER_ROLE = \"UserRole\";\n\t\tpublic const string COLUMN_NAME = \"Name\";\n\t\tpublic const string COLUMN_READ_SECURITY = \"ReadSecurity\";\n\t\tpublic const string COLUMN_WRITE_SECURITY = \"WriteSecurity\";\n\t\tpublic const string COLUMN_MOVE_SECURITY = \"MoveSecurity\";\n\t\tpublic const string COLUMN_CREATE_SECURITY = \"CreateSecurity\";\n\t\tpublic const string COLUMN_SET_ACCESS_SECURITY = \"SetAccessSecurity\";\n\t\tpublic const string COLUMN_SECURITY_MASK_ID = \"SecurityMaskId\";\n\t\tpublic const string COLUMN_CLEAR_DESCENDANTS = \"ClearDescendants\";\n\t\tpublic const string COLUMN_HAS_EXPLICIT_SECURITY = \"HasExplicitSecurity\";\n\n\t\tpublic static readonly string[] SECURITY_COLUMNS = new string[]\n\t\t{\n\t\t\tCOLUMN_READ_SECURITY,\n\t\t\tCOLUMN_WRITE_SECURITY,\n\t\t\tCOLUMN_MOVE_SECURITY,\n\t\t\tCOLUMN_CREATE_SECURITY,\n\t\t\tCOLUMN_SET_ACCESS_SECURITY\n\t\t};\n\n\t\t/// <summary>\n\t\t/// Faux value used to sort roles before groups before users.\n\t\t/// </summary>\n\t\tpublic const int SORT_USER = 99999;\n\n\t\t/// <summary>\n\t\t/// Faux value used to sort roles before groups before users.\n\t\t/// </summary>\n\t\tpublic const int SORT_GROUP = SORT_USER / 2;\n\n\t\t/// <summary>\n\t\t/// Sort roles before groups, before users, then alphabetically within groups and users.\n\t\t/// </summary>\n\t\tprivate const string SORT = COLUMN_SORT + \", \" + COLUMN_NAME;\n\n\t\tprivate const string SERIALIZATION_INFO_ACCOUNT_ID = \"_accountId\";\n\t\tprivate const string SERIALIZATION_INFO_OBJECT_UID = \"_objectUid\";\n\t\tprivate const string SERIALIZATION_INFO_OBJECT_TYPE = \"_objectType\";\n\t\tprivate const string SERIALIZATION_INFO_CLEAR_ALL_DESCENDANTS = \"_clearAllDescendants\";\n\n\t\t/// <summary>\n\t\t/// Similar to Enums.SecurityLevel except with the addition of InheritDeny and InheritGrant.\n\t\t/// </summary>\n\t\t/// <seealso cref=\"Enums.SecurityLevel\"/>\n\t\tpublic enum SecurityLevel\n\t\t{\n\t\t\tNotSet = Enums.SecurityLevel.NotSet,\n\t\t\tDeny = Enums.SecurityLevel.Deny,\n\t\t\tGrant = Enums.SecurityLevel.Grant,\n\t\t\t// Inherit deny/grant come from ancestor explicit security\n\t\t\tInheritDeny = 2,\n\t\t\tInheritGrant = 3,\n\t\t\t// Derived deny/grant are for user securities that get static security from a role/group on the same folder\n\t\t\tDerivedDeny = 4,\n\t\t\tDerivedGrant = 5\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Fields & Properties\n\n\t\tprivate int _accountId = int.MinValue;\n\t\tprivate Guid _objectUid = Guid.Empty;\n\t\tprivate Enums.ObjectType _objectType = Enums.ObjectType.Invalid;\n\t\tprivate bool _clearAllDescendants = false;\n\t\tprivate SecurityMaskTable _securityMasks = new SecurityMaskTable();\n\n\t\tpublic int AccountId\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn _accountId;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\t_accountId = value;\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid ObjectUid\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn _objectUid;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\t_objectUid = value;\n\t\t\t}\n\t\t}\n\n\t\tpublic Enums.ObjectType ObjectType\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn _objectType;\n\t\t\t}\n\n\t\t\tset\n\t\t\t{\n\t\t\t\t_objectType = value;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool ClearAllDescendants\n\t\t{\n\t\t\tget { return _clearAllDescendants; }\n\t\t\tset { _clearAllDescendants = value; }\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns the security masks available to this security table.\n\t\t/// </summary>\n\t\t/// <seealso cref=\"SecurityMaskTable\"/>\n\t\tpublic SecurityMaskTable SecurityMasks\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn _securityMasks;\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Constructors\n\n\t\tpublic SecurityTable()\n\t\t{\n\t\t\tDataColumn column;\n\n\n\t\t\tTableName = TABLE_NAME;\n\n\t\t\t//\tThe row's unique ID.\n\t\t\tcolumn = Columns.Add(COLUMN_ROW_ID, typeof(int));\n\t\t\tcolumn.AutoIncrement = true;\n\t\t\tcolumn.ReadOnly = true;\n\t\t\tPrimaryKey = new DataColumn[] { column };\n\n\t\t\t//\tA column used to sort roles before groups before users.\n\t\t\tcolumn = Columns.Add(COLUMN_SORT, typeof(int));\n\t\t\tcolumn.ReadOnly = true;\n\n\t\t\t//\tEither the required role, group ID or user ID is defined for each row in order to indicate to whom the\n\t\t\t//\tsecurity applies.\n\t\t\tcolumn = Columns.Add(COLUMN_REQUIRED_ROLE, typeof(Enums.UserRole));\n\t\t\tcolumn.ReadOnly = true;\n\n\t\t\tcolumn = Columns.Add(COLUMN_SECURITY_GROUP_UID, typeof(Guid));\n\t\t\tcolumn.ReadOnly = true;\n\t\t\tcolumn = Columns.Add(COLUMN_DISTRIBUTION_GROUP_NAME, typeof(string));\n\t\t\tcolumn.ReadOnly = true;\n\n\t\t\tcolumn = Columns.Add(COLUMN_USER_ID, typeof(Guid));\n\t\t\tcolumn.ReadOnly = true;\n\t\t\tcolumn = Columns.Add(COLUMN_USER_EMAIL, typeof(string));\n\t\t\tcolumn.ReadOnly = true;\n\t\t\tcolumn = Columns.Add(COLUMN_USER_LAST_NAME, typeof(string));\n\t\t\tcolumn.ReadOnly = true;\n\t\t\tcolumn = Columns.Add(COLUMN_USER_FIRST_NAME, typeof(string));\n\t\t\tcolumn.ReadOnly = true;\n\t\t\tcolumn = Columns.Add(COLUMN_USER_ROLE, typeof(int));\n\t\t\tcolumn.ReadOnly = true;\n\t\t\tcolumn = Columns.Add(COLUMN_HAS_EXPLICIT_SECURITY, typeof(int));\n\t\t\tcolumn.AllowDBNull = true;\n\n\t\t\t//\tThe user, group or role's display name.\n\t\t\tcolumn = Columns.Add(COLUMN_NAME, typeof(string));\n\n\t\t\tColumns.Add(COLUMN_READ_SECURITY, typeof(SecurityLevel));\n\t\t\tColumns.Add(COLUMN_WRITE_SECURITY, typeof(SecurityLevel));\n\t\t\tColumns.Add(COLUMN_MOVE_SECURITY, typeof(SecurityLevel));\n\t\t\tColumns.Add(COLUMN_CREATE_SECURITY, typeof(SecurityLevel));\n\t\t\tColumns.Add(COLUMN_SET_ACCESS_SECURITY, typeof(SecurityLevel));\n\n\t\t\t//\tSecurity mask ID.\n\t\t\tColumns.Add(COLUMN_SECURITY_MASK_ID, typeof(int));\n\n\t\t\t//  Clear Descendants CheckBox value\n\t\t\tcolumn = Columns.Add(COLUMN_CLEAR_DESCENDANTS, typeof(bool));\n\t\t\tcolumn.DefaultValue = false;\n\n\t\t\tDefaultView.Sort = SORT;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Deserialization constructor.\n\t\t/// </summary>\n\t\t/// <param name=\"info\"></param>\n\t\t/// <param name=\"context\"></param>\n\t\tprivate SecurityTable(SerializationInfo info, StreamingContext context) : base(info, context)\n\t\t{\n\t\t\t_accountId = info.GetInt32(SERIALIZATION_INFO_ACCOUNT_ID);\n\t\t\t_objectUid = new Guid(info.GetString(SERIALIZATION_INFO_OBJECT_UID));\n\t\t\t_objectType = (Enums.ObjectType)info.GetInt32(SERIALIZATION_INFO_OBJECT_TYPE);\n\t\t\t_clearAllDescendants = info.GetBoolean(SERIALIZATION_INFO_CLEAR_ALL_DESCENDANTS);\n\n\t\t\t//\tBecause DataViews are not serializeable, we need to reset the default view's sort upon deserialization.\n\t\t\tDefaultView.Sort = SORT;\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Public Methods\n\n\t\t/// <summary>\n\t\t/// Called by SecurityPersistence.LoadGrid after loading from the database to 1) convert security column nulls\n\t\t/// to not sets and 2) compute the mask ID column.\n\t\t///\n\t\t/// This should not be called otherwise.\n\t\t/// </summary>\n\t\tpublic void init(Enums.SecurityModel securityModel)\n\t\t{\n\t\t\t//\tFor legacy security, must convert security column nulls to NotSets before calling getMaskId; otherwise, all-null rows will\n\t\t\t//\tmatch the custom mask v. the no access mask.\n\t\t\t//\tFor static security, must convert nulls to denys, since there is not such thing as NotSet/Inherited security in static security\n\t\t\tforeach (DataRow security in Rows)\n\t\t\t{\n\t\t\t\tforeach (string securityColumn in SECURITY_COLUMNS)\n\t\t\t\t{\n\t\t\t\t\tif (security[securityColumn] == DBNull.Value)\n\t\t\t\t\t{\n\t\t\t\t\t\tsecurity[securityColumn] = securityModel == Enums.SecurityModel.Static ? SecurityLevel.Deny : SecurityLevel.NotSet;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsecurity[COLUMN_SECURITY_MASK_ID] = getMaskId(security);\n\t\t\t\tsecurity[COLUMN_CLEAR_DESCENDANTS] = false;\n\t\t\t}\n\n\t\t\tAcceptChanges();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns a boolean indicating success in adding the specified user to the table.\n\t\t/// </summary>\n\t\t/// <param name=\"currentUser\">CurrentUser is needed to retrieve only this account's user.</param>\n\t\t/// <param name=\"userAccountUid\">The userAccountUid of the user to add.</param>\n\t\t/// <param name=\"messages\">Output parameter: A List of strings of error messages</param>\n\t\t/// <returns>A boolean indicating success in adding the specified user.</returns>\n\t\tpublic bool addUser(UserAccount currentUser, Guid userAccountUid, out List<string> messages)\n\t\t{\n\t\t\tbool ok = true;\n\t\t\tmessages = new List<string>();\n\n            UserAccount user = ServiceLocator.GetInstance<IUserAccountRepository>().LoadByUid(currentUser.AccountId, userAccountUid);\n\n\t\t\tif (user == null)\n\t\t\t{\n\t\t\t\tmessages.Add(\"User not found.\"); //I18NTODO\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (user.Role)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.UserRole.Primary:\n\t\t\t\t\t\tmessages.Add(String.Format(\n\t\t\t\t\t\t\t\"{0} was not added because {1}s have full access.\",\n\t\t\t\t\t\t\tuser.NameString,\n\t\t\t\t\t\t\tEnums.GetUserRoleString(user.Role, user.Settings.UserRoleNameType))); //I18NTODO\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t//\tIs this a new user? (or the JIT special case?)\n\t\t\t\t\t\tDataRow[] security = Select(COLUMN_USER_ID + \" = '\" + user.Uid + \"'\");\n\t\t\t\t\t\tif (security.Length == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tDataRow row = NewRow();\n\n\t\t\t\t\t\t\trow[COLUMN_USER_ID] = user.Uid;\n\t\t\t\t\t\t\trow[COLUMN_USER_ROLE] = user.Role;\n\t\t\t\t\t\t\trow[COLUMN_NAME] = user.NameString;\n\t\t\t\t\t\t\trow[COLUMN_USER_FIRST_NAME] = user.FirstName;\n\t\t\t\t\t\t\trow[COLUMN_USER_LAST_NAME] = user.LastName;\n\t\t\t\t\t\t\trow[COLUMN_USER_EMAIL] = user.EmailAddress;\n\t\t\t\t\t\t\trow[COLUMN_SORT] = SORT_USER;\n\n\t\t\t\t\t\t\t// If JIT is enabled, the user won't already be in the list (unless they have explicit security).  Fetch security from JIT.\n\t\t\t\t\t\t\tif (user.Settings.EnableJiTSecurity)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tISecurityMap securityMap = GetSecurityMap(user);\n\n\t\t\t\t\t\t\t\tvar val = securityMap.SecurityFlags ?? Enums.Security.None;\n\n\t\t\t\t\t\t\t\t// Translate SecurityFlags (which is an Enums.Security object) to the appropriate SecurityLevels and row columns.\n\t\t\t\t\t\t\t\tforeach (string securityColumn in SECURITY_COLUMNS)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\trow[securityColumn] = TranslateSecurityFlagToSecurityLevel(securityColumn, val);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Effective security (negative maskId) is allowed in JIT rows, so we don't need to call `SetToDefaultMask()`.\n\t\t\t\t\t\t\t\trow[COLUMN_SECURITY_MASK_ID] = getMaskId(row);\n\t\t\t\t\t\t\t\trow[COLUMN_CLEAR_DESCENDANTS] = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tRows.Add(row);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Already in the list, but effective (negative mask id)\n\t\t\t\t\t\telse if (security.Length == 1 && getMaskId(security[0]) < 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSetToDefaultMask(security[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ok;\n\t\t}\n\n\n\t\t/// <summary>\n\t\t/// Returns a boolean indicating success in adding the specified groupId to the table.\n\t\t/// </summary>\n        /// <param name=\"currentUser\">Needed for context</param>\n\t\t/// <param name=\"groupUid\">The groupId of the group to add. (duh)</param>\n\t\t/// <param name=\"messages\">Output parameter: A List of strings of error messages</param>\n\t\t/// <returns>A boolean indicating success in adding the specified group.</returns>\n\t\tpublic bool addGroup(UserAccount currentUser, Guid groupUid, out List<string> messages)\n\t\t{\n\t\t\tbool ok = true;\n\t\t\tmessages = new List<string>();\n\n\t\t\tGroup group = GroupPersistence.GetInstance(currentUser).LoadByUid(currentUser, groupUid);\n\n\t\t\tif (group == null)\n\t\t\t{\n\t\t\t\tmessages.Add(\"Group not found.\"); //I18NTODO\n\t\t\t\tok = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Is this a new group?\n\t\t\t\tDataRow[] security = Select(COLUMN_SECURITY_GROUP_UID + \" = '\" + group.Uid + \"'\");\n\t\t\t\tif (security.Length == 0)\n\t\t\t\t{\n\t\t\t\t\tDataRow row = NewRow();\n\n\t\t\t\t\trow[COLUMN_SECURITY_GROUP_UID] = group.Uid;\n\t\t\t\t\trow[COLUMN_DISTRIBUTION_GROUP_NAME] = group.Name;\n\t\t\t\t\trow[COLUMN_NAME] = group.Name;\n\t\t\t\t\trow[COLUMN_SORT] = SORT_GROUP;\n\n\t\t\t\t\tRows.Add(row);\n\t\t\t\t}\n\t\t\t\t// Already in the list, but effective (negative mask id)\n\t\t\t\telse if (security.Length == 1 && getMaskId(security[0]) < 0)\n\t\t\t\t{\n\t\t\t\t\tSetToDefaultMask(security[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ok;\n\t\t}\n\n\n\n\t\t#endregion\n\n\t\t#region Private Methods\n\n\t\tprivate ISecurityMap GetSecurityMap(UserAccount user)\n\t\t{\n\t\t\t// Can't use the repository load since that will run all security filters. We only want to apply jit here.\n\t\t\tvar folder = ServiceLocator.GetInstance<IAtlasPersistenceFactory>().Get<IFolderPersistence>(user).LoadByUid(user.AccountId, user.Uid, ObjectUid);\n\t\t\treturn new JITSecurityProvider().GetSecurityMap(user, new List<Folder> { folder }, out _, null).ElementAt(0);\n\t\t}\n\n\n\t\tprivate int getMaskId(DataRow security)\n\t\t{\n\t\t\treturn SecurityMasks.GetMaskId(security);\n\t\t}\n\n\t\tprivate SecurityLevel TranslateSecurityFlagToSecurityLevel(string columnName, Enums.Security securityFlags)\n\t\t{\n\t\t\tswitch (columnName)\n\t\t\t{\n\t\t\t\tcase COLUMN_READ_SECURITY:\n\t\t\t\t\treturn (securityFlags & Enums.Security.Read) == Enums.Security.Read ? SecurityLevel.InheritGrant : SecurityLevel.InheritDeny;\n\t\t\t\tcase COLUMN_WRITE_SECURITY:\n\t\t\t\t\treturn (securityFlags & Enums.Security.Write) == Enums.Security.Write ? SecurityLevel.InheritGrant : SecurityLevel.InheritDeny;\n\t\t\t\tcase COLUMN_CREATE_SECURITY:\n\t\t\t\t\treturn (securityFlags & Enums.Security.Create) == Enums.Security.Create ? SecurityLevel.InheritGrant : SecurityLevel.InheritDeny;\n\t\t\t\tcase COLUMN_MOVE_SECURITY:\n\t\t\t\t\treturn (securityFlags & Enums.Security.Move) == Enums.Security.Move ? SecurityLevel.InheritGrant : SecurityLevel.InheritDeny;\n\t\t\t\tcase COLUMN_SET_ACCESS_SECURITY:\n\t\t\t\t\treturn (securityFlags & Enums.Security.SetAccess) == Enums.Security.SetAccess ? SecurityLevel.InheritGrant : SecurityLevel.InheritDeny;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ArgumentException($\"Invalid column '{columnName}'.\");\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Overrides\n\n\t\t/// <summary>\n\t\t/// Returns a new row with its security columns defualted.\n\t\t/// </summary>\n\t\t/// <returns>a new row with its security columns defualted</returns>\n\t\tnew public DataRow NewRow()\n\t\t{\n\t\t\tDataRow row = base.NewRow();\n\n\t\t\tSetToDefaultMask(row);\n\t\t\trow[COLUMN_CLEAR_DESCENDANTS] = false;\n\n\t\t\treturn row;\n\t\t}\n\n\t\tprivate void SetToDefaultMask(DataRow row)\n\t\t{\n\t\t\tint maskId = getMaskId(row);\n\t\t\tDataRow mask;\n\t\t\tif (maskId < 0)\n\t\t\t{\n\t\t\t\tmask = _securityMasks.Rows[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmask = _securityMasks.Rows[maskId];\n\t\t\t}\n\n\t\t\trow[COLUMN_READ_SECURITY] = mask[COLUMN_READ_SECURITY];\n\t\t\trow[COLUMN_WRITE_SECURITY] = mask[COLUMN_WRITE_SECURITY];\n\t\t\trow[COLUMN_CREATE_SECURITY] = mask[COLUMN_CREATE_SECURITY];\n\t\t\trow[COLUMN_MOVE_SECURITY] = mask[COLUMN_MOVE_SECURITY];\n\t\t\trow[COLUMN_SET_ACCESS_SECURITY] = mask[COLUMN_SET_ACCESS_SECURITY];\n\t\t\trow[COLUMN_SECURITY_MASK_ID] = mask[COLUMN_ROW_ID];\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Serialization method.\n\t\t/// </summary>\n\t\t/// <param name=\"info\"></param>\n\t\t/// <param name=\"context\"></param>\n\t\tpublic override void GetObjectData(SerializationInfo info, StreamingContext context)\n\t\t{\n\t\t\tbase.GetObjectData(info, context);\n\n\t\t\tinfo.AddValue(SERIALIZATION_INFO_ACCOUNT_ID, _accountId);\n\t\t\tinfo.AddValue(SERIALIZATION_INFO_OBJECT_UID, _objectUid);\n\t\t\tinfo.AddValue(SERIALIZATION_INFO_OBJECT_TYPE, _objectType);\n\t\t\tinfo.AddValue(SERIALIZATION_INFO_CLEAR_ALL_DESCENDANTS, _clearAllDescendants);\n\t\t}\n\n\t\t#endregion\n\t}\n}\n",
      "relevance_score": 0.7
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Http;\nusing System.Web.Http.Dispatcher;\nusing System.Web.Http.Filters;\nusing System.Web.Http.Hosting;\nusing System.Web.Mvc;\nusing System.Web.Routing;\n\nusing ADEXS.Api.Common;\nusing ADEXS.API.Content.NoBuffer;\nusing ADEXS.API.WebAPI.Filters;\nusing ADEXS.Collaboration.Infrastructure.IoC;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.ServiceProtection;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.FeatureFlags;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.ElasticCore;\nusing ADEXS.ElectronicSignature;\nusing ADEXS.MQ;\nusing ADEXS.SForce.Core;\nusing ADEXS.Web.Common;\nusing ADEXS.Web.Common.Logger;\nusing ADEXS.Web.Common.WarmUp;\n\nusing DocuSign.API.ServiceProtection.Client;\nusing DocuSign.API.ServiceProtection.Client.Common;\n\nusing IFilterProvider = System.Web.Http.Filters.IFilterProvider;\n\n\nnamespace ADEXS.API.Content\n{\n\t// Note: For instructions on enabling IIS6 or IIS7 classic mode,\n\t// visit http://go.microsoft.com/?LinkId=9394801\n\n\tpublic class WebApiApplication : ScmHttpApplication\n\t{\n\t\tprivate static readonly IDiscreetWebLog _log = DiscreetWebLogger.GetLogger(\"API.Content\");\n\n\t\tprivate static List<IServiceRegistry> CoreRegistrations =>\n\t\t\tnew List<IServiceRegistry>\n\t\t\t{\n\t\t\t\tnew ApiRegistry(),\n\t\t\t\tnew WebCoreDomainRegistry(),\n\t\t\t\tnew ElasticCoreRegistry(),\n\t\t\t\tnew MessageQueueRegistry(),\n\t\t\t\tnew WebCommonRegistry(),\n\t\t\t\tnew ApiContentRegistry(),\n\t\t\t\tnew ESignatureRegistry(),\n\t\t\t\tnew SalesForceRegistry(),\n\t\t\t\tnew ApiCommonRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew FeatureFlagRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew OneConfigServiceRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew ServiceConfigServiceRegistry(WebCoreDomainRegistry.OneConfigPath, \"API.Content.ini\"),\n\t\t\t\tnew ServiceProtectionRegistry(),\n\t\t\t\tnew CollaborationRegistry(),\n\t\t\t};\n\n\t\tprotected void Application_Start()\n\t\t{\n\t\t\tbase.ApplicationStart();\n\n\t\t\tGlobalConfiguration.Configuration.Services.Replace(typeof(IHostBufferPolicySelector), new NoBufferPolicySelector());\n\n\t\t\tbase.InitializeFeatureFlags();\n\n\t\t\tGlobalConfiguration.Configuration.IncludeErrorDetailPolicy =\n\t\t\t\t(IncludeErrorDetailPolicy)Enum.Parse(typeof(IncludeErrorDetailPolicy), ApplicationSettings.WebApiErrorDetailPolicy);\n\t\t\tAreaRegistration.RegisterAllAreas();\n\t\t\tWebApiConfig.Register(GlobalConfiguration.Configuration);\n\n\n\t\t\t// This is for implementing global level filter ordering.\n\t\t\tvar providers = GlobalConfiguration.Configuration.Services.GetFilterProviders();\n\t\t\tvar defaultprovider = providers.First(i => i is ConfigurationFilterProvider);\n\t\t\tGlobalConfiguration.Configuration.Services.Remove(typeof(IFilterProvider), defaultprovider);\n\t\t\tGlobalConfiguration.Configuration.Services.Add(typeof(IFilterProvider), new OrderedActionFilterProvider());\n\n\t\t\tFilterConfig.RegisterGlobalFilters(GlobalConfiguration.Configuration.Filters);\n\t\t\tRouteConfig.RegisterRoutes(RouteTable.Routes);\n\t\t\tGlobalConfiguration.Configuration.Services.Replace(typeof(IHttpControllerActivator), new WarmUpServiceActivator());\n\n\t\t\t// Service Protection Rule Updater\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"Starting ExternalRuleRefresherWrapper for Service Protection\");\n\n\t\t\t\tServiceProtectionEnablementEvaluator dynaThrottMainToggleEnabled = () =>\n\t\t\t\t{\n\t\t\t\t\treturn ApplicationSettings.ServProtEnableDynamicThrottling;\n\t\t\t\t};\n\n\t\t\t\tExternalRuleRefresherWrapper.Start(\n\t\t\t\t\tclient: ServiceLocator.GetInstance<IServiceProtectionClient>(),\n\t\t\t\t\tconfiguration: ServiceLocator.GetInstance<IExternalRulesUpdaterConfiguration>(),\n\t\t\t\t\tdynaThrottMainToggleEnabled);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"Error while starting ExternalRuleRefresherWrapper for Service Protection\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprotected override void Application_End()\n\t\t{\n\t\t\tExternalRuleRefresher.Stop();\n\t\t\tbase.Application_End();\n\t\t}\n\n\t\tprotected override void Bootstrap()\n\t\t{\n\t\t\tBootstrap(false);\n\t\t}\n\n\n\t\tpublic static void Bootstrap(bool force = false)\n\t\t{\n\t\t\tBootstrapper.Bootstrap(() => CoreRegistrations, force);\n\t\t}\n\n\t\tpublic static void Bootstrap(List<IServiceRegistry> customRegistrations)\n\t\t{\n\t\t\tList<IServiceRegistry> coreRegistrations = CoreRegistrations;\n\n\t\t\tif (customRegistrations?.Any() ?? false)\n\t\t\t{\n\t\t\t\tcoreRegistrations.AddRange(customRegistrations);\n\t\t\t}\n\n\t\t\tBootstrapper.Bootstrap(() => coreRegistrations, true);\n\t\t}\n\n\t\tprotected void Application_BeginRequest(object sender, EventArgs e)\n\t\t{\n\t\t\tHttpContext.Current.Response.AddHeader(\"Access-Control-Allow-Origin\", \"*\");\n\t\t\tif (HttpContext.Current.Request.HttpMethod == \"OPTIONS\")\n\t\t\t{\n\t\t\t\t//These headers are handling the \"pre-flight\" OPTIONS call sent by the browser\n\t\t\t\tHttpContext.Current.Response.AddHeader(\"Access-Control-Allow-Methods\", \"GET, POST, HEAD\");\n\t\t\t\tHttpContext.Current.Response.AddHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization, Content-Disposition\");\n\t\t\t\tHttpContext.Current.Response.End();\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    }
  ],
  "reasoning_chain": "ReasoningChain(strategy=<ReasoningStrategy.CHAIN_OF_THOUGHT: 'chain_of_thought'>, steps=[ReasoningStep(step_number=1, description='1. Analysis', reasoning='1. Analysis  \\n\u2022 Requirement: When an HTTP request comes in (begin-request) we must read Request.Headers[\"Referer\"].  \\n\u2022 When the response is about to be sent (end-request) we must read Response.Headers[\"Location\"].  ', conclusion='\u2022 When the response is about to be sent (end-request) we must read Response.Headers[\"Location\"].  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=2, description='Selected files for implementation', reasoning='Selected files for implementation  \\n1. /Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs  \\n(2. /Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs \u2013 only if common tracing helpers are required.)', conclusion='(2. /Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs \u2013 only if common tracing helpers are required.)', confidence=0.8, evidence=['LLM analysis'])], final_conclusion='These files give us direct access to the HTTP pipeline and any tracing helpers, enabling us to attach HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION to the existing HTTP request span.', overall_confidence=0.8, alternative_approaches=['2. (optional) If a custom Trace helper or OpenTelemetry initialization exists, it would live in *.Trace.cs files \u2013 from the list only DetectTypeService/DetectTypeProcessor.Trace.cs fits.   That file might hold helper extension methods for Activity tagging, so it is the only secondary candidate.', 'Alternative approach considered'])"
}