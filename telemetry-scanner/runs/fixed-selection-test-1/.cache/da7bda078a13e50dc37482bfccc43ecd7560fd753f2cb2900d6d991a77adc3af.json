{
  "selected_files": [
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class DetectTypeProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
      "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class VideoInfoProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net.Mime;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.PhysicalStorage;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FileIO;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.MimeLookup;\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.ContentStorage;\n\nnamespace ADEXS.DetectTypeService\n{\n\tpublic partial class DetectTypeProcessor : CommonTaskProcessor<DetectTypeTaskPayload>\n\t{\n\t\tprivate readonly IAtlasPersistenceFactory _atlasPersistenceFactory;\n\n\t\tprivate readonly IAtlasPhysicalStorageFactory _atlasPhysicalStorageFactory;\n\n\t\tprivate readonly IMimeDetector _mimeDetector;\n\n\t\tprivate readonly IDetectTypeServiceFeaturesConfig _featuresConfig;\n\n\t\tpublic DetectTypeProcessor()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IAtlasPersistenceFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IAtlasPhysicalStorageFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IMimeDetector>(),\n\t\t\t\tServiceLocator.GetInstance<IServiceInstrumentation>(),\n\t\t\t\tServiceLocator.GetInstance<IDetectTypeServiceFeaturesConfig>())\n\t\t{\n\t\t}\n\n\t\tpublic DetectTypeProcessor(\n\t\t\tIAtlasPersistenceFactory atlasPersistenceFactory,\n\t\t\tIAtlasPhysicalStorageFactory atlasPhysicalStorageFactory,\n\t\t\tIMimeDetector mimeDetector,\n\t\t\tIServiceInstrumentation serviceInstrumentation,\n\t\t\tIDetectTypeServiceFeaturesConfig featuresConfig)\n\t\t{\n\t\t\t_atlasPersistenceFactory = atlasPersistenceFactory;\n\t\t\t_atlasPhysicalStorageFactory = atlasPhysicalStorageFactory;\n\t\t\t_mimeDetector = mimeDetector;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t\t_featuresConfig = featuresConfig;\n\t\t}\n\n\t\tpublic override ProcessTaskResult ProcessTask()\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t// get and report the status of whether Optimizely is the feature flag provider\n\t\t\tLogger.InfoNoPII($\"Verification: IsOptimizelyVerificationFlagEnabled is {_featuresConfig.IsOptimizelyVerificationFlagEnabled} for account '{Task.AccountId}' (context accountId: '{AtlasContext.Current.AccountId}')\");\n\n\t\t\tProcessTaskResult result = new ProcessTaskResult();\n\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\tvar fileDataPersistence = _atlasPersistenceFactory.Get<IFileDataPersistence>(Task.AccountId);\n\n\t\t\tFileData fd = fileDataPersistence.LoadByUid(DeserializedPayload.FileDataUid);\n\t\t\tif (fd == null)\n\t\t\t{\n\t\t\t\tLogger.WarnNoPII($\"FileDataUid {DeserializedPayload.FileDataUid} does not exist in the db; ignoring\");\n\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\tresult.Message = \"Filedata Doesn't Exist\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// first try and detect the MIME type\n\t\t\t\t\tstring mimeType;\n\t\t\t\t\tusing (TempFile temp = new TempFile(fd.Extension))\n\t\t\t\t\t{\n\t\t\t\t\t\t//We could possibly optimize this by reading the first 256 bytes and passing them to the underlying COM library urlmon.dll.\n\t\t\t\t\t\t//See https://msdn.microsoft.com/en-us/library/ms775107(v=vs.85).aspx (FindMimeFromData function)\n\t\t\t\t\t\t_atlasPhysicalStorageFactory.GetPhysicalStorage(fd.AccountId).GetFile(fd.AccountId, fd.FileName, StorageConstants.StorageFormat.Native, temp.FileName);\n\t\t\t\t\t\tmimeType = _mimeDetector.DetectMimeType(temp.FileName);\n\t\t\t\t\t}\n\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected MIME type '{0}' for fileDataUid {1}.\", mimeType, fd.FileDataUid);\n\n\t\t\t\t\t// if still not sure try to map the extension to the MIME type\n\t\t\t\t\tif (string.IsNullOrEmpty(mimeType) || (mimeType == MediaTypeNames.Application.Octet))\n\t\t\t\t\t{\n\t\t\t\t\t\tmimeType = FileUtil.GetMimeTypeByExtension(fd.Extension);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Matched extension to MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\n\t\t\t\t\t// once we have a new MIME type, save it\n\t\t\t\t\tif (!string.IsNullOrEmpty(mimeType) && mimeType != fd.MIMEType)\n\t\t\t\t\t{\n\t\t\t\t\t\tfileDataPersistence.UpdateMIMEType(fd.Uid, mimeType);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected and set MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\t\t\te.Trace();\n\t\t\t\t\tLogger.ErrorNoPII($\"Failed to process fileDataUid {fd.FileDataUid} with exception \", e);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tTask.LastErrorMessage = e.Message;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.ErrorNoPII($\"Failed to mark fileDataUid {fd.FileDataUid} as failed with exception \", e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactivity?.SetQueueTaskResultTags(Task, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Activities.HumanActivities;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.ActivityProperties;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.ExpressionService.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Config;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\nusing ADEXS.WINS.Interfaces;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\n\nusing Platform.Common;\n\nusing SCMAppenders;\n\nusing static ADEXS.Atlas.Workflow.Activities.Handlers.InstanceHandler;\n\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing InstanceVariable = ADEXS.Core.Domain.Model.Workflow.InstanceVariable;\nusing LoggingHelper = ADEXS.Atlas.Workflow.Activities.Infrastructure.LoggingHelper;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing UserAccount = ADEXS.Core.Domain.Model.UserAccount;\n\nnamespace ADEXS.WINS.Engine\n{\n\t/// <summary>\n\t/// An instance of a workflow -- a specific example of a definition.\n\t/// This class contains methods for controlling it, but all such calls should actually be fed through\n\t/// WorkflowManager so they can be queued, etc.\n\t/// </summary>\n\tpublic class WorkflowInstance : IWINSControlInstance\n    {\n        public const int SQL_SEVERITY_LEVEL_TRANSIENT = 12;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowInstance));\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IInstanceVariableGovernance _instanceVariableGovernance;\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepository;\n\t\tprivate IGovernor _governor;\n\t\tprivate IInstanceHandler _instanceHandler;\n\t\tprivate IServiceInstrumentation _serviceInstrumentation;\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> _workflowClientConfig;\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate ICacheRepository _cacheRepository;\n\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => (_instanceVariableGovernance ?? (_instanceVariableGovernance = ServiceLocator.GetInstance<IInstanceVariableGovernance>()));\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository ?? (_workflowSettingRepository = ServiceLocator.GetInstance<IWorkflowSettingRepository>());\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\t\tprivate IInstanceHandler InstanceHandler => _instanceHandler ?? (_instanceHandler = ServiceLocator.GetInstance<IInstanceHandler>());\n\n\n\t\tprivate IServiceInstrumentation ServiceInstrumentation => _serviceInstrumentation ?? (_serviceInstrumentation = ServiceLocator.GetInstance<IServiceInstrumentation>());\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> WorkflowClientConfig => _workflowClientConfig ?? (_workflowClientConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>());\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> SiteConfig => _siteConfig ?? (_siteConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>());\n\t\tprivate ICacheRepository CacheRepository => _cacheRepository ?? (_cacheRepository = ServiceLocator.GetInstance<ICacheRepository>());\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig ?? (_workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\n\t\t/// <summary>\n\t\t/// Loads (and locks) an existing instance.  Fails if the instance doesn't exist or can't be locked.\n\t\t/// </summary>\n\t\tpublic static WorkflowInstance LoadExisting(int accountId, Guid instanceUid, IWINSDataStore data)\n        {\n\t        DateTime lockExpirationDate;\n            InstancePersistence.LockResult lockResult = data.LockInstance(accountId, instanceUid, out lockExpirationDate);\n            switch (lockResult)\n            {\n                case InstancePersistence.LockResult.AlreadyCompleted:\n                    throw new InstanceAlreadyCompletedException(string.Format(\"InstanceUid {0} is already completed\", instanceUid));\n                case InstancePersistence.LockResult.DoesNotExist:\n                    throw new ApplicationException(string.Format(\"Invalid instanceUid {0}\", instanceUid));\n                case InstancePersistence.LockResult.LockedByOther:\n                    throw new InstanceLockedException(string.Format(\"InstanceUid {0} is locked by another process\", instanceUid));\n                case InstancePersistence.LockResult.Locked:\n                    // This is our success condition\n                    break;\n                default:\n                    throw new ApplicationException(string.Format(\"Unhandled lockResult for instanceUid {0}: {1}\", instanceUid, lockResult));\n            }\n            Instance instance = data.LoadInstanceByUid(accountId, Constants.WorkflowUser, instanceUid);\n            if (instance == null) throw new ApplicationException(string.Format(\"Failed to load workflow instanceUid {1} for account {0}.\", accountId, instanceUid));\n\n\t\t\ttry\n            {\n                if (instance.ScopeUid != Guid.Empty)\n                {\n                    Scope scope = ServiceLocator.GetInstance<IDocumentScopeRepository>().GetScopeByUid(accountId, instance.ScopeUid);\n                    if (scope != null)\n                        instance.ScopeName = scope.Name;\n                }\n            }\n            catch (Exception ex)\n            {\n                // the failure to load the scope should not cause the failure to load the instance, log it and move on\n                _log.WarnNoPII(string.Format(\"Could not load the scope '{0}' for workflow instance '{1}'.\", instance.ScopeUid, instanceUid), ex);\n            }\n\n\t\t\tRevision revision = data.LoadRevisionByUid(accountId, Constants.WorkflowUser, instance.RevisionUid);\n            if (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, instance.RevisionUid));\n            // ATL-68146: Populate RevisionCreatedDate here, because LoadInstanceByUid() doesn't populate it.\n            instance.RevisionCreatedDate = revision.CreatedDate;\n            WorkflowMap workflowMap = null;\n            instance.DefinitionUid = revision.DefinitionUid;\n\n\t\t\ttry\n            {\n\t            workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n            }\n            catch (InvalidDesignDefinitionException ex)\n            {\n\t            try\n\t            {\n\t\t            new WorkflowInstance(instance, data).Abort(UserAccount.WorkflowUserAccount(accountId), ex.Message);\n\t            }\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Error aborting workflow instance '{instanceUid}' with invalid definition\", e);\n\t\t\t\t}\n\n\t            throw;\n            }\n\n            var workflowInstance = new WorkflowInstance(instance, workflowMap, data);\n\t        workflowInstance.LockExpirationDate = lockExpirationDate;\n\t        return workflowInstance;\n\n        }\n\n        private readonly IWINSDataStore _data;\n        private readonly WorkflowMap _workflowMap;\n        private Instance _instance;\n\n        // The count of the activities that have been generated by this particular in-memory instance.  This doesn't get persisted anywhere, so is\n        // cleared whenever this WorkflowInstance gets unloaded (eg, when it enters into a Waiting state).\n        // It's use is to detect runaway workflows.\n        public const int MAX_IN_MEMORY_ACTIVITY_COUNT = 5000;\n        private int _inMemoryActivityCount = 0;\n\t\tprivate int _activityExecutionCountEnforcedLimit = 0;\n\t\tprivate Guid _revisionUid = Guid.Empty;\n\t\tprivate Guid _definitionUid = Guid.Empty;\n\t\tprivate DateTime _revisionCreatedDate = DateTime.MinValue;\n\t\tprivate bool _isActivityExecutionLimitReached = false;\n\n\t\tprivate readonly object _lockObject = new object();\n        private readonly IDictionary<Guid, InstanceActivity> _unfinishedActivities = new Dictionary<Guid, InstanceActivity>();\n        private readonly Queue<Event> _queuedControlEvents = new Queue<Event>();\n        private readonly Queue<Event> _queuedEvents = new Queue<Event>();\n\n        private readonly Dictionary<string, ContentDefinition> _contentDefinitions = new Dictionary<string, ContentDefinition>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, InstanceVariable> _variables = new Dictionary<string, InstanceVariable>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, IXmlVariableDefinition> _xmlVariableDefinitions = new Dictionary<string, IXmlVariableDefinition>(StringComparer.InvariantCultureIgnoreCase);\n\n        private readonly TimedLock _lock;\n\n        // Kind of a hack -- this is kept around so that if we end the instance without reaching the End step, we have an activity that we can\n        // log the message to.\n        private Guid _lastActivityUid;\n\n        private WorkflowInstance(Instance instance, IWINSDataStore data)\n        {\n\t        _data = data;\n\t        _lock = new TimedLock(instance.Uid.ToString());\n\t        _instance = instance;\n\t\t\t_revisionUid = _instance.RevisionUid;\n\t\t\t_revisionCreatedDate = instance.RevisionCreatedDate;\n\t        LastProcessDate = DateTime.UtcNow;\n\t\t\t_definitionUid = _instance.DefinitionUid;\n\t\t}\n\n\t\tpublic WorkflowInstance(Instance instance, WorkflowMap workflowMap, IWINSDataStore data) : this(instance, data)\n        {\n            _workflowMap = workflowMap;\n            // Load up any incomplete activities.  This is pointless to do for a new workflow, but it's not expensive either,\n            // so we simply avoid trying to figure that out and simply do it.\n            QueueIncompleteActivities();\n        }\n\n        /// <summary>\n        /// The AccountId this instance is running in.\n        /// </summary>\n        public int AccountId { get { return _instance.AccountId; } }\n\n        public Dictionary<string, ContentDefinition> ContentDefinitions { get { return _contentDefinitions; } }\n\n        public IWINSDataStore DataStore { get { return _data; } }\n\n        public TimedLock ThreadLock { get { return _lock; } }\n\n        /// <summary>\n        /// An in-memory, non-persisted value -- this is used when workers are finding instances to do work on.\n        /// It acts to make the WorkflowManager more FIFO, so that some workflows don't continually get ignored in favor of\n        /// newer work coming in.\n        /// </summary>\n        public DateTime LastProcessDate { get; private set; }\n\n        /// <summary>\n        /// The model Instance object; I didn't call this Instance because I didn't want it confused with a singleton pattern, and because\n        /// I didn't like seeing \"instance.Instance\".\n        /// </summary>\n        public Instance Model { get { return _instance; } }\n\n\t\tpublic DateTime LockExpirationDate { get; set; }\n\n\t\t/// <summary>\n\t\t/// The instance's Uid.  Primary key.\n\t\t/// </summary>\n\t\tpublic Guid Uid { get { return _instance.Uid; } }\n\n        public Dictionary<string, InstanceVariable> Variables { get { return _variables; } }\n\n        public Dictionary<string, IXmlVariableDefinition> XmlVariableDefinitions { get { return _xmlVariableDefinitions; } }\n\n        public Enums.WorkflowStepStatus Status => _instance.Status;\n\n        public bool HasQueuedWork\n        {\n            get { return _queuedEvents.Count > 0 || _queuedControlEvents.Count > 0; }\n        }\n\n        public bool HasUnfinishedActivities\n        {\n            get { return _unfinishedActivities.Count > 0; }\n        }\n\n        public void QueueActivity(InstanceActivity instanceActivity)\n        {\n            lock (_lockObject)\n            {\n                _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            }\n        }\n\n\t\tpublic int ActivityExecutionCount { get; set; }\n\n\t\tpublic int ActivityExecutionCountEnforcedLimit => _activityExecutionCountEnforcedLimit;\n\n\t\tpublic bool IsActivityExecutionLimitReached => _isActivityExecutionLimitReached;\n\n\t\tpublic Guid RevisionUid => _revisionUid;\n\n\t\tpublic Guid DefinitionUid => _definitionUid;\n\n\t\tpublic DateTime RevisionCreatedDate => _revisionCreatedDate;\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\t/// <param name=\"previousActivity\"></param>\n\t\t/// <param name=\"linkName\"></param>\n\t\t/// <param name=\"localContextId\"></param>\n\t\t/// <param name=\"followEmptyPathByDefault\"></param>\n\t\t/// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n\t\tpublic void QueueActivitiesByLink(InstanceActivity previousActivity, string linkName, int localContextId = 0, bool followEmptyPathByDefault = true, bool useLinkName = false)\n        {\n            IEnumerable<WorkflowMap.Link> links;\n            bool found = false;\n            if (_workflowMap.TryGetLinks(previousActivity.Name, linkName, out links))\n            {\n                foreach (WorkflowMap.Link link in links)\n                {\n                    QueueActivityByName(previousActivity, link.ToName, localContextId, linkName, useLinkName);\n                    found = true;\n                }\n            }\n            // If we got no matches, try to go for the default (empty) output.\n            if (followEmptyPathByDefault && !found && !string.IsNullOrEmpty(linkName)) QueueActivitiesByLink(previousActivity, string.Empty, localContextId);\n        }\n\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"previousActivity\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"localContextId\"></param>\n        /// <param name=\"linkName\"></param>\n        /// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n        public void QueueActivityByName(InstanceActivity previousActivity, string name, int localContextId = 0, string linkName = null, bool useLinkName = false)\n        {\n            IWINSActivity activity;\n            if (!_workflowMap.TryGetActivity(name, out activity)) throw new ApplicationException(string.Format(\"InstanceUid {0}: Tried to execute invalid activity '{1}'\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, name)));\n\n            if (localContextId <= 0) localContextId = (previousActivity == null ? int.MinValue : previousActivity.LocalContextId);\n\n            // Create a new activity\n            InstanceActivity instanceActivity = new InstanceActivity\n            {\n                AccountId = _instance.AccountId,\n                InstanceUid = _instance.Uid,\n                Name = name,\n                ActivityTypeName = activity.LegacyElementName(),\n                Status = Enums.WorkflowStepStatus.Pending,\n                InputActivityOutput = useLinkName ? linkName : (previousActivity == null ? string.Empty : previousActivity.Output),\n                InputActivityUid = (previousActivity == null ? Guid.Empty : previousActivity.Uid),\n                LocalContextId = localContextId,\n                IsWinsActivity = true,\n                CreatedDate = DateTime.UtcNow //make sure that the in memory copy has a value\n            };\n\n            try\n            {\n                _data.CreateActivity(instanceActivity);\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorWithPII($\"Failed to queue activity {{0}} for instance {_instance?.Uid} in account {_instance?.AccountId}\", ex, name);\n                _data.ActivityFailure(_instance, instanceActivity);\n            }\n\n            _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            QueueActivity(instanceActivity);\n        }\n\n        public void QueueEvent(Event e)\n        {\n            if (_instance.Status != Enums.WorkflowStepStatus.Failed && _instance.Status != Enums.WorkflowStepStatus.Aborted)\n            {\n                lock (_lockObject)\n                {\n                    Queue<Event> queue = (e.IsControlEvent ? _queuedControlEvents : _queuedEvents);\n                    if (e.Uid != Guid.Empty)\n                    {\n                        // Ensure this item isn't already in the list\n                        if (queue.Any(e2 => e2.Uid == e.Uid)) return;\n                    }\n                    queue.Enqueue(e);\n                    WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventQueued\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n                    wrk.Log();\n\t            }\n            }\n        }\n\n        public void QueueIncompleteActivities()\n        {\n            InstanceActivities activities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n            if (activities == null || activities.Count == 0) return;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in activities) _unfinishedActivities[activity.Uid] = activity;\n            }\n\n        }\n\n        public bool CheckActivityForCompletion(InstanceActivity instanceActivity)\n        {\n            // We only care about Waiting steps.\n            if (instanceActivity.Status != Enums.WorkflowStepStatus.Waiting) return false;\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.DebugNoPII($\"CheckActivityForCompletion called for ActivityUid {instanceActivity.Uid} ({instanceActivity.Name}).\");\n\t            try\n\t            {\n\t\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\t\t            ctx.CheckForCompletion();\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t            _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n\t\t\t            SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            return true;\n\t\t            }\n                    _log.DebugWithPII($\"CheckActivityForCompletion completed for Activity ({{0}}) in status: {instanceActivity.Status}.\", instanceActivity.Name);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n                    _log.ErrorNoPII($\"CheckActivityForCompletion failed.\", e);\n\t            }\n            }\n            return false;\n        }\n\n        public bool DoNextTask()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t        CheckAndHandleInstanceStateChanges();\n\n\t\t\t// If we're in a non-processing state, we want to respond only to control events.\n\t\t\t// If we have no control events, we can just skip everything else.\n\t\t\tif (!_ShouldProcessEvent())\n\t        {\n\t\t        return _ExecuteFirstEvent(controlOnly: true);\n\t        }\n\n\t        // If we have any queued events, do one of those.\n\t        if (_ExecuteFirstEvent(controlOnly: false)) return true;\n\n\t        if (!_ShouldProcess()) return false;\n\n\t        // Otherwise, check to see if any activities need to be executed; if so, do those.\n\t        if (_ExecuteFirstActivity()) return true;\n\n\t        // If we get here, it might be that we have some unfinished activities in the database that for some reason weren't loaded into memory.\n\t        // Check for that, and, if so, load them now.\n\t        QueueIncompleteActivities();\n\t        // Try to execute an activity again -- we may have just loaded some\n\t        if (_ExecuteFirstActivity()) return true;\n\t        // If we can complete a waiting activity, do that.\n\t        if (_CheckWaitingActivities()) return true;\n\n\t        // Otherwise, we've got nothing to do and can quit.\n\t        if (!HasQueuedWork && !HasUnfinishedActivities)\n\t        {\n\t\t        _MarkCompleted();\n\t\t\t\t// If we processed nothing (the activity count is 0) we don't want to mark ourselves as waiting.  This is mostly because\n\t\t\t\t// we don't want to update our UpdatedDate (see ATL-20570).  This case occurs when our workflow is already waiting and has been\n\t\t\t\t// picked up for the day and each activity checked to see if it's done waiting.  We don't want this to trigger an update if\n\t\t\t\t// nothing has actually changed.\n\t        }\n\t        else if (_inMemoryActivityCount > 0 || _instance.Status != Enums.WorkflowStepStatus.Waiting)\n\t        {\n\t\t\t\tvar workflowConfig = WorkflowConfig(_instance.AccountId);\n\t\t\t\tvar enableSmallBenRateLimits = workflowConfig?.EnableSmallBenRateLimits ?? false;\n\n\t\t\t\tif (_instance.Status == Enums.WorkflowStepStatus.Paused\n\t\t\t\t    && ((string.Equals(ADEXS.Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.EnableExpressionApiRateLimit, \"live\", StringComparison.OrdinalIgnoreCase)\n\t\t\t\t         && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit)\n\t\t\t\t\t|| (enableSmallBenRateLimits && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit)))\n\t\t\t\t{\n\t\t\t\t\t// keep throttled workflows in paused status\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_MarkWaiting();\n\t\t\t}\n\n\t\t    return false;\n        }\n\n        public void ExecuteActivity(InstanceActivity instanceActivity)\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteActivity called for Activity ({{0}}).\", instanceActivity.Name);\n\t            IWINSWorkflowContext ctx = null;\n\t            Stopwatch sw = Stopwatch.StartNew();\n\t            try\n\t            {\n\t\t            _lastActivityUid = instanceActivity.Uid;\n\n\t\t\t\t\tif (!_ShouldProcess()) throw new ApplicationException(string.Format(\"InstanceUid {0} is in an invalid state to execute activity {1}\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, instanceActivity.Name)));\n\n\t\t            // Check for runaway workflows.\n\t\t            if (++_inMemoryActivityCount >= MAX_IN_MEMORY_ACTIVITY_COUNT)\n\t\t            {\n\t\t\t            _log.WarnNoPII(string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t\t            throw new PublicException(PublicException.FailReason.InvalidState, string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t            }\n\n\t\t\t\t\t// Governance, check if activity execution limit has been reached\n\t\t\t\t\tif (PauseWhenActivityExecutionLimitReached())\n\t\t\t\t\t{\n\t\t\t\t\t\t// In this case, the workflow is paused, purge date is set and an e-mail has been sent to support team.\n\t\t\t\t\t\t// The current activity will not be executed, unless the limits are increased and the workflow resumed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_data.ActivityExecuting(_instance, instanceActivity);\n\n\t\t            ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\t\tif (!ShouldUseScopeEventHandler() && IsTrackItActivity(activity))\n\t\t\t\t\t{\n\t\t\t\t\t\tFireWorkflowScopeEvent(null, ScopeEventType.StepInitiated, activity, ctx);\n\t\t\t\t\t}\n\n\t\t\t\t\tactivity.Execute(ctx);\n\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n\t\t\t\t\tif (e is ArgumentNullException && ctx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar message =\n\t\t\t\t            string.Format(Resources.WINSResources.ActionFailed_ReferenceID_0, Guid.NewGuid()) +\n\t\t\t\t            $\". Inst: {instanceActivity.AccountId} '{instanceActivity.InstanceUid}'.\";\n\t\t\t            _log.ErrorNoPII(message, e);\n\t\t\t\t\t\t_data.CreateInstanceHistory(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, message, true);\n\t\t            }\n\n\t\t\t\t\t// Oh my...\n\t\t\t\t\t// Look at this catch block.\n\t\t\t\t\tbool isTransient = e is TransientException;\n\t\t            bool useFailureOutput = ctx != null && activity.HasFailureOutput;\n\n\t\t            if (isTransient) throw new TransientException(e);\n\t\t            if (useFailureOutput)\n\t\t            {\n\t\t\t\t\t\tctx.ActivityVariables.Set(\"Failure\", e.Message);\n\t\t\t\t\t\tctx.MarkAsCompleted(AbstractActivity.OUTPUT_FAILURE);\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.ActivityFailure(_instance, instanceActivity);\n\t\t\t            if (ctx == null) ctx = _CreateContext(activity, instanceActivity);\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\ttry\n\t\t\t            {\n\t\t\t\t            if (_instance.Status == Enums.WorkflowStepStatus.Failed)\n\t\t\t\t            {\n\t\t\t\t\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInstanceHandler.Fail(ctx, activity, GetUnfinishedWINSWorkflowContextsWINSActivities(instanceActivity.EndDate));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAccountId = ctx.AccountId,\n\t\t\t\t\t\t\t\t\t\tScopeUid = ctx.ScopeUid,\n\t\t\t\t\t\t\t\t\t\tScopeName = ctx.ScopeName,\n\t\t\t\t\t\t\t\t\t\tStepName = instanceActivity.Name,\n\t\t\t\t\t\t\t\t\t\tStepDisplayName = GetActivityDisplayName(activity, ctx),\n\t\t\t\t\t\t\t\t\t\tStepTypeName = instanceActivity.ActivityTypeName,\n\t\t\t\t\t\t\t\t\t\tStepUid = instanceActivity.Uid,\n\t\t\t\t\t\t\t\t\t\tPeriodStart = instanceActivity.EndDate,\n\t\t\t\t\t\t\t\t\t\tEventType = (int)ScopeEventType.WorkflowFailed,\n\t\t\t\t\t\t\t\t\t\tOutput = instanceActivity.Output,\n\t\t\t\t\t\t\t\t\t\tWorkflowUid = ctx.WorkflowInstanceUid,\n\t\t\t\t\t\t\t\t\t\tWorkflowName = ctx.WorkflowName\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tEventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n\n\t\t\t\t\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Failed, instanceActivity.EndDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t            }\n\t\t\t            catch (Exception ex)\n\t\t\t            {\n\t\t\t\t        _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.WorkflowFailed}\", ex);\n\t\t\t            }\n\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n\t\t            }\n\t            }\n\t            finally\n\t            {\n\t\t            ActivityExecutionCount++;\n\t            }\n\t\t\t}\n        }\n\n        public void ExecuteCallback(InstanceActivity instanceActivity, string name, object value)\n        {\n            LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteCallback called for Activity ({{0}}) with callback {name}.\", instanceActivity.Name);\n\n\t            if (!(_ShouldProcess(instanceActivity) && _ShouldProcessEvent()))\n\t            {\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoWithPII($\"ExecuteCallback did not complete because the activity was already completed. Activity {{0}} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}. Instance status: {Model.Status}\", instanceActivity.Name);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _log.ErrorWithPII($\"InstanceUid {Uid} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}.  Instance status: {Model.Status}\");\n\t\t\t\t\t}\n\t\t            return;\n\t\t\t\t}\n\n\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\ttry\n\t\t        {\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t            activity.ExecuteCallback(ctx, name, value);\n\n\t\t            if (_instance.Status != Enums.WorkflowStepStatus.Aborted)\n\t\t            {\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\n\t\t\t\t\t// Throw so that the calling method will handle re-queuing the failed event\n\t\t\t\t\t// When resumed we will retry the recurring reminder callback\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t            catch (Exception e)\n\t            {\n\t\t\t\t\t// Note that we don't fail the workflow here -- see ATL-21019\n\t\t\t\t\tif (instanceActivity.Status == Enums.WorkflowStepStatus.Completed ||\n\t\t                Model.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoNoPII($\"The callback is unnecessary: workflow activity '{instanceActivity.Uid}' [{instanceActivity.Status}] or instance '{instanceActivity.InstanceUid}' [{Model.Status}] has already completed.\");\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t\t\t\tvar pe = e as PublicException;\n\t\t\t\t\t\t_log.ErrorNoPII($\"ExecuteCallback failed.\", pe?.InnerException ?? e);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void ExecuteEvent(Event e, bool queueOnFailure = true)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            if (e == null) return;\n\n            using var span = StartActivity();\n\n            using (ScmNDC.Push(BuildNDCTags(e)))\n            {\n\t            // If we have Uid but the lock expired we don't want to process the event as it was persisted and some other worker probably has already picked it.\n\t            if (e.Uid != Guid.Empty && e.LockExpirationDate <= LastProcessDate)\n\t            {\n\t\t            _log.InfoNoPII($\"Aborting event execution - ExecuteEvent called with an event that has an expired lock ({e.LockExpirationDate}) for callback {e.CallbackName}.\");\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t\t            return;\n\t            }\n\n\t            _log.InfoNoPII($\"ExecuteEvent called with callback {e.CallbackName}.\");\n\t            try\n\t            {\n\t\t            Stopwatch sw = Stopwatch.StartNew();\n\t\t            if (e.ActivityUid == Guid.Empty)\n\t\t            {\n\t\t\t            // We expect these to be control codes\n\t\t\t            string comment = (e.CallbackObject == null ? \"\" : e.CallbackObject.ToString());\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            case Event.ControlNames.Abort:\n\t\t\t\t\t            Abort(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForAccountCancel:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tSetPurgeDateForAccountCancel();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForRevisionSuspended:\n\t\t\t\t\t\t\t\tPauseForRevisionSuspended(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.ResumeForSuspendedRevision:\n\t\t\t\t\t\t\t\t ResumeForSuspendedRevision(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.Pause:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t            case Event.ControlNames.Resume:\n\t\t\t\t\t            Resume(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.ResumeFromError:\n\t\t\t\t\t            ResumeFromError(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.StartActivity:\n\t\t\t\t\t            QueueActivityByName(null, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            default:\n\t\t\t\t\t            throw new ApplicationException(string.Format(\"Unhandled event {0}\", e.CallbackName));\n\t\t\t            }\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            // These *may* be control codes.  If they're not control codes, then\n\t\t\t            // we expect them to be a callback to an activity.\n\t\t\t            InstanceActivity activity;\n\t\t\t            if (!_unfinishedActivities.TryGetValue(e.ActivityUid, out activity)) activity = _data.LoadActivityByUid(_instance.AccountId, Constants.WorkflowUser, e.ActivityUid);\n\t\t\t            if (activity == null || activity.InstanceUid != e.InstanceUid) throw new ApplicationException(string.Format(\"Invalid ActivityUid {0} for InstanceUid {1}\", e.ActivityUid, e.InstanceUid));\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            // TODO: Start specific steps, fire specific outputs, complete specific steps, etc.\n\t\t\t\t            default:\n\t\t\t\t\t            ExecuteCallback(activity, e.CallbackName, e.CallbackObject);\n\t\t\t\t\t            break;\n\t\t\t            }\n\t\t            }\n\t\t            if (e.Uid != Guid.Empty) _data.EventSuccess(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventExecuted\")\n\t\t\t\t\t{\n\t\t\t\t\t\tTotalMs = sw.ElapsedMilliseconds,\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid, WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t            wrk.Log();\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t            catch (Exception excp)\n\t            {\n\t\t            _log.ErrorNoPII($\"Error processing eventUid {e.Uid} ({e.CallbackName}).\", excp);\n\t\t            if (!queueOnFailure) throw;\n\t\t            if (e.Uid == Guid.Empty)\n\t\t            {\n\t\t\t            e.NextProcessDate = _data.NextProcessDate();\n\t\t\t            e.ErrorCount = 1;\n\t\t\t            e.LastErrorMessage = excp.Message;\n\t\t\t            _data.CreateEvent(e);\n\t\t\t            WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnExecuteException\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t\t};\n\t\t\t            wrk.Log();\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.EventFailure(e.AccountId, e.Uid, _data.NextProcessDate(), excp.Message);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void Abort(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in _unfinishedActivities.Values)\n                {\n\t                try\n\t                {\n\t\t                IWINSActivity winsActivity = _SafeGetActivity(activity);\n\t\t                IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n\t\t                winsActivity.OnActivityAborted(ctx);\n\t                }\n\t                catch (Exception ex)\n\t                {\n\t\t                _log.ErrorNoPII(string.Format(\"Failed OnActivityAborted AccountId {0}, ActivityUid {1}\", user.AccountId, activity.Uid), ex);\n\t\t\t\t\t}\n                }\n                new WorkflowControlInstance(Model).Abort(user, comment);\n\n\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t{\n\t\t\t\t\tInstanceHandler.Abort(_instance, user, GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime.UtcNow));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Aborted, DateTime.UtcNow);\n\t\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowAborted);\n\t\t\t\t}\n\n\t\t\t\t_ForceReload();\n            }\n        }\n\n        public int SetPurgeDateForAccountCancel()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        var daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForAccountCancel();\n\t\t        _ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t        }\n        }\n\n        public void ClearPurgeDate()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        new WorkflowControlInstance(Model).ClearPurgeDate();\n\t\t        _ForceReload();\n\t        }\n        }\n\n\t\tpublic void Pause(UserAccount user, string comment)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Pause - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).Pause);\n\t\t}\n\n\t\tpublic void PauseForRevisionSuspended(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status == Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - No action taken, instance already paused\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).PauseForRevisionSuspended);\n\t\t}\n\n\t\tpublic void ResumeForSuspendedRevision(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status != Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, instance not paused. Status:{Model.Status}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if instance UpdatedBy has changed since the PauseForRevisionSuspended was invoked, if it has we do not want to do anything.\n\t\t\tif (Model.UpdatedBy != WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, UpdatedBy is not {WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - Resuming\");\n\t\t\tResume(user, comment);\n\t\t\tClearPurgeDate();\n\t\t}\n\n\t\tpublic bool PauseWhenActivityExecutionLimitReached()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Governance, check whether the number of executed activities exceeded the configured limit\n\t\t\t\t_isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(AccountId, Uid, _instance.RevisionUid, _instance.RevisionCreatedDate, ActivityExecutionCount, out _activityExecutionCountEnforcedLimit);\n\n\t\t\t\tif (_isActivityExecutionLimitReached)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum limit (Actual={ActivityExecutionCount}, EnforcedLimit={_activityExecutionCountEnforcedLimit}) and will be paused.\");\n\n\t\t\t\t\tPause(UserAccount.WorkflowUserAccount(AccountId), \"Workflow activity execution limit reached.\");\n\n\t\t\t\t\tTrySendActivityExecutionLimitExceedNotification(SetPurgeDateForAccountCancel());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' activity execution limit\", e);\n\t\t\t}\n\n\t\t\treturn _isActivityExecutionLimitReached;\n\t\t}\n\n\t\tpublic void PauseWhenThrottled(InstanceActivity activity, WorkflowApiRequestThrottledException exception)\n\t\t{\n\t\t\tRequires.NotNull(activity, nameof(InstanceActivity));\n\t\t\tRequires.NotNull(exception, nameof(WorkflowApiRequestThrottledException));\n\n\t\t\tif (exception.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.NotThrottled)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' is not throttled and will not be paused.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tactivity.Status = Enums.WorkflowStepStatus.Paused;\n\t\t\t\tvar throttledByApi = exception.ThrottledApiAsString();\n\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum {throttledByApi} request limit and will be paused. Message: {exception.Message}\");\n\n\t\t\t\tPauseInstance(UserAccount.WorkflowUserAccount(AccountId), $\"{throttledByApi} requests limit reached.\", new WorkflowControlInstance(Model).PauseForWorkflowRateLimitExceed);\n\n\t\t\t\t// Send notification\n\t\t\t\tswitch (exception.WorkflowThrottledStatus)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit:\n\t\t\t\t\t\tTrySendExpressionRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit:\n\t\t\t\t\t\tTrySendSmallBenRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_log.WarnNoPII(\"No notifications sent for unsupported throttle status\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mark instance as throttled for current workflow run session, WorkflowThrottledStatus property is not persisted and refreshed on reload\n\t\t\t\t_instance.WorkflowThrottledStatus = exception.WorkflowThrottledStatus;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception e)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' rate limit request limit with status {exception?.WorkflowThrottledStatus}\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublic int SetPurgeDateForWorkflowRateLimit()\n\t\t{\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tvar daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForWorkflowRateLimit();\n\t\t\t\t_ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid GetAdvancedWorkflowNotificationUserAccountUid()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while retrieving AdvancedWorkflowNotificationUserAccountUid for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\t\t}\n\n\t\tpublic void TrySendSmallBenRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\t// Send notification - pending ATL-90622\n\t\t}\n\n\t\tpublic void TrySendExpressionRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\tif (!ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetEnableWorkflowLimitNotifications(AccountId))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"EnableWorkflowLimitNotifications disabled for account {AccountId}, not sending expression rate limit exceeded notification\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (advancedWorkflowNotificationUserAccountUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {advancedWorkflowNotificationUserAccountUid} to receive expression rate limit exceeded notification\");\n\t\t\t\tUserAccount notificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, advancedWorkflowNotificationUserAccountUid);\n\n\t\t\t\tif (string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"AdvancedWorkflowNotificationUser '{advancedWorkflowNotificationUserAccountUid}' not found or missing email address. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar emailRecipients = new List<string>() { notificationUser.EmailAddress };\n\n\t\t\t\t_log.InfoNoPII($\"Sending expression rate limit exceeded notification to user '{advancedWorkflowNotificationUserAccountUid}' for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseExpressionRateLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowInstanceId = _instance.Id,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Resume(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).Resume(user, comment);\n                _ForceReload();\n            }\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Resume(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n        }\n\n        public void ResumeFromError(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).ResumeFromError(user, comment);\n                _ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.ResumeFromError(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n\t\t}\n\n        public void SaveToDatabase()\n        {\n            // We may have in-memory events that need to be saved to the db.\n\t\t\tPersistEvents();\n            _PersistVariables();\n        }\n\n        public void SaveEventsToDatabase()\n        {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPersistEvents();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save unsaved events for instance {Uid} to db\", e);\n\t\t\t}\n\t\t}\n\n\t    public void ArchiveVariables()\n        {\n            var incompleteActivities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, _instance.Uid);\n            // don't archive if there are any incomplete activites besides the one that has triggered this\n            if (incompleteActivities != null && incompleteActivities.Count > 1)\n            {\n                return;\n            }\n            _data.ArchiveVariables(AccountId, Constants.WorkflowUser, Uid);\n        }\n\n\t    public bool HasExistingLockExpired()\n\t    {\n\t\t    return LockExpirationDate < DateTime.UtcNow;\n\t    }\n\n\n        /// <summary>\n        /// Replaces variables provided in the dictionary returning replaced variables\n        /// </summary>\n        public void SetVariables(\n\t        InstanceActivity instanceActivity,\n\t        Dictionary<string, object> variables,\n\t        out List<InstanceVariable> oldVariables,\n\t        out bool areVariablesOverTotalSizeLimit,\n\t        out int totalVariablesSizeBytes,\n\t        out int totalVariablesSizeLimitBytes,\n\t\t\tout Dictionary<string, int> oversizedVariables,\n\t        out int variableValueSizeLimitBytes)\n        {\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            _log.DebugWithPII($\"SetVariables called for ActivityUid {instanceActivity.Uid} ({{0}}).\", instanceActivity.Name);\n\n            // We create the context so that the variable dictionaries get populated\n            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n            oldVariables = new List<InstanceVariable>();\n            var newVariables = UpdateVariablesHelper.PopulateContextVariables(ctx, this.Model, variables);\n\n            // Only set variables that are under the size limit\n\t\t\toversizedVariables = InstanceVariableGovernance.GetOversizedVariables(ctx.AccountId, newVariables, ctx.SubmittedDate, out variableValueSizeLimitBytes);\n\t\t\tforeach (InstanceVariable variable in newVariables)\n\t\t\t{\n\t\t\t\tif (!oversizedVariables.ContainsKey(variable.Name))\n\t\t\t\t{\n\t\t\t\t\toldVariables.Add(Variables[variable.Name]);\n\t\t\t\t\t// we could do \"ctx.Variables.Set(variable.Key, variable.Value);\" but that would log as the instanceActivity and we don't want that...\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Undo setting the variables, if the instance's total variable size exceeds the limit\n\t\t\tareVariablesOverTotalSizeLimit = InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(ctx.AccountId,\n\t\t\t\tVariables.Select(x => x.Value), ctx.SubmittedDate, activityConfiguration: null, out totalVariablesSizeBytes, out totalVariablesSizeLimitBytes);\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tforeach (InstanceVariable variable in oldVariables)\n\t\t\t\t{\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n        }\n\n        public DateTime GetLastAbortNotificationDate()\n        {\n\t        if (!_contextInitialized)\n\t        {\n\t\t        _LoadVariables();\n            }\n\n\t        if (_variables.TryGetValue(WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE, out InstanceVariable lastNotificationDate) &&\n\t            DateTime.TryParse(lastNotificationDate.Value.ToString(), out DateTime dateTime))\n\t        {\n\t\t        return dateTime;\n\t        }\n\n            return DateTime.MinValue;\n        }\n\n        public void SaveLastAbortNotificationDate(int accountId, Guid workflowInstanceUid, DateTime lastAbortNotificationDate)\n        {\n            var variable = InstanceVariable.CreateFromValue(\n\t            accountId,\n\t            workflowInstanceUid,\n\t            WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE,\n\t            Enums.WorkflowVariableType.Date,\n\t            lastAbortNotificationDate);\n\n            ServiceLocator.GetInstance<IInstanceVariablePersistence>().Save(Constants.WorkflowUser, variable);\n\n        }\n\n        /// <summary>\n        /// Called when we've finished work on an activity -- either executing it or performing a callback on it.\n        /// </summary>\n        private void _ActivityWorkCompleted(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx, Stopwatch sw)\n        {\n\t        // If it's flagged as completed, update in the db, queue up any next activities, and remove it from our list.\n            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n            {\n                _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n                SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t\tlock (_unfinishedActivities)\n                {\n                    if (_unfinishedActivities.ContainsKey(instanceActivity.Uid)) _unfinishedActivities.Remove(instanceActivity.Uid);\n                }\n            }\n            else\n            {\n                // Otherwise, it's still running.  Flag it as waiting so it doesn't get processed again.\n                instanceActivity.Status = Enums.WorkflowStepStatus.Waiting;\n                _data.SaveInstanceActivity(instanceActivity);\n            }\n\n            _log.InfoWithPII($\"_ActivityWorkCompleted done for Activity ({{0}}) in status: {instanceActivity.Status} ({sw.ElapsedMilliseconds} ms).\", instanceActivity.Name);\n\n\n            // log workload data\n            try\n            {\n                WorkflowWorkload ww = new WorkflowWorkload();\n                ww.Add(ctx);\n                ww.TotalMs = sw.ElapsedMilliseconds;\n\t\t\t\tww.StartTime = DateTime.UtcNow.AddMilliseconds(-ww.TotalMs);\n                ww.Status = instanceActivity.Status.ToString();\n                ww.Output = instanceActivity.Output;\n                ww.ActivityCreatedDate = instanceActivity.CreatedDate;\n                ww.ActivityStartDate = instanceActivity.StartDate;\n                if (DateTime.MinValue < instanceActivity.EndDate && instanceActivity.EndDate < DateTime.MaxValue)\n                    ww.ActivityEndDate = instanceActivity.EndDate;\n                if (DateTime.MinValue < _instance.CreatedDate && _instance.CreatedDate < DateTime.MaxValue)\n\t                ww.InstanceCreatedDate = _instance.CreatedDate;\n                ww.ActivityKind = activity.Kind.ToString();\n                ww.RevisionUid = _instance.RevisionUid.ToString();\n\t\t\t\tww.DefinitionUid = _instance.DefinitionUid.ToString();\n\t\t\t\tww.WorkflowDB = DataStore.GetDbNameForAccount(instanceActivity.AccountId);\n\n\t\t\t\tww.Log();\n            }\n            catch (Exception ex)\n            {\n                _log.WarnNoPII(\"Failed to log workload.\", ex);\n            }\n        }\n\n\t\tprivate void CompleteScopeStep(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n            try\n            {\n                if (IsTrackItActivity(activity))\n                {\n                    Documents documents = null;\n                    if (ctx.TrackActivity())\n                    {\n                        documents = ((ITrackItActivity)activity).GetDocuments(ctx);\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, instanceActivity.Uid,\n                            documents, instanceActivity.Output, instanceActivity.Status,\n                            instanceActivity.EndDate);\n                    }\n\n                    WorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n                    {\n                        AccountId = ctx.AccountId,\n                        Documents = documents?.Select(d => new WorkflowScopeEvent.DocumentDetail() { Uid = d.Uid, Name = d.Name }).ToList(),\n                        ScopeUid = ctx.ScopeUid,\n                        ScopeName = ctx.ScopeName,\n                        StepName = instanceActivity.Name,\n                        StepDisplayName = GetActivityDisplayName(activity, ctx),\n                        StepTypeName = instanceActivity.ActivityTypeName,\n                        StepUid = instanceActivity.Uid,\n                        PeriodStart = instanceActivity.EndDate,\n                        EventType = (int)ScopeEventType.StepFinished,\n                        Output = instanceActivity.Output,\n                        WorkflowUid = ctx.WorkflowInstanceUid,\n                        WorkflowName = ctx.WorkflowName\n                    };\n                    WorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n                    {\n                        EventData = scopeEventData\n                    };\n                    EventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.StepFinished}\", ex);\n            }\n        }\n\n        private void SaveInstanceActivityVariables(InstanceActivity instanceActivity, IWINSWorkflowContext ctx)\n        {\n\t        if (ctx.WorkflowUserAccount.Account.Settings.EnableWorkflowVariableHistory)\n\t        {\n\t\t        var instanceVariableRepository = ServiceLocator.GetInstance<IInstanceVariableRepository>();\n\t\t        instanceVariableRepository.SaveVariableHistory(instanceActivity.AccountId, ctx.WorkflowUserAccount.Uid,\n\t\t\t        instanceActivity.InstanceUid, instanceActivity.Uid, ctx.Variables.GetAllVariables());\n\t        }\n        }\n\n        private List<WINSWorkflowContextWINSActivity> GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime endDate)\n        {\n\t\t\tvar list = new List<WINSWorkflowContextWINSActivity>();\n\n\t\t\tif (!HasUnfinishedActivities) return list;\n\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values);\n            }\n\n            IWINSWorkflowContext ctx = null;\n            foreach (var activity in activities)\n            {\n                var winsActivity = _SafeGetActivity(activity);\n                ctx = _CreateContext(winsActivity, activity);\n\n                if (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n                {\n\t\t\t\t\tlist.Add(new WINSWorkflowContextWINSActivity { EndDate = endDate, WINSActivity = winsActivity, WINSWorkflowContext = ctx });\n\t\t\t\t}\n            }\n\n\t\t\treturn list;\n        }\n\n\t\tprivate void AbortOrFailScopeStep(Enums.WorkflowStepStatus status, DateTime endDate)\n\t\t{\n\t\t\tif (!HasUnfinishedActivities) return;\n\n\t\t\tList<InstanceActivity> activities;\n\t\t\tlock (_unfinishedActivities)\n\t\t\t{\n\t\t\t\tactivities = new List<InstanceActivity>(_unfinishedActivities.Values);\n\t\t\t}\n\t\t\tIWINSWorkflowContext ctx = null;\n\t\t\tforeach (var activity in activities)\n\t\t\t{\n\t\t\t\tvar winsActivity = _SafeGetActivity(activity);\n\t\t\t\tctx = _CreateContext(winsActivity, activity);\n\n\t\t\t\tif (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n\t\t\t\t{\n\t\t\t\t\tvar documents = ((ITrackItActivity)winsActivity).GetDocuments(ctx);\n\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, activity.Uid, documents, null, status, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool _CheckWaitingActivities()\n        {\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values.Where(n => n.Status == Enums.WorkflowStepStatus.Waiting));\n            }\n            bool success = false;\n            foreach (InstanceActivity activity in activities)\n            {\n                if (CheckActivityForCompletion(activity)) success = true;\n            }\n            return success;\n        }\n\n        private bool _contextInitialized = false;\n        private IWINSWorkflowContext _CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n            IWINSWorkflowContext ctx = CreateContext(activity, instanceActivity);\n            AtlasContext.Current.UserAccount = ctx.WorkflowUserAccount;\n            // Only do this once.  If it's been done, it's done.\n            if (_contextInitialized) return ctx;\n\n            // This all depends on the properties for the Start step.  We always want a Start step for normal processing;\n            // however, we don't necessarily have a Start step for our tests.\n            StartActivity start = _workflowMap.StartActivity;\n            if (start == null)\n            {\n                if (_data.IsTest) return ctx;\n                throw new ApplicationException(string.Format(\"Cannot find StartActivity for InstanceUid {0}\", _instance.Uid));\n            }\n\n            // Contents\n            string[][] contents = start.DefinedContents;\n            if (contents != null && contents.Length > 0)\n            {\n                foreach (string[] t in contents)\n                {\n                    ContentDefinition definition = new ContentDefinition(t);\n                    if (!_contentDefinitions.ContainsKey(definition.Name)) _contentDefinitions[definition.Name] = definition;\n                }\n            }\n\n            _LoadVariables();\n\n            // XML Variables\n            // Because XmlVariables have dependencies on the variables as well, it's easier to feed this through the xml variable handler\n            // rather than replicate the code.\n            List<IXmlVariableDefinition> definitions = start.DefinedXmlVariables;\n            if (definitions != null && definitions.Count > 0)\n            {\n                foreach (IXmlVariableDefinition definition in definitions)\n                {\n                    if (!_xmlVariableDefinitions.ContainsKey(definition.Name)) ctx.XmlVariables.Declare(definition, logMessage: false);\n                }\n            }\n\n            _contextInitialized = true;\n            return ctx;\n\t\t}\n\n        public IWINSWorkflowContext CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowContextFactory>().CreateWorkflowContext(this, activity, instanceActivity);\n        }\n\n\t\tprivate void _LoadVariables()\n        {\n\t        // Variables\n\t        Dictionary<string, InstanceVariable> variables = _data.LoadVariablesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n\t        foreach (InstanceVariable variable in variables.Values)\n\t        {\n\t\t        if (!_variables.ContainsKey(variable.Name)) _variables[variable.Name] = variable;\n\t        }\n        }\n\n        private bool _ExecuteFirstActivity()\n        {\n            InstanceActivity activity = null;\n            lock (_unfinishedActivities)\n            {\n                if (_unfinishedActivities.Count > 0) activity = _unfinishedActivities.Values.FirstOrDefault(n => n.Status == Enums.WorkflowStepStatus.Pending || n.Status == Enums.WorkflowStepStatus.Executing);\n            }\n            if (activity == null) return false;\n            ExecuteActivity(activity);\n            return true;\n        }\n\n        private bool _ExecuteFirstEvent(bool controlOnly = false)\n        {\n            // We always try to execute control events first.\n            Event e = null;\n            lock (_queuedControlEvents)\n            {\n                if (_queuedControlEvents.Count > 0) e = _queuedControlEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            // If we're only caring about control events, we can quit now.\n            if (controlOnly) return false;\n\n            // Otherwise, we do the same thing with the rest of the events.\n            lock (_queuedEvents)\n            {\n                if (_queuedEvents.Count > 0) e = _queuedEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            return false;\n        }\n\n        private void _ForceReload()\n        {\n            // Reload the object to get new state -- we do this inside the lock so that there's no race condition\n            // between this and a worker who may be working on the object\n            lock (_lockObject)\n            {\n                Guid instanceUid = Uid;\n                _instance = _data.LoadInstanceByUid(AccountId, Constants.WorkflowUser, instanceUid);\n                if (_instance == null) throw new ApplicationException(string.Format(\"Failed to reload instanceUid: {0}\", instanceUid));\n            }\n        }\n\n        private void _MarkCompleted()\n        {\n\t        if (_instance.IsCompleted)\n\t        {\n\t\t        _log.InfoNoPII($\"Instance {_instance.Uid} is already complete with status {_instance.Status}\");\n\t\t        return;\n\t        }\n\n            _PersistVariables();\n            bool endActivityFailure = _workflowMap.HasEndActivity() && !_instance.EndActivityReached;\n            Enums.WorkflowStepStatus endStatus = endActivityFailure ? Enums.WorkflowStepStatus.Failed : Enums.WorkflowStepStatus.Completed;\n            _data.SaveInstance(_instance);\n            _data.InstanceCompleted(_instance, endStatus);\n\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Complete(_instance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventType = _instance.Status == Enums.WorkflowStepStatus.Failed ? ScopeEventType.WorkflowFailed : ScopeEventType.WorkflowFinished;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t{\n\t\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\t\tPeriodStart = _instance.EndDate,\n\t\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\t\tWorkflowName = _instance.Name\n\t\t\t\t\t};\n\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t\t{\n\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t};\n\t\t\t\t\tEventRepo.FireEvent(_instance.AccountId, scopeEvent);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event {_instance.ScopeUid} for eventtype {eventType}\", ex);\n\t\t\t\t}\n\t\t\t}\n\n            if (endActivityFailure && _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                if (_lastActivityUid == Guid.Empty)\n                {\n                    _log.WarnNoPII($\"No activities for workflow.\");\n                }\n                else\n                {\n                    InstanceActivity activity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, _lastActivityUid);\n                    IWINSActivity winsActivity = _SafeGetActivity(activity);\n                    IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n                    LoggingHelper.LogActivityErrorNoPII(ctx, Resources.WINSResources.WorkflowExitedWithoutReachingTheEndActivity);\n                }\n\n            }\n            if (_instance.Status == Enums.WorkflowStepStatus.Completed || _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n            }\n        }\n\n        private void _MarkWaiting()\n        {\n            _PersistVariables();\n            _instance.Status = Enums.WorkflowStepStatus.Waiting;\n            _data.SaveInstance(_instance);\n        }\n\n        private void _PersistVariables()\n        {\n            InstanceVariables variables = new InstanceVariables();\n            foreach (InstanceVariable variable in _variables.Values) if (variable.IsModified) variables.Add(variable);\n            _data.SaveInstanceVariables(AccountId, Constants.WorkflowUser, variables);\n        }\n\n        private void PersistEvents()\n\t\t{\n\t\t\tlock (_queuedControlEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedControlEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedControlEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlock (_queuedEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        private void PersistEvent(Event e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_data.CreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_data.UnlockEvent(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventUnlockedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save event {e.Uid}, for instance {e.InstanceUid}, activity {e.ActivityUid}, and callback name {e.CallbackName} to db\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate IWINSActivity _SafeGetActivity(InstanceActivity instanceActivity)\n        {\n            try\n            {\n                IWINSActivity activity;\n                if (_workflowMap.TryGetActivity(instanceActivity.Name, out activity)) return activity;\n                // There is a problem with old MWF workflow data where the name of the activity is really the type name.\n                // Don't ask.  It's a stupid and boring story.\n                // But we still should handle it, at least for awhile.  So: if we get here because we didn't match name, we should see\n                // if we match type name.\n                // This whole thing is a huge hack that should get removed when it can.\n                InstanceActivity inputActivity = null;\n                if (instanceActivity.InputActivityUid != Guid.Empty) inputActivity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, instanceActivity.InputActivityUid);\n                if (_workflowMap.LegacyTryGetActivityByTypeName(instanceActivity.Name, inputActivity == null ? \"\" : inputActivity.Name, instanceActivity.InputActivityOutput ?? \"\", out activity))\n                {\n                    // Rename it so we get one less instance of this in the future\n                    instanceActivity.Name = activity.Name;\n                    return activity;\n                }\n                throw new ApplicationException(string.Format(\"Invalid activity name '{0}' for instanceUid '{1}'.\", instanceActivity.Name, instanceActivity.InstanceUid));\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"_SafeGetActivity failed.\", e);\n                return null;\n            }\n        }\n\n        private bool _ShouldProcess(InstanceActivity instanceActivity)\n        {\n            switch (instanceActivity.Status)\n            {\n                case Enums.WorkflowStepStatus.Executing:\n                case Enums.WorkflowStepStatus.Pending:\n                case Enums.WorkflowStepStatus.Waiting:\n                case Enums.WorkflowStepStatus.Aborted:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool _ShouldProcess()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        private bool _ShouldProcessEvent()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                    case Enums.WorkflowStepStatus.Aborted:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        //ITrackItActivity interface is implemented by activities whose data is tracked in DocumentScope and ScopeEvent tables.\n        private bool IsTrackItActivity(IWINSActivity activity)\n        {\n            return activity is ITrackItActivity;\n        }\n\n\t\tprivate void FireWorkflowScopeEvent(UserAccount user, ScopeEventType eventType, IWINSActivity activity = null, IWINSWorkflowContext ctx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo\n\t\t\t\t{\n\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\tPeriodStart = DateTime.UtcNow,\n\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\tWorkflowName = _instance.Name,\n\t\t\t\t\tEventBy = user == null ? null : new WorkflowScopeEvent.Assignee() { Email = user.EmailAddress, Name = user.FriendlyName, Uid = user.Uid }\n\t\t\t\t};\n\n\t\t\t\tif (activity != null && ctx != null)\n\t\t\t\t{\n\t\t\t\t\tscopeEventData.StepName = ctx.ActivityName;\n\t\t\t\t\tscopeEventData.StepDisplayName = GetActivityDisplayName(activity, ctx);\n\t\t\t\t\tscopeEventData.StepTypeName = ctx.ActivityTypeName;\n\t\t\t\t\tscopeEventData.StepUid = ctx.ActivityUid;\n\t\t\t\t}\n\n\t\t\t\tEventRepo.FireEvent(_instance.AccountId, new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t{\n\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event scopeUid: {_instance.ScopeUid}, instanceUid: {_instance.Uid} eventType: {eventType}\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void RemoveProperties(InstanceActivity instanceActivity, IWINSActivity activity)\n\t    {\n\t\t    // We need to delete properties if this is not a human activity or WaitForNextStepAfterCompletion is not set\n\t\t    if (activity is AbstractHumanActivity && ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetWaitForNextStepAfterCompletion(instanceActivity.AccountId))\n\t\t    {\n\t\t\t\t_data.DeleteActivityPropertiesWithExclusion(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, new List<string> { nameof(AbstractHumanActivity.WaitForNextStep) });\n\t\t\t\t_log.InfoNoPII(\"Removing activity properties except WaitForNextStep\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    _data.DeleteActivityProperties(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid);\n\t\t\t    _log.InfoNoPII(\"Removing activity properties\");\n\t\t    }\n\t    }\n\n\t\tprivate string[] BuildNDCTags(InstanceActivity instanceActivity) => instanceActivity != null ? new[] { $\"ActivityId:{instanceActivity.Uid}\",$\"W:{instanceActivity.InstanceUid}\" } : new string[] { };\n\t    private string[] BuildNDCTags(Event e) => e != null ? new[] { $\"ActivityId:{e.ActivityUid}\", $\"W:{e.InstanceUid}\" } : new string[] { };\n\n\t\t/// <summary>\n\t\t/// Try to send an e-mail to support when a workflow instance activity execution account exceeds configured threshold.\n\t\t/// </summary>\n\t\t/// <param name=\"pausedPurgeDays\">Number of days to purge workflow related data</param>\n\t\t/// <returns>\n\t\t/// True\t-> Success.\n\t\t/// False\t-> Fail to send email.\n\t\t/// </returns>\n\t\tprivate bool TrySendActivityExecutionLimitExceedNotification(int pausedPurgeDays)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\t// Support should get the email\n\t\t\t\tvar supportEmailAddress = WorkflowSettingRepository.GetSupportNotificationEmailAddress(AccountId);\n\t\t\t\tif (!string.IsNullOrEmpty(supportEmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(supportEmailAddress);\n\t\t\t\t}\n\n\t\t\t\t// Also send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive activity execution limit exceeded notification\");\n\t\t\t\t\tnotificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, notificationUserUid);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Email support address setting is empty, and there is no AdvancedWorkflowNotificationUser configured. Thus, not sending activity execution limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Sending activity execution limit exceeded notification to {emailRecipients.Count} {(emailRecipients.Count > 1 ? \"recipients\" : \"recipient\")} for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseActivityExecutionLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowRevisionUid = _instance.RevisionUid,\n\t\t\t\t\tNumberOfActivitiesExecuted = ActivityExecutionCount,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetActivityDisplayName(IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n\t\t\treturn activity is AbstractHumanActivity abstractHumanActivity\n\t\t\t\t? abstractHumanActivity.ActivityDisplayName.Evaluate(ctx)\n\t\t\t\t: null;\n\t\t}\n\n\t\tprivate bool ShouldUseScopeEventHandler() => WorkflowFeatureFlags.UseScopeEventHandler &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t Model?.EngineVersion == Core.Workflow.Constants.EngineVersionV2;\n\n\t\tprivate void PauseInstance(UserAccount user, string comment, Action<UserAccount, string> pauseMethod)\n\t\t{\n\t\t\tRequires.NotNull(pauseMethod, nameof(pauseMethod));\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tpauseMethod(user, comment);\n\t\t\t\t_ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Pause(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowPaused);\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{\n\t\t\tvar environmentType = SiteConfig?.Value?.EnvironmentType;\n\t\t\tvar isGrpcEnabled = WorkflowClientConfig?.Value?.IsGrpcClientEnabled == true;\n\n\t\t\tvar isRunningOnCloudWithGrpcEnabled = environmentType == Core.Util.Config.EnvironmentType.Cloud && isGrpcEnabled;\n\n\t\t\tif (isRunningOnCloudWithGrpcEnabled && InstanceStateChangedHelper.IsInstanceStateChanged(_instance.Uid, ActivityExecutionCount, CacheRepository, WorkflowSettingRepository))\n\t\t\t{\n\t\t\t\t_ForceReload();\n\t\t\t\tInstanceStateChangedHelper.RemoveInstanceStateChanged(_instance.Uid, CacheRepository);\n\t\t\t}\n\t\t}\n    }\n}\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
      "content": "#if NET\n#nullable enable\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService\n{\n    private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore\n#endif\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
      "content": "#if NET\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Domain.Repository.Workflow.Mappers;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Workflow.Model;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing Google.Protobuf.WellKnownTypes;\nusing Google.Rpc;\n\nusing Grpc.Core;\n\nusing Microsoft.Extensions.Logging;\n\nusing OpenTelemetry.Trace;\n\nusing Definition = ADEXS.Core.Domain.Model.Workflow.Definition;\nusing Design = DocuSign.CLM.Workflow.Core.Persistence.Model.Design;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing StartParameters = ADEXS.Core.Domain.Model.Workflow.StartParameters;\nusing Status = Grpc.Core.Status;\nusing StatusCode = Grpc.Core.StatusCode;\nusing ValueExpressionOneOfCase = ADEXS.WINS.V1.VariableUpdate.ValueExpressionOneofCase;\nusing VariableUpdate = ADEXS.Core.Domain.Repository.Workflow.Types.VariableUpdate;\nusing Version = ADEXS.Core.Domain.Model.Workflow.Version;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService : WINS.V1.WinsService.WinsServiceBase\n{\n\tprivate static readonly Status StatusInvalidArgumentInstanceUid = new(StatusCode.InvalidArgument, \"InstanceUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentActivityUid = new(StatusCode.InvalidArgument, \"ActivityUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentVersionUid = new(StatusCode.InvalidArgument, \"VersionUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentRevisionUid = new(StatusCode.InvalidArgument, \"RevisionUid is malformed\");\n\n\tprivate readonly ILogger _logger;\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate readonly IUserAccountRepository _userAccountRepository;\n\n\tprivate readonly IWorkflowClient _workflowClient;\n\n\tprivate readonly IWorkflowV1GrpcMapper _workflowV1GrpcMapper;\n\n\tpublic WinsService(\n\t\tIWorkflowClient workflowClient,\n\t\tIUserAccountRepository userAccountRepository,\n\t\tIWorkflowV1GrpcMapper workflowV1GrpcMapper,\n\t\tIServiceInstrumentation serviceInstrumentation,\n\t\tILogger<WinsService> logger)\n\t{\n\t\t_workflowClient = workflowClient;\n\t\t_userAccountRepository = userAccountRepository;\n\t\t_workflowV1GrpcMapper = workflowV1GrpcMapper;\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t_logger = logger;\n\t}\n\n\tpublic override Task<CreateNewWorkflowDefinitionResponse> CreateNewWorkflowDefinition(\n\t\t[NotNull] CreateNewWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.CreateNewWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar definitionModel = _workflowClient.CreateNewWorkflowDefinition(userAccount, request.WorkflowName);\n\n\t\t\tvar definition = _workflowV1GrpcMapper.Map<Definition, WINS.V1.Definition>(definitionModel);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new CreateNewWorkflowDefinitionResponse {Definition = definition});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ExportWorkflowDefinitionResponse> ExportWorkflowDefinition(\n\t\t[NotNull] ExportWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ExportWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar definitionXml = _workflowClient.ExportWorkflowDefinition(userAccount, request.WorkflowName);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ExportWorkflowDefinitionResponse {DefinitionXml = definitionXml});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ImportWorkflowDefinitionResponse> ImportWorkflowDefinition(\n\t\t[NotNull] ImportWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ImportWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revisionModel = _workflowClient.ImportWorkflowDefinition(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.DefinitionXml,\n\t\t\t\trequest.OverwriteExistingWorkflow,\n\t\t\t\trequest.Comment,\n\t\t\t\trequest.TemplateId,\n\t\t\t\trequest.TemplateVersion);\n\n\t\t\tvar revision = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revisionModel);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ImportWorkflowDefinitionResponse {Revision = revision});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PublishWorkflowResponse> PublishWorkflow(\n\t\t[NotNull] PublishWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))\n\t\t{\n\t\t\tLogger.PublishWorkflowInvalidArgument(_logger, request.User.AccountId, ex: null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentVersionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PublishWorkflow(_logger, request.User.AccountId, request.VersionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowClient.PublishWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\tversionUid,\n\t\t\t\trequest.RevisionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar revisionResponse = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revision);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PublishWorkflowResponse {Revision = revisionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PublishWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PublishWorkflowByNameResponse> PublishWorkflowByName(\n\t\t[NotNull] PublishWorkflowByNameRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PublishWorkflowByName(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowClient.PublishWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.VersionNumber,\n\t\t\t\trequest.RevisionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar revisionResponse = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revision);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PublishWorkflowByNameResponse {Revision = revisionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<VersionWorkflowResponse> VersionWorkflow(\n\t\t[NotNull] VersionWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))\n\t\t{\n\t\t\tLogger.VersionWorkflowInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentVersionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.VersionWorkflow(_logger, request.User.AccountId, request.SourceVersionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowClient.VersionWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\tsourceVersionUid,\n\t\t\t\trequest.SourceRevisionNumber,\n\t\t\t\trequest.NewVersionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar versionResponse = _workflowV1GrpcMapper.Map<Version, WINS.V1.Version>(version);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new VersionWorkflowResponse {Version = versionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.VersionWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<VersionWorkflowByNameResponse> VersionWorkflowByName(\n\t\t[NotNull] VersionWorkflowByNameRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.VersionWorkflowByName(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowClient.VersionWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceVersionNumber,\n\t\t\t\trequest.SourceRevisionNumber,\n\t\t\t\trequest.NewVersionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar versionResponse = _workflowV1GrpcMapper.Map<Version, WINS.V1.Version>(version);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new VersionWorkflowByNameResponse {Version = versionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<KillWorkflowResponse> KillWorkflow(KillWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.KillWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.KillWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.KillWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new KillWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.KillWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.KillWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.KillWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PauseWorkflowResponse> PauseWorkflow(PauseWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.PauseWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PauseWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.PauseWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PauseWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PauseWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PauseWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PauseWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ResumeWorkflowResponse> ResumeWorkflow(\n\t\tResumeWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.ResumeWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.ResumeWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.ResumeWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ResumeWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ResumeWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ResumeWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ResumeWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ResumeFailedWorkflowResponse> ResumeFailedWorkflow(\n\t\tResumeFailedWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.ResumeFailedWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.ResumeFailedWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ResumeFailedWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SystemCallbackResponse> SystemCallback(\n\t\t[NotNull] SystemCallbackRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(request.CallbackName))\n\t\t{\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(StatusCode.InvalidArgument, $\"{nameof(request.CallbackName)} is null or empty\"));\n\t\t}\n\n\t\tLogger.SystemCallback(\n\t\t\t_logger,\n\t\t\trequest.AccountId,\n\t\t\trequest.InstanceUid,\n\t\t\trequest.ActivityUid,\n\t\t\trequest.CallbackName);\n\n\t\ttry\n\t\t{\n\t\t\t_workflowClient.SystemCallback(\n\t\t\t\trequest.AccountId,\n\t\t\t\tinstanceUid,\n\t\t\t\tactivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\trequest.CallbackData);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new SystemCallbackResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SystemCallbackInvalidArgument(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\targEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SystemCallbackFailed(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\tpublicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SystemCallbackFailed(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\tex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowResponse> StartWorkflow(StartWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.StartWorkflow(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.StartWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowFromSourceResponse> StartWorkflowFromSource(\n\t\tStartWorkflowFromSourceRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.StartWorkflowFromSource(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar newInstanceUid = _workflowClient.StartWorkflowFromSource(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam,\n\t\t\t\tinstanceUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.AddTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, newInstanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowFromSourceResponse {InstanceUid = newInstanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowWithParametersResponse> StartWorkflowWithParameters(\n\t\tStartWorkflowWithParametersRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\t\tValidateUser(request?.StartParameters?.Submitter);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tValidateAndParseUserUid(request.StartParameters!.Submitter.Uid, request.StartParameters.Submitter.AccountId, out var submitterUserAccountUid);\n\n\t\tLogger.StartWorkflowWithParameters(_logger, request.User.AccountId, request.InstanceUid, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar submitterUserAccount = LoadUserAccountSafe(request.StartParameters.Submitter.AccountId, submitterUserAccountUid);\n\n\t\t\tvar startParameters = new StartParameters(submitterUserAccount, null, null, null);\n\t\t\t_workflowV1GrpcMapper.Map(request.StartParameters, startParameters);\n\n\t\t\tvar newInstanceUid = _workflowClient.StartWorkflowWithParameters(\n\t\t\t\tuserAccount,\n\t\t\t\trevisionUid,\n\t\t\t\tstartParameters,\n\t\t\t\tinstanceUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.AddTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, newInstanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowWithParametersResponse {InstanceUid = newInstanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartRoutingApprovalWorkflowResponse> StartRoutingApprovalWorkflow(\n\t\tStartRoutingApprovalWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.StartRoutingApprovalWorkflow(_logger, request.User.AccountId, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.StartRoutingApprovalWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trevisionUid,\n\t\t\t\trequest.RoutingApprovalName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartRoutingApprovalWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SendStartWorkflowResponse> SendStartWorkflow(\n\t\tSendStartWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.SendStartWorkflow(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.SendStartWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t\treturn Task.FromResult(new SendStartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SendStartWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SendStartWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SendStartWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SubmitWorkItemResponse> SubmitWorkItem(\n\t\tSubmitWorkItemRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))\n\t\t{\n\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, ex: null);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"WorkItemUid is malformed\"));\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.SubmitWorkItem(_logger, request.User.AccountId, request.WorkItemUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables = new Dictionary<string, object>();\n\n\t\t\tforeach (var wireVariable in request.UpdatedVariables)\n\t\t\t{\n\t\t\t\tvar workflowVariableType =\n\t\t\t\t\t_workflowV1GrpcMapper.Map<WorkflowVariableType, Enums.WorkflowVariableType>(wireVariable.Type);\n\n\t\t\t\tif (!WorkflowConversion.TryParseVariableValue(\n\t\t\t\t\t    request.User.AccountId,\n\t\t\t\t\t    workflowVariableType,\n\t\t\t\t\t    wireVariable.Value.ToStringUtf8(),\n\t\t\t\t\t    out var outputValue))\n\t\t\t\t{\n\t\t\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, null);\n\t\t\t\t\tthrow new RpcException(\n\t\t\t\t\t\tnew Status(StatusCode.InvalidArgument, \"Unable to parse one of updated variables\"));\n\t\t\t\t}\n\n\t\t\t\tupdatedVariables[wireVariable.Name] = outputValue;\n\t\t\t}\n\n\t\t\t_workflowClient.SubmitWorkItem(\n\t\t\t\tuserAccount,\n\t\t\t\tworkItemUid,\n\t\t\t\trequest.Output,\n\t\t\t\trequest.Comments,\n\t\t\t\trequest.ActivityMessages,\n\t\t\t\tupdatedVariables);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new SubmitWorkItemResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SubmitWorkItemFailed(_logger, request.User.AccountId, request.WorkItemUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SubmitWorkItemFailed(_logger, request.User.AccountId, request.WorkItemUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<LoadDesignResponse> LoadDesign(LoadDesignRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.LoadDesign(_logger, request.User.AccountId, request.Version.Uid, request.Version.DefinitionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowV1GrpcMapper.Map<WINS.V1.Version, Version>(request.Version);\n\n\t\t\tvar design = _workflowClient.LoadDesign(userAccount, version);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(design);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new LoadDesignResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.LoadDesignInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.LoadDesignFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.LoadDesignFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<LoadDesignByRevisionResponse> LoadDesignByRevision(\n\t\tLoadDesignByRevisionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.LoadDesignByRevision(_logger, request.User.AccountId, request.Revision.Uid, request.Revision.VersionUid, request.Revision.DefinitionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowV1GrpcMapper.Map<WINS.V1.Revision, Revision>(request.Revision);\n\n\t\t\tvar design = _workflowClient.LoadDesign(userAccount, revision);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(design);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new LoadDesignByRevisionResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ConvertLegacyDefinitionResponse> ConvertLegacyDefinition(\n\t\tConvertLegacyDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ConvertLegacyDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar oldDesign = _workflowV1GrpcMapper.Map<WINS.V1.Design, Design>(request.OldDesign);\n\n\t\t\tvar newDesign = _workflowClient.ConvertLegacyDefinition(userAccount, oldDesign);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(newDesign);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ConvertLegacyDefinitionResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<CompileExpressionBuilderExpressionResponse> CompileExpressionBuilderExpression(\n\t\tCompileExpressionBuilderExpressionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (string.IsNullOrWhiteSpace(request.Code))\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"Code is null or empty\"));\n\t\t}\n\n\t\tLogger.CompileExpressionBuilderExpression(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar output = _workflowClient.CompileExpressionBuilderExpression(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.Code,\n\t\t\t\trequest.AdditionalCode,\n\t\t\t\trequest.ReturnType);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new CompileExpressionBuilderExpressionResponse {Output = output});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<UpdateVariablesResponse> UpdateVariables(\n\t\tUpdateVariablesRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceInstanceUid, out var sourceInstanceUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceActivityUid, out var sourceActivityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tLogger.UpdateVariables(_logger, request.User.AccountId, request.ActivityUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables =\n\t\t\t\t_workflowV1GrpcMapper\n\t\t\t\t\t.Map<List<ADEXS.WINS.V1.VariableUpdate>, List<VariableUpdate>>(\n\t\t\t\t\t\trequest.VariableUpdates.ToList());\n\n\t\t\tvar result = _workflowClient.UpdateVariables(\n\t\t\t\tuserAccount,\n\t\t\t\tactivityUid,\n\t\t\t\tupdatedVariables,\n\t\t\t\tsourceInstanceUid,\n\t\t\t\tsourceActivityUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new UpdateVariablesResponse {Result = result});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.UpdateVariablesFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<UpdateVariablesWithResultResponse> UpdateVariablesWithResult(\n\t\tUpdateVariablesWithResultRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceInstanceUid, out var sourceInstanceUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceActivityUid, out var sourceActivityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tLogger.UpdateVariablesWithResult(_logger, request.User.AccountId, request.ActivityUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables =\n\t\t\t\t_workflowV1GrpcMapper\n\t\t\t\t\t.Map<List<ADEXS.WINS.V1.VariableUpdate>, List<VariableUpdate>>(\n\t\t\t\t\t\trequest.VariableUpdates.ToList());\n\n\t\t\tvar result = _workflowClient.UpdateVariablesWithResult(\n\t\t\t\tuserAccount,\n\t\t\t\tactivityUid,\n\t\t\t\tupdatedVariables,\n\t\t\t\tsourceInstanceUid,\n\t\t\t\tsourceActivityUid);\n\n\t\t\tvar resultResponse = _workflowV1GrpcMapper\n\t\t\t\t.Map<WorkflowEnums.UpdateParentVariableResult, UpdateParentVariableResult>(result);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new UpdateVariablesWithResultResponse {Result = resultResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<IsActivityExecutionLimitReachedResponse> IsActivityExecutionLimitReached(\n\t\t[NotNull] IsActivityExecutionLimitReachedRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tLogger.IsActivityExecutionLimitReached(_logger, request.AccountId, request.InstanceUid, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar revisionCreatedDate = _workflowV1GrpcMapper.Map<Timestamp, DateTime>(request.RevisionCreatedDate);\n\n\t\t\tvar isLimitReached = _workflowClient.IsActivityExecutionLimitReached(\n\t\t\t\trequest!.AccountId,\n\t\t\t\tinstanceUid,\n\t\t\t\trevisionUid,\n\t\t\t\trevisionCreatedDate,\n\t\t\t\trequest.ActivityExecutionCount);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new IsActivityExecutionLimitReachedResponse {IsLimitReached = isLimitReached});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedFailed(_logger, request.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedFailed(_logger, request.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tprivate static RpcException HandleArgumentException(Activity? activity, ArgumentException argEx)\n\t{\n\t\tactivity?.AddException(argEx);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)StatusCode.InvalidArgument,\n\t\t\tMessage = string.Empty,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(argEx.ToRpcDebugInfo())\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static RpcException HandleUnknownException(Activity? activity, Exception ex)\n\t{\n\t\tactivity?.AddException(ex);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)StatusCode.Internal,\n\t\t\tMessage = string.Empty,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(ex.ToRpcDebugInfo())\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static RpcException HandlePublicException(Activity? activity, PublicException ex)\n\t{\n\t\tactivity?.AddException(ex);\n\t\tvar statusCode = GetStatusCodeFromFailReason(ex.Reason);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)statusCode,\n\t\t\tMessage = ex.Message,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(ex.ToRpcDebugInfo()),\n\t\t\t\tAny.Pack(new ErrorInfo\n\t\t\t\t{\n\t\t\t\t\tDomain = nameof(PublicException),\n\t\t\t\t\tReason = ex.Reason.ToString(),\n\t\t\t\t\tMetadata =\n\t\t\t\t\t{\n\t\t\t\t\t\t{ nameof(ex.Message), ex.Message },\n\t\t\t\t\t\t{ nameof(ex.InternalMessage), ex.InternalMessage }\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static StatusCode GetStatusCodeFromFailReason(PublicException.FailReason failReason)\n\t{\n\t\treturn failReason switch\n\t\t{\n\t\t\tPublicException.FailReason.NonexistentObject => StatusCode.NotFound,\n\t\t\tPublicException.FailReason.InvalidArgument => StatusCode.InvalidArgument,\n\t\t\tPublicException.FailReason.InvalidState => StatusCode.FailedPrecondition,\n\t\t\tPublicException.FailReason.InternalError => StatusCode.Internal,\n\t\t\tPublicException.FailReason.TemporarilyUnavailable => StatusCode.Unavailable,\n\t\t\tPublicException.FailReason.PermissionDenied => StatusCode.PermissionDenied,\n\t\t\tPublicException.FailReason.ObjectAlreadyExists => StatusCode.AlreadyExists,\n\t\t\t_ => StatusCode.Internal, // Default case\n\t\t};\n\t}\n\n\tprivate static void ValidateUser(UserAccount? user)\n\t{\n\t\tif (user == null)\n\t\t{\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"User is null\"));\n\t\t}\n\t}\n\n\tprivate void ValidateAndParseUserUid(string userUid, int accountId, out Guid userAccountUid)\n\t{\n\t\tif (!Guid.TryParse(userUid, out userAccountUid))\n\t\t{\n\t\t\tLogger.UserUidFormatError(_logger, userUid, accountId);\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(\n\t\t\t\t\tStatusCode.InvalidArgument,\n\t\t\t\t\t\"User.Uid is malformed\"));\n\t\t}\n\t}\n\n\tprivate void ValidateWorkflowName(string workflowName)\n\t{\n\t\tif (string.IsNullOrEmpty(workflowName))\n\t\t{\n\t\t\tLogger.WorkflowFormatError(_logger);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"WorkflowName is null or empty\"));\n\t\t}\n\t}\n\n\tprivate Core.Domain.Model.UserAccount? LoadUserAccountSafe(int accountId, Guid userAccountUid)\n\t{\n\t\tvar userAccount = _userAccountRepository.LoadByUid(accountId, userAccountUid);\n\n\t\tif (userAccount == null)\n\t\t{\n\t\t\tLogger.UserAccountNotFound(_logger, userAccountUid, accountId);\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(\n\t\t\t\t\tStatusCode.NotFound,\n\t\t\t\t\t$\"User {userAccountUid} not found in account {accountId}\"));\n\t\t}\n\n\t\treturn userAccount;\n\t}\n}\n\n#nullable restore\n#endif\n",
      "relevance_score": 100
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/ICoreInstrumentationLifetimeService.cs",
      "content": "\ufeff#nullable enable\n\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing OpenTelemetry.Metrics;\n\nusing OpenTelemetry.Trace;\n\nnamespace ADEXS.Core.ServiceFramework;\n\npublic interface ICoreInstrumentationLifetimeService\n{\n\tTask StartAsync(\n\t\tAssembly? assembly = null,\n\t\tAction<TracerProviderBuilder>? configureTracer = null,\n\t\tAction<MeterProviderBuilder>? configureMeter = null,\n\t\tCancellationToken cancellationToken = default);\n\n\tTask StopAsync(CancellationToken cancellationToken = default);\n}\n#nullable restore\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.MQ;\nusing ADEXS.Core.Domain;\nusing System.Threading;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing System.IO;\nusing ADEXS.Core.Domain.Model;\nusing System.Diagnostics;\n\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.ServiceFramework;\nusing CLM.MessageDefines;\nusing CLM.MessageDefines.Constants;\nusing CLM.MessageDefines.Interfaces;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\n\nusing StructureMap;\nusing ADEXS.MqWorkers.Config.Context;\nusing ADEXS.MqWorkers.Extensions;\nusing ADEXS.MqWorkers.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.MqWorkers.Config;\n\nnamespace ADEXS.Services.MessageWorkerService\n{\n\t//Should probably make an interface that encapsulates the methods for loading and\n\t//updating the Tasks so that we don't have to be tied to MessageQueues for this type of worker\n\tpublic class DispatchedWorker<T, U> : AbstractServiceQueue<T> where T : class, IQueueTask, new() where U : class, ITaskProcessor<T>, new()\n\t{\n\t\tprivate const string DESIRED_WORKER_COUNT = \"_WorkerCount\";\n\t\tprivate const string DESIRED_WORKER_MULTIPLIER = \"_WorkerMultiplier\";\n\t\tprivate const string TASK_DISPATCHERS = \"_TaskDispatchers\";\n\t\tprivate const string DESIRED_STAND_ALONE = \"_StandAlone\";\n\t\tprivate const string DEFAULT_TASK_DISPATCHERS = \"DefaultTaskDispatchers\";\n\t\tprivate const int DEFAULT_WORKER_COUNT = 5;\n\t\tprivate const double DEAFULT_CORE_TO_WORKER_MULTIPLIER = 0;\n\t\tprivate readonly string TASKPROCESSOR = Configuration.GetStringAppSetting(PROCESSSTART_NAME, \"ADEXS.TaskProcessor.exe\");\n\t\tprivate const string PROCESSSTART_NAME = \"PROCESSSTART_NAME\";\n\t\tprivate string _typeName;\n\t\tprivate readonly TaskTypes _taskType;\n\t\tprivate bool _standAlone;\n\n\t\tprivate readonly IContainer _container;         // optionally injected DI container\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate readonly Func<U> _createProcessor;\n\t\tprivate int _fetchMod;\n\n\t\t[ThreadStatic]\n\t\tprivate static int _errorCount = 0;\n\n\t\tpublic override string Name => base.Name + TypeName;\n\n\t\t[EventSource(\"Workers\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly PropertyBagEventSource _workersEventSource = new PropertyBagEventSource();\n\n\t\t[Counter(\"Workers Count\", \"CLM.DispatchedWorker\", MeasureProperty = \"Count\", InstanceProperty = \"Description\")]\n\t\t[EventSource(\"Workers Count\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly CountEventSource _workersCountEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\")]\n\t\t[Counter(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\", InstanceProperty = \"Description\")]\n\t\tprivate static ExceptionEventSource _workerLoggingExceptionEventSource = new ExceptionEventSource();\n\n\t\tstatic DispatchedWorker()\n\t\t{\n\t\t\t// Kazmon emits from a generic type do not work without this call\n\t\t\tMonitoringRuntime.RegisterGenericType(typeof(DispatchedWorker<T, U>));\n\t\t}\n\n\t\tpublic string TypeName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\t_typeName ??= _taskType.ToString();\n\t\t\t\treturn _typeName;\n\t\t\t}\n\t\t}\n\n\t\tpublic IMessageQueueWrapperFactory MessageQueueWrapperFactory { get; set; }\n\n\t\t/// <summary>\n\t\t/// Legacy Constructor -- delegates to the new overload; passes DI container extracted from ServiceLocator.\n\t\t/// This method will be deprecated in the future -- prefer the (IServicedComponent, IContainer) overload.\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this dispatched worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\tpublic DispatchedWorker(IServicedComponent component, TaskTypes taskType, IWatchedSingletonConfig<ISiteConfig> siteConfig) : this(component, taskType, ServiceLocator.Container, Activator.CreateInstance<U>, siteConfig)\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor overload that accepts a DI container (stepping stone to moving away from SL pattern).\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\t/// <param name=\"container\">the DI container for service discovery and IOC</param>\n\t\tinternal DispatchedWorker(IServicedComponent component, TaskTypes taskType, IContainer container, Func<U> processorFactory, IWatchedSingletonConfig<ISiteConfig> siteConfig) : base(component)\n\t\t{\n\t\t\t_container = container;\n\t\t\t_createProcessor = processorFactory ?? (() => new U());\n\t\t\tServiceLocator.BuildUp(this);\n\t\t\t_taskType = taskType;\n\t\t\t//This is here to prevent a regression following ATL-81324\n\t\t\tif (TypeName != typeof(T).Name)\n\t\t\t\tthrow new ArgumentException($\"Failed to initialize DispatchedWorker: Task Name ({typeof(T).Name}) must match task type ({TypeName})\");\n\t\t\t_waitOnNoItems = false;\n\t\t\t_standAlone = Configuration.GetBooleanAppSetting(TypeName + DESIRED_STAND_ALONE, false);\n\t\t\tif (_standAlone) _log.DebugNoPII($\"Worker running in StandAlone mode for {TypeName}\");\n\t\t\t_siteConfig = siteConfig;\n\t\t}\n\n\t\tprivate ProcessTaskResult RunExternalTaskProcessor(ProcessTaskRequest taskRequest)\n\t\t{\n\t\t\tvar accountId = taskRequest.Task.AccountId;\n\t\t\tbool useAnonymousPipes = TasksManagementFeatureFlags.UseAnonymousPipeForExternalTaskProcessors &&\n\t\t\t                         Configuration.GetBooleanAppSetting(\n\t\t\t\t                         $\"{accountId}_UseAnonymousPipeForExternalTaskProcessors\", true);\n\t\t\t_log.InfoNoPII(useAnonymousPipes\n\t\t\t\t? \"Worker using Anonymous Pipes for Request and Results\"\n\t\t\t\t: \"Worker using Temp Files for Request and Results\");\n\t\t\tExternalTaskWorker externalTaskWorker = ExternalTaskWorkerFactory.GetExternalTaskWorker(useAnonymousPipes);\n\t\t\treturn externalTaskWorker.RunExternalProcessor(taskRequest,TASKPROCESSOR);\n\t\t}\n\n\t\tprotected override int MaxQueueDepth()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_WorkerMaxQueueDepth\", Configuration.GetInt32AppSetting(TypeName + WORKER_MAXSET, WORKER_MAXSET_DEFAULT)) * DesiredWorkerCount();\n\t\t}\n\n\t\tprotected override IList<T> Fetch(int fetchCount)\n\t\t{\n\t\t\tList<T> tasks = new List<T>();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPeriodicPulse();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not pulse for ''{TypeName}''.\", ex);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttasks = FetchFromQueues(fetchCount);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not load the items for the queue: {TypeName}\", ex);\n\t\t\t\t_lastFetchDate = DateTime.UtcNow;\n\t\t\t}\n\n\t\t\tAttemptRestorePropertiesFromPayload(tasks);\n\n\t\t\treturn tasks;\n\t\t}\n\n\t\tprivate List<T> FetchFromQueues(int fetchCount)\n\t\t{\n\t\t\tvar queuePaths = DefaultQueue.GetWorkerMqPaths(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\n\t\t\t// keep incrementing to pull from a different queue on each fetch, fetching from all queues seems to have an adverse effect on the channels\n\t\t\t_fetchMod %= queuePaths.Length;\n\t\t\tvar queuePath = queuePaths[_fetchMod];\n\t\t\t_fetchMod++;\n\n\t\t\treturn FetchSingleQueue(fetchCount, queuePath);\n\t\t}\n\n\t\tprivate List<T> FetchSingleQueue(int fetchCount, string path)\n\t\t{\n\t\t\tbool isMainPath = path == DefaultQueue.GetWorkerMqPath(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\t\t\tint waitTime = isMainPath ? TaskUtilities.InitialReceiveWaitMS(TypeName) : Configuration.GetInt32AppSetting(\"InitialReceiveWaitAdditionalQueueMS\", 20);\n\t\t\tusing (IMessageQueueWrapper pdfMQ = MessageQueueWrapperFactory.CreateReceiveInstance(Configuration.GetStringAppSetting(TypeName + \"_WorkerMQPath\", path)))\n\t\t\t{\n\t\t\t\treturn pdfMQ.ReceiveMultiple<T>(waitTime, MQApplicationSettings.DefaultExtraReceiveWaitMS, fetchCount);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Restore the task type properties from the payload. This will only live temporarily as we move\n\t\t/// all tasks toward using the CommonTask payload. If we fail to restore from properties we should log to kazmon\n\t\t/// but we should not not block tasks from getting processed. We are also logging when we find a task\n\t\t/// without a payload set.\n\t\t/// </summary>\n\t\tprivate void AttemptRestorePropertiesFromPayload(List<T> tasks)\n\t\t{\n\t\t\t// App Setting to disable this behavior just in case of issues\n\t\t\tvar restoreFromPayload = Configuration.GetBooleanAppSetting($\"RestoreTaskFromPayload_All\", true) &&\n\t\t\t\tConfiguration.GetBooleanAppSetting($\"RestoreTaskFromPayload_{TypeName}\", true);\n\n\t\t\tforeach (var task in tasks)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (task is CommonTask cTask)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string.IsNullOrEmpty(cTask.Payload))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Log to kazmon to ensure that we don't miss any tasks\n\t\t\t\t\t\t\tCommonTaskPayloadHelper.CommonTaskPayloadMissingEventSource.Emit(1, cTask.Label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (restoreFromPayload)\n\t\t\t\t\t\t\t\tcTask.RestorePropertiesFromPayload();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tCommonTaskPayloadHelper.PayloadRestoreExceptionEventSource.Emit(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate QueueItemType _lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\tpublic override void AdjustWorkers()\n\t\t{\n\t\t\tbase.AdjustWorkers();\n\n\t\t\tint desiredWorkerCount = DesiredWorkerCount(out double multiplier);\n\t\t\tSetEnabled(desiredWorkerCount > 0);\n\t\t\tQueueItemType currentQueueStatus = (desiredWorkerCount > 0) ? QueueItemType.QueueStarted : QueueItemType.QueueStopped;\n\t\t\tif (currentQueueStatus == _lastSentQueueStatus) return;\n\n\t\t\tEmitWorkerConfiguration(currentQueueStatus, desiredWorkerCount, multiplier);\n\t\t\tstring adminQueuePath = \"Unset\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tT startTask = new T\n\t\t\t\t{\n\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\tQueueItemType = currentQueueStatus,\n\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t};\n\n\t\t\t\tif (!_standAlone)\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueuePath = GetAdminQueuePath(machine);\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(adminQueuePath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(startTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = currentQueueStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:AdjustWorkers - Could not contact the administration queue: \" + adminQueuePath, ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitWorkerConfiguration(QueueItemType queueItemtype, int desiredWorkerCount, double multiplier)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_workersCountEventSource.Emit(desiredWorkerCount, TypeName);\n\n\t\t\t\tusing (var propertyBag = _workersEventSource.CreateEventPropertyBag(queueItemtype.ToString()))\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TaskType\", TypeName);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"DesiredWorkerCount\", desiredWorkerCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"Multiplier\", multiplier.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ProcessorCount\", Environment.ProcessorCount.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_workerLoggingExceptionEventSource.Emit(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetMachineName() => System.Net.Dns.GetHostName();\n\t\tprivate string GetTaskTypeName() => typeof(T).FullName;\n\n\t\tprivate static int _queueStateTouchIntervalMin = 60;\n\t\tprivate DateTime _nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\n\t\tprotected virtual void PeriodicPulse()\n\t\t{\n\t\t\tif (_nextStateTouchTime < DateTime.UtcNow)\n\t\t\t{\n\t\t\t\tQueueStatePersistence.AuthenticationInstance.Touch(GetMachineName(), GetTaskTypeName());\n\t\t\t\t_nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Blast the local queue back to the dispatcher so that it can be\n\t\t/// dispatched to another worker.\n\t\t///\n\t\t/// Also sends a disable me message\n\t\t/// </summary>\n\t\tpublic override void Stop()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//Try to do a prelim kill before the stop of the workers\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch\n\t\t\t{\n\t\t\t\t_log.DebugNoPII(\"Didn't kill processes first time\");\n\t\t\t}\n\n\t\t\tbase.Stop();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSetEnabled(false);\n\t\t\t\tif (!_standAlone && (_lastSentQueueStatus != QueueItemType.QueueStopped))\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tT stopTask = new T\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\t\t\tQueueItemType = QueueItemType.QueueStopped,\n\t\t\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(machine)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(stopTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\t\t\t}\n\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:Stop - Exception generated during stop:\", ex);\n\t\t\t}\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStopped, 0, 0);\n\t\t}\n\n\t\tprivate void KillTaskProcessors()\n\t\t{\n\t\t\tvar nestedContainer = CreateNestedContainer(null);\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);  // necessary to determine if processor would run out-of-process\n\t\t\t// attempt to kill any active out-of-process processors\n\t\t\tif (processor.RunInSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t\t\tstring processName = Path.GetFileNameWithoutExtension(TASKPROCESSOR);\n\t\t\t\tProcess[] tokill = System.Diagnostics.Process.GetProcessesByName(processName);\n\t\t\t\tif (tokill.Length > 0)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"Killing {processName} processes.\");\n\t\t\t\t\tforeach (Process p in tokill)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Failed to kill process with pid: {p.Id}\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void SetEnabled(bool enable)\n\t\t{\n\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\t\t\tbool alreadySet = false;\n\t\t\tstring taskTypeName = GetTaskTypeName();\n\t\t\t_log.DebugNoPII($\"Task type: {taskTypeName}, enable set to {enable}\");\n\n\t\t\tforeach (QueueState state in QueueStatePersistence.AuthenticationInstance.LoadAll())\n\t\t\t{\n\t\t\t\tif (state.MachineName.Equals(GetMachineName(), StringComparison.InvariantCultureIgnoreCase)\n\t\t\t\t\t&& state.TaskTypeName == taskTypeName)\n\t\t\t\t{\n\t\t\t\t\tif (enable)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine already exists for task type {taskTypeName}, attempting to enable it\");\n\t\t\t\t\t\tRegisterQueueState(state);\n\t\t\t\t\t\talreadySet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine exists for task type {taskTypeName}, attempting to disable it\");\n\t\t\t\t\t\tstate.Enabled = false;\n\t\t\t\t\t\tQueueStatePersistence.AuthenticationInstance.Save(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (enable && !alreadySet)\n\t\t\t{\n\t\t\t\t// must be a new entry in the queuestate table\n\t\t\t\t_log.DebugNoPII($\"Machine does not already exist for task type {taskTypeName}, attempting to create it\");\n\t\t\t\tRegisterQueueState(null);\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// This will either create the queuestate or update\n\t\t/// it as enabled.\n\t\t/// </summary>\n\t\tprivate void RegisterQueueState(QueueState queueState)\n\t\t{\n\t\t\tif (queueState == null)\n\t\t\t{\n\t\t\t\tqueueState = new QueueState();\n\t\t\t\tType taskType = typeof(T);\n\t\t\t\tqueueState.MachineName = GetMachineName();\n\t\t\t\tqueueState.TaskAssemblyName = taskType.Assembly.GetName().Name;\n\t\t\t\tqueueState.TaskTypeName = GetTaskTypeName();\n\t\t\t\t_log.DebugNoPII($\"Creating new entry in QueueState for tasktype: {queueState.TaskTypeName}\");\n\t\t\t}\n\n\t\t\tqueueState.Enabled = true;\n\t\t\tqueueState.WorkerCount = DesiredWorkerCount(out double multiplier);\n\n\t\t\t_log.DebugNoPII($\"Saving QueueState for task type: {queueState.TaskTypeName} with properties - machine name: {queueState.MachineName},\" +\n\t\t\t\t$\"assembly name: {queueState.TaskAssemblyName} enabled: {queueState.Enabled}, worker count: {queueState.WorkerCount}\");\n\n\t\t\tQueueStatePersistence.AuthenticationInstance.Save(queueState);\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStarted, queueState.WorkerCount, multiplier);\n\t\t}\n\n\t\tprotected override TaskResult Process(T task, out string message)\n\t\t{\n\t\t\tmessage = null;\n\n\t\t\tAtlasContext.Current.AccountId = task.AccountId;\n\t\t\tAtlasContext.Current.TransactionId = task.CorrelationId;\n\t\t\tif (task is IUserTask usrTask)\n\t\t\t{\n\t\t\t\tAtlasContext.Current.UserAccountUid = usrTask.UserAccountUid;\n\t\t\t}\n\n\t\t\tGuid corrToken;\n\t\t\tGuid.TryParse(task.CorrelationId, out corrToken);\n\n\t\t\tusing var activity = StartActivity(task, corrToken);\n\n\t\t\tstring telemetryLabel = task.Label;\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\tusing (var logger = new TaskServiceRequestEventLogger(corrToken, telemetryLabel))\n\t\t\t{\n\t\t\t\t// introduces request-scoped container for user context state (and any other future per-request DI state)\n\t\t\t\tusing var nestedContainer = CreateNestedContainer(AtlasContext.Current);\n\n\t\t\t\t// The DataPoint enum is defined in DocuSign sources. Trying to use some, hopefully with close enough semantics.\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, task.AccountId);\n\t\t\t\tServiceContext.Log(DataPoint.QueueItemId, task.UniqueId);\n\t\t\t\tServiceContext.Log(DataPoint.TimeQueued, $\"{task.CreatedDate:yyyy-MM-dd HH:mm:ss.fff}\");\n\t\t\t\tif (Guid.Empty != AtlasContext.Current.UserAccountUid)\n\t\t\t\t{\n\t\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The nugget inside the monitoring wrapper.\n\t\t\t\t\tTaskResult taskResult = ProcessTask(task, nestedContainer, out message, activity);\n\n\t\t\t\t\tServiceContext.Log(DataPoint.ApiStatus, $\"{taskResult}\");\n\t\t\t\t\tlogger.Success = (taskResult != TaskResult.Failure);\n\t\t\t\t\tactivity?.SetStatusFromTask(taskResult);\n\t\t\t\t\treturn taskResult;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tex.Trace().Report();\n\t\t\t\t\tthrow;\n \t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (!logger.Success && null != message)\n\t\t\t\t\t{\n\t\t\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate TaskResult ProcessTask(T task, IContainer nestedContainer, out string message, Activity activity)\n\t\t{\n\t\t\tProcessTaskResult result = new ProcessTaskResult() { Message = \"Context Set\" };\n\n\t\t\tif (TaskUtilities.CheckSuspendedTaskTypeForAccount(TypeName, task.AccountId))\n\t\t\t{\n\t\t\t\tmessage = $\"task failed because Aid {task.AccountId} is in the suspended account list for {TypeName}\";\n\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\ttask.ErrorCount = int.MaxValue;\n\t\t\t\treturn TaskResult.Failure;\n\t\t\t}\n\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);\n\n\t\t\tAtlasContext.Current.ActionType = processor.ActionType;\n\n\t\t\tif (processor.RunInSeparateProcess && !processor.HandleSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t \t\tProcessTaskRequest taskRequest = new ProcessTaskRequest()\n\t\t\t\t{\n\t\t\t\t\tAccountId = AtlasContext.Current.AccountId,\n\t\t\t\t\tUserAccountUid = AtlasContext.Current.UserAccountUid,\n\t\t\t\t\tActionType = AtlasContext.Current.ActionType,\n\t\t\t\t\tProcessorTypeName = processor.GetType().AssemblyQualifiedName,\n\t\t\t\t\tTask = task,\n\t\t\t\t\tTaskType = _taskType,\n\t\t\t\t\tCorrelationToken = MonitoringContext.CorrelationToken ?? Guid.Empty\n\t\t\t\t};\n\t\t\t\tresult = RunExternalTaskProcessor(taskRequest);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprocessor.Task = task;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tprocessor.PreProcess();\n\t\t\t\t\tresult = processor.ProcessTask();\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tprocessor.PostProcess();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = result.Message;\n\n\t\t\tactivity?.SetQueueTaskResultTags(task, new MqWorkers.DispatchedWorker.ProcessTaskResult { Message = message });\n\n\t\t\treturn result.TaskResult;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an instance of the ITaskProcessor that should be used when processing a request.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This method takes into account whether we are using a scoped DI container, and if so, will\n\t\t/// attempt to get the task processor from there to ensure that other scoped DI services (eg user context)\n\t\t/// are also correctly set up. If the supplied `container` parameter is null we create a non-scoped\n\t\t/// processor instance, otherwise we demand it from the container (which may throw if none is registered).\n\t\t/// </remarks>\n\t\t/// <param name=\"container\">Optional (nullable) DI container from which we acquire scoped processors</param>\n\t\t/// <returns>An instance of ITaskProcessor{T} that can process the task.</returns>\n\t\tprivate U CreateTaskProcessor(IContainer container)\n\t\t{\n\t\t\t// NOTE: If we have a nested DI container, defer to it for the ITaskProcessor instance.\n\t\t\t//       If there is no nested container, or it doesn't have a ITaskProcessor registered,\n\t\t\t//       instantiate one one locally.\n\t\t\treturn container?.GetInstance<U>() ?? _createProcessor.Invoke();\n\t\t}\n\n\t\tprotected override void UpdateFailure(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//this will requeue it if needed\n\t\t\t\ttask.QueueItemType = QueueItemType.Ack;\n\t\t\t}, () =>\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Again errors should pause the movement of the items.\n\t\t\t\t * For this worker.\n\t\t\t\t */\n\t\t\t\tif (_errorCount++ % Configuration.GetInt32AppSetting(\"ErrorCountSleepMod\", 100) == 0)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(SleepMilliSeconds());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateUnlock(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//task will requeue it\n\t\t\t\ttask.QueueItemType = QueueItemType.Task;\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateSuccess(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.QueueItemType = QueueItemType.Completed;\n\t\t\t});\n\t\t}\n\n\t\tprivate void SendTaskStatusUpdate(T task, Action beforeSend, Action afterSend = null)\n\t\t{\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\t{\n\t\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\n\t\t\t\tbeforeSend();\n\n\t\t\t\tstring sendMachine = task.SendMachine; // Send() changes the SendMachine property, so store it here in case we need to restore it after an exception.\n\n\t\t\t\tusing (IMessageQueueWrapper adminQueue = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(task.SendMachine)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueue.Send(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Detected IOException.  Will retry once.\", ioe);\n\n\t\t\t\t\t\tadminQueue.ReSend(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Restore original SendMachine, for the sake of the UpdateFailure() call from AbstractServiceQueue.\n\t\t\t\t\t\ttask.SendMachine = sendMachine;\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (afterSend != null)\n\t\t\t\t{\n\t\t\t\t\tafterSend();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Crate a nested DI container for the user context (and potentially other request-scoped DI state).\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// Introduced as part of ATL-72998 to add support for feature flag integration, which requires access to\n\t\t/// the request-scoped Account/User identity for flag resolution decisions.\n\t\t/// </remarks>\n\t\t/// <param name=\"atlasContext\">Atlas request context for this request/task</param>\n\t\t/// <returns>Disposable DI container for this request-scoped state</returns>\n\t\tprivate IContainer CreateNestedContainer(IAtlasContext atlasContext)\n\t\t{\n\t\t\tvar nestedContainer = _container.GetNestedContainer();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (atlasContext != null)\n\t\t\t\t{\n\t\t\t\t\tvar userContextSetter = nestedContainer.TryGetInstance<IUserContextSetter>();\n\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tuserContextSetter.AccountId = atlasContext.AccountId;\n\t\t\t\t\t\tuserContextSetter.UserId = atlasContext.UserAccountUid; // this may be null, but that's ok\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Should we have a specific OT telemetry event for this condition? It's most like incorrectly configured DI setup, but may not be a defect.\n\t\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire IUserContextSetter - transactionId {atlasContext.TransactionId} will proceed without scoped user context.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar taskContextSetter = nestedContainer.TryGetInstance<ITaskTypeContextSetter>();\n\n\t\t\t\tif (taskContextSetter != null)\n\t\t\t\t{\n\t\t\t\t\ttaskContextSetter.TaskType = _taskType;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire ITaskTypeContextSetter - {TypeName} will proceed without scoped task type context.\");\n\t\t\t\t}\n\n\t\t\t\treturn nestedContainer;\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\tnestedContainer?.Dispose();  // avoid leaking nested container\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic virtual int StandardSleepSeconds => 5;\n\t\tprotected override int SleepSeconds()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_SleepSeconds\", StandardSleepSeconds);\n\t\t}\n\n\t\tpublic virtual int StandardWorkerCount => DEFAULT_WORKER_COUNT;\n\n\t\tpublic override int DesiredWorkerCount()\n\t\t{\n\t\t\treturn DesiredWorkerCount(out _);\n\t\t}\n\n\t\tprivate int DesiredWorkerCount(out double multiplier)\n\t\t{\n\t\t\tmultiplier = 0;\n\t\t\tint count = -1;\n\t\t\tif (IsOneConfigEnabledForWorkerCount())\n\t\t\t{\n\t\t\t\tvar mqTasksconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IMqTasksConfig>>()?.Value;\n\t\t\t\tvar taskConfigs = mqTasksconfigs?.TaskConfigs;\n\t\t\t\tif (taskConfigs != null && taskConfigs.TryGetValue(TypeName, out var taskConfig))\n\t\t\t\t{\n\t\t\t\t\tcount = taskConfig.WorkerCount;\n\t\t\t\t\tmultiplier = taskConfig.WorkerMultiplier;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Failed to retrieve task configuration from INI file for TaskName: {TypeName}. Falling back to legacy processing.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count < 0)\n\t\t\t{\n\t\t\t\t// Rely on appsetting if oneConfig is disabled or if it cannot retrive from oneconfig\n\t\t\t\tcount = Configuration.GetInt32AppSetting(TypeName + DESIRED_WORKER_COUNT, StandardWorkerCount);\n\t\t\t\tmultiplier = Configuration.GetDoubleAppSetting(TypeName + DESIRED_WORKER_MULTIPLIER, DEAFULT_CORE_TO_WORKER_MULTIPLIER);\n\t\t\t}\n\n\t\t\t// we still want to be able to force the count to zero in order to turn off a worker group effectively\n\t\t\t// let's check the worker count based on the number of logical cores and a configured multiplier\n\t\t\tif (count != 0 && multiplier > 0)\n\t\t\t{\n\t\t\t\t// use the number of logical cores and a multiplier to determine a good worker count number.\n\t\t\t\tint numCores = Environment.ProcessorCount;\n\t\t\t\tcount = Math.Max((int)(numCores * multiplier), 1);  // we really never want a > 0 multiplier to cause a zero worker count\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tprivate bool IsOneConfigEnabledForWorkerCount()\n\t\t{\n\t\t\tbool isOneConfigEnabled = false;\n\t\t\tif(ConfigWrapper.UseOneConfigMqTasksConfig)\n\t\t\t{\n\t\t\t\tvar appconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOneConfigMqTasks_\" + appconfigs?.AppName, true))\n\t\t\t\t{\n\t\t\t\t\tisOneConfigEnabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isOneConfigEnabled;\n\t\t}\n\n\t\tprivate IEnumerable<string> DispatcherMachines()\n\t\t{\n\t\t\treturn StringUtil.Split('|', Configuration.GetStringAppSetting(TypeName + TASK_DISPATCHERS, Configuration.GetStringAppSetting(DEFAULT_TASK_DISPATCHERS, GetMachineName())));\n\t\t}\n\n\t\tprivate string GetAdminQueuePath(string machine)\n\t\t{\n\t\t\treturn string.Format(Configuration.GetStringAppSetting(TypeName + \"_EventMQPathFormat\", DefaultQueue.GetAdminMqPathFormat(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName))), machine ?? GetMachineName());\n\t\t}\n\n\t\tprivate Activity StartActivity(T task, Guid correlationToken) =>\n\t\t\tServiceInstrumentation.ActivitySource\n\t\t\t\t?.StartActivity(\n\t\t\t\t\ttask.Label ?? $\"{nameof(ADEXS.Services.MessageWorkerService)}\",\n\t\t\t\t\tActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}\n",
      "relevance_score": 0.85
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
      "content": "\ufeffusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Model;\nusing ADEXS.Atlas.Workflow.Readers.DefinitionConverter;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Conversions;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.WINS.Interfaces;\nusing SCMAppenders;\nusing Version = ADEXS.Core.Domain.Model.Workflow.Version;\nusing ADEXS.Core.Domain.Repository.Workflow.Types;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Model;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.Core.Workflow.Infrastructure.Telemetry;\nusing CLM.MessageDefines.Constants;\nusing Monitoring = DocuSign.Monitoring;\nusing Polly;\nusing IExpressionServiceClient = ADEXS.Core.Workflow.Expressions.Interfaces.IExpressionServiceClient;\nusing CoreDomainWorkflowRepository = ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing Definition = ADEXS.Core.Domain.Model.Workflow.Definition;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing Design = DocuSign.CLM.Workflow.Core.Persistence.Model.Design;\nusing IGovernor = ADEXS.WINS.Engine.Throttling.IGovernor;\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\nusing ADEXS.Core.Domain.FeatureFlags.Remoting;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Domain.Repository.ProvisioningRepository;\nusing ADEXS.Core.Domain.ExpressionService;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Workflow.Infrastructure.FeatureFlags;\nusing ADEXS.Core.Workflow.Config;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\n\nusing CallbackEventBehavior = DocuSign.CLM.Workflow.Core.Contracts.Model.WorkflowEnums.CallbackEventBehavior;\n\nusing Platform.Common;\n\nnamespace ADEXS.WINS.Engine\n{\n\tpublic class WINSManager : AbstractRemotable, IWorkflowClient\n\t{\n\t\tpublic const int LockMaxRetry = 20;\n\t\tpublic const int LockMsWaitBetweenRetry = 1000;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WINSManager));\n\n\t\tprivate readonly IGovernor _governor;\n\n\t\tprivate readonly IWorkflowSettingRepository _workflowSettingRepository;\n\n\t\tprivate readonly IInstanceVariableGovernance _instanceVariableGovernance;\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\n\t\tprivate IGovernor Governor => _governor;\n\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository;\n\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => _instanceVariableGovernance;\n\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig = (_workflowConfig ?? ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\n\t\tprivate readonly ICacheRepository _cacheRepository;\n\n\t\tpublic WINSManager()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IGovernor>(),\n\t\t\t\tServiceLocator.GetInstance<IWorkflowSettingRepository>(),\n\t\t\t\tServiceLocator.GetInstance<IInstanceVariableGovernance>(),\n\t\t\t\tServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>(),\n\t\t\t\tServiceLocator.GetInstance<ICacheRepository>())\n\t\t{\n\t\t}\n\n\t\tpublic WINSManager(\n\t\t\tIGovernor governor,\n\t\t\tIWorkflowSettingRepository workflowSettingRepository,\n\t\t\tIInstanceVariableGovernance instanceVariableGovernance,\n\t\t\tIWatchedSingletonConfig<ISiteConfig> siteConfig,\n\t\t\tICacheRepository cacheRepository)\n\t\t{\n\t\t\t_governor = governor;\n\t\t\t_workflowSettingRepository = workflowSettingRepository;\n\t\t\t_instanceVariableGovernance = instanceVariableGovernance;\n\t\t\t_siteConfig = siteConfig;\n\t\t\t_cacheRepository = cacheRepository;\n\t\t}\n\n\t\tpublic override string RemoteServiceURL =>\n\t\t\tApplicationSettings.WorkflowIsBulk\n\t\t\t\t? ApplicationSettings.WinsSlowServiceURL\n\t\t\t\t: ApplicationSettings.WinsServiceURL;\n\n\t\t#region Code shared with ADEXS.Core.Domain.Repository.Workflow.Client.RemoteWINSClient\n\n\t\tpublic Definition CreateNewWorkflowDefinition(UserAccount user, string workflowName)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar result = WINSClientLibrary.CreateNewWorkflowDefinition(user, workflowName);\n\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorWithPII($\"Error creating new workflow definition for workflowName {{0}}\", e, workflowName);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void KillWorkflow(UserAccount user, Guid instanceUid, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid);\n\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid);\n\t\t\t\t\t\t\tcontrol.Abort(user, comment);\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error killing instance\"), e);\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic IWorkItem LoadWorkItem(UserAccount user, Guid workItemUid)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.LoadWorkItem(user, workItemUid);\n\t\t\t\t\tif (result != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, result.InstanceUid);\n\t\t\t\t\t}\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error loading workItemUid {0}\", workItemUid), e);\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void PauseWorkflow(UserAccount user, Guid instanceUid, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid);\n\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid);\n\t\t\t\t\t\t\tcontrol.Pause(user, comment);\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error pausing instance\"), e);\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void ResumeFailedWorkflow(UserAccount user, Guid instanceUid, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tif (WorkflowManager.Instance.IsInstanceRevisionExecutionSuspended(user.AccountId, instanceUid, out Guid revisionUid))\n\t\t\t\t{\n\t\t\t\t\tstring message = $\"Cannot resume failed instance {instanceUid} because its revision {revisionUid} is suspended\";\n\t\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\t\tthrow new ApplicationException(message);\n\t\t\t\t}\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid);\n\t\t\t\t\t\t\tcontrol.ResumeFromError(user, comment);\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error resuming failed instance\"), e);\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void ResumeWorkflow(UserAccount user, Guid instanceUid, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tif (WorkflowManager.Instance.IsInstanceRevisionExecutionSuspended(user.AccountId, instanceUid, out Guid revisionUid))\n\t\t\t\t{\n\t\t\t\t\tstring message =\n\t\t\t\t\t\t$\"Cannot resume instance {instanceUid} because its revision {revisionUid} is suspended\";\n\t\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\t\tthrow new ApplicationException(message);\n\t\t\t\t}\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid);\n\t\t\t\t\t\t\tcontrol.Resume(user, comment);\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error resuming instance\"), e);\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void SubmitWorkItem(UserAccount user, Guid workItemUid, string output, string comments, IList<string> activityMessages, IDictionary<string, object> updatedVariables)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII(string.Format(\"SubmitWorkItem: WorkItemUid {0}, output {1}\", workItemUid, PII.Encode(output)));\n\t\t\t\t\t\tWorkItem workItem = WorkItemPersistence.WorkflowInstance(user.AccountId).LoadByUid(user.AccountId, user.Uid, workItemUid);\n\t\t\t\t\t\tif (workItem == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new ApplicationException(string.Format(\"Invalid workItemUid '{0}' for accountId '{1}'\", workItemUid, user.AccountId));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, workItem.InstanceUid);\n\n\t\t\t\t\t\tvar instance = ServiceLocator.GetInstance<IInstanceRepository>().LoadByUId(user.AccountId, user.Uid, workItem.InstanceUid);\n\n\t\t\t\t\t\tif (instance.EngineVersion == Core.Workflow.Constants.EngineVersionV2 && WorkflowConfig(user.AccountId).EnableWorkflowEngineV2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.InfoNoPII(\"Submitting work item (v2) via API\");\n\t\t\t\t\t\t\tvar workflowEngineV2Service = ServiceLocator.GetInstance<IWorkflowEngineV2Service>();\n\t\t\t\t\t\t\tworkflowEngineV2Service.SubmitWorkItem(user.AccountId, user.Uid, workItemUid, output, comments, updatedVariables);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (workItem.Status != Enums.WorkflowStepActivityStatus.WaitingAssigned && workItem.Status != Enums.WorkflowStepActivityStatus.WaitingUnassigned) throw new WorkItemAlreadyCompletedException(string.Format($\"WorkItemUid '{workItemUid}' is already completed for instance {instance.Uid}\"));\n\t\t\t\t\t\t\tif (WorkflowManager.Instance.IsInstanceRevisionExecutionSuspended(user.AccountId, workItem.InstanceUid, out Guid revisionUid))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstring message =\n\t\t\t\t\t\t\t\t\t$\"Cannot submit WorkItem {workItemUid} for instance {workItem.InstanceUid} because its revision {revisionUid} is suspended\";\n\t\t\t\t\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\t\t\t\t\tthrow new ApplicationException(message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tWorkItemResponse response = new WorkItemResponse(user, output, comments, activityMessages, updatedVariables);\n\t\t\t\t\t\t\tEvent e = Event.CreateCallbackEvent(workItem.AccountId, workItem.InstanceUid, workItem.ActivityUid, workItem.Uid.ToString(), response);\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (WorkflowManager.Instance.IsAcceptingWork)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowManager.Instance.ExecuteEvent(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t_log.WarnNoPII($\"Workflow manager is no longer accepting work, will attempt to queue {workItemUid}\");\n\t\t\t\t\t\t\t\t\tWorkflowManager.Instance.QueueEvent(e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (InstanceAlreadyCompletedException)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (InstanceLockedException ilex)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII($\"SubmitWorkItem: Instance locked for WorkItemUid {workItemUid}, output {PII.Encode(output)}, will attempt to queue event - {ilex.Message}\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.QueueEvent(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII(string.Format(\"SubmitWorkItem: Internal error while executing event for WorkItemUid {0}, output {1}, will attempt to queue event\", workItemUid, PII.Encode(output)), ex);\n\t\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{ex.Message} {ex.StackTrace}\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.QueueEvent(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (WorkItemAlreadyCompletedException wacex)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"SubmitWorkItem: WorkItem {workItemUid} already completed, output {PII.Encode(output)}, no action taken - {wacex.Message}\");\n\t\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidState, \"The specified workitem is already completed\");\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InstanceAlreadyCompletedException iacex)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"SubmitWorkItem: Instance for WorkItem {workItemUid} already completed, output {PII.Encode(output)}, no action taken - {iacex.Message}\");\n\t\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidState, \"The specified workflow is already completed\");\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PublicException pe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII($\"Error submitting workItemUid {workItemUid} - PublicException ({pe.Reason}) was thrown\", pe.InnerException);\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error submitting workItemUid {0} with output {1}\", workItemUid, PII.Encode(output)), e);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t// Web.Resources.BPM.NoSuchStep\n\t\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidState, \"The specified workflow step is either already completed, or is no longer assigned to you.\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Design LoadDesign(UserAccount user, Version version)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IVersionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, version.Uid);\n\n\t\t\t\tif (design.IsOld && AccountPersistence.AuthenticationInstance.LoadById(user.AccountId).Settings.UseNewWorkflowDesigner)\n\t\t\t\t{\n\t\t\t\t\tif (AccountPersistence.AuthenticationInstance.LoadById(user.AccountId).Settings.ConvertToNewWorkflowDesign)\n\t\t\t\t\t{\n\t\t\t\t\t\tdesign = new Legacy2Designer(new DefinitionReaderLegacy(design)).Convert(user, version);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ApplicationException(string.Format(\"ConvertToNewWorkflowDesign account setting is off. Cannot convert workflow with version {0}\", version.Uid));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn design;\n\t\t\t}\n\t\t}\n\n\t\tpublic Design LoadDesign(UserAccount user, Revision revision)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IRevisionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, revision.Uid);\n\n\t\t\t\tif (design.IsOld && AccountPersistence.AuthenticationInstance.LoadById(user.AccountId).Settings.UseNewWorkflowDesigner)\n\t\t\t\t{\n\t\t\t\t\tif (AccountPersistence.AuthenticationInstance.LoadById(user.AccountId).Settings.ConvertToNewWorkflowDesign)\n\t\t\t\t\t{\n\t\t\t\t\t\tdesign = new Legacy2Designer(new DefinitionReaderLegacy(design)).Convert(user, revision);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ApplicationException(string.Format(\"ConverToNewWorkflowDesign account setting is off. Cannot convert workflow with revision {0}\", revision.Uid));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn design;\n\t\t\t}\n\t\t}\n\n\t\tpublic Design ConvertLegacyDefinition(UserAccount user, Design oldDesign)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = new Legacy2Designer(new DefinitionReaderLegacy(oldDesign)).Convert(user);\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpublic string CompileExpressionBuilderExpression(UserAccount user, string code, string additionalCode, string returnType)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tstring jwtToken = null;\n\n\t\t\t\tif (Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.CloudExpressionAPIBehavior == FeatureFlagConstants.ApiCallBehaviorLive\n\t\t\t\t\t|| Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.CloudExpressionAPIBehavior == FeatureFlagConstants.ApiCallBehaviorShadow\n\t\t\t\t\t|| !IsOnPrem())\n\t\t\t\t{\n\t\t\t\t\tjwtToken = ServiceLocator.GetInstance<IDSAccountsServerRepository>()\n\t\t\t\t\t\t.GetJwtGrantAccessToken(DSAccountsServerRepository.WorkflowScopes, secretName: ExpressionServiceClient.CLMWorkflowExpressionTokenRSAInfoSecretName);\n\t\t\t\t}\n\n\t\t\t\tvar workflowEvaluateExpressionResult = ServiceLocator.GetInstance<IExpressionServiceClient>()\n\t\t\t\t\t.WorkflowCompileExpression(user.AccountId, code, additionalCode, returnType,\n\t\t\t\t\t\tWorkflowSettingRepository.GetEnableWorkflowExpressionErrorWithSource(user.AccountId), jwtToken\n\t\t\t\t\t\t);\n\n\t\t\t\treturn workflowEvaluateExpressionResult.ErrorMessage;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool UpdateVariables(UserAccount userAccount, Guid activityUid, List<VariableUpdate> variableUpdates, Guid sourceInstanceUid, Guid sourceActivityUid)\n\t\t{\n\t\t\treturn UpdateVariablesWithResult(userAccount, activityUid, variableUpdates, sourceInstanceUid, sourceActivityUid) == WorkflowEnums.UpdateParentVariableResult.Updated;\n\t\t}\n\n\t\tpublic WorkflowEnums.UpdateParentVariableResult UpdateVariablesWithResult(UserAccount userAccount, Guid activityUid, List<VariableUpdate> variableUpdates, Guid sourceInstanceUid, Guid sourceActivityUid)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(userAccount.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(userAccount.AccountId, sourceInstanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid);\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(userAccount.AccountId, sourceInstanceUid)))\n\t\t\t\t{\n\t\t\t\t\tInstanceActivity parentActivity = InstanceActivityPersistence.WorkflowInstance(userAccount.AccountId).LoadByUId(userAccount.AccountId, userAccount.Uid, activityUid);\n\t\t\t\t\tif (parentActivity == null) throw new ApplicationException(string.Format(\"Cannot load parentActivityUid {0}: No matching record\", activityUid));\n\n\t\t\t\t\tWorkflowInstance parentWorkflowInstance = null;\n\t\t\t\t\tvar workflowManager = WorkflowManager.Instance;\n\t\t\t\t\tvar wasInMemory = false;\n\t\t\t\t\tWorkflowEnums.UpdateParentVariableResult result;\n\n\t\t\t\t\tvar instance = ServiceLocator.GetInstance<IWorkflowRepository>().LoadInstanceById(userAccount.AccountId, userAccount.Uid, sourceInstanceUid);\n\t\t\t\t\tClientWorkflowContext ctx = new ClientWorkflowContext(userAccount.Uid, instance, sourceActivityUid);\n\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Attempting to get a lock on instance {parentActivity.InstanceUid}\");\n\n\t\t\t\t\t\tif (!WorkflowManager.Instance.IsAcceptingWork)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII(\n\t\t\t\t\t\t\t\t$\"Workflow manager is no longer accepting work. Cannot update parent instance uid {parentActivity.InstanceUid}\");\n\t\t\t\t\t\t\treturn WorkflowEnums.UpdateParentVariableResult.Error;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparentWorkflowInstance = GetLockedParentWorkflowInstance(ctx, parentActivity.InstanceUid,\n\t\t\t\t\t\t\tworkflowManager, out wasInMemory);\n\t\t\t\t\t\tif (parentWorkflowInstance == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(\n\t\t\t\t\t\t\t\t$\"Giving up on trying to get a lock on parent instance {parentActivity.InstanceUid} after {LockMaxRetry} tries\");\n\t\t\t\t\t\t\treturn WorkflowEnums.UpdateParentVariableResult.Error;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_log.DebugNoPII($\"Got a lock on parent instance {parentWorkflowInstance.Uid}\");\n\n\t\t\t\t\t\t// We need parentWorkflowInstance to have it's variable properties populated, this below call will do that (as a side-effect) via _CreateContext, the result is irrelevant\n\t\t\t\t\t\tparentWorkflowInstance.CheckActivityForCompletion(parentActivity);\n\n\t\t\t\t\t\tresult =\n\t\t\t\t\t\t\tUpdateVariables(ctx, parentWorkflowInstance, parentActivity, variableUpdates)\n\t\t\t\t\t\t\t\t? WorkflowEnums.UpdateParentVariableResult.Updated\n\t\t\t\t\t\t\t\t: WorkflowEnums.UpdateParentVariableResult.NotUpdated;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InstanceLockedException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII(ex.Message, ex);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{ex.Message} {ex.StackTrace}\");\n\t\t\t\t\t\tresult = WorkflowEnums.UpdateParentVariableResult.ParentInstanceLocked;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII(ex.Message, ex);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{ex.Message} {ex.StackTrace}\");\n\t\t\t\t\t\tresult = WorkflowEnums.UpdateParentVariableResult.Error;\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tctx.LogDebugNoPII($\"Unlocked parent instance {parentWorkflowInstance?.Uid}\");\n\t\t\t\t\t\tReleaseLock(parentWorkflowInstance, workflowManager, wasInMemory);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// The reason for the destinationContext parameter is when we're updating variables in\n\t\t/// a different workflow than the current one; eg, the UpdateParentVariableAction\n\t\t/// makes use of this.\n\t\t/// </summary>\n\t\tpublic static bool UpdateVariables(ClientWorkflowContext sourceContext, WorkflowInstance parentWorkflowInstance, InstanceActivity parentActivity, List<VariableUpdate> updates)\n\t\t{\n\t\t\tClientWorkflowContext updateContext = new ClientWorkflowContext(sourceContext.UserAccountUid, parentWorkflowInstance.Model);\n\n\t\t\tvar variableNameValues = UpdateVariablesHelper.BuildVariablesToUpdate(sourceContext, updateContext, updates);\n\n\t\t\t// Update variables\n\t\t\tint updateCount = 0;\n\t\t\tparentWorkflowInstance.SetVariables(\n\t\t\t\tparentActivity,\n\t\t\t\tvariableNameValues,\n\t\t\t\tout List<InstanceVariable> oldVariables,\n\t\t\t\tout bool areVariablesOverTotalSizeLimit,\n\t\t\t\tout int totalVariablesSizeBytes,\n\t\t\t\tout int totalVariablesSizeLimitBytes,\n\t\t\t\tout Dictionary<string, int> oversizedVariables,\n\t\t\t\tout int variableValueSizeLimitBytes);\n\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tsourceContext.LogActivityErrorNoPII(\n\t\t\t\t\tstring.Format(\n\t\t\t\t\t\tAtlas.Workflow.Activities.Resources.WINSResources.TheWorkflowsTotalVariableSizeIs0BytesAndIsOverTheLimitOf1Bytes,\n\t\t\t\t\t\ttotalVariablesSizeBytes,\n\t\t\t\t\t\ttotalVariablesSizeLimitBytes));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Log oversized variables\n\t\t\t\tforeach (var variable in oversizedVariables)\n\t\t\t\t{\n\t\t\t\t\tsourceContext.LogActivityErrorWithPII(\n\t\t\t\t\t\tstring.Format(\n\t\t\t\t\t\t\tAtlas.Workflow.Activities.Resources.WINSResources.Variable0Is0BytesInSizeAndIsOverTheVariableSizeLimitOf1BytesTheVariableCannotBeSet,\n\t\t\t\t\t\t\tvariable.Value,\n\t\t\t\t\t\t\tvariableValueSizeLimitBytes),\n\t\t\t\t\t\tpii: variable.Key);\n\t\t\t\t}\n\n\t\t\t\t// Log updates\n\t\t\t\tupdateCount = UpdateVariablesHelper.LogUpdates(sourceContext, updateContext, variableNameValues, oldVariables);\n\t\t\t}\n\n\t\t\treturn updateCount > 0;\n\t\t}\n\n\t\tprivate WorkflowInstance GetLockedParentWorkflowInstance(ClientWorkflowContext sourceContext, Guid parentInstanceUid, WorkflowManager workflowManager, out bool wasInMemory)\n\t\t{\n\t\t\tvar policy = Policy\n\t\t\t\t.Handle<InstanceLockedException>()\n\t\t\t\t.OrResult<(WorkflowInstance WorkflowInstance, bool WasInMemory)>(r => r.WorkflowInstance == null)\n\t\t\t\t.WaitAndRetry(LockMaxRetry, (_) => TimeSpan.FromMilliseconds(LockMsWaitBetweenRetry),\n\t\t\t\t\t(result, timeSpan, retryCount, context) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tvar logMessage = $\"{nameof(LoadAndLockExisting)} failed trying to lock instance {parentInstanceUid} on retry {retryCount} out of {LockMaxRetry}\";\n\t\t\t\t\t\tif (result.Exception != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"{logMessage}, with exception.\", result.Exception);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (result.Result.WorkflowInstance == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"{logMessage}, with null instance.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"{logMessage}.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\tWorkflowInstance workflowInstance;\n\t\t\t(workflowInstance, wasInMemory) = policy.Execute(() => LoadAndLockExisting(sourceContext.AccountId, parentInstanceUid, workflowManager));\n\t\t\treturn workflowInstance;\n\t\t}\n\n\t\tprivate (WorkflowInstance workflowInstance, bool wasInMemory) LoadAndLockExisting(int accountId, Guid parentInstanceUid, WorkflowManager workflowManager)\n\t\t{\n\t\t\tvar workflowInstance =\n\t\t\t\tworkflowManager.LoadAndLockExisting(accountId, parentInstanceUid, out bool wasInMemory);\n\t\t\treturn (workflowInstance, wasInMemory);\n\t\t}\n\n\t\tprivate static void ReleaseLock(WorkflowInstance workflowInstance, WorkflowManager workflowManager, bool wasInMemory)\n\t\t{\n\t\t\tif (workflowInstance != null)\n\t\t\t{\n\t\t\t\tif (wasInMemory)\n\t\t\t\t{\n\t\t\t\t\tworkflowManager.RemoveLock(workflowInstance);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tworkflowManager.RemoveInstance(workflowInstance, DateTime.UtcNow.AddMinutes(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void SystemCallback(int accountId, Guid instanceUid, Guid activityUid, string callbackName, object callbackData = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid);\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(accountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII(string.Format(\"System callback with callbackName {0}\", callbackName));\n\t\t\t\t\t\tInstance instance = InstancePersistence.WorkflowInstance(accountId).LoadByUId(accountId, Constants.WorkflowUser, instanceUid);\n\t\t\t\t\t\tif (instance == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new ArgumentException(string.Format(\"Invalid instanceUid '{0}' for accountId '{1}'\", instanceUid, accountId));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (instance.IsCompleted && instance.Status != Enums.WorkflowStepStatus.Failed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.InfoNoPII($\"Ignoring callback '{callbackName}' for instance '{instanceUid}' in '{instance.Status}' status\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (activityUid == Guid.Empty) _GuessLegacyActivityUid(instance, ref activityUid, ref callbackName);\n\t\t\t\t\t\tif (activityUid == Guid.Empty && WorkflowSettingRepository.GetDisableCreatingEventsWithEmptyActivityUids())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// if the activityUid is still empty, do not create an event for it\n\t\t\t\t\t\t\tstring emptyActivityErrorMsg = $\"ActivityUid cannot be empty when creating an event (event '{callbackName}', instance '{instanceUid}' for account '{accountId}')\";\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ErrorMessage, $\"UserError: {emptyActivityErrorMsg}\");\n\t\t\t\t\t\t\t_log.WarnNoPII(emptyActivityErrorMsg);\n\t\t\t\t\t\t\tthrow new ArgumentException(emptyActivityErrorMsg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tEvent e = Event.CreateCallbackEvent(accountId, instanceUid, activityUid, callbackName, callbackData);\n\n\t\t\t\t\t\tbool reachedMaxInstancesInMemory = false;\n\t\t\t\t\t\tbool alreadyMaxedOutForAccount = false;\n\t\t\t\t\t\tbool isInPenaltyBox = false;\n\n\t\t\t\t\t\tif ((isInPenaltyBox = Governor.IsInPenaltyBox(accountId)) ||\n\t\t\t\t\t\t\t\t(reachedMaxInstancesInMemory = WorkflowManager.Instance.IsFull) ||\n\t\t\t\t\t\t\t\t(alreadyMaxedOutForAccount = WorkflowManager.Instance.AlreadyMaxedOutForAccount(accountId)))\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tWorkflowManager.Instance.CreateEvent(e);\n\n\t\t\t\t\t\t\tif (isInPenaltyBox)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"Account is currently in penalty box. Creating Event '{callbackName}'\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.LogInstanceDeferredGovernanceLimitReached(instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (reachedMaxInstancesInMemory)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"Instances is full for account. Creating Event '{callbackName}'\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.LogInstanceDeferredMaxInstancesInMemory(instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (alreadyMaxedOutForAccount)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"Instances already maxed out for account. Creating Event '{callbackName}'\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.LogInstanceDeferredMaxedOutForAccount(instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWorkflowManager.Instance.QueueEvent(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error processing system callback with callbackName {0}\", callbackName), e);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic string ExportWorkflowDefinition(UserAccount user, string workflowName, int versionNumber = int.MinValue, int revisionNumber = int.MinValue)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = WINSClientLibrary.ExportWorkflowDefinition(user, workflowName, versionNumber, revisionNumber);\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpublic Revision ImportWorkflowDefinition(UserAccount user, string workflowName, string definitionData, bool overwriteExistingWorkflow, string comment = \"\", string templateId = \"\", int templateVersion = int.MinValue)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\n\t\t\t\t\tif (string.IsNullOrEmpty(comment)) comment = \"ImportWorkflowDefinition\";\n\t\t\t\t\tVersionPersistence versionPersistence = VersionPersistence.WorkflowInstance(user.AccountId);\n\t\t\t\t\tRevisionPersistence revisionPersistence = RevisionPersistence.WorkflowInstance(user.AccountId);\n\t\t\t\t\tDefinition definition = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IDefinitionRepository>().LoadByName(user.AccountId, user.Uid, workflowName);\n\t\t\t\t\tVersion version;\n\t\t\t\t\tif (definition == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdefinition = CreateNewWorkflowDefinition(user, workflowName);\n\t\t\t\t\t\tif (definition.LatestVersionUid == Guid.Empty) throw new ApplicationException(string.Format(\"DefinitionUid {0} returned a null LatestVersionUid\", definition.Uid));\n\t\t\t\t\t\tversion = versionPersistence.LoadByUid(user.AccountId, user.Uid, definition.LatestVersionUid);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tversion = versionPersistence.LoadByUid(user.AccountId, user.Uid, definition.LatestVersionUid);\n\t\t\t\t\t\t// It is possible that we already have this definition xml; if so, we don't need to reversion.\n\t\t\t\t\t\tDesign checkDesign = versionPersistence.LoadDesignerDefinitionByUid(user.AccountId, user.Uid, version.Uid);\n\n\t\t\t\t\t\tif (overwriteExistingWorkflow || checkDesign.Definition != definitionData)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(checkDesign.Definition))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tversion = VersionWorkflow(user, version.Uid, comment: comment);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbool isJson = definitionData.isValidJson();\n\t\t\t\t\tif (isJson)\n\t\t\t\t\t{\n\t\t\t\t\t\tversionPersistence.SaveDesignerDefinition(user, version.Uid, definitionData, comment);\n\n\t\t\t\t\t\tif (!string.IsNullOrWhiteSpace(templateId))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tversion.TemplateId = templateId;\n\t\t\t\t\t\t\tversion.TemplateVersion = templateVersion;\n\t\t\t\t\t\t\tversionPersistence.Save(version, definitionData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tversionPersistence.SaveLegacyXml(user, version.Uid, definitionData, comment);\n\t\t\t\t\t}\n\n\t\t\t\t\t// It is possible that we already have this definition xml published; if so, we don't need to publish again.\n\t\t\t\t\tif (version.IsPublished())\n\t\t\t\t\t{\n\t\t\t\t\t\tRevision revision = revisionPersistence.LoadLatestByVersionUid(user.AccountId, user.Uid, version.Uid);\n\t\t\t\t\t\tDesign checkDesign = revisionPersistence.LoadDesignerDefinitionByUid(user.AccountId, user.Uid, revision.Uid);\n\t\t\t\t\t\tif ((isJson && checkDesign.DesignerDefinition == definitionData) || checkDesign.LegacyXml == definitionData)\n\t\t\t\t\t\t\treturn revision;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar publishedRevision = _PublishWorkflow(user, version.Uid, comment: comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn publishedRevision;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Revision PublishWorkflow(UserAccount user, string workflowName, int versionNumber, int revisionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\t\tVersion version = VersionPersistence.WorkflowInstance(user.AccountId).LoadByNameAndVersion(user.AccountId, user.Uid, workflowName, versionNumber);\n\t\t\t\t\tvar publishedRevision = _PublishWorkflow(user, version.Uid, revisionNumber, comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn publishedRevision;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Revision PublishWorkflow(UserAccount user, Guid versionUid, int revisionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\t\tvar publishedRevision = _PublishWorkflow(user, versionUid, revisionNumber, comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn publishedRevision;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Version VersionWorkflow(UserAccount user, string workflowName, int sourceVersionNumber, int sourceRevisionNumber = int.MinValue, int newVersionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, workflowName, sourceVersionNumber, sourceRevisionNumber, newVersionNumber, comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Version VersionWorkflow(UserAccount user, Guid sourceVersionUid, int sourceRevisionNumber = int.MinValue, int newVersionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, sourceVersionUid, sourceRevisionNumber, newVersionNumber, comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic bool IsActivityExecutionLimitReached(int accountId, Guid instanceUid, Guid revisionUid, DateTime revisionCreatedDate, int activityExecutionCount)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tbool isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(accountId, instanceUid, revisionUid, revisionCreatedDate, activityExecutionCount, out _);\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn isActivityExecutionLimitReached;\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Remoted methods called by clients\n\n\t\tpublic Guid StartRoutingApprovalWorkflow(UserAccount user, Guid revisionUid, string routingApprovalName, string sourceType, string sourceId, string xmlParam = null)\n\t\t{\n\t\t\tRequires.NotNull(user, nameof(user));\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tStartParameters startParameters = new StartParameters(user, xmlParam, sourceType, sourceId);\n\t\t\t\t\t// This is for routing/approval workflows.  Each one has a different revision, but they all come in with the same\n\t\t\t\t\t// definition, which is named \"RoutingApproval\".  This lets us override that name and provide the one we really want.\n\t\t\t\t\tstartParameters.RoutingApprovalInstanceName = routingApprovalName;\n\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, revisionUid, startParameters);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid SendStartWorkflow(UserAccount user, string workflowName, string sourceType, string sourceId, string xmlParam = null)\n\t\t{\n\t\t\tRequires.NotNull(user, nameof(user));\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tGuid result = WorkflowRepository.SendStartWorkflow(user, workflowName, sourceType, sourceId, xmlParam);\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, result);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid StartWorkflow(UserAccount user, string workflowName, string sourceType, string sourceId, string xmlParam = null, Guid instanceUid = default(Guid))\n\t\t{\n\t\t\treturn StartWorkflowFromSource(user, workflowName, sourceType, sourceId, xmlParam, instanceUid);\n\t\t}\n\n\t\tpublic Guid StartWorkflowFromSource(UserAccount user, string workflowName, string sourceType, string sourceId, string xmlParam, Guid instanceUid)\n\t\t{\n\t\t\tRequires.NotNull(user, nameof(user));\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, user.Uid, workflowName, xmlParam, sourceType, sourceId, instanceUid);\n\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PublicException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ex.Reason == PublicException.FailReason.NonexistentObject)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Framework.Common.ExceptionDataPoint.ApiExceptionMessage, $\"Request failed to start workflow instance '{instanceUid}' for account '{user.AccountId}'. Reason: No such workflow found.\");\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid StartWorkflowWithParameters(UserAccount user, Guid revisionUid, StartParameters startParameters, Guid instanceUid = default(Guid))\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, revisionUid, startParameters, instanceUid);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\n\t\tprivate Revision _PublishWorkflow(UserAccount user, Guid versionUid, int revisionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\t// The point of this is to make sure that we can understand the definition and translate it.  If we can't, we want to flag\n\t\t\t// that now, rather than when they try to run the workflow.\n\n\t\t\tvar version = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IVersionRepository>().LoadByUid(user.AccountId, user.Uid, versionUid);\n\t\t\tServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromVersion(version).BuildWorkflowMap(version);\n\n\t\t\tRevisionPersistence revisionPersistence = RevisionPersistence.WorkflowInstance(user.AccountId);\n\t\t\tGuid publishedRevisionUid = revisionPersistence.Publish(user, versionUid, revisionNumber: revisionNumber, comment: comment);\n\n\t\t\tRevision revision = revisionPersistence.LoadByUid(user.AccountId, user.Uid, publishedRevisionUid);\n\n\t\t\tCoreDomainWorkflowRepository.IRevisionRepository revisionRepository = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IRevisionRepository>();\n\n\t\t\tnew DefinitionEventEmitter\n\t\t\t{\n\t\t\t\tEventName = DefinitionEventEmitter.DefinitionEventType.RevisionPublished,\n\t\t\t\tAccountId = user.AccountId,\n\t\t\t\tUserAccountUid = user.Uid,\n\t\t\t\tDefinitionUid = revision.DefinitionUid,\n\t\t\t\tVersionUid = revision.VersionUid,\n\t\t\t\tRevisionUid = revision.Uid,\n\t\t\t\tIsFirstRevision = revisionRepository.LoadByDefinitionUid(user.AccountId, user.Uid, revision.DefinitionUid).Count <= 1,\n\t\t\t\tTemplateId = version.TemplateId,\n\t\t\t\tTemplateVersion = version.TemplateId == null ? 0 : version.TemplateVersion\n\t\t\t}.Emit();\n\n\t\t\treturn revision;\n\t\t}\n\n\t\tprivate Guid _StartWorkflow(int accountId, Guid revisionUid, StartParameters startParameters, Guid instanceUid = default(Guid))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (Governor.IsStartInstanceLimitReached(accountId))\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Start instance limit reached - Preventing the starting of a workflow for revisionUid {revisionUid} from source type '{startParameters.SourceType}' and source id '{startParameters.SourceId}'\");\n\t\t\t\t\tGovernor.EmitInstanceStartCountExceededTelemetry(accountId);\n\n\t\t\t\t\tthrow new PublicException(PublicException.FailReason.TemporarilyUnavailable, Resources.WINSResources.TooManyWorkflowStarted);\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Starting workflow for revisionUid {revisionUid} from source type '{startParameters.SourceType}' and source id '{startParameters.SourceId}'\");\n\n\t\t\t\tvar paramsXml = InstanceVariable.CreateFromValueString(accountId, instanceUid, \"ParametersXml\", Enums.WorkflowVariableType.Xml, startParameters.ParametersXml);\n\t\t\t\tThrowIfVariablesOverSizeLimit(accountId, paramsXml, DateTime.UtcNow);\n\n\t\t\t\tinstanceUid = WorkflowManager.Instance.CreateNewInstance(accountId, revisionUid, startParameters, instanceUid);\n\n\t\t\t\tnew ManagerWorkload(\"InstanceCreated\", accountId, instanceUid)\n\t\t\t\t{\n\t\t\t\t\tRevisionUid = revisionUid.ToString(),\n\t\t\t\t\tSourceId = startParameters.SourceId,\n\t\t\t\t\tSourceType = startParameters.SourceType,\n\t\t\t\t\tScopeUid = startParameters.ScopeUid,\n\t\t\t\t\tInitiatingUser = startParameters.Submitter.Uid,\n\t\t\t\t\tInitiatingInstanceUid = startParameters.ParentInstanceUid,\n\t\t\t\t}.Log();\n\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(accountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII(string.Format(\"Created instance for revisionUid {0}\", revisionUid));\n\t\t\t\t\tif (startParameters.AlertParent)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring msg = \"\";\n\t\t\t\t\t\tServiceLocator.GetInstance<IWorkflowCallbackHelper>().RegisterWorkflowCallback(\n\t\t\t\t\t\t\taccountId,\n\t\t\t\t\t\t\tstartParameters.Submitter,\n\t\t\t\t\t\t\tstartParameters.ParentInstanceUid,\n\t\t\t\t\t\t\tstartParameters.ParentActivityUid,\n\t\t\t\t\t\t\tstring.Empty,\n\t\t\t\t\t\t\tScmEnums.EventType.WorkflowStatusChanged,\n\t\t\t\t\t\t\tstartParameters.CallbackName,\n\t\t\t\t\t\t\tinstanceUid,\n\t\t\t\t\t\t\tstartParameters.CallbackEventDestPath,\n\t\t\t\t\t\t\tref msg,\n\t\t\t\t\t\t\tCallbackEventBehavior.Blocking);\n\t\t\t\t\t}\n\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, instanceUid);\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowRevisionUid, revisionUid);\n\n\t\t\t\t\treturn instanceUid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(string.Format(\"Error starting workflow for revisionUid {0}\", revisionUid), e);\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid _StartWorkflow(int accountId, Guid userAccountUid, string workflowName, string xmlParameters, string sourceType, string sourceId, Guid instanceUid = default(Guid))\n\t\t{\n\t\t\t_log.InfoWithPII($\"Request to start ({{0}}) with instanceUid {instanceUid} from source type '{sourceType}' and source id '{sourceId}'\", workflowName);\n\n\t\t\tUserAccount user = ServiceLocator.GetInstance<IUserAccountRepository>().LoadByUid(accountId, userAccountUid);\n\n\t\t\tDefinition definition = WorkflowRepository.LoadDefinition(accountId, userAccountUid, workflowName);\n\t\t\tif (definition == null)\n\t\t\t{\n\t\t\t\t_log.WarnWithPII($\"User {userAccountUid} trying to start workflow of invalid name ({{0}})\", workflowName);\n\t\t\t\tthrow new PublicException(PublicException.FailReason.NonexistentObject, string.Format(\"Invalid workflow name: {0}\", workflowName));\n\t\t\t}\n\n\t\t\tif (definition.LatestRevisionUid == Guid.Empty)\n\t\t\t{\n\t\t\t\t_log.WarnWithPII($\"Workflow ({{0}}) has no published versions\", workflowName);\n\t\t\t\tthrow new PublicException(PublicException.FailReason.NonexistentObject, string.Format(\"Workflow {0} is not published\", workflowName));\n\t\t\t}\n\n\t\t\tStartParameters startParameters = new StartParameters(user, xmlParameters, sourceType, sourceId);\n\n\t\t\treturn _StartWorkflow(accountId, definition.LatestRevisionUid, startParameters, instanceUid);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// In the previous incarnation of WINS, ActivityUid was not part of the callbackName -- MWF required\n\t\t/// all bookmark names to be unique amongst instance, not amongst activity, so it wasn't necessary.\n\t\t/// If we're receiving an old MWF-callback (eg, for a workflow that was running at the time), we might need to\n\t\t/// parse this out.\n\t\t/// Or at least try.\n\t\t/// </summary>\n\t\tprivate void _GuessLegacyActivityUid(Instance instance, ref Guid activityUid, ref string callbackName)\n\t\t{\n\t\t\tif (string.IsNullOrEmpty(callbackName)) return;\n\t\t\tif (Event.ControlNames.IsControlName(callbackName)) return;\n\t\t\t// Attempt #1: In many cases this used the format {ActivityUid}@{Name}; if so, we should strip the ActivityUid out and return it.\n\t\t\tstring callbackNameText = callbackName;\n\t\t\tint pos = callbackName.IndexOf(\"@\");\n\t\t\tif (pos >= 0)\n\t\t\t{\n\t\t\t\tstring activityUidText = callbackName.Substring(0, pos);\n\t\t\t\tcallbackNameText = callbackName.Substring(pos + 1);\n\t\t\t\tif (Conversions.TryParseGuid(activityUidText) != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tactivityUid = Conversions.TryParseGuid(activityUidText);\n\t\t\t\t\tcallbackName = callbackNameText;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInstanceActivityBookmarks bookmarks = InstanceActivityBookmarkPersistence.WorkflowInstance(instance.AccountId).LoadByInstance(instance.AccountId, instance.Uid);\n\t\t\t// Attempt #2: Do we have a single callback match for the name?  If so, use that.\n\t\t\tIEnumerable<InstanceActivityBookmark> matches = bookmarks.Where(n => n.CallbackName == callbackNameText);\n\t\t\tif (matches.Count() == 1)\n\t\t\t{\n\t\t\t\tactivityUid = matches.First().ActivityUid;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Otherwise, not much we can do.  It's possible it's not meant for an activity (eg, an \"Abort\" command event), so we definitely\n\t\t\t// don't want to throw an error.\n\t\t}\n\n\t\t[DocuSign.Monitoring.EventSource(\"RemotedCallsException\", \"CLM.WINSManager\")]\n\t\t[DocuSign.Monitoring.Counter(\"RemotedCallsException\", \"CLM.WINSManager\", InstanceProperty = \"Description\")]\n\t\tprivate static DocuSign.Monitoring.ExceptionEventSource _remotedCallErrorEvent = new DocuSign.Monitoring.ExceptionEventSource();\n#pragma warning disable CA1822 // Member 'BuildRequestEventLoggerAndClearMonitoringContext' does not access instance data and can be marked as static. Reason: used in .net 4.8\n\t\tprivate TaskServiceRequestEventLogger BuildRequestEventLoggerAndClearMonitoringContext(int accountId, Guid intanceUid = default, [CallerMemberName] string action = null)\n#pragma warning restore CA1822 // Member 'BuildRequestEventLoggerAndClearMonitoringContext' does not access instance data and can be marked as static. Reason: used in .net 4.8\n\t\t{\n\t\t\tTaskServiceRequestEventLogger logger = null;\n\t\t\ttry\n\t\t\t{\n#if NETFRAMEWORK\n\t\t\t\t// note: checking this setting will be logged under unknown Application if we're in a remote call and we're not hitting the cache\n\t\t\t\tif (WorkflowSettingRepository.GetClearKazmonContextInsideRemoteProxyCalls())\n\t\t\t\t{\n\t\t\t\t\t// these public methods are not only called externally but also by each other so we may call this twice in the context of the same request\n\t\t\t\t\t// knowing when to reset the context because it was a remote call vs a call from another public method is not trivial hence checking whether the current ServiceContext is a transparent proxy or a real object\n\t\t\t\t\tif (System.Runtime.Remoting.RemotingServices.IsTransparentProxy(DocuSign.Monitoring.ServiceContext.Current))\n\t\t\t\t\t{\n\t\t\t\t\t\t_remotedCallErrorEvent.Emit(\"Monitoring Context is a remote object and cannot be accessed; resetting\", \"TransparentProxyReset\");\n\t\t\t\t\t\tlogger = new TaskServiceRequestEventLogger(Guid.Empty, action);\n\t\t\t\t\t}\n\t\t\t\t\t// when making multiple remote proxy calls from the same request the second remote call and above have the context cleared from the first request (happening via AsyncRequestEventLogger.Dispose)\n\t\t\t\t\telse if (DocuSign.Monitoring.MonitoringContext.TraceToken == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger = new TaskServiceRequestEventLogger(Guid.Empty, action);\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\tif (DocuSign.Monitoring.MonitoringContext.TraceToken == null)\n\t\t\t\t{\n\t\t\t\t\tlogger = new TaskServiceRequestEventLogger(Guid.Empty, action);\n\t\t\t\t}\n#endif\n\n\t\t\t\t// Log Something within the remoting call.\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiLogger, $\"InRemoteCall: {Core.Domain.FeatureFlags.WorkflowFeatureFlags.TestSettingForLoggingInRemotingCall}\");\n\t\t\t\t// Log AccountId for remoting call\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.AccountId, accountId);\n\n\t\t\t\tif (intanceUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t// Log WorkflowInstanceUid for remoting call\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, intanceUid);\n\t\t\t\t}\n\t\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types - we want to catch all exception here, this is just logging logic\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_remotedCallErrorEvent.Emit(ex, \"Exception\");\n\t\t\t\t// Log Exception and Stack Trace for remoting call\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{ex.Message} {ex.StackTrace}\");\n\t\t\t}\n\t\t\treturn logger;\n\t\t}\n\n\n\t\tpublic void ThrowIfVariablesOverSizeLimit(int accountId, InstanceVariable variable, DateTime instanceCreatedDate)\n\t\t{\n\t\t\tif (InstanceVariableGovernance.IsVariableValueOverSizeLimit(accountId, variable, instanceCreatedDate, activityConfiguration: null,\n\t\t\t\tout int variableValueSizeBytes, out int variableValueSizeLimitBytes))\n\t\t\t{\n\t\t\t\tthrow new PublicException(\n\t\t\t\t\tPublicException.FailReason.InvalidArgument,\n\t\t\t\t\tstring.Format(\n\t\t\t\t\t\tstring.Format(\n\t\t\t\t\t\t\tResources.WINSResources.Variable0Is0BytesInSizeAndIsOverTheVariableSizeLimitOf1BytesTheVariableCannotBeSet,\n\t\t\t\t\t\t\tvariableValueSizeBytes,\n\t\t\t\t\t\t\tvariableValueSizeLimitBytes),\n\t\t\t\t\t\tvariable.Name));\n\t\t\t}\n\n\t\t\tif (InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(accountId, new InstanceVariables { variable }, instanceCreatedDate, activityConfiguration: null,\n\t\t\t\tout int totalVariablesSizeBytes, out int totalVariablesSizeLimitBytes))\n\t\t\t{\n\t\t\t\tthrow new PublicException(\n\t\t\t\t\tPublicException.FailReason.InvalidArgument,\n\t\t\t\t\tstring.Format(\n\t\t\t\t\t\tstring.Format(\n\t\t\t\t\t\t\tResources.WINSResources.TheWorkflowsTotalVariableSizeIs0BytesAndIsOverTheLimitOf1BytesTheVariable0CannotBeSet,\n\t\t\t\t\t\t\ttotalVariablesSizeBytes,\n\t\t\t\t\t\t\ttotalVariablesSizeLimitBytes),\n\t\t\t\t\t\tvariable.Name));\n\t\t\t}\n\t\t}\n\n\t\tprivate string[] BuildNDCTags(int accountId, Guid instanceUid) => instanceUid != default(Guid) ? new[] { $\"A:{accountId}\", $\"W:{instanceUid}\" } : new[] { $\"A:{accountId}\" };\n\n\t\tpublic void CheckEnableMigrationSuspendWorkflowFeature(int accountId)\n\t\t{\n\t\t\tif (WorkflowSettingRepository.GetEnableSuspendWorkflowFeature(accountId))\n\t\t\t{\n\t\t\t\tthrow new PublicException(PublicException.FailReason.TemporarilyUnavailable, Resources.WINSResources.WorkflowAndTaskFeatureTemporarilyUnavailableTryAgainLater);\n\t\t\t}\n\t\t}\n\n\t\tprivate static IDisposable CreateFeatureFlagsRemoteCallWrapper(int accountId)\n\t\t{\n#if NETFRAMEWORK\n\t\t\treturn FeatureFlagsRemoteCallWrapperFactory.CreateInstance(accountId);\n#else\n\t\t\treturn null;\n#endif\n\t\t}\n\n\t\tprivate bool IsOnPrem()\n\t\t{\n\t\t\tvar environmentType = _siteConfig?.Value?.EnvironmentType;\n\t\t\treturn environmentType == Core.Util.Config.EnvironmentType.OnPrem;\n\t\t}\n\n\t\tprivate void SaveInstanceStateChangedForGrpcEngineV1(Guid instanceUid)\n\t\t{\n\t\t\tvar workflowV1ClientInvariantConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>();\n\n\t\t\tif (!IsOnPrem() && workflowV1ClientInvariantConfig?.Value?.IsGrpcClientEnabled == true)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Saving instance state change for instanceUid: {instanceUid}\");\n\t\t\t\tInstanceStateChangedHelper.SaveInstanceStateChanged(instanceUid, _cacheRepository, WorkflowSettingRepository);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Skipping save of instance state change for instanceUid: {instanceUid}\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowContext.cs",
      "content": "\ufeffusing System;\nusing System.Xml;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Handlers;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Compatibility;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Xml;\nusing ADEXS.Core.Workflow.Config;\n\nnamespace ADEXS.WINS.Engine\n{\n\tpublic class WorkflowContext : IWINSWorkflowContext\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowContext));\n\n\t\tprivate readonly IWINSActivity _activity;\n\t\tprivate readonly WorkflowInstance _instance;\n\t\tprivate readonly InstanceActivity _instanceActivity;\n\n\t\tpublic WorkflowContext(WorkflowInstance instance, IWINSActivity activity, InstanceActivity instanceActivity)\n\t\t{\n\t\t\t_instance = instance;\n\t\t\t_activity = activity;\n\t\t\t_instanceActivity = instanceActivity;\n\t\t\t_log.InfoNoPII($\"Create new Context for account '{instanceActivity?.AccountId}', existing context hash is '{AtlasContext.Current?.GetHashCode()}'\");\n\t\t\tAtlasContext.Current.AccountId = AccountId;\n\t\t\t_log.InfoNoPII($\"Set accountId to '{instanceActivity?.AccountId}' on context '{AtlasContext.Current?.GetHashCode()}'\");\n\t\t}\n\n\t\tpublic DateTime SubmittedDate { get { return _instance.Model.CreatedDate; } }\n\n\t\tpublic Guid WorkflowInstanceUid => _instance.Uid;\n\n\t\tpublic long WorkflowInstanceId { get { return _instance.Model.Id; } }\n\n\t\tpublic Guid WorkflowDefinitionUid\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_instance.Model.DefinitionUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\treturn _instance.DefinitionUid;\n\t\t\t\t}\n\t\t\t\treturn _instance.Model.DefinitionUid;\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid WorkflowRevisionUid\n\t\t{\n\t\t\tget { return _instance.Model.RevisionUid == Guid.Empty ? _instance.RevisionUid : _instance.Model.RevisionUid; }\n\t\t}\n\n\t\tpublic DateTime RevisionCreatedDate { get{ return _instance.RevisionCreatedDate; } }\n\n\t\tpublic bool WorkflowInstanceFromApproval { get { return _instance.Model.FromApproval; } }\n\n\t\tpublic bool CheckForCompletion()\n\t\t{\n\t\t\tif (_instanceActivity.Status == Enums.WorkflowStepStatus.Completed) return true;\n\t\t\tstring output = Output;\n\t\t\tif (!_activity.CanBeMarkedAsCompleted(this, ref output)) return false;\n\t\t\tMarkAsCompleted(output);\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic int CreateLocalWorkflowContext()\n\t\t{\n\t\t\tif (_instanceActivity.LocalContextId < 0) throw new ApplicationException($\"Invalid local context id {_instanceActivity.LocalContextId} on instance {_instanceActivity.Uid}.\");\n\t\t\tint id = _instance.Model.GetNextLocalContextId();\n\t\t\tif (id < 1) throw new ApplicationException(string.Format(\"Received invalid local index: {0}\", id));\n\t\t\tXmlVariables.CopyLocalVariables(_instanceActivity.LocalContextId, id);\n\t\t\treturn id;\n\t\t}\n\n\t\tpublic void InitializeStartActivity()\n\t\t{\n\t\t\tif (!(_activity is StartActivity)) throw new ApplicationException(\"InitializeStartActivity should only be called from the StartActivity\");\n\t\t\tStartActivity start = (StartActivity)_activity;\n\t\t\tstring notify = start.SendNotification.Evaluate(this);\n\t\t\tif (string.IsNullOrEmpty(notify)) notify = \"Default\";\n\t\t\tswitch (notify.ToLower())\n\t\t\t{\n\t\t\t\tcase \"yes\":\n\t\t\t\t\t_instance.Model.NotifyOnError = true;\n\t\t\t\t\tContacts contacts = start.Notifiers.Evaluate(this);\n\t\t\t\t\t_instance.Model.NotifyEmail = (contacts != null && contacts.Count > 0 ? contacts.GetEmailAddresses() : \"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"no\":\n\t\t\t\t\t_instance.Model.NotifyOnError = false;\n\t\t\t\t\t_instance.Model.NotifyEmail = \"\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t_instance.Model.NotifyOnError = true;\n\t\t\t\t\t_instance.Model.NotifyEmail = \"\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpublic string Evaluate(string s)\n\t\t{\n\t\t\treturn WorkflowExpression.Evaluate(this, s).ProcessedExpression;\n\t\t}\n\n\t\tpublic string EvaluateTokensOnly(string s)\n\t\t{\n\t\t\treturn WorkflowExpression.EvaluateTokens(this, s).ProcessedExpression;\n\t\t}\n\n\t\tpublic Instance WorkflowModel => _instance.Model;\n\n\n\t\tprivate long _timeZoneId = long.MinValue;\n\t\tpublic long TimeZoneId\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_timeZoneId < 1) _timeZoneId = new AccountSettings(this.AccountId, Constants.SystemUser).TimeZoneId;\n\t\t\t\treturn _timeZoneId;\n\t\t\t}\n\t\t}\n\n\t\tpublic DateTime FromAccountTimeZone(DateTime accountDate)\n\t\t{\n\t\t\treturn CommonRepository.DateTimeToUniversal(TimeZoneId, accountDate);\n\t\t}\n\n\t\tpublic DateTime ToAccountTimeZone(DateTime utcDate)\n\t\t{\n\t\t\treturn CommonRepository.DateTimeFromUniversal(TimeZoneId, utcDate);\n\t\t}\n\n\t\tpublic string ToAccountTimeZoneString(DateTime utcDate)\n\t\t{\n\t\t\tDateTime local = ToAccountTimeZone(utcDate);\n\t\t\treturn string.Format(\"{0} (UTC{1})\", local.ToString(\"yyyy-MM-dd HH:mm:ss.fff\"), local.ToString(\"zzz\"));\n\t\t}\n\n\n\t\tpublic void MarkAsCompleted(string output)\n\t\t{\n\t\t\tif (output == null) throw new ArgumentNullException(\"output\");\n\t\t\t_instanceActivity.Output = output;\n\t\t\t_activity.OnActivityCompleted(this);\n\t\t\t_instanceActivity.Status = Enums.WorkflowStepStatus.Completed;\n\t\t}\n\n\t\tpublic void MarkAsAborted()\n\t\t{\n\t\t\t_activity.OnActivityAborted(this);\n\t\t}\n\n\t\tpublic bool TrackActivity()\n\t\t{\n\t\t\tbool trackActivity = false;\n\t\t\tBoolean.TryParse(InstanceVariables.Get(string.Format(\"{0}{1}\", WINSClientLibrary.INSTANCE_VARIABLE_PREFIX, WINSClientLibrary.VAR_TRACK_ACTIVITY)).ToString(), out trackActivity);\n\n\t\t\treturn trackActivity;\n\t\t}\n\n\t\tpublic void PersistVariables()\n\t\t{\n\t\t\tDataStore.SaveInstanceVariables(AccountId, UserAccountUid, Variables.GetAllVariables());\n\t\t}\n\n\t\tpublic void QueueOutput(string linkName, bool createNewContext = false)\n\t\t{\n\t\t\t// Because these are fired when the activity is not completed, we do not want to follow the empty path by default -- we\n\t\t\t// want exact matches only.  Otherwise, you get behavior such as Edit Document outputting twice -- once for the \"User Completed\"\n\t\t\t// output (that goes through here), and the \"Action Completed\" output when the step is actually completed.\n\t\t\t_instance.QueueActivitiesByLink(_instanceActivity, linkName, createNewContext ? CreateLocalWorkflowContext(): 0, followEmptyPathByDefault: false, useLinkName: true);\n\t\t}\n\n\t\tpublic void UpdateInformation(string information)\n\t\t{\n\t\t\t_instance.Model.Information = information;\n\t\t\tSaveInstance();\n\t\t}\n\n\t\tpublic int AccountId { get { return _instanceActivity.AccountId; } }\n\n\t\tpublic IWINSActivity Activity\n\t\t{\n\t\t\tget { return _activity; }\n\t\t}\n\n\t\tpublic string ActivityName { get { return _activity.Name; } }\n\n\t\tpublic string ActivityTypeName { get { return _instanceActivity.ActivityTypeName; } }\n\n\t\tpublic Guid ActivityUid { get { return _instanceActivity.Uid; } }\n\n\t\tpublic DateTime ActivityStartDate { get { return _instanceActivity.StartDate; } }\n\n\t\tprivate WorkflowInstanceVariableHandler _instanceVariables;\n\t\tpublic WorkflowInstanceVariableHandler InstanceVariables\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_instanceVariables == null) _instanceVariables = new WorkflowInstanceVariableHandler(this);\n\t\t\t\treturn _instanceVariables;\n\t\t\t}\n\t\t}\n\n\t\tIInstanceVariableHandler IWorkflowContext.InstanceVariables\n\t\t{\n\t\t\tget { return InstanceVariables; }\n\t\t}\n\n\t\tprivate WorkflowActivityVariableHandler _activityVariables;\n\t\tpublic WorkflowActivityVariableHandler ActivityVariables\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_activityVariables == null) _activityVariables = new WorkflowActivityVariableHandler(this);\n\t\t\t\treturn _activityVariables;\n\t\t\t}\n\t\t}\n\n\t\tIActivityVariableHandler IWorkflowContext.ActivityVariables\n\t\t{\n\t\t\tget { return ActivityVariables; }\n\t\t}\n\n\t\t[NonSerialized]\n\t\tprivate WorkflowBookmarkHandler _bookmarks = null;\n\t\tpublic IWorkflowBookmarkHandler Bookmarks\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_bookmarks == null) _bookmarks = new WorkflowBookmarkHandler(this);\n\t\t\t\treturn _bookmarks;\n\t\t\t}\n\t\t}\n\n\t\t[NonSerialized]\n\t\tprivate WorkflowContentHandler _contents;\n\t\tpublic WorkflowContentHandler Contents\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_contents == null) _contents = new WorkflowContentHandler(this, _instance.ContentDefinitions);\n\t\t\t\treturn _contents;\n\t\t\t}\n\t\t}\n\t\tIContentHandler IWorkflowContext.Contents\n\t\t{\n\t\t\tget { return Contents; }\n\t\t}\n\n\t\tpublic IWINSDataStore DataStore { get { return _instance.DataStore; } }\n\n\t\tpublic bool IsEndActivityReached()\n\t\t{\n\t\t\treturn _instance.Model.EndActivityReached;\n\t\t}\n\t\tpublic void SetEndActivityReached()\n\t\t{\n\t\t\t_instance.Model.EndActivityReached = true;\n\t\t}\n\n\t\tpublic void SetWorkflowOutput(string output)\n\t\t{\n\t\t\t_instance.Model.Output = output;\n\t\t}\n\n\t\tpublic void SaveInstance()\n\t\t{\n\t\t\t_instance.DataStore.SaveInstance(_instance.Model);\n\t\t}\n\n\t\tpublic Guid InputActivityUid { get { return _instanceActivity.InputActivityUid; } }\n\n\t\tpublic int LocalWorkflowContextId { get { return _instanceActivity.LocalContextId; } }\n\n\t\tpublic string Output\n\t\t{\n\t\t\tget { return _instanceActivity.Output; }\n\t\t\tset { _instanceActivity.Output = value; }\n\t\t}\n\n\t\tpublic string Parameters { get { return _instance.Model.ParametersXml; } }\n\n\t\tpublic XmlDocument ParametersAsXml\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tstring parameters = Parameters;\n\t\t\t\tif (string.IsNullOrEmpty(parameters)) return WorkflowParameterBuilder.GetEmptyParameters();\n\t\t\t\tXmlDocument xml = new XmlDocument();\n\t\t\t\txml.LoadXMLNoDTD(parameters);\n\t\t\t\treturn xml;\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid ParentActivityUid { get { return _instance.Model.ParentActivityUid; } }\n\n\t\tpublic Guid ScopeUid { get { return _instance.Model.ScopeUid; } }\n\n\t\tpublic string ScopeName\n\t\t{\n\t\t\tget { return _instance.Model.ScopeName; }\n\t\t\tset { _instance.Model.ScopeName = value; }\n\t\t}\n\n\t\tpublic string SourceType => _instance.Model.SourceType;\n\n\t\tpublic string SourceId => _instance.Model.SourceId;\n\n\t\tprivate WorkflowPropertyHandler _properties;\n\t\tpublic WorkflowPropertyHandler Properties\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_properties == null) _properties = new WorkflowPropertyHandler(this, _activity);\n\t\t\t\treturn _properties;\n\t\t\t}\n\t\t}\n\t\tIPropertyHandler IWorkflowContext.Properties\n\t\t{\n\t\t\tget { return Properties; }\n\t\t}\n\n\t\t[NonSerialized]\n\t\tprivate IResourceCompatibility _sendTo;\n\t\tpublic IResourceCompatibility SendTo\n\t\t{\n\t\t\tget { return _sendTo; }\n\t\t\tset { _sendTo = value; }\n\t\t}\n\n\t\tpublic Guid SubmittedByUid { get { return _instance.Model.StartBPMUserUid; } }\n\t\tpublic UserAccount _submitter = null;\n\t\tpublic UserAccount Submitter\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_submitter == null)\n\t\t\t\t{\n\t\t\t\t\tUserAccount user = UserAccountPersistence.AuthenticationInstance.LoadByUid(SubmittedByUid);\n\t\t\t\t\tif (user == null) user = WorkflowUserAccount;\n\t\t\t\t\t_submitter = user;\n\t\t\t\t}\n\t\t\t\treturn _submitter;\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid UserAccountUid { get; } = Constants.WorkflowUser;\n\n\t\t[NonSerialized]\n\t\tprivate WorkflowVariableHandler _variables;\n\t\tpublic WorkflowVariableHandler Variables\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_variables == null) _variables = new WorkflowVariableHandler(this, _instance.Variables);\n\t\t\t\treturn _variables;\n\t\t\t}\n\t\t}\n\t\tIVariableHandler IWorkflowContext.Variables\n\t\t{\n\t\t\tget { return Variables; }\n\t\t}\n\n\t\tpublic string WorkflowName { get { return _instance.Model.Name; } }\n\n\t\tprivate UserAccount _workflowUserAccount;\n\t\tpublic UserAccount WorkflowUserAccount\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_workflowUserAccount != null) return _workflowUserAccount;\n\n\t\t\t\tvar workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(AccountId);\n\t\t\t\tif (workflowConfig?.UseDirectWorkflowUserAccountInitialization == true)\n\t\t\t\t{\n\t\t\t\t\tLoggingHelper.LogInfoNoPII(this, \"UseDirectWorkflowUserAccountInitialization is set to true\");\n\t\t\t\t\treturn _workflowUserAccount = UserAccount.WorkflowUserAccount(AccountId);\n\t\t\t\t}\n\n\t\t\t\treturn _workflowUserAccount = ServiceLocator.GetInstance<IUserAccountRepository>().LoadByUid(AccountId, WorkflowUserAccountUid);\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid WorkflowUserAccountUid => Constants.WorkflowUser;\n\n\t\t[NonSerialized]\n\t\tprivate WorkflowXmlVariableHandler _xmlVariables;\n\t\tpublic WorkflowXmlVariableHandler XmlVariables\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_xmlVariables == null) _xmlVariables = new WorkflowXmlVariableHandler(this, _instance.XmlVariableDefinitions);\n\t\t\t\treturn _xmlVariables;\n\t\t\t}\n\t\t}\n\n\t\tIXmlVariableHandler IWorkflowContext.XmlVariables\n\t\t{\n\t\t\tget { return XmlVariables; }\n\t\t}\n\n\t\tpublic UserAccount CompletingUser { get; set; }\n\n\t\tpublic UserAccount AssignedUser { get; set; }\n\n\t\tpublic InstanceActivity InstanceActivity => _instanceActivity;\n\n\t\tpublic string FormatActivityVariableName(string name)\n\t\t{\n\t\t\treturn WorkflowVariableHandler.FormatActivityVariableName(ActivityName, name);\n\t\t}\n\t}\n}\n",
      "relevance_score": 0.7
    }
  ],
  "reasoning_chain": "ReasoningChain(strategy=<ReasoningStrategy.CHAIN_OF_THOUGHT: 'chain_of_thought'>, steps=[ReasoningStep(step_number=1, description='Step 1 \u2013 Analysis', reasoning='Step 1 \u2013 Analysis  \\n\u2022 Requirement: enrich every \u201cHTTP server span\u201d in the CLM web application with two extra attributes.  \\n\u2022 Attribute sources:  ', conclusion='\u2022 Attribute sources:  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=2, description='Step 2 \u2013 Planning', reasoning='Step 2 \u2013 Planning  \\n\u2022 Modify only those *.Trace.cs files that already have OpenTelemetry Activity/Span creation code.  \\n\u2022 Within the part where the Activity is created (ActivitySource/StartActivity) or enriched (SetTag / SetStatus), add:  ', conclusion='\u2022 Within the part where the Activity is created (ActivitySource/StartActivity) or enriched (SetTag / SetStatus), add:  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=3, description='Step 3 \u2013 Implementation \u2013 SELECTED FILES', reasoning='Step 3 \u2013 Implementation \u2013 SELECTED FILES  \\n1. /Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs  \\n2. /Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs  ', conclusion='2. /Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=4, description='(If after inspection any of these files do not actually start HTTP server spans, drop it during real implementation, but based on naming they are the strongest candidates.)', reasoning='(If after inspection any of these files do not actually start HTTP server spans, drop it during real implementation, but based on naming they are the strongest candidates.)\\n\\nStep 4 \u2013 Validation  ', conclusion='Step 4 \u2013 Validation  ', confidence=0.8, evidence=['LLM analysis']), ReasoningStep(step_number=5, description='Step 4 \u2013 Validation', reasoning='Step 4 \u2013 Validation  \\n\u2022 Unit / integration test: send an HTTP request with a Referer header and a server-side redirect (Location header). Verify via exporter or collector that the resulting span carries the two new attributes.  \\n\u2022 Manual check: run application with OTLP console exporter and inspect span output.', conclusion='\u2022 Manual check: run application with OTLP console exporter and inspect span output.', confidence=0.8, evidence=['LLM analysis'])], final_conclusion='\u2022 Unit / integration test: send an HTTP request with a Referer header and a server-side redirect (Location header). Verify via exporter or collector that the resulting span carries the two new attributes.', overall_confidence=0.8, alternative_approaches=['Alternative approaches considered'])"
}