{
  "execution_summary": {
    "total_stages": 10,
    "completed": 10,
    "failed": 0,
    "cache_hits": 0,
    "total_execution_time": 466.75827503204346
  },
  "stage_details": {
    "ticket_processing": {
      "stage_name": "ticket_processing",
      "status": "StageStatus.COMPLETED",
      "result": "## OpenTelemetry Span Attributes Missing - HTTP Redirect Tracking\n\n**Summary:** Add missing HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION attributes to CLM web application spans\n\n**Problem Description:**\nOur OpenTelemetry spans in the CLM (Contract Lifecycle Management) web application are missing critical HTTP attributes needed for debugging redirect flows and investigating user journey issues. Specifically:\n\n1. **Missing Attribute**: `HTTP_REFERER` - The referring page URL that led to the current request\n2. **Missing Attribute**: `HTTP_RESPONSE_REDIRECT_LOCATION` - The destination URL when a 302/redirect response occurs\n\n**Business Impact:**\n- Cannot trace user navigation flows through CLM application\n- Difficult to investigate redirect-related issues and errors\n- Missing context for 302 responses that redirect to error pages\n\n**Technical Details:**\n\n**Target Application:** CLM Web Application (clm-web)\n**Environment:** Demo (but affects all environments)\n**Specific Pages Affected:**\n- `/clm/Documents/BrowseDocuments.aspx`\n- `/clm/SSO/SSOEndpoint.ashx` \n- Any page that handles redirects (HTTP 302 responses)\n\n**Expected Kusto Query Results:**\nAfter fix, this query should show the missing attributes:\n```kusto\nOtlpSpanEvents\n| where Environment == \"Demo\"\n| where url_path == \"/clm/Documents/BrowseDocuments.aspx\"\n| where http_status_code > 200\n| project Timestamp, url_path, http_status_code, HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION\n```\n\n**Implementation Requirements:**\n\n1. **Add HTTP_REFERER attribute** to all incoming HTTP requests\n   - Source: `Request.Headers[\"Referer\"]` or `HttpContext.Request.Headers.Referer`\n   - Add to span as: `activity.SetTag(\"HTTP_REFERER\", refererValue)`\n\n2. **Add HTTP_RESPONSE_REDIRECT_LOCATION attribute** for redirect responses\n   - Source: `Response.Headers[\"Location\"]` when status code is 301/302/303/307/308\n   - Add to span as: `activity.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", locationValue)`\n\n**Files to Look For:**\n- CLM web application middleware or request handling code\n- ASP.NET request pipeline components\n- OpenTelemetry instrumentation configuration\n- Files containing \"ActivitySource\", \"SetTag\", or \"AddTag\" method calls\n- Middleware files that handle HTTP requests/responses\n- Look for existing telemetry code in CLM-related projects\n\n**Acceptance Criteria:**\n- [ ] HTTP_REFERER attribute captured from incoming request headers\n- [ ] HTTP_RESPONSE_REDIRECT_LOCATION attribute captured for 302+ responses  \n- [ ] Attributes visible in OtlpSpanEvents Kusto table\n- [ ] No performance degradation from additional attribute collection\n- [ ] Proper null/empty value handling for missing headers\n\n**Technical Notes:**\n- Follow existing OpenTelemetry patterns in the codebase\n- Ensure attribute names match exactly: \"HTTP_REFERER\" and \"HTTP_RESPONSE_REDIRECT_LOCATION\"\n- Add attributes to HTTP request spans, not separate spans\n- Handle edge cases where headers might be missing or empty\n",
      "error": null,
      "execution_time": 0.00043511390686035156,
      "cache_hit": false
    },
    "intent_extraction": {
      "stage_name": "intent_extraction",
      "status": "StageStatus.COMPLETED",
      "result": {
        "issue_category": "INSTRUMENTATION",
        "static_analysis_query": {
          "find_method_call": "SetTag"
        },
        "semantic_description": "Add HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION headers as span attributes on CLM web HTTP request spans.",
        "search_keywords": [
          "HTTP_REFERER",
          "HTTP_RESPONSE_REDIRECT_LOCATION",
          "SetTag",
          "ActivitySource",
          "middleware",
          "redirect"
        ],
        "telemetry_operation": {
          "type": "span",
          "target_name": "incoming http request span",
          "action": "ADD_ATTRIBUTES",
          "attributes_to_add": [
            {
              "name": "HTTP_REFERER",
              "value_source": "Request.Headers[\"Referer\"]"
            },
            {
              "name": "HTTP_RESPONSE_REDIRECT_LOCATION",
              "value_source": "Response.Headers[\"Location\"]"
            }
          ],
          "new_span_name": null,
          "new_metric_details": {}
        },
        "confidence": "IntentConfidence.HIGH",
        "operation_type": "OperationType.MULTI_FILE",
        "complexity_score": 5,
        "estimated_files": 3,
        "validation_result": {
          "is_valid": true,
          "confidence": "IntentConfidence.HIGH",
          "issues": [],
          "suggestions": []
        },
        "sub_tasks": [
          {
            "order": 1,
            "name": "Code-base Discovery",
            "action": "locate_configuration",
            "description": "Search clm-web solution for existing OpenTelemetry boot-strapper, ActivitySource registrations, and any custom span enrichment middleware.",
            "search_keywords": [
              "AddOpenTelemetry",
              "UseOpenTelemetry",
              "ActivitySource",
              "SetTag",
              "EnrichWith"
            ],
            "expected_files": [
              "Startup.cs",
              "Program.cs (for .NET 6+)",
              "TelemetryExtensions.cs",
              "OpenTelemetryMiddleware.cs"
            ],
            "validation_criteria": "All files that configure instrumentation are identified and documented."
          },
          {
            "order": 2,
            "name": "Determine Injection Point",
            "action": "design_middleware",
            "description": "Confirm the best place in the ASP.NET pipeline to read request headers early (for Referer) and response headers late (for Location) while staying on the same server span. Usually a custom middleware registered immediately after UseRouting and before UseEndpoints.",
            "dependencies": [
              1
            ],
            "validation_criteria": "Middleware ordering diagram updated; decision recorded in design notes."
          },
          {
            "order": 3,
            "name": "Implement Request Header Enrichment",
            "action": "add_referer_tag",
            "description": "Inside chosen middleware, capture `HttpContext.Request.Headers[\"Referer\"]` (case-insensitive). If not null/empty, call `Activity.Current?.SetTag(\"HTTP_REFERER\", refererValue)`.",
            "code_changes": [
              "Telemetry/RequestEnrichmentMiddleware.cs"
            ],
            "dependencies": [
              2
            ],
            "validation_criteria": "Unit test verifies span includes HTTP_REFERER when header is present and omits when absent."
          },
          {
            "order": 4,
            "name": "Implement Response Header Enrichment",
            "action": "add_redirect_location_tag",
            "description": "After `await _next(context)` returns, inspect `context.Response.StatusCode` for 301,302,303,307,308. If match and `Location` header exists, call `Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", locationValue)`.",
            "code_changes": [
              "Telemetry/RequestEnrichmentMiddleware.cs"
            ],
            "dependencies": [
              3
            ],
            "validation_criteria": "Unit test simulating 302 confirms tag present with correct URL; 200 path confirms tag absent."
          },
          {
            "order": 5,
            "name": "Wire-up Middleware",
            "action": "register_middleware",
            "description": "Add `app.UseMiddleware<RequestEnrichmentMiddleware>();` in Startup.cs/Program.cs immediately after routing.",
            "dependencies": [
              4
            ],
            "validation_criteria": "Application compiles and requests flow correctly with middleware executed."
          },
          {
            "order": 6,
            "name": "Static Analysis / Linter",
            "action": "run_static_analysis",
            "description": "Run Solution analyzers and stylecop; ensure no new warnings. Confirm no PII violations with security linter (full URLs allowed per data-privacy guidelines).",
            "dependencies": [
              5
            ],
            "validation_criteria": "CI passes without new style or security violations."
          },
          {
            "order": 7,
            "name": "Automated Tests",
            "action": "add_tests",
            "description": "Add or extend integration tests that spin up TestServer, issue request with Referer header and simulate redirect response to verify both tags arrive in exported spans (use InMemoryExporter).",
            "expected_files": [
              "TelemetryTests/RequestEnrichmentTests.cs"
            ],
            "dependencies": [
              5
            ],
            "validation_criteria": "New tests pass in CI and fail if tags removed."
          },
          {
            "order": 8,
            "name": "Local Manual Verification",
            "action": "manual_test",
            "description": "Run clm-web locally with OTLP exporter pointed at dev collector + console exporter. Trigger BrowseDocuments.aspx which redirects via SSO. Observe span attributes in console and Grafana/Jaeger.",
            "dependencies": [
              7
            ],
            "validation_criteria": "HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION visible on corresponding span."
          },
          {
            "order": 9,
            "name": "Deploy to Demo Environment",
            "action": "deploy_demo",
            "description": "Promote branch to Demo slot via CI/CD. Enable feature flag `Telemetry.RedirectEnrichment` if gated (optional).",
            "dependencies": [
              8
            ],
            "validation_criteria": "Deployment green; smoke tests succeed."
          },
          {
            "order": 10,
            "name": "Kusto Validation",
            "action": "run_kusto_query",
            "description": "Execute the expected Kusto query provided in ticket. Confirm both columns populated for new traffic.",
            "dependencies": [
              9
            ],
            "validation_criteria": "\u226595% of new 3xx spans contain both attributes when headers present."
          },
          {
            "order": 11,
            "name": "Performance Benchmark",
            "action": "perf_test",
            "description": "Run load test comparing p95 latency before/after. Confirm added tags do not degrade response time >1 ms or increase span size >200 B.",
            "dependencies": [
              10
            ],
            "validation_criteria": "Performance thresholds met."
          },
          {
            "order": 12,
            "name": "Rollout to All Environments",
            "action": "deploy_prod",
            "description": "Merge to main, tag release, promote via staged ring deployment (Test \u2192 Staging \u2192 Prod). Monitor logs & Kusto dashboards.",
            "dependencies": [
              11
            ],
            "validation_criteria": "No errors in production; attributes visible in Prod Kusto."
          },
          {
            "order": 13,
            "name": "Documentation & Closeout",
            "action": "update_docs",
            "description": "Update RUNBOOK.md and Telemetry_Conventions.md with new attributes. Close ticket after stakeholder sign-off.",
            "dependencies": [
              12
            ],
            "validation_criteria": "Docs merged; ticket moved to Done."
          }
        ],
        "contextual_hints": [
          "Hooking the response header capture late enough in the pipeline to guarantee Location header is set for 3xx responses but early enough to be on the same span",
          "Ensuring attributes are only added to the server-side http span (avoiding duplication on nested child spans)",
          "Validating changes across every hosting configuration (IIS, Kestrel, Azure App Service) and all redirect status codes",
          "Writing automated or manual tests that trigger real 302 flows in CI/CD"
        ],
        "similar_patterns": [
          "http-server span enrichment",
          "response redirect attribute capture"
        ],
        "implementation_strategy": {
          "extend_existing": true,
          "create_new": false,
          "preferred_approach": "middleware"
        },
        "exact_requirements": {
          "attribute_names": [
            "HTTP_REFERER",
            "HTTP_RESPONSE_REDIRECT_LOCATION",
            "HTTP_REFERER",
            "HTTP_RESPONSE_REDIRECT_LOCATION"
          ],
          "patterns": [
            "kusto\nOtlpSpanEvents\n| where Environment == \"Demo\"\n| where url_path == \"/clm/Documents/BrowseDocuments.aspx\"\n| where http_status_code > 200\n| project Timestamp, url_path, http_status_code, HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION\n",
            "\n\n**Implementation Requirements:**\n\n1. **Add HTTP_REFERER attribute** to all incoming HTTP requests\n   - Source: ",
            "\n   - Add to span as: ",
            "\n\n2. **Add HTTP_RESPONSE_REDIRECT_LOCATION attribute** for redirect responses\n   - Source: ",
            " when status code is 301/302/303/307/308\n   - Add to span as: "
          ],
          "implementation_notes": [
            "SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", locationValue)`\n\n**Files to Look For:**\n- CLM web application middleware or request handling code\n- ASP",
            "NET request pipeline components\n- OpenTelemetry instrumentation configuration\n- Files containing \"ActivitySource\", \"SetTag\", or \"AddTag\" method calls\n- Middleware files that handle HTTP requests/responses\n- Look for existing telemetry code in CLM-related projects\n\n**Acceptance Criteria:**\n- [ ] HTTP_REFERER attribute captured from incoming request headers\n- [ ] HTTP_RESPONSE_REDIRECT_LOCATION attribute captured for 302+ responses  \n- [ ] Attributes visible in OtlpSpanEvents Kusto table\n- [ ] No performance degradation from additional attribute collection\n- [ ] Proper null/empty value handling for missing headers\n\n**Technical Notes:**\n- Follow existing OpenTelemetry patterns in the codebase\n- Ensure attribute names match exactly: \"HTTP_REFERER\" and \"HTTP_RESPONSE_REDIRECT_LOCATION\"\n- Add attributes to HTTP request spans, not separate spans\n- Handle edge cases where headers might be missing or empty"
          ]
        },
        "telemetry_analysis": null
      },
      "error": null,
      "execution_time": 35.55663514137268,
      "cache_hit": false
    },
    "project_parsing": {
      "stage_name": "project_parsing",
      "status": "StageStatus.COMPLETED",
      "result": [
        "/Users/shuaib.tabit/Documents/Atlas/src/ActIntegration\\ActIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdminService\\AdminService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdvancedInsightsService\\AdvancedInsightsService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AdvancedInsightsService.IntegrationTests\\AdvancedInsightsService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AgreementDefinitionModel\\AdmIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.ABAC.PDP\\API.ABAC.PDP.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation.IntegrationTests/API.Allocation.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/API.Allocation.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Authentication\\API.Authentication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Common\\API.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Content\\API.Content.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Content.EndToEndTests\\API.Content.EndToEndTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal.Common\\API.DocuSignInternal.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal.IntegrationTests\\API.DocuSignInternal.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal\\API.DocuSignInternal.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper.IntegrationTests/API.GateKeeper.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper\\API.GateKeeper.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch.EndToEndTests\\API.OpenSearch.EndToEndTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch\\API.OpenSearch.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Provisioning.IntegrationTests/API.Provisioning.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.Provisioning\\API.Provisioning.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI\\API.SfGenAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WebAPI\\API.WebAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities\\API.WorkflowActivities.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities.IntegrationTests\\API.WorkflowActivities.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities.Client/API.WorkflowActivities.Client.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowDesign\\API.WorkflowDesign.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowDesign.IntegrationTests\\API.WorkflowDesign.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities\\Atlas.Workflow.Activities.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Client\\Atlas.Workflow.Client.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Readers\\Atlas.Workflow.Readers.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService\\AtlasDataManipulationService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService.IntegrationTests\\AtlasDataManipulationService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthenticationApplication\\AuthenticationApplication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthenticationApplication.IntegrationTests\\AuthenticationApplication.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthMaintenanceService\\AuthMaintenanceService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/AuthMaintenanceService.IntegrationTests\\AuthMaintenanceService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Automation.Toolkit.Tests\\Automation.Toolkit.Tests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ChatNotification\\ChatNotification.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CodeRunner\\CodeRunner.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Collaboration.Core\\Collaboration.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Collaboration.Infrastructure\\Collaboration.Infrastructure.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ConnectServiceIntegration\\ConnectServiceIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain.Testing\\Core.Domain.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain\\Core.Domain.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework\\Core.ServiceFramework.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework.Testing\\Core.ServiceFramework.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types\\Core.Types.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRules\\CustomRules.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRuleService\\CustomRuleService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CustomRuleService.IntegrationTests\\CustomRuleService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService\\DetectTypeService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService.IntegrationTests\\DetectTypeService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocToPDFService\\DocToPDFService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocToPDFService.IntegrationTests\\DocToPDFService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentAssembly\\DocumentAssembly.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCompareService\\DocumentCompareService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCompareService.IntegrationTests\\DocumentCompareService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCreation\\DocumentCreation.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCreation.IntegrationTests\\DocumentCreation.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElasticCore\\ElasticCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElasticIndexing\\ElasticIndexing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ElectronicSignature\\ElectronicSignature.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService\\ESignatureService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService.IntegrationTests\\ESignatureService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ETL\\ETL.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ExtractService\\ExtractService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ExtractService.IntegrationTests\\ExtractService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Fax\\Fax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/FormGen\\FormGen.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GenericEventProcessor\\GenericEventProcessor.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GenericEventProcessor.IntegrationTests\\GenericEventProcessor.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/GraphQLCore\\GraphQLCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/HtmlService\\HtmlService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/InboundFax\\InboundFax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/InteractivePreviewCore\\InteractivePreviewCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MaintenanceService\\MaintenanceService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MenuActions\\DocumentReviewMenuActions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService\\MessageWorkerService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/NewsService\\NewsService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/NewsService.IntegrationTests\\NewsService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ObligationManagementIntegration\\ObligationManagementIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OfficeWebAppsAPI.IntegrationTests/OfficeWebAppsAPI.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OfficeWebAppsAPI\\OfficeWebAppsAPI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OneConfig.Testing\\OneConfig.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients\\DacDocGenApiClient\\DacDocGenApiClient.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients\\Doc2PdfApiClient\\Doc2PdfApiClient.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OrchestrationIntegration\\OrchestrationIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEmail\\OutboundEmail.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEmail.IntegrationTests\\OutboundEmail.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEvent\\OutboundEvent.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundEvent.IntegrationTests\\OutboundEvent.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundFax\\OutboundFax.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/OutboundHttpService\\OutboundHttpService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Packaging\\Packaging.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/PdfService\\PdfService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProcessBuilder\\ProcessBuilder.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProfileLogger\\ProfileLogger.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProxyLayer\\ProxyLayer.Core\\ProxyLayer.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ProxyLayer\\ProxyLayer.Infrastructure\\ProxyLayer.Infrastructure.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ReportingService\\ReportingService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/ReportingService.IntegrationTests\\ReportingService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication\\REST.Authentication.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Common\\REST.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content\\REST.Content.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/REST.WebServices\\REST.WebServices.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/RtmIntegration\\RtmIntegration.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SANitationService\\SANitationService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SForce.Core\\SForce.Core.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SForce.Services\\SForce.Services.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SFTPServer\\SFTPServer.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SFTPServer.IntegrationTests\\SFTPServer.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SharedTemplates\\SharedTemplates.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SMTPServer\\SMTPServer.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/SMTPServer.IntegrationTests\\SMTPServer.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/StructuredDocumentService\\StructuredDocumentService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/StructuredDocumentService.IntegrationTests\\StructuredDocumentService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TaskProcessor\\TaskProcessor.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TreeService\\TreeService.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/TreeService.IntegrationTests\\TreeService.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/UserTaskList\\UserTaskList.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback\\VendorCallback.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Testing\\Web.Common.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Abstractions/Web.Common.Abstractions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.Resources/Web.Common.Resources.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common\\Web.Common.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Web.Common.AspNetCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.Abstractions\\Web.CommonUI.Abstractions.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.Resources/Web.CommonUI.Resources.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI\\Web.CommonUI.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI.AspNetCore\\Web.CommonUI.AspNetCore\\Web.CommonUI.AspNetCore.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.IntegrationTests\\Web.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web.Testing\\Web.Testing.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/Web\\Web.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebNet\\WebNet.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebNet.IntegrationTests\\WebNet.IntegrationTests.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebContent\\WebContent.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebShare\\WebShare.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap\\WebSoap.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WINS.Protocol\\WINS.Protocol.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WINS\\WINS.csproj",
        "/Users/shuaib.tabit/Documents/Atlas/src/CLM.Search\\dirs.proj",
        "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap.EndToEndTests\\WebSoap.EndToEndTests.csproj"
      ],
      "error": null,
      "execution_time": 0.01108407974243164,
      "cache_hit": false
    },
    "graph_building": {
      "stage_name": "graph_building",
      "status": "StageStatus.COMPLETED",
      "result": {
        "projects_count": 143,
        "graph_loaded": true
      },
      "error": null,
      "execution_time": 410.2729799747467,
      "cache_hit": false
    },
    "intelligent_search": {
      "stage_name": "intelligent_search",
      "status": "StageStatus.COMPLETED",
      "result": [
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (4 occurrences); Contains method call: SetTag (4 times); Matches 2 keywords: SetTag, ActivitySource; Matches 2 keywords: SetTag, ActivitySource",
          "matching_patterns": [
            "SetTag",
            "ActivitySource"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)",
            "?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);",
            "?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (4 occurrences); Contains method call: SetTag (4 times); Matches 2 keywords: SetTag, ActivitySource; Matches 2 keywords: SetTag, ActivitySource",
          "matching_patterns": [
            "SetTag",
            "ActivitySource"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)",
            "?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);",
            "?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "Logger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (2 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: OpenTelemetry.Metrics; Matches 4 keywords: HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION, SetTag, redirect; Matches 4 keywords: HTTP_REFERER, HTTP_RESPONSE_REDIRECT_LOCATION, SetTag, redirect",
          "matching_patterns": [
            "Pattern: OpenTelemetry",
            "HTTP_RESPONSE_REDIRECT_LOCATION",
            "Pattern: UseOpenTelemetry",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Import: OpenTelemetry.Trace",
            "Import: OpenTelemetry.Metrics",
            "SetTag",
            "Pattern: Monitoring",
            "Import: DocuSign.CLM.Monitoring",
            "Pattern: Metrics",
            "redirect",
            "HTTP_REFERER"
          ],
          "context_snippets": [
            "// [ATL-90561] Adding HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION to traces for NetFramework\n\t\t\t\t\t\t//options.EnrichWithHttpResponse = (Activity activity, HttpResponse response) =>\n\t\t\t\t\t\t//\t{\n\t\t\t\t\t\t//\t\tactivity.SetTag(OtelSemanticConventions.AttributeHttpResponseRedirectUrl, response?.Headers[\"Location\"]);\n\t\t\t\t\t\t//\t};\n\t\t\t\t\t\t//\toptions.EnrichWithHttpRequest = (Activity activity, HttpRequest request) =>\n\t\t\t\t\t\t//\t{",
            "//\t};\n\t\t\t\t\t\t//\toptions.EnrichWithHttpRequest = (Activity activity, HttpRequest request) =>\n\t\t\t\t\t\t//\t{\n\t\t\t\t\t\t//\t\tactivity.SetTag(OtelSemanticConventions.AttributeHttpReferer, request?.Headers[\"Referer\"]);\n\t\t\t\t\t\t//\t};\n\t\t\t\t\t\t.AddAspNetInstrumentation(options =>\n\t\t\t\t\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
          "matching_patterns": [
            "Pattern: OpenTelemetry",
            "Import: DocuSign.Monitoring",
            "Pattern: Instrumentation",
            "Import: var activity = StartActivity(task, corrToken)",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: ActivitySource",
            "Pattern: Monitoring",
            "SetTag",
            "Import: DocuSign.CLM.Monitoring",
            "Pattern: StartActivity"
          ],
          "context_snippets": [
            "ActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);",
            "parentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (9 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid), Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid); Contains method call: SetTag (9 times)",
          "matching_patterns": [
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid)",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: ActivitySource",
            "Import: var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid)",
            "SetTag",
            "Pattern: StartActivity",
            "Import: var span = StartActivity()"
          ],
          "context_snippets": [
            "LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));",
            "LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;",
            "private Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)",
            "?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)",
            ".SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);",
            ".SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);",
            ".SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()",
            ".SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (54 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: OpenTelemetry.Trace, Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId); Contains method call: SetTag (54 times)",
          "matching_patterns": [
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)",
            "SetTag",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid)",
            "Pattern: OpenTelemetry",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid)",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid)",
            "Pattern: AddTag",
            "Import: OpenTelemetry.Trace",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)",
            "Pattern: StartActivity",
            "Import: var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid)"
          ],
          "context_snippets": [
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);",
            "{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.StartParameters?.Submitter);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartRoutingApprovalWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);",
            "request.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t\treturn Task.FromResult(new SendStartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))\n\t\t{",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);",
            "ServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);",
            "{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))",
            "using var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "private void OnPostRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(HttpContext.Current);\n\t\t\tLogSessionSize(HttpContext.Current?.Session);\n\t\t\t_performanceLog.SetSession(HttpContext.Current?.Session);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tPopulateFeatureFlagContext(AtlasContext.Current.UserAccount, context);\n\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
          "matching_patterns": [
            "Pattern: OpenTelemetry",
            "Import: OpenTelemetry.Instrumentation.AspNet",
            "Import: var activity = StartActivity()\n\t\t\t\t?.SetStatus(ActivityStatusCode.Ok)",
            "Import: DocuSign.Monitoring",
            "Pattern: Instrumentation",
            "Import: OpenTelemetry.Context.Propagation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Import: OpenTelemetry.Trace",
            "Pattern: ActivitySource",
            "SetTag",
            "Pattern: Monitoring",
            "Import: DocuSign.CLM.Monitoring",
            "Import: var activity = StartActivity()",
            "Pattern: StartActivity"
          ],
          "context_snippets": [
            "private Activity StartActivity([CallerMemberName] string name = \"\") =>\n\t\t\tSessionStateProviderActivitySource\n\t\t\t\t.StartActivity($\"{nameof(RedisSessionStateProviderWrapper)}.{name}\")\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n\n\t\t#endregion\n\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences); Telemetry infrastructure: Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions, Import: var activity = StartActivity()",
          "matching_patterns": [
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
            "Pattern: ActivitySource",
            "SetTag",
            "Pattern: Metrics",
            "Import: var activity = StartActivity()",
            "Pattern: StartActivity",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions"
          ],
          "context_snippets": [
            "{\n\t\t\tvar result = MimeLookup.GetMimeType(filePath);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))",
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.UrlMon))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);",
            "?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.UrlMon))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n\n\tstatic class MimeLookup"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (3 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "using var stream = File.OpenRead(filePath);\n\t\t\tvar result = MimeGuesser.GuessMimeType(stream);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))",
            "_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.MimeGuesser))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n}",
            "?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.MimeGuesser))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (5 occurrences); Contains method call: SetTag (5 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "_serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity($\"{InstrumentationNames.MediaInfo}.{name}\")\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t\t?.SetMetricName(InstrumentationNames.MediaInfo);\n\n\t\tprivate Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>",
            "private Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);",
            "private Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}",
            "activity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}",
            "?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (6 occurrences); Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "where T : IQueueTask\n\t\t=>\n\t\tactivity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);",
            "=>\n\t\tactivity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);",
            "activity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);\n\n\tpublic static Activity? SetQueueTaskResultTags<T>(this Activity? activity, T task, ProcessTaskResult result)",
            "?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);\n\n\tpublic static Activity? SetQueueTaskResultTags<T>(this Activity? activity, T task, ProcessTaskResult result)\n\t\twhere T : IQueueTask",
            "where T : IQueueTask\n\t\t=>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageResultMessage, result.Message)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageLastErrorMessage, task.LastErrorMessage);\n}\n#nullable restore",
            "=>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageResultMessage, result.Message)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageLastErrorMessage, task.LastErrorMessage);\n}\n#nullable restore"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 100,
          "reasoning": "Direct match for 'SetTag' (1 occurrences)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "try\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}"
          ],
          "confidence": 0.95
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics, Import: OpenTelemetry.Metrics",
          "matching_patterns": [
            "Import: DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics",
            "Import: OpenTelemetry.Metrics",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Config file: program.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: ADEXS.Caching.OpenTelemetry.Extensions, Import: ADEXS.CqlCorePersistence.OpenTelemetry, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
          "matching_patterns": [
            "Import: ADEXS.Caching.OpenTelemetry.Extensions",
            "Import: ADEXS.CqlCorePersistence.OpenTelemetry",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions",
            "Import: DocuSign.Msf.AspNet.OpenTelemetry",
            "Import: OpenTelemetry.Exporter",
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: ConfigureServices",
            "Config file: startup.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/ICoreInstrumentationLifetimeService.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace, Pattern: OpenTelemetry",
          "matching_patterns": [
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: TracerProvider",
            "Pattern: MeterProvider",
            "Config file: icoreinstrumentationlifetimeservice.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/CoreInstrumentationLifetimeService.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 100,
          "reasoning": "Telemetry infrastructure: Import: ADEXS.ServiceFramework.OpenTelemetry.Extensions, Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace",
          "matching_patterns": [
            "Import: ADEXS.ServiceFramework.OpenTelemetry.Extensions",
            "Import: OpenTelemetry.Metrics",
            "Import: OpenTelemetry.Trace",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Metrics",
            "Pattern: TracerProvider",
            "Pattern: MeterProvider",
            "Config file: coreinstrumentationlifetimeservice.cs"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (15 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "using var saveActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes));\n\t\t\tsaveActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar stopwatch = Stopwatch.StartNew();",
            "?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes));\n\t\t\tsaveActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar statusMessages = new Messages();",
            "{\n\t\t\t\tattrvm = WebUtility.HtmlDecode(attrvm);\n\t\t\t\tvar attributes = attrvm.ToObject<AttributesViewModel>();\n\t\t\t\tsaveActivity?.SetTag(\"docusign.document.id\", attributes.docUid);\n\n\t\t\t\tvar document = LoadAndValidateDocument(attributes.docUid);",
            "using var loadActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\tif (!HasSufficientRightsToView())",
            "using var loadGroupSchemaActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry",
            "using var refreshActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "using var loadCascadingDropdownOptionsActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);",
            "?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Controls/FormExtensions.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (10 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "{\n               tag.MergeAttribute(\"id\", id);\n           }\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, Dictionary<string, string> attributes)",
            "private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, Dictionary<string, string> attributes)\n       {\n           tag.MergeAttributes(attributes);\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasImageTag(TTagBuilder tag, string spriteClassName, string additionalClassName)",
            "{\n           tag.ApplyHtmlAttributes(htmlAttributes);\n           tag.AddCssClass(\"LinkButton\");\n           SetTagContent(tag, string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Close : text);\n           if (!tag.Attributes.ContainsKey(\"onclick\"))\n           {\n               tag.Attributes.Add(\"onclick\", \"CloseWindoid();return false;\");",
            "}\n           }, TTagRenderMode.SelfClosing);\n\n           SetTagContent(tag, imageHtml);\n       }\n\n       private static THtml BuildAtlasMetadataField(THtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value, CultureInfo culture)",
            "div.ApplyHtmlAttributes(htmlAttributes);\n           div.AddCssClass(\"atlasfield\");\n           div.Attributes.Add(\"id\", $\"{member.Member.Name}Field\");\n           SetTagContent(div, labelHtml, controlHtml);\n       }\n\n       private static void ConfigureFaUxFieldFor<TModel, TValue>(TTagBuilder div, Expression<Func<TModel, TValue>> expression, object htmlAttributes, THtml labelHtml, THtml controlHtml)",
            "t.AddCssClass(\"theme_primary-dark_background-color\");\n           });\n\n           SetTagContent(div, icon, controlHtml, labelHtml, spanLine);\n       }\n\n       private static TTagBuilder BuildLabel(string name, string displayName)",
            "var tag = new TTagBuilder(\"label\");\n           tag.Attributes[\"for\"] = name;\n           tag.AddCssClass(AtlasLabelName);\n           SetTagContent(tag, displayName);\n           return tag;\n       }",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, string content)\n       {\n#if NETFRAMEWORK\n           tag.SetInnerText(content);",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, THtml htmlContent)\n       {\n#if NETFRAMEWORK\n           tag.InnerHtml = htmlContent.ToHtmlString();",
            "/// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, params THtml[] htmlContents)\n       {\n#if NETFRAMEWORK\n           using (var writer = new StringWriter())"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowScopeEvents/WorkflowScopeEventsController.Trace.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowActivities/WorkflowActivitiesController.Trace.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (6 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowDefinition/WorkflowDefinitionController.Trace.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (4 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            ".StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);",
            ".SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}",
            "?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}",
            "?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs",
          "strategy": "SearchStrategy.STRUCTURAL",
          "relevance_score": 100,
          "reasoning": "Contains method call: SetTag (7 times)",
          "matching_patterns": [
            "SetTag"
          ],
          "context_snippets": [
            "namespace ADEXS.Core.Domain.Utilities;\npublic static class ActivityEnricher\n{\n\tpublic static void SetTagsWithCommonFields(this Activity activity, HttpContext context)\n\t{\n\t\tif (activity == null)\n\t\t{",
            "{\n\t\tif (AtlasContext.Current != null && AtlasContext.Current.AccountId != 0 && AtlasContext.Current.AccountId != int.MinValue)\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, AtlasContext.Current.AccountId);\n\t\t\treturn;\n\t\t}",
            "var account = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(account))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, account);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}",
            "{\n\t\tif (AtlasContext.Current != null && !System.Guid.Empty.Equals(AtlasContext.Current.UserAccountUid))\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, AtlasContext.Current.UserAccountUid);\n\t\t\treturn;\n\t\t}",
            "var userId = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(userId))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userId);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}",
            "{\n\t\tif (!string.IsNullOrEmpty(context?.Session?.SessionID))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, context?.Session?.SessionID);\n\t\t}\n\t}\n#else",
            "var session = context == null ? null : GetSession(context);\n\t\tif (!string.IsNullOrEmpty(session?.Id))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, session?.Id);\n\t\t}\n\t}"
          ],
          "confidence": 0.9
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Constants.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 100,
          "reasoning": "file contains configuration or constants; contains telemetry symbol: ADEXS.Core.Types.Constants.Forms.EmitMetafieldInputAttribute(System.Guid); has relationship to telemetry symbol: ADEXS.Core.Types.Constants.Forms.EmitMetafieldInputAttribute(System.Guid); contains telemetry symbol: ADEXS.Core.Types.Constants.Forms.EmitMetagroupLabelElement(System.Guid); symbol is application entry point or middleware; contains HTTP-related constant: ADEXS.Core.Types.Constants.CustomHeaders; contains HTTP-related constant: ADEXS.Core.Types.Constants.DocuSignCustomHeaders; contains HTTP-related constant: ADEXS.Core.Types.Constants.ActCustomHeaders; contains HTTP-related constant: ADEXS.Core.Types.Constants.HttpContextCache; contains HTTP-related constant: ADEXS.Core.Types.Constants.HttpContextCookie; contains telemetry symbol: ADEXS.Core.Types.Constants.SystemMetadataGroupNames; contains telemetry symbol: ADEXS.Core.Types.Constants.HtmlAttributes; contains HTTP-related constant: ADEXS.Core.Types.Constants.Allocation; contains telemetry symbol: ADEXS.Core.Types.Constants.FileDataSource.UploadSourceAttribute; contains telemetry symbol: ADEXS.Core.Types.Constants.MetadataHtmlAttributes; contains telemetry symbol: ADEXS.Core.Types.Constants.AgreementDetailsImpliedMetadataGuids",
          "matching_patterns": [
            "configuration_pattern",
            "telemetry_symbol_ADEXS.Core.Types.Constants.Forms.EmitMetafieldInputAttribute(System.Guid)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Types.Constants.Forms.EmitMetagroupLabelElement(System.Guid)",
            "application_entry_point",
            "http_constant_ADEXS.Core.Types.Constants.CustomHeaders",
            "http_constant_ADEXS.Core.Types.Constants.DocuSignCustomHeaders",
            "http_constant_ADEXS.Core.Types.Constants.ActCustomHeaders",
            "http_constant_ADEXS.Core.Types.Constants.HttpContextCache",
            "http_constant_ADEXS.Core.Types.Constants.HttpContextCookie",
            "telemetry_symbol_ADEXS.Core.Types.Constants.SystemMetadataGroupNames",
            "telemetry_symbol_ADEXS.Core.Types.Constants.HtmlAttributes",
            "http_constant_ADEXS.Core.Types.Constants.Allocation",
            "telemetry_symbol_ADEXS.Core.Types.Constants.FileDataSource.UploadSourceAttribute",
            "telemetry_symbol_ADEXS.Core.Types.Constants.MetadataHtmlAttributes",
            "telemetry_symbol_ADEXS.Core.Types.Constants.AgreementDetailsImpliedMetadataGuids"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Enums.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 100,
          "reasoning": "has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool); has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool); has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool); has relationship to telemetry symbol: System.Collections.Generic.IEnumerable<System.ComponentModel.DescriptionAttribute>.FirstOrDefault<System.ComponentModel.DescriptionAttribute>(); has relationship to telemetry symbol: System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo, System.Type); has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool); has relationship to telemetry symbol: System.Reflection.MemberInfo.GetCustomAttributes(System.Type, bool)",
          "matching_patterns": [
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 95,
          "reasoning": "Telemetry infrastructure: Import: Monitoring = DocuSign.Monitoring, Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar result = WINSClientLibrary.CreateNewWorkflowDefinition(user, workflowName), Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
          "matching_patterns": [
            "Import: Monitoring = DocuSign.Monitoring",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar result = WINSClientLibrary.CreateNewWorkflowDefinition(user, workflowName)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.LoadWorkItem(user, workItemUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII(string.Format(\"SubmitWorkItem: WorkItemUid {0}, output {1}\", workItemUid, PII.Encode(output)))",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IVersionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, version.Uid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IRevisionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, revision.Uid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = new Legacy2Designer(new DefinitionReaderLegacy(oldDesign)).Convert(user)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tstring jwtToken = null",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(userAccount.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(userAccount.AccountId, sourceInstanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = WINSClientLibrary.ExportWorkflowDefinition(user, workflowName, versionNumber, revisionNumber)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, workflowName, sourceVersionNumber, sourceRevisionNumber, newVersionNumber, comment)",
            "Import: (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, sourceVersionUid, sourceRevisionNumber, newVersionNumber, comment)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tbool isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(accountId, instanceUid, revisionUid, revisionCreatedDate, activityExecutionCount, out _)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tStartParameters startParameters = new StartParameters(user, xmlParam, sourceType, sourceId)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tGuid result = WorkflowRepository.SendStartWorkflow(user, workflowName, sourceType, sourceId, xmlParam)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, user.Uid, workflowName, xmlParam, sourceType, sourceId, instanceUid)",
            "Import: (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, revisionUid, startParameters, instanceUid)",
            "Pattern: Monitoring"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/ActIntegration/Client/ActIntegrationClient.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequestV2Async(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Guid, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon, bool); has relationship to telemetry symbol: System.TimeSpan.FromSeconds(double); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequestV2(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Guid, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon, bool); has relationship to telemetry symbol: System.TimeSpan.FromSeconds(double); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequest(ADEXS.Core.Domain.Model.UserAccount, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon); has relationship to telemetry symbol: System.TimeSpan.FromSeconds(double); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.GetHttpClient(); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.GetTokenScopesForHttpMethod(System.Net.Http.HttpMethod, ADEXS.ActIntegration.ActAccountInfo); contains HTTP-related constant: ADEXS.ActIntegration.ActIntegrationClient.AddDefaultRequestHeaders(ADEXS.ActIntegration.ActAccountInfo, string, System.Net.Http.HttpClient, string, string, string)",
          "matching_patterns": [
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequestV2Async(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Guid, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon, bool)",
            "telemetry_relationship",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequestV2(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Guid, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon, bool)",
            "telemetry_relationship",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.MakeHttpRequest(ADEXS.Core.Domain.Model.UserAccount, System.Net.Http.HttpMethod, string, string, string, string, int, DocuSign.CLM.Monitoring.SmartMon.ISmartMon)",
            "telemetry_relationship",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.GetHttpClient()",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.GetTokenScopesForHttpMethod(System.Net.Http.HttpMethod, ADEXS.ActIntegration.ActAccountInfo)",
            "http_constant_ADEXS.ActIntegration.ActIntegrationClient.AddDefaultRequestHeaders(ADEXS.ActIntegration.ActAccountInfo, string, System.Net.Http.HttpClient, string, string, string)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients/DacDocGenApiClient/Api/GenApi.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.GenerateDocumentV1WithHttpInfo(string, DacDocGenApiClient.Model.GenerateDocumentRequest); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.GenerateDocumentV1WithHttpInfoAsync(string, DacDocGenApiClient.Model.GenerateDocumentRequest, System.Threading.CancellationToken); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.ParseTemplateV1WithHttpInfo(System.Guid, DacDocGenApiClient.Model.ParseTemplateRequest); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.ParseTemplateV1WithHttpInfoAsync(System.Guid, DacDocGenApiClient.Model.ParseTemplateRequest, System.Threading.CancellationToken); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.UploadTemplateV1WithHttpInfo(System.Guid, string, DacDocGenApiClient.Client.FileParameter, long?); contains HTTP-related constant: DacDocGenApiClient.Api.GenApi.UploadTemplateV1WithHttpInfoAsync(System.Guid, string, DacDocGenApiClient.Client.FileParameter, long?, System.Threading.CancellationToken)",
          "matching_patterns": [
            "http_constant_DacDocGenApiClient.Api.GenApi.GenerateDocumentV1WithHttpInfo(string, DacDocGenApiClient.Model.GenerateDocumentRequest)",
            "http_constant_DacDocGenApiClient.Api.GenApi.GenerateDocumentV1WithHttpInfoAsync(string, DacDocGenApiClient.Model.GenerateDocumentRequest, System.Threading.CancellationToken)",
            "http_constant_DacDocGenApiClient.Api.GenApi.ParseTemplateV1WithHttpInfo(System.Guid, DacDocGenApiClient.Model.ParseTemplateRequest)",
            "http_constant_DacDocGenApiClient.Api.GenApi.ParseTemplateV1WithHttpInfoAsync(System.Guid, DacDocGenApiClient.Model.ParseTemplateRequest, System.Threading.CancellationToken)",
            "http_constant_DacDocGenApiClient.Api.GenApi.UploadTemplateV1WithHttpInfo(System.Guid, string, DacDocGenApiClient.Client.FileParameter, long?)",
            "http_constant_DacDocGenApiClient.Api.GenApi.UploadTemplateV1WithHttpInfoAsync(System.Guid, string, DacDocGenApiClient.Client.FileParameter, long?, System.Threading.CancellationToken)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/OpenApiClients/DacDocGenApiClient/Client/ApiClient.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains HTTP-related constant: DacDocGenApiClient.Client.CustomJsonCodec.Deserialize<T>(System.Net.Http.HttpResponseMessage); contains HTTP-related constant: DacDocGenApiClient.Client.CustomJsonCodec.Deserialize(System.Net.Http.HttpResponseMessage, System.Type); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.NewRequest(System.Net.Http.HttpMethod, string, DacDocGenApiClient.Client.RequestOptions, DacDocGenApiClient.Client.IReadableConfiguration); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.InterceptRequest(System.Net.Http.HttpRequestMessage); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.InterceptResponse(System.Net.Http.HttpRequestMessage, System.Net.Http.HttpResponseMessage); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.ToApiResponse<T>(System.Net.Http.HttpResponseMessage, object, System.Uri); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.Exec<T>(System.Net.Http.HttpRequestMessage, DacDocGenApiClient.Client.IReadableConfiguration); contains HTTP-related constant: DacDocGenApiClient.Client.ApiClient.ExecAsync<T>(System.Net.Http.HttpRequestMessage, DacDocGenApiClient.Client.IReadableConfiguration, System.Threading.CancellationToken)",
          "matching_patterns": [
            "http_constant_DacDocGenApiClient.Client.CustomJsonCodec.Deserialize<T>(System.Net.Http.HttpResponseMessage)",
            "http_constant_DacDocGenApiClient.Client.CustomJsonCodec.Deserialize(System.Net.Http.HttpResponseMessage, System.Type)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.NewRequest(System.Net.Http.HttpMethod, string, DacDocGenApiClient.Client.RequestOptions, DacDocGenApiClient.Client.IReadableConfiguration)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.InterceptRequest(System.Net.Http.HttpRequestMessage)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.InterceptResponse(System.Net.Http.HttpRequestMessage, System.Net.Http.HttpResponseMessage)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.ToApiResponse<T>(System.Net.Http.HttpResponseMessage, object, System.Uri)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.Exec<T>(System.Net.Http.HttpRequestMessage, DacDocGenApiClient.Client.IReadableConfiguration)",
            "http_constant_DacDocGenApiClient.Client.ApiClient.ExecAsync<T>(System.Net.Http.HttpRequestMessage, DacDocGenApiClient.Client.IReadableConfiguration, System.Threading.CancellationToken)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS.Protocol/obj/Debug/net48/docusign/workflow/wins/v1alpha1/WinsModels.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.WriteTagAndValue(ref Google.Protobuf.WriteContext, string); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag()",
          "matching_patterns": [
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS.Protocol/obj/Debug/net48/docusign/workflow/wins/v1alpha1/WinsService.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.WriteTagAndValue(ref Google.Protobuf.WriteContext, string); has relationship to telemetry symbol: Google.Protobuf.FieldCodec<string>.CalculateSizeWithTag(string); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag(); has relationship to telemetry symbol: Google.Protobuf.JsonFormatter.ToDiagnosticString(Google.Protobuf.IMessage); has relationship to telemetry symbol: Google.Protobuf.WriteContext.WriteRawTag(byte); has relationship to telemetry symbol: Google.Protobuf.ParseContext.ReadTag()",
          "matching_patterns": [
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Client/WorkflowDesignRepository.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); has relationship to telemetry symbol: ADEXS.Atlas.Workflow.Client.Telemetry.WorkflowClientTelemetry.GetTimer(string); contains HTTP-related constant: ADEXS.Atlas.Workflow.Client.WorkflowDesignRepository.GetWorkflowDesignApi(int, System.Guid, System.Net.Http.HttpClient, string)",
          "matching_patterns": [
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "http_constant_ADEXS.Atlas.Workflow.Client.WorkflowDesignRepository.GetWorkflowDesignApi(int, System.Guid, System.Net.Http.HttpClient, string)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Adm/Mapping/AdmMapper.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.AgreementMapperTimeSpanUnitsResolver; contains telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.AgreementMapperTimeSpanUnitsResolver.Resolve(ADEXS.Core.Domain.Model.Agreement, DocuSign.Adm.Api.Models.AgreementCreate, ADEXS.Core.Domain.Model.AgreementPeriod, DocuSign.Adm.Api.Models.TimeSpanUnits?, AutoMapper.ResolutionContext); has relationship to telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?); has relationship to telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?); has relationship to telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?); has relationship to telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?); contains telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter; contains telemetry symbol: ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?)",
          "matching_patterns": [
            "telemetry_symbol_ADEXS.Core.Domain.Adm.Mapping.AgreementMapperTimeSpanUnitsResolver",
            "telemetry_symbol_ADEXS.Core.Domain.Adm.Mapping.AgreementMapperTimeSpanUnitsResolver.Resolve(ADEXS.Core.Domain.Model.Agreement, DocuSign.Adm.Api.Models.AgreementCreate, ADEXS.Core.Domain.Model.AgreementPeriod, DocuSign.Adm.Api.Models.TimeSpanUnits?, AutoMapper.ResolutionContext)",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter",
            "telemetry_symbol_ADEXS.Core.Domain.Adm.Mapping.TimeSpanUnitsConverter.Convert(DocuSign.Adm.Api.Models.TimeSpanUnits?)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AIConfiguration/ConfigurationService.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "file contains configuration or constants; has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateAOMAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.GetAttributeGroups(ADEXS.Core.Domain.Model.UserAccount); has relationship to telemetry symbol: ADEXS.Core.Domain.Repository.MetadataRepository.IMetadataGroupRepository.LoadByAccountId(int); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.SaveAttributeMapping(ADEXS.Core.Domain.Model.UserAccount, ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMapping); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateClmAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>); has relationship to telemetry symbol: ADEXS.Core.Domain.Repository.MetadataRepository.IMetadataGroupRepository.LoadByUid(int, System.Guid); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateAOMAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>); has relationship to telemetry symbol: ADEXS.Core.Domain.Repository.AgreementRepository.IAgreementFieldService.GetStandardFields(ADEXS.Core.Domain.Model.UserAccount, ADEXS.Core.Domain.Repository.AgreementRepository.Tag?); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.ConfigurationService.CreateRuleModelMappingBasicDetails(ADEXS.Core.Domain.Model.UserAccount, System.Guid, ADEXS.Core.Domain.Model.MetadataField, ADEXS.Core.Domain.Model.MetadataGroup, System.Collections.Generic.List<ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>); has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsCustomAttributeSupported(ADEXS.Core.Domain.Model.MetadataField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsStandardAttributeSupported(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); has relationship to telemetry symbol: ADEXS.Core.Domain.SmartAgreement.AIModelManagement.IAiModelManagement.GetAllowedModelItemsByAccount(ADEXS.Core.Domain.Model.Account); has relationship to telemetry symbol: ADEXS.Core.Domain.Repository.AgreementRepository.IAgreementFieldService.GetStandardFields(ADEXS.Core.Domain.Model.UserAccount, ADEXS.Core.Domain.Repository.AgreementRepository.Tag?)",
          "matching_patterns": [
            "configuration_pattern",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.GetAttributeGroups(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.SaveAttributeMapping(ADEXS.Core.Domain.Model.UserAccount, ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMapping)",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateClmAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.PopulateAOMAttributes(ADEXS.Core.Domain.Model.UserAccount, System.Guid, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>, System.Collections.Generic.List<ADEXS.Core.Domain.AIConfiguration.Models.RuleModelMappingBasicDetails>, System.Collections.Generic.List<System.Linq.IGrouping<ADEXS.Core.Types.Enums.AIRulesEngineMappingObjectType, ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>>)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.ConfigurationService.CreateRuleModelMappingBasicDetails(ADEXS.Core.Domain.Model.UserAccount, System.Guid, ADEXS.Core.Domain.Model.MetadataField, ADEXS.Core.Domain.Model.MetadataGroup, System.Collections.Generic.List<ADEXS.Core.Domain.Model.AIDocument.AIRulesEngineMapping>)",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AIConfiguration/Utilities/DataTypeHelper.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "file contains configuration or constants; has relationship to telemetry symbol: System.Collections.Generic.Dictionary<ADEXS.Core.Types.Enums.DataType, ADEXS.Core.Types.Enums.AttributeFieldType>.GetValueOrDefault<ADEXS.Core.Types.Enums.DataType, ADEXS.Core.Types.Enums.AttributeFieldType>(ADEXS.Core.Types.Enums.DataType, ADEXS.Core.Types.Enums.AttributeFieldType); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsSupported(ADEXS.Core.Types.Enums.DataType, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsCustomAttributeSupported(ADEXS.Core.Domain.Model.MetadataField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsSupported(ADEXS.Core.Types.Enums.DataType, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsStandardAttributeSupported(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType); has relationship to telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.GetStandardAttributeDataType(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField); contains telemetry symbol: ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.GetStandardAttributeDataType(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField)",
          "matching_patterns": [
            "configuration_pattern",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsSupported(ADEXS.Core.Types.Enums.DataType, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType)",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsCustomAttributeSupported(ADEXS.Core.Domain.Model.MetadataField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.IsStandardAttributeSupported(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField, out ADEXS.Core.Types.Enums.AttributeFieldType, out RulesEngineAPIClient.Model.DataType)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.AIConfiguration.Utilities.DataTypeHelper.GetStandardAttributeDataType(ADEXS.Core.Domain.Repository.AgreementRepository.AgreementField)"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Aom/AomUtilities.cs",
          "strategy": "SearchStrategy.GRAPH_BASED",
          "relevance_score": 90,
          "reasoning": "contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeCustomNameToDefaultDictionary(ADEXS.Core.Domain.Model.UserAccount); contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeDefaultToCustomNameDictionary(ADEXS.Core.Domain.Model.UserAccount); contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeFieldUid(ADEXS.Core.Domain.Model.UserAccount); has relationship to telemetry symbol: LanguageExt.Prelude.Optional<ADEXS.Core.Domain.Model.MetadataGroup>(ADEXS.Core.Domain.Model.MetadataGroup?); contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeFieldUid(System.Guid, ADEXS.Core.Domain.Model.MetadataFields); contains telemetry symbol: ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementValueFieldUid(ADEXS.Core.Domain.Model.UserAccount); has relationship to telemetry symbol: LanguageExt.Prelude.Optional<ADEXS.Core.Domain.Model.MetadataGroup>(ADEXS.Core.Domain.Model.MetadataGroup?); has relationship to telemetry symbol: LanguageExt.Prelude.Optional<ADEXS.Core.Domain.Model.MetadataGroup>(ADEXS.Core.Domain.Model.MetadataGroup?)",
          "matching_patterns": [
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeCustomNameToDefaultDictionary(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeDefaultToCustomNameDictionary(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeFieldUid(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_relationship",
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementTypeFieldUid(System.Guid, ADEXS.Core.Domain.Model.MetadataFields)",
            "telemetry_symbol_ADEXS.Core.Domain.Aom.AomUtilities.GetAgreementValueFieldUid(ADEXS.Core.Domain.Model.UserAccount)",
            "telemetry_relationship",
            "telemetry_relationship"
          ],
          "context_snippets": [],
          "confidence": 0.8
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/AbstractServicedComponent.cs",
          "strategy": "SearchStrategy.PATTERN",
          "relevance_score": 85,
          "reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Monitoring, Import: service invocation to start process,\n\t\t\t\t\t// so Assembly.EntryAssembly is not represents correct service assembly. We are\n\t\t\t\t\t// using GetType().Assembly instead, which would provide correct release version.\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: this.GetType().Assembly))\n\t\t\t\t\t\t\t.GetAwaiter().GetResult()",
          "matching_patterns": [
            "Import: DocuSign.CLM.Monitoring",
            "Import: DocuSign.Monitoring",
            "Import: service invocation to start process,\n\t\t\t\t\t// so Assembly.EntryAssembly is not represents correct service assembly. We are\n\t\t\t\t\t// using GetType().Assembly instead, which would provide correct release version.\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: this.GetType().Assembly))\n\t\t\t\t\t\t\t.GetAwaiter().GetResult()",
            "Pattern: OpenTelemetry",
            "Pattern: Instrumentation",
            "Pattern: Monitoring",
            "Pattern: UseOpenTelemetry"
          ],
          "context_snippets": [],
          "confidence": 0.85
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/GlobalSuppressions.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 80,
          "reasoning": "Matches 2 keywords: middleware, redirect; Matches 2 keywords: middleware, redirect",
          "matching_patterns": [
            "middleware",
            "redirect"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 70,
          "reasoning": "Matches 2 keywords: middleware, redirect; Matches 2 keywords: middleware, redirect",
          "matching_patterns": [
            "middleware",
            "redirect"
          ],
          "context_snippets": [],
          "confidence": 0.6
        },
        {
          "file_path": "/Users/shuaib.tabit/Documents/Atlas/src/AuthenticationApplication/Program.cs",
          "strategy": "SearchStrategy.KEYWORD",
          "relevance_score": 70,
          "reasoning": "Matches 2 keywords: middleware, redirect; Matches 2 keywords: middleware, redirect",
          "matching_patterns": [
            "middleware",
            "redirect"
          ],
          "context_snippets": [],
          "confidence": 0.6
        }
      ],
      "error": null,
      "execution_time": 4.014617919921875,
      "cache_hit": false
    },
    "advanced_analysis": {
      "stage_name": "advanced_analysis",
      "status": "StageStatus.COMPLETED",
      "result": {
        "impact_analysis": {
          "direct_impact": [
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/CoreInstrumentationLifetimeService.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/ICoreInstrumentationLifetimeService.cs"
          ],
          "indirect_impact": [
            "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Persistence/Model/QueueStatePersistence.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/DocumentRepository/DocumentReader.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/BaseApiHandlerSecure.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Activities/Helpers/UpdateVariablesHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/User/UserAccountRepository.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/PerformanceLog.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebShare/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Helpers/InstanceStateChangedHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowContext.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowManager.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WebContent/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Telemetry/WorkflowEventWorkload.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.WebServices/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/REST.Content/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/ExternalTaskWorker.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/Workflow/WorkflowConversion.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/Workflow/InstanceVariable.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.ABAC.PDP/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.WebAPI/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/InstanceWorker.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/API.Authentication/Global.asax.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Models/WorkflowMap.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Infrastructure/LoggingHelper.cs",
            "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowXmlVariableHandler.cs"
          ],
          "risk_score": 10,
          "affected_patterns": [
            "ArchitecturalPattern.DEPENDENCY_INJECTION",
            "ArchitecturalPattern.SINGLETON",
            "ArchitecturalPattern.FACTORY"
          ],
          "breaking_changes": [
            "Service registration changes may affect dependency injection",
            "Startup configuration changes may affect application boot"
          ],
          "test_requirements": [
            "Middleware pipeline integration tests",
            "Unit tests for modified methods",
            "Service registration validation tests",
            "OpenTelemetry span validation tests",
            "Integration tests for telemetry data collection"
          ]
        },
        "code_clusters": [
          {
            "name": "Cluster (12 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/User/UserAccountRepository.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Helpers/InstanceStateChangedHelper.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Activities/Helpers/UpdateVariablesHelper.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/User/UserAccountRepository.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Activities/Helpers/UpdateVariablesHelper.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Helpers/InstanceStateChangedHelper.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowControlInstance.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Exceptions/WorkflowApiRequestThrottledException.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/User/UserAccountRepository.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Activities/Helpers/UpdateVariablesHelper.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/PropertyTypes/StringProperty.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Helpers/InstanceStateChangedHelper.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Workload.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Helpers/InstanceStateChangedHelper.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Model/UserAccount.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Activities/Helpers/UpdateVariablesHelper.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Atlas.Workflow.Activities/Handlers/WorkflowVariableHandler.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowWorkload.cs": []
            },
            "architectural_patterns": [
              "ArchitecturalPattern.SINGLETON"
            ],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 12
          },
          {
            "name": "Cluster (4 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/BaseApiHandlerSecure.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/BaseApiHandlerSecure.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/NpsUtilities.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/AtlasUrlHelper.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 4
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/DocumentRepository/DocumentReader.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/DocumentRepository/DocumentReader.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Repository/DocumentRepository/DocumentReader.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          },
          {
            "name": "Service Layer",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Log.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 3
          },
          {
            "name": "Cluster (4 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/PerformanceLog.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/PerformanceLog.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs",
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/PerformanceLog.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/RequestHeaders/IPAddressUtil.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/AtlasContext.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 4
          },
          {
            "name": "Cluster (10 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WebShare/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/API.Content/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.OpenSearch/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs": [],
              "/Users/shuaib.tabit/Documents/Atlas/src/WebShare/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.SfGenAPI/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/REST.Authentication/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/API.DocuSignInternal/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/WebSoap/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/VendorCallback/Global.asax.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs"
              ]
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/Helpers/ConfigurationHelper.cs"
            ],
            "test_coverage": 0.0,
            "complexity_score": 10
          },
          {
            "name": "Cluster (2 files)",
            "files": [
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Persistence/Model/QueueStatePersistence.cs"
            ],
            "relationships": {
              "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs": [
                "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Persistence/Model/QueueStatePersistence.cs"
              ],
              "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Persistence/Model/QueueStatePersistence.cs": []
            },
            "architectural_patterns": [],
            "entry_points": [],
            "configuration_files": [],
            "test_coverage": 0.0,
            "complexity_score": 2
          }
        ]
      },
      "error": null,
      "execution_time": 0.004909992218017578,
      "cache_hit": false
    },
    "file_selection": {
      "stage_name": "file_selection",
      "status": "StageStatus.COMPLETED",
      "result": {
        "selected_files": [
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
            "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class DetectTypeProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.DetectTypeName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.DetectTypeTask))\n\t\t\t?.SetMetricName(InstrumentationNames.DetectTypeName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignFileDataId, DeserializedPayload.FileDataUid);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
            "content": "\ufeff#nullable enable\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing ServiceTraceSemanticConventions = ADEXS.DetectTypeService.Telemetry.ServiceTraceSemanticConventions;\nusing MqWorkersServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService;\n\npublic partial class VideoInfoProcessor\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.VideoInfoName}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t?.SetTag(MqWorkersServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, nameof(TaskTypes.VideoInfoTask))\n\t\t\t?.SetMetricName(InstrumentationNames.VideoInfoName)\n\t\t\t?.SetQueueTaskTags(Task)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDocumentId, DeserializedPayload.DocumentUid);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net.Mime;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.QueueTasks;\nusing ADEXS.Core.Domain.Persistence;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.PhysicalStorage;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FileIO;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions.Telemetry;\nusing ADEXS.DetectTypeService.MimeLookup;\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\nusing ADEXS.ServiceFramework;\n\nusing DocuSign.CLM.ContentStorage;\n\nnamespace ADEXS.DetectTypeService\n{\n\tpublic partial class DetectTypeProcessor : CommonTaskProcessor<DetectTypeTaskPayload>\n\t{\n\t\tprivate readonly IAtlasPersistenceFactory _atlasPersistenceFactory;\n\n\t\tprivate readonly IAtlasPhysicalStorageFactory _atlasPhysicalStorageFactory;\n\n\t\tprivate readonly IMimeDetector _mimeDetector;\n\n\t\tprivate readonly IDetectTypeServiceFeaturesConfig _featuresConfig;\n\n\t\tpublic DetectTypeProcessor()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IAtlasPersistenceFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IAtlasPhysicalStorageFactory>(),\n\t\t\t\tServiceLocator.GetInstance<IMimeDetector>(),\n\t\t\t\tServiceLocator.GetInstance<IServiceInstrumentation>(),\n\t\t\t\tServiceLocator.GetInstance<IDetectTypeServiceFeaturesConfig>())\n\t\t{\n\t\t}\n\n\t\tpublic DetectTypeProcessor(\n\t\t\tIAtlasPersistenceFactory atlasPersistenceFactory,\n\t\t\tIAtlasPhysicalStorageFactory atlasPhysicalStorageFactory,\n\t\t\tIMimeDetector mimeDetector,\n\t\t\tIServiceInstrumentation serviceInstrumentation,\n\t\t\tIDetectTypeServiceFeaturesConfig featuresConfig)\n\t\t{\n\t\t\t_atlasPersistenceFactory = atlasPersistenceFactory;\n\t\t\t_atlasPhysicalStorageFactory = atlasPhysicalStorageFactory;\n\t\t\t_mimeDetector = mimeDetector;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t\t_featuresConfig = featuresConfig;\n\t\t}\n\n\t\tpublic override ProcessTaskResult ProcessTask()\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t// get and report the status of whether Optimizely is the feature flag provider\n\t\t\tLogger.InfoNoPII($\"Verification: IsOptimizelyVerificationFlagEnabled is {_featuresConfig.IsOptimizelyVerificationFlagEnabled} for account '{Task.AccountId}' (context accountId: '{AtlasContext.Current.AccountId}')\");\n\n\t\t\tProcessTaskResult result = new ProcessTaskResult();\n\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\tvar fileDataPersistence = _atlasPersistenceFactory.Get<IFileDataPersistence>(Task.AccountId);\n\n\t\t\tFileData fd = fileDataPersistence.LoadByUid(DeserializedPayload.FileDataUid);\n\t\t\tif (fd == null)\n\t\t\t{\n\t\t\t\tLogger.WarnNoPII($\"FileDataUid {DeserializedPayload.FileDataUid} does not exist in the db; ignoring\");\n\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\tresult.Message = \"Filedata Doesn't Exist\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// first try and detect the MIME type\n\t\t\t\t\tstring mimeType;\n\t\t\t\t\tusing (TempFile temp = new TempFile(fd.Extension))\n\t\t\t\t\t{\n\t\t\t\t\t\t//We could possibly optimize this by reading the first 256 bytes and passing them to the underlying COM library urlmon.dll.\n\t\t\t\t\t\t//See https://msdn.microsoft.com/en-us/library/ms775107(v=vs.85).aspx (FindMimeFromData function)\n\t\t\t\t\t\t_atlasPhysicalStorageFactory.GetPhysicalStorage(fd.AccountId).GetFile(fd.AccountId, fd.FileName, StorageConstants.StorageFormat.Native, temp.FileName);\n\t\t\t\t\t\tmimeType = _mimeDetector.DetectMimeType(temp.FileName);\n\t\t\t\t\t}\n\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected MIME type '{0}' for fileDataUid {1}.\", mimeType, fd.FileDataUid);\n\n\t\t\t\t\t// if still not sure try to map the extension to the MIME type\n\t\t\t\t\tif (string.IsNullOrEmpty(mimeType) || (mimeType == MediaTypeNames.Application.Octet))\n\t\t\t\t\t{\n\t\t\t\t\t\tmimeType = FileUtil.GetMimeTypeByExtension(fd.Extension);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Matched extension to MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\n\t\t\t\t\t// once we have a new MIME type, save it\n\t\t\t\t\tif (!string.IsNullOrEmpty(mimeType) && mimeType != fd.MIMEType)\n\t\t\t\t\t{\n\t\t\t\t\t\tfileDataPersistence.UpdateMIMEType(fd.Uid, mimeType);\n\t\t\t\t\t\tTask.LastErrorMessage = string.Format(\"Detected and set MIME type '{0}' for fileDataUid {1} with extension '{2}'.\", mimeType, fd.FileDataUid, fd.Extension);\n\t\t\t\t\t}\n\t\t\t\t\tLogger.InfoNoPII(Task.LastErrorMessage);\n\t\t\t\t\tresult.TaskResult = TaskResult.Success;\n\t\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, mimeType);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tresult.TaskResult = TaskResult.Failure;\n\t\t\t\t\te.Trace();\n\t\t\t\t\tLogger.ErrorNoPII($\"Failed to process fileDataUid {fd.FileDataUid} with exception \", e);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tTask.LastErrorMessage = e.Message;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e2)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.ErrorNoPII($\"Failed to mark fileDataUid {fd.FileDataUid} as failed with exception \", e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tactivity?.SetQueueTaskResultTags(Task, result);\n\t\t\treturn result;\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
            "content": "\ufeff// BUGBUG: ATL-71924 Move code dependent on System.Web out of Core.Domain\n#if NETFRAMEWORK\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.ServiceFramework.Helpers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.FeatureFlags;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing log4net;\nusing log4net.Config;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing ApplicationInfo = ADEXS.Core.Domain.Utilities.ApplicationInfo;\n\nnamespace ADEXS.Web.Common;\n\n/// <summary>\n/// Base class for all SCM web applications.\n/// </summary>\npublic abstract class ScmHttpApplication : HttpApplication\n{\n\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\t/// <summary>\n\t/// Don't use the standard Application_Start(). .Net picks one via reflection\n\t/// and runs it. Ends up being this one here, not the one in the derived class.\n\t/// </summary>\n\tprotected void ApplicationStart()\n\t{\n\t\t// log4net initialization\n\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n\t\tXmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\tConfigurationHelper.InitializeConfiguration();\n\n\t\tif (ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\n\t\t// Use MSF specific env variable, fallback to app settings.\n\t\tvar appName = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? AppConfig.AppName(ApplicationInfo.Name);\n\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? SiteConfig.Environment(\"Unknown\");\n\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\n\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\tapplicationName: appName,\n\t\t\tappVersion: typeof(ScmHttpApplication).Assembly.GetName().Version.ToString(),\n\t\t\tenvironmentName: environment,\n\t\t\tsiteName: site,\n\t\t\tpartitionName: partition,\n\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\tshouldEnableLogFileListener: () => Configuration.GetBooleanAppSetting(\"KazmonEnableLogFileListener\", false));\n\n\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t{\n\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\tassembly: typeof(ScmHttpApplication).Assembly,\n\t\t\t\t\tconfigureTracer: tracerProviderBuilder =>\n\t\t\t\t\t{\n\t\t\t\t\t\t_ = tracerProviderBuilder\n\t\t\t\t\t\t// [ATL-90561] Adding HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION to traces for NetFramework\n\t\t\t\t\t\t//options.EnrichWithHttpResponse = (Activity activity, HttpResponse response) =>\n\t\t\t\t\t\t//\t{\n\t\t\t\t\t\t//\t\tactivity.SetTag(OtelSemanticConventions.AttributeHttpResponseRedirectUrl, response?.Headers[\"Location\"]);\n\t\t\t\t\t\t//\t};\n\t\t\t\t\t\t//\toptions.EnrichWithHttpRequest = (Activity activity, HttpRequest request) =>\n\t\t\t\t\t\t//\t{\n\t\t\t\t\t\t//\t\tactivity.SetTag(OtelSemanticConventions.AttributeHttpReferer, request?.Headers[\"Referer\"]);\n\t\t\t\t\t\t//\t};\n\t\t\t\t\t\t.AddAspNetInstrumentation(options =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t})\n\t\t\t\t\t.AddSource(typeof(RedisSessionStateProviderWrapper).FullName);\n\t\t\t\t\t},\n\t\t\t\t\tconfigureMeter: o => o.AddAspNetInstrumentation(options => options.Enrich = (HttpContext context, ref TagList tags) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!tags.Any(t => t.Key == \"http.route\") &&\n\t\t\t\t\t\t\tcontext.Request != null &&\n\t\t\t\t\t\t\t(context.Request.Url.AbsolutePath.EndsWith(\"aspx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"asmx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"ashx\", StringComparison.OrdinalIgnoreCase)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttags.Add(\"url.path\", context.Request.Url.AbsolutePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}))).GetAwaiter().GetResult();\n\t\t\t}\n\t\t}\n\n\t\tif (!ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This one stays the standard Application_End(), as no derive class overrides it.\n\t/// </summary>\n\tprotected virtual void Application_End()\n\t{\n\t\ttry\n\t\t{\n\t\t\tLogManager.Shutdown();\n\t\t}\n\t\tcatch { }\n\n\t\tUninitializeFeatureFlags();\n\n\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t{\n\t\t\t// Run synchronously\n\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t}\n\n\t\tKazmonMonitoring.ShutdownKazmon();\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to initialize feature flags.\n\t/// </summary>\n\tprotected virtual void InitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t}\n\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application shutdown to uninitialize feature flags.\n\t/// </summary>\n\tprotected virtual void UninitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to bootstrap the dependency injection container.\n\t/// </summary>\n\tprotected virtual void Bootstrap()\n\t{\n\t}\n}\n\n#endif\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.MQ;\nusing ADEXS.Core.Domain;\nusing System.Threading;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing System.IO;\nusing ADEXS.Core.Domain.Model;\nusing System.Diagnostics;\n\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.ServiceFramework;\nusing CLM.MessageDefines;\nusing CLM.MessageDefines.Constants;\nusing CLM.MessageDefines.Interfaces;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\n\nusing StructureMap;\nusing ADEXS.MqWorkers.Config.Context;\nusing ADEXS.MqWorkers.Extensions;\nusing ADEXS.MqWorkers.Telemetry;\n\nusing CLM.MessageDefines.Tasks;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.MqWorkers.Config;\n\nnamespace ADEXS.Services.MessageWorkerService\n{\n\t//Should probably make an interface that encapsulates the methods for loading and\n\t//updating the Tasks so that we don't have to be tied to MessageQueues for this type of worker\n\tpublic class DispatchedWorker<T, U> : AbstractServiceQueue<T> where T : class, IQueueTask, new() where U : class, ITaskProcessor<T>, new()\n\t{\n\t\tprivate const string DESIRED_WORKER_COUNT = \"_WorkerCount\";\n\t\tprivate const string DESIRED_WORKER_MULTIPLIER = \"_WorkerMultiplier\";\n\t\tprivate const string TASK_DISPATCHERS = \"_TaskDispatchers\";\n\t\tprivate const string DESIRED_STAND_ALONE = \"_StandAlone\";\n\t\tprivate const string DEFAULT_TASK_DISPATCHERS = \"DefaultTaskDispatchers\";\n\t\tprivate const int DEFAULT_WORKER_COUNT = 5;\n\t\tprivate const double DEAFULT_CORE_TO_WORKER_MULTIPLIER = 0;\n\t\tprivate readonly string TASKPROCESSOR = Configuration.GetStringAppSetting(PROCESSSTART_NAME, \"ADEXS.TaskProcessor.exe\");\n\t\tprivate const string PROCESSSTART_NAME = \"PROCESSSTART_NAME\";\n\t\tprivate string _typeName;\n\t\tprivate readonly TaskTypes _taskType;\n\t\tprivate bool _standAlone;\n\n\t\tprivate readonly IContainer _container;         // optionally injected DI container\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate readonly Func<U> _createProcessor;\n\t\tprivate int _fetchMod;\n\n\t\t[ThreadStatic]\n\t\tprivate static int _errorCount = 0;\n\n\t\tpublic override string Name => base.Name + TypeName;\n\n\t\t[EventSource(\"Workers\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly PropertyBagEventSource _workersEventSource = new PropertyBagEventSource();\n\n\t\t[Counter(\"Workers Count\", \"CLM.DispatchedWorker\", MeasureProperty = \"Count\", InstanceProperty = \"Description\")]\n\t\t[EventSource(\"Workers Count\", \"CLM.DispatchedWorker\")]\n\t\tprivate static readonly CountEventSource _workersCountEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\")]\n\t\t[Counter(\"Worker Logging Exceptions\", \"CLM.DispatchedWorker\", InstanceProperty = \"Description\")]\n\t\tprivate static ExceptionEventSource _workerLoggingExceptionEventSource = new ExceptionEventSource();\n\n\t\tstatic DispatchedWorker()\n\t\t{\n\t\t\t// Kazmon emits from a generic type do not work without this call\n\t\t\tMonitoringRuntime.RegisterGenericType(typeof(DispatchedWorker<T, U>));\n\t\t}\n\n\t\tpublic string TypeName\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\t_typeName ??= _taskType.ToString();\n\t\t\t\treturn _typeName;\n\t\t\t}\n\t\t}\n\n\t\tpublic IMessageQueueWrapperFactory MessageQueueWrapperFactory { get; set; }\n\n\t\t/// <summary>\n\t\t/// Legacy Constructor -- delegates to the new overload; passes DI container extracted from ServiceLocator.\n\t\t/// This method will be deprecated in the future -- prefer the (IServicedComponent, IContainer) overload.\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this dispatched worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\tpublic DispatchedWorker(IServicedComponent component, TaskTypes taskType, IWatchedSingletonConfig<ISiteConfig> siteConfig) : this(component, taskType, ServiceLocator.Container, Activator.CreateInstance<U>, siteConfig)\n\t\t{\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor overload that accepts a DI container (stepping stone to moving away from SL pattern).\n\t\t/// </summary>\n\t\t/// <param name=\"component\">the component this worker services</param>\n\t\t/// <param name=\"taskType\">the task that will be run by this worker</param>\n\t\t/// <param name=\"container\">the DI container for service discovery and IOC</param>\n\t\tinternal DispatchedWorker(IServicedComponent component, TaskTypes taskType, IContainer container, Func<U> processorFactory, IWatchedSingletonConfig<ISiteConfig> siteConfig) : base(component)\n\t\t{\n\t\t\t_container = container;\n\t\t\t_createProcessor = processorFactory ?? (() => new U());\n\t\t\tServiceLocator.BuildUp(this);\n\t\t\t_taskType = taskType;\n\t\t\t//This is here to prevent a regression following ATL-81324\n\t\t\tif (TypeName != typeof(T).Name)\n\t\t\t\tthrow new ArgumentException($\"Failed to initialize DispatchedWorker: Task Name ({typeof(T).Name}) must match task type ({TypeName})\");\n\t\t\t_waitOnNoItems = false;\n\t\t\t_standAlone = Configuration.GetBooleanAppSetting(TypeName + DESIRED_STAND_ALONE, false);\n\t\t\tif (_standAlone) _log.DebugNoPII($\"Worker running in StandAlone mode for {TypeName}\");\n\t\t\t_siteConfig = siteConfig;\n\t\t}\n\n\t\tprivate ProcessTaskResult RunExternalTaskProcessor(ProcessTaskRequest taskRequest)\n\t\t{\n\t\t\tvar accountId = taskRequest.Task.AccountId;\n\t\t\tbool useAnonymousPipes = TasksManagementFeatureFlags.UseAnonymousPipeForExternalTaskProcessors &&\n\t\t\t                         Configuration.GetBooleanAppSetting(\n\t\t\t\t                         $\"{accountId}_UseAnonymousPipeForExternalTaskProcessors\", true);\n\t\t\t_log.InfoNoPII(useAnonymousPipes\n\t\t\t\t? \"Worker using Anonymous Pipes for Request and Results\"\n\t\t\t\t: \"Worker using Temp Files for Request and Results\");\n\t\t\tExternalTaskWorker externalTaskWorker = ExternalTaskWorkerFactory.GetExternalTaskWorker(useAnonymousPipes);\n\t\t\treturn externalTaskWorker.RunExternalProcessor(taskRequest,TASKPROCESSOR);\n\t\t}\n\n\t\tprotected override int MaxQueueDepth()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_WorkerMaxQueueDepth\", Configuration.GetInt32AppSetting(TypeName + WORKER_MAXSET, WORKER_MAXSET_DEFAULT)) * DesiredWorkerCount();\n\t\t}\n\n\t\tprotected override IList<T> Fetch(int fetchCount)\n\t\t{\n\t\t\tList<T> tasks = new List<T>();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPeriodicPulse();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not pulse for ''{TypeName}''.\", ex);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttasks = FetchFromQueues(fetchCount);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII($\"Could not load the items for the queue: {TypeName}\", ex);\n\t\t\t\t_lastFetchDate = DateTime.UtcNow;\n\t\t\t}\n\n\t\t\tAttemptRestorePropertiesFromPayload(tasks);\n\n\t\t\treturn tasks;\n\t\t}\n\n\t\tprivate List<T> FetchFromQueues(int fetchCount)\n\t\t{\n\t\t\tvar queuePaths = DefaultQueue.GetWorkerMqPaths(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\n\t\t\t// keep incrementing to pull from a different queue on each fetch, fetching from all queues seems to have an adverse effect on the channels\n\t\t\t_fetchMod %= queuePaths.Length;\n\t\t\tvar queuePath = queuePaths[_fetchMod];\n\t\t\t_fetchMod++;\n\n\t\t\treturn FetchSingleQueue(fetchCount, queuePath);\n\t\t}\n\n\t\tprivate List<T> FetchSingleQueue(int fetchCount, string path)\n\t\t{\n\t\t\tbool isMainPath = path == DefaultQueue.GetWorkerMqPath(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName));\n\t\t\tint waitTime = isMainPath ? TaskUtilities.InitialReceiveWaitMS(TypeName) : Configuration.GetInt32AppSetting(\"InitialReceiveWaitAdditionalQueueMS\", 20);\n\t\t\tusing (IMessageQueueWrapper pdfMQ = MessageQueueWrapperFactory.CreateReceiveInstance(Configuration.GetStringAppSetting(TypeName + \"_WorkerMQPath\", path)))\n\t\t\t{\n\t\t\t\treturn pdfMQ.ReceiveMultiple<T>(waitTime, MQApplicationSettings.DefaultExtraReceiveWaitMS, fetchCount);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Restore the task type properties from the payload. This will only live temporarily as we move\n\t\t/// all tasks toward using the CommonTask payload. If we fail to restore from properties we should log to kazmon\n\t\t/// but we should not not block tasks from getting processed. We are also logging when we find a task\n\t\t/// without a payload set.\n\t\t/// </summary>\n\t\tprivate void AttemptRestorePropertiesFromPayload(List<T> tasks)\n\t\t{\n\t\t\t// App Setting to disable this behavior just in case of issues\n\t\t\tvar restoreFromPayload = Configuration.GetBooleanAppSetting($\"RestoreTaskFromPayload_All\", true) &&\n\t\t\t\tConfiguration.GetBooleanAppSetting($\"RestoreTaskFromPayload_{TypeName}\", true);\n\n\t\t\tforeach (var task in tasks)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tif (task is CommonTask cTask)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (string.IsNullOrEmpty(cTask.Payload))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Log to kazmon to ensure that we don't miss any tasks\n\t\t\t\t\t\t\tCommonTaskPayloadHelper.CommonTaskPayloadMissingEventSource.Emit(1, cTask.Label);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (restoreFromPayload)\n\t\t\t\t\t\t\t\tcTask.RestorePropertiesFromPayload();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tCommonTaskPayloadHelper.PayloadRestoreExceptionEventSource.Emit(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate QueueItemType _lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\tpublic override void AdjustWorkers()\n\t\t{\n\t\t\tbase.AdjustWorkers();\n\n\t\t\tint desiredWorkerCount = DesiredWorkerCount(out double multiplier);\n\t\t\tSetEnabled(desiredWorkerCount > 0);\n\t\t\tQueueItemType currentQueueStatus = (desiredWorkerCount > 0) ? QueueItemType.QueueStarted : QueueItemType.QueueStopped;\n\t\t\tif (currentQueueStatus == _lastSentQueueStatus) return;\n\n\t\t\tEmitWorkerConfiguration(currentQueueStatus, desiredWorkerCount, multiplier);\n\t\t\tstring adminQueuePath = \"Unset\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tT startTask = new T\n\t\t\t\t{\n\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\tQueueItemType = currentQueueStatus,\n\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t};\n\n\t\t\t\tif (!_standAlone)\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueuePath = GetAdminQueuePath(machine);\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(adminQueuePath))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(startTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = currentQueueStatus;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:AdjustWorkers - Could not contact the administration queue: \" + adminQueuePath, ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitWorkerConfiguration(QueueItemType queueItemtype, int desiredWorkerCount, double multiplier)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_workersCountEventSource.Emit(desiredWorkerCount, TypeName);\n\n\t\t\t\tusing (var propertyBag = _workersEventSource.CreateEventPropertyBag(queueItemtype.ToString()))\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TaskType\", TypeName);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"DesiredWorkerCount\", desiredWorkerCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"Multiplier\", multiplier.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ProcessorCount\", Environment.ProcessorCount.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_workerLoggingExceptionEventSource.Emit(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetMachineName() => System.Net.Dns.GetHostName();\n\t\tprivate string GetTaskTypeName() => typeof(T).FullName;\n\n\t\tprivate static int _queueStateTouchIntervalMin = 60;\n\t\tprivate DateTime _nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\n\t\tprotected virtual void PeriodicPulse()\n\t\t{\n\t\t\tif (_nextStateTouchTime < DateTime.UtcNow)\n\t\t\t{\n\t\t\t\tQueueStatePersistence.AuthenticationInstance.Touch(GetMachineName(), GetTaskTypeName());\n\t\t\t\t_nextStateTouchTime = DateTime.UtcNow.AddMinutes(_queueStateTouchIntervalMin);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Blast the local queue back to the dispatcher so that it can be\n\t\t/// dispatched to another worker.\n\t\t///\n\t\t/// Also sends a disable me message\n\t\t/// </summary>\n\t\tpublic override void Stop()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//Try to do a prelim kill before the stop of the workers\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch\n\t\t\t{\n\t\t\t\t_log.DebugNoPII(\"Didn't kill processes first time\");\n\t\t\t}\n\n\t\t\tbase.Stop();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSetEnabled(false);\n\t\t\t\tif (!_standAlone && (_lastSentQueueStatus != QueueItemType.QueueStopped))\n\t\t\t\t{\n\t\t\t\t\tforeach (string machine in DispatcherMachines())\n\t\t\t\t\t{\n\t\t\t\t\t\tT stopTask = new T\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tLastProcessedDate = DateTime.UtcNow,\n\t\t\t\t\t\t\tQueueItemType = QueueItemType.QueueStopped,\n\t\t\t\t\t\t\tSendMachine = Environment.MachineName,\n\t\t\t\t\t\t\tUniqueId = Guid.NewGuid().ToString()\n\t\t\t\t\t\t};\n\t\t\t\t\t\tusing (IMessageQueueWrapper mq = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(machine)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmq.Send(stopTask);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_lastSentQueueStatus = QueueItemType.QueueStopped;\n\t\t\t\t}\n\n\t\t\t\tKillTaskProcessors();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"DispatchedWorker:Stop - Exception generated during stop:\", ex);\n\t\t\t}\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStopped, 0, 0);\n\t\t}\n\n\t\tprivate void KillTaskProcessors()\n\t\t{\n\t\t\tvar nestedContainer = CreateNestedContainer(null);\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);  // necessary to determine if processor would run out-of-process\n\t\t\t// attempt to kill any active out-of-process processors\n\t\t\tif (processor.RunInSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t\t\tstring processName = Path.GetFileNameWithoutExtension(TASKPROCESSOR);\n\t\t\t\tProcess[] tokill = System.Diagnostics.Process.GetProcessesByName(processName);\n\t\t\t\tif (tokill.Length > 0)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"Killing {processName} processes.\");\n\t\t\t\t\tforeach (Process p in tokill)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp.Kill();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"Failed to kill process with pid: {p.Id}\", ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void SetEnabled(bool enable)\n\t\t{\n\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\t\t\tbool alreadySet = false;\n\t\t\tstring taskTypeName = GetTaskTypeName();\n\t\t\t_log.DebugNoPII($\"Task type: {taskTypeName}, enable set to {enable}\");\n\n\t\t\tforeach (QueueState state in QueueStatePersistence.AuthenticationInstance.LoadAll())\n\t\t\t{\n\t\t\t\tif (state.MachineName.Equals(GetMachineName(), StringComparison.InvariantCultureIgnoreCase)\n\t\t\t\t\t&& state.TaskTypeName == taskTypeName)\n\t\t\t\t{\n\t\t\t\t\tif (enable)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine already exists for task type {taskTypeName}, attempting to enable it\");\n\t\t\t\t\t\tRegisterQueueState(state);\n\t\t\t\t\t\talreadySet = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Machine exists for task type {taskTypeName}, attempting to disable it\");\n\t\t\t\t\t\tstate.Enabled = false;\n\t\t\t\t\t\tQueueStatePersistence.AuthenticationInstance.Save(state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (enable && !alreadySet)\n\t\t\t{\n\t\t\t\t// must be a new entry in the queuestate table\n\t\t\t\t_log.DebugNoPII($\"Machine does not already exist for task type {taskTypeName}, attempting to create it\");\n\t\t\t\tRegisterQueueState(null);\n\t\t\t}\n\t\t}\n\t\t/// <summary>\n\t\t/// This will either create the queuestate or update\n\t\t/// it as enabled.\n\t\t/// </summary>\n\t\tprivate void RegisterQueueState(QueueState queueState)\n\t\t{\n\t\t\tif (queueState == null)\n\t\t\t{\n\t\t\t\tqueueState = new QueueState();\n\t\t\t\tType taskType = typeof(T);\n\t\t\t\tqueueState.MachineName = GetMachineName();\n\t\t\t\tqueueState.TaskAssemblyName = taskType.Assembly.GetName().Name;\n\t\t\t\tqueueState.TaskTypeName = GetTaskTypeName();\n\t\t\t\t_log.DebugNoPII($\"Creating new entry in QueueState for tasktype: {queueState.TaskTypeName}\");\n\t\t\t}\n\n\t\t\tqueueState.Enabled = true;\n\t\t\tqueueState.WorkerCount = DesiredWorkerCount(out double multiplier);\n\n\t\t\t_log.DebugNoPII($\"Saving QueueState for task type: {queueState.TaskTypeName} with properties - machine name: {queueState.MachineName},\" +\n\t\t\t\t$\"assembly name: {queueState.TaskAssemblyName} enabled: {queueState.Enabled}, worker count: {queueState.WorkerCount}\");\n\n\t\t\tQueueStatePersistence.AuthenticationInstance.Save(queueState);\n\t\t\tEmitWorkerConfiguration(QueueItemType.QueueStarted, queueState.WorkerCount, multiplier);\n\t\t}\n\n\t\tprotected override TaskResult Process(T task, out string message)\n\t\t{\n\t\t\tmessage = null;\n\n\t\t\tAtlasContext.Current.AccountId = task.AccountId;\n\t\t\tAtlasContext.Current.TransactionId = task.CorrelationId;\n\t\t\tif (task is IUserTask usrTask)\n\t\t\t{\n\t\t\t\tAtlasContext.Current.UserAccountUid = usrTask.UserAccountUid;\n\t\t\t}\n\n\t\t\tGuid corrToken;\n\t\t\tGuid.TryParse(task.CorrelationId, out corrToken);\n\n\t\t\tusing var activity = StartActivity(task, corrToken);\n\n\t\t\tstring telemetryLabel = task.Label;\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\tusing (var logger = new TaskServiceRequestEventLogger(corrToken, telemetryLabel))\n\t\t\t{\n\t\t\t\t// introduces request-scoped container for user context state (and any other future per-request DI state)\n\t\t\t\tusing var nestedContainer = CreateNestedContainer(AtlasContext.Current);\n\n\t\t\t\t// The DataPoint enum is defined in DocuSign sources. Trying to use some, hopefully with close enough semantics.\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, task.AccountId);\n\t\t\t\tServiceContext.Log(DataPoint.QueueItemId, task.UniqueId);\n\t\t\t\tServiceContext.Log(DataPoint.TimeQueued, $\"{task.CreatedDate:yyyy-MM-dd HH:mm:ss.fff}\");\n\t\t\t\tif (Guid.Empty != AtlasContext.Current.UserAccountUid)\n\t\t\t\t{\n\t\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The nugget inside the monitoring wrapper.\n\t\t\t\t\tTaskResult taskResult = ProcessTask(task, nestedContainer, out message, activity);\n\n\t\t\t\t\tServiceContext.Log(DataPoint.ApiStatus, $\"{taskResult}\");\n\t\t\t\t\tlogger.Success = (taskResult != TaskResult.Failure);\n\t\t\t\t\tactivity?.SetStatusFromTask(taskResult);\n\t\t\t\t\treturn taskResult;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tex.Trace().Report();\n\t\t\t\t\tthrow;\n \t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tif (!logger.Success && null != message)\n\t\t\t\t\t{\n\t\t\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate TaskResult ProcessTask(T task, IContainer nestedContainer, out string message, Activity activity)\n\t\t{\n\t\t\tProcessTaskResult result = new ProcessTaskResult() { Message = \"Context Set\" };\n\n\t\t\tif (TaskUtilities.CheckSuspendedTaskTypeForAccount(TypeName, task.AccountId))\n\t\t\t{\n\t\t\t\tmessage = $\"task failed because Aid {task.AccountId} is in the suspended account list for {TypeName}\";\n\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\ttask.ErrorCount = int.MaxValue;\n\t\t\t\treturn TaskResult.Failure;\n\t\t\t}\n\n\t\t\tvar processor = CreateTaskProcessor(nestedContainer);\n\n\t\t\tAtlasContext.Current.ActionType = processor.ActionType;\n\n\t\t\tif (processor.RunInSeparateProcess && !processor.HandleSeparateProcess && _siteConfig.IsOnPremEnvironment())\n\t\t\t{\n\t\t \t\tProcessTaskRequest taskRequest = new ProcessTaskRequest()\n\t\t\t\t{\n\t\t\t\t\tAccountId = AtlasContext.Current.AccountId,\n\t\t\t\t\tUserAccountUid = AtlasContext.Current.UserAccountUid,\n\t\t\t\t\tActionType = AtlasContext.Current.ActionType,\n\t\t\t\t\tProcessorTypeName = processor.GetType().AssemblyQualifiedName,\n\t\t\t\t\tTask = task,\n\t\t\t\t\tTaskType = _taskType,\n\t\t\t\t\tCorrelationToken = MonitoringContext.CorrelationToken ?? Guid.Empty\n\t\t\t\t};\n\t\t\t\tresult = RunExternalTaskProcessor(taskRequest);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprocessor.Task = task;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tprocessor.PreProcess();\n\t\t\t\t\tresult = processor.ProcessTask();\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tprocessor.PostProcess();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = result.Message;\n\n\t\t\tactivity?.SetQueueTaskResultTags(task, new MqWorkers.DispatchedWorker.ProcessTaskResult { Message = message });\n\n\t\t\treturn result.TaskResult;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns an instance of the ITaskProcessor that should be used when processing a request.\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// This method takes into account whether we are using a scoped DI container, and if so, will\n\t\t/// attempt to get the task processor from there to ensure that other scoped DI services (eg user context)\n\t\t/// are also correctly set up. If the supplied `container` parameter is null we create a non-scoped\n\t\t/// processor instance, otherwise we demand it from the container (which may throw if none is registered).\n\t\t/// </remarks>\n\t\t/// <param name=\"container\">Optional (nullable) DI container from which we acquire scoped processors</param>\n\t\t/// <returns>An instance of ITaskProcessor{T} that can process the task.</returns>\n\t\tprivate U CreateTaskProcessor(IContainer container)\n\t\t{\n\t\t\t// NOTE: If we have a nested DI container, defer to it for the ITaskProcessor instance.\n\t\t\t//       If there is no nested container, or it doesn't have a ITaskProcessor registered,\n\t\t\t//       instantiate one one locally.\n\t\t\treturn container?.GetInstance<U>() ?? _createProcessor.Invoke();\n\t\t}\n\n\t\tprotected override void UpdateFailure(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//this will requeue it if needed\n\t\t\t\ttask.QueueItemType = QueueItemType.Ack;\n\t\t\t}, () =>\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * Again errors should pause the movement of the items.\n\t\t\t\t * For this worker.\n\t\t\t\t */\n\t\t\t\tif (_errorCount++ % Configuration.GetInt32AppSetting(\"ErrorCountSleepMod\", 100) == 0)\n\t\t\t\t{\n\t\t\t\t\tThread.Sleep(SleepMilliSeconds());\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateUnlock(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.LastErrorMessage = message;\n\t\t\t\ttask.LastProcessedDate = DateTime.UtcNow;\n\t\t\t\t//task will requeue it\n\t\t\t\ttask.QueueItemType = QueueItemType.Task;\n\t\t\t});\n\t\t}\n\n\t\tprotected override void UpdateSuccess(T task, string message)\n\t\t{\n\t\t\tSendTaskStatusUpdate(task, () =>\n\t\t\t{\n\t\t\t\ttask.QueueItemType = QueueItemType.Completed;\n\t\t\t});\n\t\t}\n\n\t\tprivate void SendTaskStatusUpdate(T task, Action beforeSend, Action afterSend = null)\n\t\t{\n\t\t\tusing (LogContext.Set(task.CorrelationId))\n\t\t\t{\n\t\t\t\tif (_standAlone) return;        // short-circuit any communication message based services\n\n\t\t\t\tbeforeSend();\n\n\t\t\t\tstring sendMachine = task.SendMachine; // Send() changes the SendMachine property, so store it here in case we need to restore it after an exception.\n\n\t\t\t\tusing (IMessageQueueWrapper adminQueue = MessageQueueWrapperFactory.CreateInstance<T>(GetAdminQueuePath(task.SendMachine)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tadminQueue.Send(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"Detected IOException.  Will retry once.\", ioe);\n\n\t\t\t\t\t\tadminQueue.ReSend(task);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Restore original SendMachine, for the sake of the UpdateFailure() call from AbstractServiceQueue.\n\t\t\t\t\t\ttask.SendMachine = sendMachine;\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (afterSend != null)\n\t\t\t\t{\n\t\t\t\t\tafterSend();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Crate a nested DI container for the user context (and potentially other request-scoped DI state).\n\t\t/// </summary>\n\t\t/// <remarks>\n\t\t/// Introduced as part of ATL-72998 to add support for feature flag integration, which requires access to\n\t\t/// the request-scoped Account/User identity for flag resolution decisions.\n\t\t/// </remarks>\n\t\t/// <param name=\"atlasContext\">Atlas request context for this request/task</param>\n\t\t/// <returns>Disposable DI container for this request-scoped state</returns>\n\t\tprivate IContainer CreateNestedContainer(IAtlasContext atlasContext)\n\t\t{\n\t\t\tvar nestedContainer = _container.GetNestedContainer();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (atlasContext != null)\n\t\t\t\t{\n\t\t\t\t\tvar userContextSetter = nestedContainer.TryGetInstance<IUserContextSetter>();\n\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tuserContextSetter.AccountId = atlasContext.AccountId;\n\t\t\t\t\t\tuserContextSetter.UserId = atlasContext.UserAccountUid; // this may be null, but that's ok\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Should we have a specific OT telemetry event for this condition? It's most like incorrectly configured DI setup, but may not be a defect.\n\t\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire IUserContextSetter - transactionId {atlasContext.TransactionId} will proceed without scoped user context.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar taskContextSetter = nestedContainer.TryGetInstance<ITaskTypeContextSetter>();\n\n\t\t\t\tif (taskContextSetter != null)\n\t\t\t\t{\n\t\t\t\t\ttaskContextSetter.TaskType = _taskType;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Unable to create or acquire ITaskTypeContextSetter - {TypeName} will proceed without scoped task type context.\");\n\t\t\t\t}\n\n\t\t\t\treturn nestedContainer;\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\tnestedContainer?.Dispose();  // avoid leaking nested container\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic virtual int StandardSleepSeconds => 5;\n\t\tprotected override int SleepSeconds()\n\t\t{\n\t\t\treturn Configuration.GetInt32AppSetting(TypeName + \"_SleepSeconds\", StandardSleepSeconds);\n\t\t}\n\n\t\tpublic virtual int StandardWorkerCount => DEFAULT_WORKER_COUNT;\n\n\t\tpublic override int DesiredWorkerCount()\n\t\t{\n\t\t\treturn DesiredWorkerCount(out _);\n\t\t}\n\n\t\tprivate int DesiredWorkerCount(out double multiplier)\n\t\t{\n\t\t\tmultiplier = 0;\n\t\t\tint count = -1;\n\t\t\tif (IsOneConfigEnabledForWorkerCount())\n\t\t\t{\n\t\t\t\tvar mqTasksconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IMqTasksConfig>>()?.Value;\n\t\t\t\tvar taskConfigs = mqTasksconfigs?.TaskConfigs;\n\t\t\t\tif (taskConfigs != null && taskConfigs.TryGetValue(TypeName, out var taskConfig))\n\t\t\t\t{\n\t\t\t\t\tcount = taskConfig.WorkerCount;\n\t\t\t\t\tmultiplier = taskConfig.WorkerMultiplier;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Failed to retrieve task configuration from INI file for TaskName: {TypeName}. Falling back to legacy processing.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(count < 0)\n\t\t\t{\n\t\t\t\t// Rely on appsetting if oneConfig is disabled or if it cannot retrive from oneconfig\n\t\t\t\tcount = Configuration.GetInt32AppSetting(TypeName + DESIRED_WORKER_COUNT, StandardWorkerCount);\n\t\t\t\tmultiplier = Configuration.GetDoubleAppSetting(TypeName + DESIRED_WORKER_MULTIPLIER, DEAFULT_CORE_TO_WORKER_MULTIPLIER);\n\t\t\t}\n\n\t\t\t// we still want to be able to force the count to zero in order to turn off a worker group effectively\n\t\t\t// let's check the worker count based on the number of logical cores and a configured multiplier\n\t\t\tif (count != 0 && multiplier > 0)\n\t\t\t{\n\t\t\t\t// use the number of logical cores and a multiplier to determine a good worker count number.\n\t\t\t\tint numCores = Environment.ProcessorCount;\n\t\t\t\tcount = Math.Max((int)(numCores * multiplier), 1);  // we really never want a > 0 multiplier to cause a zero worker count\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\n\t\tprivate bool IsOneConfigEnabledForWorkerCount()\n\t\t{\n\t\t\tbool isOneConfigEnabled = false;\n\t\t\tif(ConfigWrapper.UseOneConfigMqTasksConfig)\n\t\t\t{\n\t\t\t\tvar appconfigs = ServiceLocator.GetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOneConfigMqTasks_\" + appconfigs?.AppName, true))\n\t\t\t\t{\n\t\t\t\t\tisOneConfigEnabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn isOneConfigEnabled;\n\t\t}\n\n\t\tprivate IEnumerable<string> DispatcherMachines()\n\t\t{\n\t\t\treturn StringUtil.Split('|', Configuration.GetStringAppSetting(TypeName + TASK_DISPATCHERS, Configuration.GetStringAppSetting(DEFAULT_TASK_DISPATCHERS, GetMachineName())));\n\t\t}\n\n\t\tprivate string GetAdminQueuePath(string machine)\n\t\t{\n\t\t\treturn string.Format(Configuration.GetStringAppSetting(TypeName + \"_EventMQPathFormat\", DefaultQueue.GetAdminMqPathFormat(TypeName, TaskUtilities.GetMessageBrokerTypeByTaskType(TypeName))), machine ?? GetMachineName());\n\t\t}\n\n\t\tprivate Activity StartActivity(T task, Guid correlationToken) =>\n\t\t\tServiceInstrumentation.ActivitySource\n\t\t\t\t?.StartActivity(\n\t\t\t\t\ttask.Label ?? $\"{nameof(ADEXS.Services.MessageWorkerService)}\",\n\t\t\t\t\tActivityKind.Consumer,\n\t\t\t\t\tparentContext: correlationToken.ToActivityContext())\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageType, TraceSemanticConventions.MessageTypeValues.Received)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageTaskName, TypeName)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageQueueType, ServiceTraceSemanticConventions.DocuSignMessageQueueTypeWorker)\n\t\t\t\t?.SetQueueTaskTags(task);\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities;\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Activities.HumanActivities;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Models;\nusing ADEXS.Atlas.Workflow.Activities.Telemetry;\nusing ADEXS.Atlas.Workflow.ActivityProperties;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.ExpressionService.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Emails;\nusing ADEXS.Core.Domain.Messaging.Framework.Integration.Interfaces;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow.Config;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.WINS.Engine.Throttling;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\nusing ADEXS.WINS.Interfaces;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.OneConfig.Extensions;\n\nusing Platform.Common;\n\nusing SCMAppenders;\n\nusing static ADEXS.Atlas.Workflow.Activities.Handlers.InstanceHandler;\n\nusing IEventRepository = ADEXS.Core.Domain.Repository.EventRepository.IEventRepository;\nusing InstanceVariable = ADEXS.Core.Domain.Model.Workflow.InstanceVariable;\nusing LoggingHelper = ADEXS.Atlas.Workflow.Activities.Infrastructure.LoggingHelper;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing UserAccount = ADEXS.Core.Domain.Model.UserAccount;\n\nnamespace ADEXS.WINS.Engine\n{\n\t/// <summary>\n\t/// An instance of a workflow -- a specific example of a definition.\n\t/// This class contains methods for controlling it, but all such calls should actually be fed through\n\t/// WorkflowManager so they can be queued, etc.\n\t/// </summary>\n\tpublic class WorkflowInstance : IWINSControlInstance\n    {\n        public const int SQL_SEVERITY_LEVEL_TRANSIENT = 12;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WorkflowInstance));\n\n\t\tprivate IEventRepository _eventRepo;\n\t\tprivate IInstanceVariableGovernance _instanceVariableGovernance;\n\t\tprivate IWorkflowSettingRepository _workflowSettingRepository;\n\t\tprivate IGovernor _governor;\n\t\tprivate IInstanceHandler _instanceHandler;\n\t\tprivate IServiceInstrumentation _serviceInstrumentation;\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> _workflowClientConfig;\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\t\tprivate ICacheRepository _cacheRepository;\n\n\t\tprivate IEventRepository EventRepo => (_eventRepo ?? (_eventRepo = ServiceLocator.GetInstance<IEventRepository>()));\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => (_instanceVariableGovernance ?? (_instanceVariableGovernance = ServiceLocator.GetInstance<IInstanceVariableGovernance>()));\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository ?? (_workflowSettingRepository = ServiceLocator.GetInstance<IWorkflowSettingRepository>());\n\t\tprivate IGovernor Governor => _governor ?? (_governor = ServiceLocator.GetInstance<IGovernor>());\n\t\tprivate IInstanceHandler InstanceHandler => _instanceHandler ?? (_instanceHandler = ServiceLocator.GetInstance<IInstanceHandler>());\n\n\n\t\tprivate IServiceInstrumentation ServiceInstrumentation => _serviceInstrumentation ?? (_serviceInstrumentation = ServiceLocator.GetInstance<IServiceInstrumentation>());\n\t\tprivate IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig> WorkflowClientConfig => _workflowClientConfig ?? (_workflowClientConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>());\n\t\tprivate IWatchedSingletonConfig<ISiteConfig> SiteConfig => _siteConfig ?? (_siteConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>());\n\t\tprivate ICacheRepository CacheRepository => _cacheRepository ?? (_cacheRepository = ServiceLocator.GetInstance<ICacheRepository>());\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig ?? (_workflowConfig = ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\n\t\t/// <summary>\n\t\t/// Loads (and locks) an existing instance.  Fails if the instance doesn't exist or can't be locked.\n\t\t/// </summary>\n\t\tpublic static WorkflowInstance LoadExisting(int accountId, Guid instanceUid, IWINSDataStore data)\n        {\n\t        DateTime lockExpirationDate;\n            InstancePersistence.LockResult lockResult = data.LockInstance(accountId, instanceUid, out lockExpirationDate);\n            switch (lockResult)\n            {\n                case InstancePersistence.LockResult.AlreadyCompleted:\n                    throw new InstanceAlreadyCompletedException(string.Format(\"InstanceUid {0} is already completed\", instanceUid));\n                case InstancePersistence.LockResult.DoesNotExist:\n                    throw new ApplicationException(string.Format(\"Invalid instanceUid {0}\", instanceUid));\n                case InstancePersistence.LockResult.LockedByOther:\n                    throw new InstanceLockedException(string.Format(\"InstanceUid {0} is locked by another process\", instanceUid));\n                case InstancePersistence.LockResult.Locked:\n                    // This is our success condition\n                    break;\n                default:\n                    throw new ApplicationException(string.Format(\"Unhandled lockResult for instanceUid {0}: {1}\", instanceUid, lockResult));\n            }\n            Instance instance = data.LoadInstanceByUid(accountId, Constants.WorkflowUser, instanceUid);\n            if (instance == null) throw new ApplicationException(string.Format(\"Failed to load workflow instanceUid {1} for account {0}.\", accountId, instanceUid));\n\n\t\t\ttry\n            {\n                if (instance.ScopeUid != Guid.Empty)\n                {\n                    Scope scope = ServiceLocator.GetInstance<IDocumentScopeRepository>().GetScopeByUid(accountId, instance.ScopeUid);\n                    if (scope != null)\n                        instance.ScopeName = scope.Name;\n                }\n            }\n            catch (Exception ex)\n            {\n                // the failure to load the scope should not cause the failure to load the instance, log it and move on\n                _log.WarnNoPII(string.Format(\"Could not load the scope '{0}' for workflow instance '{1}'.\", instance.ScopeUid, instanceUid), ex);\n            }\n\n\t\t\tRevision revision = data.LoadRevisionByUid(accountId, Constants.WorkflowUser, instance.RevisionUid);\n            if (revision == null) throw new ApplicationException(string.Format(\"Failed to load workflow definition version {1} for account {0}.\", accountId, instance.RevisionUid));\n            // ATL-68146: Populate RevisionCreatedDate here, because LoadInstanceByUid() doesn't populate it.\n            instance.RevisionCreatedDate = revision.CreatedDate;\n            WorkflowMap workflowMap = null;\n            instance.DefinitionUid = revision.DefinitionUid;\n\n\t\t\ttry\n            {\n\t            workflowMap = ServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromRevision(revision).BuildWorkflowMap(revision);\n            }\n            catch (InvalidDesignDefinitionException ex)\n            {\n\t            try\n\t            {\n\t\t            new WorkflowInstance(instance, data).Abort(UserAccount.WorkflowUserAccount(accountId), ex.Message);\n\t            }\n\t\t\t\tcatch(Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Error aborting workflow instance '{instanceUid}' with invalid definition\", e);\n\t\t\t\t}\n\n\t            throw;\n            }\n\n            var workflowInstance = new WorkflowInstance(instance, workflowMap, data);\n\t        workflowInstance.LockExpirationDate = lockExpirationDate;\n\t        return workflowInstance;\n\n        }\n\n        private readonly IWINSDataStore _data;\n        private readonly WorkflowMap _workflowMap;\n        private Instance _instance;\n\n        // The count of the activities that have been generated by this particular in-memory instance.  This doesn't get persisted anywhere, so is\n        // cleared whenever this WorkflowInstance gets unloaded (eg, when it enters into a Waiting state).\n        // It's use is to detect runaway workflows.\n        public const int MAX_IN_MEMORY_ACTIVITY_COUNT = 5000;\n        private int _inMemoryActivityCount = 0;\n\t\tprivate int _activityExecutionCountEnforcedLimit = 0;\n\t\tprivate Guid _revisionUid = Guid.Empty;\n\t\tprivate Guid _definitionUid = Guid.Empty;\n\t\tprivate DateTime _revisionCreatedDate = DateTime.MinValue;\n\t\tprivate bool _isActivityExecutionLimitReached = false;\n\n\t\tprivate readonly object _lockObject = new object();\n        private readonly IDictionary<Guid, InstanceActivity> _unfinishedActivities = new Dictionary<Guid, InstanceActivity>();\n        private readonly Queue<Event> _queuedControlEvents = new Queue<Event>();\n        private readonly Queue<Event> _queuedEvents = new Queue<Event>();\n\n        private readonly Dictionary<string, ContentDefinition> _contentDefinitions = new Dictionary<string, ContentDefinition>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, InstanceVariable> _variables = new Dictionary<string, InstanceVariable>(StringComparer.InvariantCultureIgnoreCase);\n        private readonly Dictionary<string, IXmlVariableDefinition> _xmlVariableDefinitions = new Dictionary<string, IXmlVariableDefinition>(StringComparer.InvariantCultureIgnoreCase);\n\n        private readonly TimedLock _lock;\n\n        // Kind of a hack -- this is kept around so that if we end the instance without reaching the End step, we have an activity that we can\n        // log the message to.\n        private Guid _lastActivityUid;\n\n        private WorkflowInstance(Instance instance, IWINSDataStore data)\n        {\n\t        _data = data;\n\t        _lock = new TimedLock(instance.Uid.ToString());\n\t        _instance = instance;\n\t\t\t_revisionUid = _instance.RevisionUid;\n\t\t\t_revisionCreatedDate = instance.RevisionCreatedDate;\n\t        LastProcessDate = DateTime.UtcNow;\n\t\t\t_definitionUid = _instance.DefinitionUid;\n\t\t}\n\n\t\tpublic WorkflowInstance(Instance instance, WorkflowMap workflowMap, IWINSDataStore data) : this(instance, data)\n        {\n            _workflowMap = workflowMap;\n            // Load up any incomplete activities.  This is pointless to do for a new workflow, but it's not expensive either,\n            // so we simply avoid trying to figure that out and simply do it.\n            QueueIncompleteActivities();\n        }\n\n        /// <summary>\n        /// The AccountId this instance is running in.\n        /// </summary>\n        public int AccountId { get { return _instance.AccountId; } }\n\n        public Dictionary<string, ContentDefinition> ContentDefinitions { get { return _contentDefinitions; } }\n\n        public IWINSDataStore DataStore { get { return _data; } }\n\n        public TimedLock ThreadLock { get { return _lock; } }\n\n        /// <summary>\n        /// An in-memory, non-persisted value -- this is used when workers are finding instances to do work on.\n        /// It acts to make the WorkflowManager more FIFO, so that some workflows don't continually get ignored in favor of\n        /// newer work coming in.\n        /// </summary>\n        public DateTime LastProcessDate { get; private set; }\n\n        /// <summary>\n        /// The model Instance object; I didn't call this Instance because I didn't want it confused with a singleton pattern, and because\n        /// I didn't like seeing \"instance.Instance\".\n        /// </summary>\n        public Instance Model { get { return _instance; } }\n\n\t\tpublic DateTime LockExpirationDate { get; set; }\n\n\t\t/// <summary>\n\t\t/// The instance's Uid.  Primary key.\n\t\t/// </summary>\n\t\tpublic Guid Uid { get { return _instance.Uid; } }\n\n        public Dictionary<string, InstanceVariable> Variables { get { return _variables; } }\n\n        public Dictionary<string, IXmlVariableDefinition> XmlVariableDefinitions { get { return _xmlVariableDefinitions; } }\n\n        public Enums.WorkflowStepStatus Status => _instance.Status;\n\n        public bool HasQueuedWork\n        {\n            get { return _queuedEvents.Count > 0 || _queuedControlEvents.Count > 0; }\n        }\n\n        public bool HasUnfinishedActivities\n        {\n            get { return _unfinishedActivities.Count > 0; }\n        }\n\n        public void QueueActivity(InstanceActivity instanceActivity)\n        {\n            lock (_lockObject)\n            {\n                _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            }\n        }\n\n\t\tpublic int ActivityExecutionCount { get; set; }\n\n\t\tpublic int ActivityExecutionCountEnforcedLimit => _activityExecutionCountEnforcedLimit;\n\n\t\tpublic bool IsActivityExecutionLimitReached => _isActivityExecutionLimitReached;\n\n\t\tpublic Guid RevisionUid => _revisionUid;\n\n\t\tpublic Guid DefinitionUid => _definitionUid;\n\n\t\tpublic DateTime RevisionCreatedDate => _revisionCreatedDate;\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\t/// <param name=\"previousActivity\"></param>\n\t\t/// <param name=\"linkName\"></param>\n\t\t/// <param name=\"localContextId\"></param>\n\t\t/// <param name=\"followEmptyPathByDefault\"></param>\n\t\t/// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n\t\tpublic void QueueActivitiesByLink(InstanceActivity previousActivity, string linkName, int localContextId = 0, bool followEmptyPathByDefault = true, bool useLinkName = false)\n        {\n            IEnumerable<WorkflowMap.Link> links;\n            bool found = false;\n            if (_workflowMap.TryGetLinks(previousActivity.Name, linkName, out links))\n            {\n                foreach (WorkflowMap.Link link in links)\n                {\n                    QueueActivityByName(previousActivity, link.ToName, localContextId, linkName, useLinkName);\n                    found = true;\n                }\n            }\n            // If we got no matches, try to go for the default (empty) output.\n            if (followEmptyPathByDefault && !found && !string.IsNullOrEmpty(linkName)) QueueActivitiesByLink(previousActivity, string.Empty, localContextId);\n        }\n\n        /// <summary>\n        ///\n        /// </summary>\n        /// <param name=\"previousActivity\"></param>\n        /// <param name=\"name\"></param>\n        /// <param name=\"localContextId\"></param>\n        /// <param name=\"linkName\"></param>\n        /// <param name=\"useLinkName\">when true, uses linkName as the InputActivityOutput instead of getting it from previousActivity.Output</param>\n        public void QueueActivityByName(InstanceActivity previousActivity, string name, int localContextId = 0, string linkName = null, bool useLinkName = false)\n        {\n            IWINSActivity activity;\n            if (!_workflowMap.TryGetActivity(name, out activity)) throw new ApplicationException(string.Format(\"InstanceUid {0}: Tried to execute invalid activity '{1}'\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, name)));\n\n            if (localContextId <= 0) localContextId = (previousActivity == null ? int.MinValue : previousActivity.LocalContextId);\n\n            // Create a new activity\n            InstanceActivity instanceActivity = new InstanceActivity\n            {\n                AccountId = _instance.AccountId,\n                InstanceUid = _instance.Uid,\n                Name = name,\n                ActivityTypeName = activity.LegacyElementName(),\n                Status = Enums.WorkflowStepStatus.Pending,\n                InputActivityOutput = useLinkName ? linkName : (previousActivity == null ? string.Empty : previousActivity.Output),\n                InputActivityUid = (previousActivity == null ? Guid.Empty : previousActivity.Uid),\n                LocalContextId = localContextId,\n                IsWinsActivity = true,\n                CreatedDate = DateTime.UtcNow //make sure that the in memory copy has a value\n            };\n\n            try\n            {\n                _data.CreateActivity(instanceActivity);\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorWithPII($\"Failed to queue activity {{0}} for instance {_instance?.Uid} in account {_instance?.AccountId}\", ex, name);\n                _data.ActivityFailure(_instance, instanceActivity);\n            }\n\n            _unfinishedActivities[instanceActivity.Uid] = instanceActivity;\n            QueueActivity(instanceActivity);\n        }\n\n        public void QueueEvent(Event e)\n        {\n            if (_instance.Status != Enums.WorkflowStepStatus.Failed && _instance.Status != Enums.WorkflowStepStatus.Aborted)\n            {\n                lock (_lockObject)\n                {\n                    Queue<Event> queue = (e.IsControlEvent ? _queuedControlEvents : _queuedEvents);\n                    if (e.Uid != Guid.Empty)\n                    {\n                        // Ensure this item isn't already in the list\n                        if (queue.Any(e2 => e2.Uid == e.Uid)) return;\n                    }\n                    queue.Enqueue(e);\n                    WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventQueued\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n                    wrk.Log();\n\t            }\n            }\n        }\n\n        public void QueueIncompleteActivities()\n        {\n            InstanceActivities activities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n            if (activities == null || activities.Count == 0) return;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in activities) _unfinishedActivities[activity.Uid] = activity;\n            }\n\n        }\n\n        public bool CheckActivityForCompletion(InstanceActivity instanceActivity)\n        {\n            // We only care about Waiting steps.\n            if (instanceActivity.Status != Enums.WorkflowStepStatus.Waiting) return false;\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.DebugNoPII($\"CheckActivityForCompletion called for ActivityUid {instanceActivity.Uid} ({instanceActivity.Name}).\");\n\t            try\n\t            {\n\t\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\t\t            ctx.CheckForCompletion();\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t            _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n\t\t\t            SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            return true;\n\t\t            }\n                    _log.DebugWithPII($\"CheckActivityForCompletion completed for Activity ({{0}}) in status: {instanceActivity.Status}.\", instanceActivity.Name);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n                    _log.ErrorNoPII($\"CheckActivityForCompletion failed.\", e);\n\t            }\n            }\n            return false;\n        }\n\n        public bool DoNextTask()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t        CheckAndHandleInstanceStateChanges();\n\n\t\t\t// If we're in a non-processing state, we want to respond only to control events.\n\t\t\t// If we have no control events, we can just skip everything else.\n\t\t\tif (!_ShouldProcessEvent())\n\t        {\n\t\t        return _ExecuteFirstEvent(controlOnly: true);\n\t        }\n\n\t        // If we have any queued events, do one of those.\n\t        if (_ExecuteFirstEvent(controlOnly: false)) return true;\n\n\t        if (!_ShouldProcess()) return false;\n\n\t        // Otherwise, check to see if any activities need to be executed; if so, do those.\n\t        if (_ExecuteFirstActivity()) return true;\n\n\t        // If we get here, it might be that we have some unfinished activities in the database that for some reason weren't loaded into memory.\n\t        // Check for that, and, if so, load them now.\n\t        QueueIncompleteActivities();\n\t        // Try to execute an activity again -- we may have just loaded some\n\t        if (_ExecuteFirstActivity()) return true;\n\t        // If we can complete a waiting activity, do that.\n\t        if (_CheckWaitingActivities()) return true;\n\n\t        // Otherwise, we've got nothing to do and can quit.\n\t        if (!HasQueuedWork && !HasUnfinishedActivities)\n\t        {\n\t\t        _MarkCompleted();\n\t\t\t\t// If we processed nothing (the activity count is 0) we don't want to mark ourselves as waiting.  This is mostly because\n\t\t\t\t// we don't want to update our UpdatedDate (see ATL-20570).  This case occurs when our workflow is already waiting and has been\n\t\t\t\t// picked up for the day and each activity checked to see if it's done waiting.  We don't want this to trigger an update if\n\t\t\t\t// nothing has actually changed.\n\t        }\n\t        else if (_inMemoryActivityCount > 0 || _instance.Status != Enums.WorkflowStepStatus.Waiting)\n\t        {\n\t\t\t\tvar workflowConfig = WorkflowConfig(_instance.AccountId);\n\t\t\t\tvar enableSmallBenRateLimits = workflowConfig?.EnableSmallBenRateLimits ?? false;\n\n\t\t\t\tif (_instance.Status == Enums.WorkflowStepStatus.Paused\n\t\t\t\t    && ((string.Equals(ADEXS.Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.EnableExpressionApiRateLimit, \"live\", StringComparison.OrdinalIgnoreCase)\n\t\t\t\t         && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit)\n\t\t\t\t\t|| (enableSmallBenRateLimits && _instance.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit)))\n\t\t\t\t{\n\t\t\t\t\t// keep throttled workflows in paused status\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t_MarkWaiting();\n\t\t\t}\n\n\t\t    return false;\n        }\n\n        public void ExecuteActivity(InstanceActivity instanceActivity)\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity {0} in workflow map for instanceUid {1}\", instanceActivity.ActivityTypeName, Uid));\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteActivity called for Activity ({{0}}).\", instanceActivity.Name);\n\t            IWINSWorkflowContext ctx = null;\n\t            Stopwatch sw = Stopwatch.StartNew();\n\t            try\n\t            {\n\t\t            _lastActivityUid = instanceActivity.Uid;\n\n\t\t\t\t\tif (!_ShouldProcess()) throw new ApplicationException(string.Format(\"InstanceUid {0} is in an invalid state to execute activity {1}\", Uid, PII.Encode(ApplicationSettings.PIIHashingStrategy, instanceActivity.Name)));\n\n\t\t            // Check for runaway workflows.\n\t\t            if (++_inMemoryActivityCount >= MAX_IN_MEMORY_ACTIVITY_COUNT)\n\t\t            {\n\t\t\t            _log.WarnNoPII(string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t\t            throw new PublicException(PublicException.FailReason.InvalidState, string.Format(\"In-memory activity count exceeded: {0} activities without entering into a Waiting state\", _inMemoryActivityCount));\n\t\t            }\n\n\t\t\t\t\t// Governance, check if activity execution limit has been reached\n\t\t\t\t\tif (PauseWhenActivityExecutionLimitReached())\n\t\t\t\t\t{\n\t\t\t\t\t\t// In this case, the workflow is paused, purge date is set and an e-mail has been sent to support team.\n\t\t\t\t\t\t// The current activity will not be executed, unless the limits are increased and the workflow resumed.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t_data.ActivityExecuting(_instance, instanceActivity);\n\n\t\t            ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\t\tif (!ShouldUseScopeEventHandler() && IsTrackItActivity(activity))\n\t\t\t\t\t{\n\t\t\t\t\t\tFireWorkflowScopeEvent(null, ScopeEventType.StepInitiated, activity, ctx);\n\t\t\t\t\t}\n\n\t\t\t\t\tactivity.Execute(ctx);\n\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t            {\n\t\t\t\t\tif (e is ArgumentNullException && ctx == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar message =\n\t\t\t\t            string.Format(Resources.WINSResources.ActionFailed_ReferenceID_0, Guid.NewGuid()) +\n\t\t\t\t            $\". Inst: {instanceActivity.AccountId} '{instanceActivity.InstanceUid}'.\";\n\t\t\t            _log.ErrorNoPII(message, e);\n\t\t\t\t\t\t_data.CreateInstanceHistory(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, message, true);\n\t\t            }\n\n\t\t\t\t\t// Oh my...\n\t\t\t\t\t// Look at this catch block.\n\t\t\t\t\tbool isTransient = e is TransientException;\n\t\t            bool useFailureOutput = ctx != null && activity.HasFailureOutput;\n\n\t\t            if (isTransient) throw new TransientException(e);\n\t\t            if (useFailureOutput)\n\t\t            {\n\t\t\t\t\t\tctx.ActivityVariables.Set(\"Failure\", e.Message);\n\t\t\t\t\t\tctx.MarkAsCompleted(AbstractActivity.OUTPUT_FAILURE);\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.ActivityFailure(_instance, instanceActivity);\n\t\t\t            if (ctx == null) ctx = _CreateContext(activity, instanceActivity);\n\t\t\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\t\t\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\t\t\ttry\n\t\t\t            {\n\t\t\t\t            if (_instance.Status == Enums.WorkflowStepStatus.Failed)\n\t\t\t\t            {\n\t\t\t\t\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInstanceHandler.Fail(ctx, activity, GetUnfinishedWINSWorkflowContextsWINSActivities(instanceActivity.EndDate));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tAccountId = ctx.AccountId,\n\t\t\t\t\t\t\t\t\t\tScopeUid = ctx.ScopeUid,\n\t\t\t\t\t\t\t\t\t\tScopeName = ctx.ScopeName,\n\t\t\t\t\t\t\t\t\t\tStepName = instanceActivity.Name,\n\t\t\t\t\t\t\t\t\t\tStepDisplayName = GetActivityDisplayName(activity, ctx),\n\t\t\t\t\t\t\t\t\t\tStepTypeName = instanceActivity.ActivityTypeName,\n\t\t\t\t\t\t\t\t\t\tStepUid = instanceActivity.Uid,\n\t\t\t\t\t\t\t\t\t\tPeriodStart = instanceActivity.EndDate,\n\t\t\t\t\t\t\t\t\t\tEventType = (int)ScopeEventType.WorkflowFailed,\n\t\t\t\t\t\t\t\t\t\tOutput = instanceActivity.Output,\n\t\t\t\t\t\t\t\t\t\tWorkflowUid = ctx.WorkflowInstanceUid,\n\t\t\t\t\t\t\t\t\t\tWorkflowName = ctx.WorkflowName\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tEventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n\n\t\t\t\t\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Failed, instanceActivity.EndDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t            }\n\t\t\t            catch (Exception ex)\n\t\t\t            {\n\t\t\t\t        _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.WorkflowFailed}\", ex);\n\t\t\t            }\n\n\t\t\t            _unfinishedActivities.Remove(instanceActivity.Uid);\n\t\t\t            _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n\t\t            }\n\t            }\n\t            finally\n\t            {\n\t\t            ActivityExecutionCount++;\n\t            }\n\t\t\t}\n        }\n\n        public void ExecuteCallback(InstanceActivity instanceActivity, string name, object value)\n        {\n            LastProcessDate = DateTime.UtcNow;\n\n\t\t\tusing var span = StartActivity()\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, instanceActivity?.Uid);\n\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) return;\n\n            using (ScmNDC.Push(BuildNDCTags(instanceActivity)))\n            {\n\t            _log.InfoWithPII($\"ExecuteCallback called for Activity ({{0}}) with callback {name}.\", instanceActivity.Name);\n\n\t            if (!(_ShouldProcess(instanceActivity) && _ShouldProcessEvent()))\n\t            {\n\t\t            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoWithPII($\"ExecuteCallback did not complete because the activity was already completed. Activity {{0}} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}. Instance status: {Model.Status}\", instanceActivity.Name);\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _log.ErrorWithPII($\"InstanceUid {Uid} is in an invalid state to process callback {name}. Activity status: {instanceActivity.Status}.  Instance status: {Model.Status}\");\n\t\t\t\t\t}\n\t\t            return;\n\t\t\t\t}\n\n\t            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n\n\t\t\t\ttry\n\t\t        {\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t            activity.ExecuteCallback(ctx, name, value);\n\n\t\t            if (_instance.Status != Enums.WorkflowStepStatus.Aborted)\n\t\t            {\n\t\t\t            _ActivityWorkCompleted(instanceActivity, activity, ctx, sw);\n\t\t            }\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t\t\t\tcatch (ExpressionApiRequestThrottledException expressionApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\texpressionApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, expressionApiThrottledException);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (SmallBenApiRequestThrottledException smallBenApiThrottledException)\n\t\t\t\t{\n\t\t\t\t\tsmallBenApiThrottledException.WorkflowThrottledStatus = Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit;\n\t\t\t\t\tPauseWhenThrottled(instanceActivity, smallBenApiThrottledException);\n\n\t\t\t\t\t// Throw so that the calling method will handle re-queuing the failed event\n\t\t\t\t\t// When resumed we will retry the recurring reminder callback\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t            catch (Exception e)\n\t            {\n\t\t\t\t\t// Note that we don't fail the workflow here -- see ATL-21019\n\t\t\t\t\tif (instanceActivity.Status == Enums.WorkflowStepStatus.Completed ||\n\t\t                Model.Status == Enums.WorkflowStepStatus.Completed)\n\t\t            {\n\t\t\t\t\t\t_log.InfoNoPII($\"The callback is unnecessary: workflow activity '{instanceActivity.Uid}' [{instanceActivity.Status}] or instance '{instanceActivity.InstanceUid}' [{Model.Status}] has already completed.\");\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t\t\t\tvar pe = e as PublicException;\n\t\t\t\t\t\t_log.ErrorNoPII($\"ExecuteCallback failed.\", pe?.InnerException ?? e);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void ExecuteEvent(Event e, bool queueOnFailure = true)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            if (e == null) return;\n\n            using var span = StartActivity();\n\n            using (ScmNDC.Push(BuildNDCTags(e)))\n            {\n\t            // If we have Uid but the lock expired we don't want to process the event as it was persisted and some other worker probably has already picked it.\n\t            if (e.Uid != Guid.Empty && e.LockExpirationDate <= LastProcessDate)\n\t            {\n\t\t            _log.InfoNoPII($\"Aborting event execution - ExecuteEvent called with an event that has an expired lock ({e.LockExpirationDate}) for callback {e.CallbackName}.\");\n\t\t\t\t\tspan?.SetStatus(ActivityStatusCode.Ok);\n\t\t            return;\n\t            }\n\n\t            _log.InfoNoPII($\"ExecuteEvent called with callback {e.CallbackName}.\");\n\t            try\n\t            {\n\t\t            Stopwatch sw = Stopwatch.StartNew();\n\t\t            if (e.ActivityUid == Guid.Empty)\n\t\t            {\n\t\t\t            // We expect these to be control codes\n\t\t\t            string comment = (e.CallbackObject == null ? \"\" : e.CallbackObject.ToString());\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            case Event.ControlNames.Abort:\n\t\t\t\t\t            Abort(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForAccountCancel:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tSetPurgeDateForAccountCancel();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.PauseForRevisionSuspended:\n\t\t\t\t\t\t\t\tPauseForRevisionSuspended(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.ResumeForSuspendedRevision:\n\t\t\t\t\t\t\t\t ResumeForSuspendedRevision(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase Event.ControlNames.Pause:\n\t\t\t\t\t\t\t\tPause(e.BPMUser, comment);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t            case Event.ControlNames.Resume:\n\t\t\t\t\t            Resume(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.ResumeFromError:\n\t\t\t\t\t            ResumeFromError(e.BPMUser, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            case Event.ControlNames.StartActivity:\n\t\t\t\t\t            QueueActivityByName(null, comment);\n\t\t\t\t\t            break;\n\t\t\t\t            default:\n\t\t\t\t\t            throw new ApplicationException(string.Format(\"Unhandled event {0}\", e.CallbackName));\n\t\t\t            }\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            // These *may* be control codes.  If they're not control codes, then\n\t\t\t            // we expect them to be a callback to an activity.\n\t\t\t            InstanceActivity activity;\n\t\t\t            if (!_unfinishedActivities.TryGetValue(e.ActivityUid, out activity)) activity = _data.LoadActivityByUid(_instance.AccountId, Constants.WorkflowUser, e.ActivityUid);\n\t\t\t            if (activity == null || activity.InstanceUid != e.InstanceUid) throw new ApplicationException(string.Format(\"Invalid ActivityUid {0} for InstanceUid {1}\", e.ActivityUid, e.InstanceUid));\n\t\t\t            switch (e.CallbackName)\n\t\t\t            {\n\t\t\t\t            // TODO: Start specific steps, fire specific outputs, complete specific steps, etc.\n\t\t\t\t            default:\n\t\t\t\t\t            ExecuteCallback(activity, e.CallbackName, e.CallbackObject);\n\t\t\t\t\t            break;\n\t\t\t            }\n\t\t            }\n\t\t            if (e.Uid != Guid.Empty) _data.EventSuccess(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventExecuted\")\n\t\t\t\t\t{\n\t\t\t\t\t\tTotalMs = sw.ElapsedMilliseconds,\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid, WorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t            wrk.Log();\n\n\t\t            span?.SetStatus(ActivityStatusCode.Ok);\n\t            }\n\t            catch (Exception excp)\n\t            {\n\t\t            _log.ErrorNoPII($\"Error processing eventUid {e.Uid} ({e.CallbackName}).\", excp);\n\t\t            if (!queueOnFailure) throw;\n\t\t            if (e.Uid == Guid.Empty)\n\t\t            {\n\t\t\t            e.NextProcessDate = _data.NextProcessDate();\n\t\t\t            e.ErrorCount = 1;\n\t\t\t            e.LastErrorMessage = excp.Message;\n\t\t\t            _data.CreateEvent(e);\n\t\t\t            WorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnExecuteException\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t\t};\n\t\t\t            wrk.Log();\n\t\t            }\n\t\t            else\n\t\t            {\n\t\t\t            _data.EventFailure(e.AccountId, e.Uid, _data.NextProcessDate(), excp.Message);\n\t\t            }\n\t            }\n            }\n        }\n\n        public void Abort(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                foreach (InstanceActivity activity in _unfinishedActivities.Values)\n                {\n\t                try\n\t                {\n\t\t                IWINSActivity winsActivity = _SafeGetActivity(activity);\n\t\t                IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n\t\t                winsActivity.OnActivityAborted(ctx);\n\t                }\n\t                catch (Exception ex)\n\t                {\n\t\t                _log.ErrorNoPII(string.Format(\"Failed OnActivityAborted AccountId {0}, ActivityUid {1}\", user.AccountId, activity.Uid), ex);\n\t\t\t\t\t}\n                }\n                new WorkflowControlInstance(Model).Abort(user, comment);\n\n\t\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t\t{\n\t\t\t\t\tInstanceHandler.Abort(_instance, user, GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime.UtcNow));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAbortOrFailScopeStep(Enums.WorkflowStepStatus.Aborted, DateTime.UtcNow);\n\t\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowAborted);\n\t\t\t\t}\n\n\t\t\t\t_ForceReload();\n            }\n        }\n\n        public int SetPurgeDateForAccountCancel()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        var daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForAccountCancel();\n\t\t        _ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t        }\n        }\n\n        public void ClearPurgeDate()\n        {\n\t        LastProcessDate = DateTime.UtcNow;\n\t        lock (_lockObject)\n\t        {\n\t\t        new WorkflowControlInstance(Model).ClearPurgeDate();\n\t\t        _ForceReload();\n\t        }\n        }\n\n\t\tpublic void Pause(UserAccount user, string comment)\n\t\t{\n\t\t\t_log.InfoNoPII($\"Pause - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).Pause);\n\t\t}\n\n\t\tpublic void PauseForRevisionSuspended(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status == Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - No action taken, instance already paused\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"PauseForRevisionSuspended - Pausing\");\n\t\t\tPauseInstance(user, comment, new WorkflowControlInstance(Model).PauseForRevisionSuspended);\n\t\t}\n\n\t\tpublic void ResumeForSuspendedRevision(UserAccount user, string comment)\n\t\t{\n\t\t\tif (Model.Status != Enums.WorkflowStepStatus.Paused)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, instance not paused. Status:{Model.Status}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Check if instance UpdatedBy has changed since the PauseForRevisionSuspended was invoked, if it has we do not want to do anything.\n\t\t\tif (Model.UpdatedBy != WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - No action taken, UpdatedBy is not {WorkflowControlInstance.PauseForSuspendedRevisionUpdatedBy}\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_log.InfoNoPII($\"ResumeForSuspendedRevision - Resuming\");\n\t\t\tResume(user, comment);\n\t\t\tClearPurgeDate();\n\t\t}\n\n\t\tpublic bool PauseWhenActivityExecutionLimitReached()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Governance, check whether the number of executed activities exceeded the configured limit\n\t\t\t\t_isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(AccountId, Uid, _instance.RevisionUid, _instance.RevisionCreatedDate, ActivityExecutionCount, out _activityExecutionCountEnforcedLimit);\n\n\t\t\t\tif (_isActivityExecutionLimitReached)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum limit (Actual={ActivityExecutionCount}, EnforcedLimit={_activityExecutionCountEnforcedLimit}) and will be paused.\");\n\n\t\t\t\t\tPause(UserAccount.WorkflowUserAccount(AccountId), \"Workflow activity execution limit reached.\");\n\n\t\t\t\t\tTrySendActivityExecutionLimitExceedNotification(SetPurgeDateForAccountCancel());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' activity execution limit\", e);\n\t\t\t}\n\n\t\t\treturn _isActivityExecutionLimitReached;\n\t\t}\n\n\t\tpublic void PauseWhenThrottled(InstanceActivity activity, WorkflowApiRequestThrottledException exception)\n\t\t{\n\t\t\tRequires.NotNull(activity, nameof(InstanceActivity));\n\t\t\tRequires.NotNull(exception, nameof(WorkflowApiRequestThrottledException));\n\n\t\t\tif (exception.WorkflowThrottledStatus == Enums.WorkflowThrottledStatus.NotThrottled)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' is not throttled and will not be paused.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tactivity.Status = Enums.WorkflowStepStatus.Paused;\n\t\t\t\tvar throttledByApi = exception.ThrottledApiAsString();\n\n\t\t\t\t_log.InfoNoPII($\"Workflow instance '{Uid}' for account '{AccountId}' has exceeded the maximum {throttledByApi} request limit and will be paused. Message: {exception.Message}\");\n\n\t\t\t\tPauseInstance(UserAccount.WorkflowUserAccount(AccountId), $\"{throttledByApi} requests limit reached.\", new WorkflowControlInstance(Model).PauseForWorkflowRateLimitExceed);\n\n\t\t\t\t// Send notification\n\t\t\t\tswitch (exception.WorkflowThrottledStatus)\n\t\t\t\t{\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToExpressionRateLimit:\n\t\t\t\t\t\tTrySendExpressionRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Enums.WorkflowThrottledStatus.ThrottledDueToSmallBenRateLimit:\n\t\t\t\t\t\tTrySendSmallBenRateLimitExceedNotification(SetPurgeDateForWorkflowRateLimit(), GetAdvancedWorkflowNotificationUserAccountUid());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t_log.WarnNoPII(\"No notifications sent for unsupported throttle status\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// mark instance as throttled for current workflow run session, WorkflowThrottledStatus property is not persisted and refreshed on reload\n\t\t\t\t_instance.WorkflowThrottledStatus = exception.WorkflowThrottledStatus;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception e)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Unable to pause instance '{Uid}' for account '{AccountId}' rate limit request limit with status {exception?.WorkflowThrottledStatus}\", e);\n\t\t\t}\n\t\t}\n\n\t\tpublic int SetPurgeDateForWorkflowRateLimit()\n\t\t{\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tvar daysUntilPurge = new WorkflowControlInstance(Model).SetPurgeDateForWorkflowRateLimit();\n\t\t\t\t_ForceReload();\n\t\t\t\treturn daysUntilPurge;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid GetAdvancedWorkflowNotificationUserAccountUid()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while retrieving AdvancedWorkflowNotificationUserAccountUid for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn Guid.Empty;\n\t\t\t}\n\t\t}\n\n\t\tpublic void TrySendSmallBenRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\t// Send notification - pending ATL-90622\n\t\t}\n\n\t\tpublic void TrySendExpressionRateLimitExceedNotification(int pausedPurgeDays, Guid advancedWorkflowNotificationUserAccountUid)\n\t\t{\n\t\t\tif (!ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetEnableWorkflowLimitNotifications(AccountId))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"EnableWorkflowLimitNotifications disabled for account {AccountId}, not sending expression rate limit exceeded notification\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (advancedWorkflowNotificationUserAccountUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"There is no AdvancedWorkflowNotificationUser configured. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {advancedWorkflowNotificationUserAccountUid} to receive expression rate limit exceeded notification\");\n\t\t\t\tUserAccount notificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, advancedWorkflowNotificationUserAccountUid);\n\n\t\t\t\tif (string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"AdvancedWorkflowNotificationUser '{advancedWorkflowNotificationUserAccountUid}' not found or missing email address. Not sending expression rate limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar emailRecipients = new List<string>() { notificationUser.EmailAddress };\n\n\t\t\t\t_log.InfoNoPII($\"Sending expression rate limit exceeded notification to user '{advancedWorkflowNotificationUserAccountUid}' for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseExpressionRateLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowInstanceId = _instance.Id,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn;\n\t\t\t}\n#pragma warning disable CA1031\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tpublic void Resume(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).Resume(user, comment);\n                _ForceReload();\n            }\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Resume(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n        }\n\n        public void ResumeFromError(UserAccount user, string comment)\n        {\n            LastProcessDate = DateTime.UtcNow;\n            lock (_lockObject)\n            {\n                new WorkflowControlInstance(Model).ResumeFromError(user, comment);\n                _ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.ResumeFromError(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowResumed);\n\t\t\t}\n\t\t}\n\n        public void SaveToDatabase()\n        {\n            // We may have in-memory events that need to be saved to the db.\n\t\t\tPersistEvents();\n            _PersistVariables();\n        }\n\n        public void SaveEventsToDatabase()\n        {\n\t\t\ttry\n\t\t\t{\n\t\t\t\tPersistEvents();\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save unsaved events for instance {Uid} to db\", e);\n\t\t\t}\n\t\t}\n\n\t    public void ArchiveVariables()\n        {\n            var incompleteActivities = _data.LoadIncompleteActivitiesByInstanceUid(AccountId, Constants.WorkflowUser, _instance.Uid);\n            // don't archive if there are any incomplete activites besides the one that has triggered this\n            if (incompleteActivities != null && incompleteActivities.Count > 1)\n            {\n                return;\n            }\n            _data.ArchiveVariables(AccountId, Constants.WorkflowUser, Uid);\n        }\n\n\t    public bool HasExistingLockExpired()\n\t    {\n\t\t    return LockExpirationDate < DateTime.UtcNow;\n\t    }\n\n\n        /// <summary>\n        /// Replaces variables provided in the dictionary returning replaced variables\n        /// </summary>\n        public void SetVariables(\n\t        InstanceActivity instanceActivity,\n\t        Dictionary<string, object> variables,\n\t        out List<InstanceVariable> oldVariables,\n\t        out bool areVariablesOverTotalSizeLimit,\n\t        out int totalVariablesSizeBytes,\n\t        out int totalVariablesSizeLimitBytes,\n\t\t\tout Dictionary<string, int> oversizedVariables,\n\t        out int variableValueSizeLimitBytes)\n        {\n            IWINSActivity activity = _SafeGetActivity(instanceActivity);\n            if (activity == null) throw new ApplicationException(string.Format(\"Cannot find expected activity '{0}' in workflow map for instanceUid '{1}'.\", instanceActivity.ActivityTypeName, Uid));\n            _log.DebugWithPII($\"SetVariables called for ActivityUid {instanceActivity.Uid} ({{0}}).\", instanceActivity.Name);\n\n            // We create the context so that the variable dictionaries get populated\n            IWINSWorkflowContext ctx = _CreateContext(activity, instanceActivity);\n            oldVariables = new List<InstanceVariable>();\n            var newVariables = UpdateVariablesHelper.PopulateContextVariables(ctx, this.Model, variables);\n\n            // Only set variables that are under the size limit\n\t\t\toversizedVariables = InstanceVariableGovernance.GetOversizedVariables(ctx.AccountId, newVariables, ctx.SubmittedDate, out variableValueSizeLimitBytes);\n\t\t\tforeach (InstanceVariable variable in newVariables)\n\t\t\t{\n\t\t\t\tif (!oversizedVariables.ContainsKey(variable.Name))\n\t\t\t\t{\n\t\t\t\t\toldVariables.Add(Variables[variable.Name]);\n\t\t\t\t\t// we could do \"ctx.Variables.Set(variable.Key, variable.Value);\" but that would log as the instanceActivity and we don't want that...\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Undo setting the variables, if the instance's total variable size exceeds the limit\n\t\t\tareVariablesOverTotalSizeLimit = InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(ctx.AccountId,\n\t\t\t\tVariables.Select(x => x.Value), ctx.SubmittedDate, activityConfiguration: null, out totalVariablesSizeBytes, out totalVariablesSizeLimitBytes);\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tforeach (InstanceVariable variable in oldVariables)\n\t\t\t\t{\n\t\t\t\t\tVariables[variable.Name] = variable;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n        }\n\n        public DateTime GetLastAbortNotificationDate()\n        {\n\t        if (!_contextInitialized)\n\t        {\n\t\t        _LoadVariables();\n            }\n\n\t        if (_variables.TryGetValue(WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE, out InstanceVariable lastNotificationDate) &&\n\t            DateTime.TryParse(lastNotificationDate.Value.ToString(), out DateTime dateTime))\n\t        {\n\t\t        return dateTime;\n\t        }\n\n            return DateTime.MinValue;\n        }\n\n        public void SaveLastAbortNotificationDate(int accountId, Guid workflowInstanceUid, DateTime lastAbortNotificationDate)\n        {\n            var variable = InstanceVariable.CreateFromValue(\n\t            accountId,\n\t            workflowInstanceUid,\n\t            WINSClientLibrary.VAR_LAST_ABORT_NOTIFICATION_DATE,\n\t            Enums.WorkflowVariableType.Date,\n\t            lastAbortNotificationDate);\n\n            ServiceLocator.GetInstance<IInstanceVariablePersistence>().Save(Constants.WorkflowUser, variable);\n\n        }\n\n        /// <summary>\n        /// Called when we've finished work on an activity -- either executing it or performing a callback on it.\n        /// </summary>\n        private void _ActivityWorkCompleted(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx, Stopwatch sw)\n        {\n\t        // If it's flagged as completed, update in the db, queue up any next activities, and remove it from our list.\n            if (instanceActivity.Status == Enums.WorkflowStepStatus.Completed)\n            {\n                _data.ActivityCompleted(instanceActivity, (activity is AbstractHumanActivity));\n                SaveInstanceActivityVariables(instanceActivity, ctx);\n\n\t\t\t\tRemoveProperties(instanceActivity, activity);\n\n\t\t\t\tif (!ShouldUseScopeEventHandler()) CompleteScopeStep(instanceActivity, activity, ctx);\n\n\t\t\t\tactivity.ActivityFinished(ctx);\n\n\t\t\t\tQueueActivitiesByLink(instanceActivity, instanceActivity.Output);\n\t\t\t\tlock (_unfinishedActivities)\n                {\n                    if (_unfinishedActivities.ContainsKey(instanceActivity.Uid)) _unfinishedActivities.Remove(instanceActivity.Uid);\n                }\n            }\n            else\n            {\n                // Otherwise, it's still running.  Flag it as waiting so it doesn't get processed again.\n                instanceActivity.Status = Enums.WorkflowStepStatus.Waiting;\n                _data.SaveInstanceActivity(instanceActivity);\n            }\n\n            _log.InfoWithPII($\"_ActivityWorkCompleted done for Activity ({{0}}) in status: {instanceActivity.Status} ({sw.ElapsedMilliseconds} ms).\", instanceActivity.Name);\n\n\n            // log workload data\n            try\n            {\n                WorkflowWorkload ww = new WorkflowWorkload();\n                ww.Add(ctx);\n                ww.TotalMs = sw.ElapsedMilliseconds;\n\t\t\t\tww.StartTime = DateTime.UtcNow.AddMilliseconds(-ww.TotalMs);\n                ww.Status = instanceActivity.Status.ToString();\n                ww.Output = instanceActivity.Output;\n                ww.ActivityCreatedDate = instanceActivity.CreatedDate;\n                ww.ActivityStartDate = instanceActivity.StartDate;\n                if (DateTime.MinValue < instanceActivity.EndDate && instanceActivity.EndDate < DateTime.MaxValue)\n                    ww.ActivityEndDate = instanceActivity.EndDate;\n                if (DateTime.MinValue < _instance.CreatedDate && _instance.CreatedDate < DateTime.MaxValue)\n\t                ww.InstanceCreatedDate = _instance.CreatedDate;\n                ww.ActivityKind = activity.Kind.ToString();\n                ww.RevisionUid = _instance.RevisionUid.ToString();\n\t\t\t\tww.DefinitionUid = _instance.DefinitionUid.ToString();\n\t\t\t\tww.WorkflowDB = DataStore.GetDbNameForAccount(instanceActivity.AccountId);\n\n\t\t\t\tww.Log();\n            }\n            catch (Exception ex)\n            {\n                _log.WarnNoPII(\"Failed to log workload.\", ex);\n            }\n        }\n\n\t\tprivate void CompleteScopeStep(InstanceActivity instanceActivity, IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n            try\n            {\n                if (IsTrackItActivity(activity))\n                {\n                    Documents documents = null;\n                    if (ctx.TrackActivity())\n                    {\n                        documents = ((ITrackItActivity)activity).GetDocuments(ctx);\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, instanceActivity.Uid,\n                            documents, instanceActivity.Output, instanceActivity.Status,\n                            instanceActivity.EndDate);\n                    }\n\n                    WorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n                    {\n                        AccountId = ctx.AccountId,\n                        Documents = documents?.Select(d => new WorkflowScopeEvent.DocumentDetail() { Uid = d.Uid, Name = d.Name }).ToList(),\n                        ScopeUid = ctx.ScopeUid,\n                        ScopeName = ctx.ScopeName,\n                        StepName = instanceActivity.Name,\n                        StepDisplayName = GetActivityDisplayName(activity, ctx),\n                        StepTypeName = instanceActivity.ActivityTypeName,\n                        StepUid = instanceActivity.Uid,\n                        PeriodStart = instanceActivity.EndDate,\n                        EventType = (int)ScopeEventType.StepFinished,\n                        Output = instanceActivity.Output,\n                        WorkflowUid = ctx.WorkflowInstanceUid,\n                        WorkflowName = ctx.WorkflowName\n                    };\n                    WorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(ctx.AccountId, ctx.WorkflowInstanceUid)\n                    {\n                        EventData = scopeEventData\n                    };\n                    EventRepo.FireEvent(ctx.WorkflowUserAccount.Account, scopeEvent);\n                }\n            }\n            catch (Exception ex)\n            {\n                _log.ErrorNoPII($\"Error in saving scope event {ctx.ScopeUid} for eventtype {ScopeEventType.StepFinished}\", ex);\n            }\n        }\n\n        private void SaveInstanceActivityVariables(InstanceActivity instanceActivity, IWINSWorkflowContext ctx)\n        {\n\t        if (ctx.WorkflowUserAccount.Account.Settings.EnableWorkflowVariableHistory)\n\t        {\n\t\t        var instanceVariableRepository = ServiceLocator.GetInstance<IInstanceVariableRepository>();\n\t\t        instanceVariableRepository.SaveVariableHistory(instanceActivity.AccountId, ctx.WorkflowUserAccount.Uid,\n\t\t\t        instanceActivity.InstanceUid, instanceActivity.Uid, ctx.Variables.GetAllVariables());\n\t        }\n        }\n\n        private List<WINSWorkflowContextWINSActivity> GetUnfinishedWINSWorkflowContextsWINSActivities(DateTime endDate)\n        {\n\t\t\tvar list = new List<WINSWorkflowContextWINSActivity>();\n\n\t\t\tif (!HasUnfinishedActivities) return list;\n\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values);\n            }\n\n            IWINSWorkflowContext ctx = null;\n            foreach (var activity in activities)\n            {\n                var winsActivity = _SafeGetActivity(activity);\n                ctx = _CreateContext(winsActivity, activity);\n\n                if (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n                {\n\t\t\t\t\tlist.Add(new WINSWorkflowContextWINSActivity { EndDate = endDate, WINSActivity = winsActivity, WINSWorkflowContext = ctx });\n\t\t\t\t}\n            }\n\n\t\t\treturn list;\n        }\n\n\t\tprivate void AbortOrFailScopeStep(Enums.WorkflowStepStatus status, DateTime endDate)\n\t\t{\n\t\t\tif (!HasUnfinishedActivities) return;\n\n\t\t\tList<InstanceActivity> activities;\n\t\t\tlock (_unfinishedActivities)\n\t\t\t{\n\t\t\t\tactivities = new List<InstanceActivity>(_unfinishedActivities.Values);\n\t\t\t}\n\t\t\tIWINSWorkflowContext ctx = null;\n\t\t\tforeach (var activity in activities)\n\t\t\t{\n\t\t\t\tvar winsActivity = _SafeGetActivity(activity);\n\t\t\t\tctx = _CreateContext(winsActivity, activity);\n\n\t\t\t\tif (ctx.TrackActivity() && IsTrackItActivity(winsActivity))\n\t\t\t\t{\n\t\t\t\t\tvar documents = ((ITrackItActivity)winsActivity).GetDocuments(ctx);\n\n\t\t\t\t\tServiceLocator.GetInstance<IDocumentScopeRepository>().CompleteStep(ctx.AccountId, ctx.ScopeUid, activity.Uid, documents, null, status, endDate);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool _CheckWaitingActivities()\n        {\n            List<InstanceActivity> activities;\n            lock (_unfinishedActivities)\n            {\n                activities = new List<InstanceActivity>(_unfinishedActivities.Values.Where(n => n.Status == Enums.WorkflowStepStatus.Waiting));\n            }\n            bool success = false;\n            foreach (InstanceActivity activity in activities)\n            {\n                if (CheckActivityForCompletion(activity)) success = true;\n            }\n            return success;\n        }\n\n        private bool _contextInitialized = false;\n        private IWINSWorkflowContext _CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n            IWINSWorkflowContext ctx = CreateContext(activity, instanceActivity);\n            AtlasContext.Current.UserAccount = ctx.WorkflowUserAccount;\n            // Only do this once.  If it's been done, it's done.\n            if (_contextInitialized) return ctx;\n\n            // This all depends on the properties for the Start step.  We always want a Start step for normal processing;\n            // however, we don't necessarily have a Start step for our tests.\n            StartActivity start = _workflowMap.StartActivity;\n            if (start == null)\n            {\n                if (_data.IsTest) return ctx;\n                throw new ApplicationException(string.Format(\"Cannot find StartActivity for InstanceUid {0}\", _instance.Uid));\n            }\n\n            // Contents\n            string[][] contents = start.DefinedContents;\n            if (contents != null && contents.Length > 0)\n            {\n                foreach (string[] t in contents)\n                {\n                    ContentDefinition definition = new ContentDefinition(t);\n                    if (!_contentDefinitions.ContainsKey(definition.Name)) _contentDefinitions[definition.Name] = definition;\n                }\n            }\n\n            _LoadVariables();\n\n            // XML Variables\n            // Because XmlVariables have dependencies on the variables as well, it's easier to feed this through the xml variable handler\n            // rather than replicate the code.\n            List<IXmlVariableDefinition> definitions = start.DefinedXmlVariables;\n            if (definitions != null && definitions.Count > 0)\n            {\n                foreach (IXmlVariableDefinition definition in definitions)\n                {\n                    if (!_xmlVariableDefinitions.ContainsKey(definition.Name)) ctx.XmlVariables.Declare(definition, logMessage: false);\n                }\n            }\n\n            _contextInitialized = true;\n            return ctx;\n\t\t}\n\n        public IWINSWorkflowContext CreateContext(IWINSActivity activity, InstanceActivity instanceActivity)\n        {\n\t\t\treturn ServiceLocator.GetInstance<IWorkflowContextFactory>().CreateWorkflowContext(this, activity, instanceActivity);\n        }\n\n\t\tprivate void _LoadVariables()\n        {\n\t        // Variables\n\t        Dictionary<string, InstanceVariable> variables = _data.LoadVariablesByInstanceUid(AccountId, Constants.WorkflowUser, Uid);\n\t        foreach (InstanceVariable variable in variables.Values)\n\t        {\n\t\t        if (!_variables.ContainsKey(variable.Name)) _variables[variable.Name] = variable;\n\t        }\n        }\n\n        private bool _ExecuteFirstActivity()\n        {\n            InstanceActivity activity = null;\n            lock (_unfinishedActivities)\n            {\n                if (_unfinishedActivities.Count > 0) activity = _unfinishedActivities.Values.FirstOrDefault(n => n.Status == Enums.WorkflowStepStatus.Pending || n.Status == Enums.WorkflowStepStatus.Executing);\n            }\n            if (activity == null) return false;\n            ExecuteActivity(activity);\n            return true;\n        }\n\n        private bool _ExecuteFirstEvent(bool controlOnly = false)\n        {\n            // We always try to execute control events first.\n            Event e = null;\n            lock (_queuedControlEvents)\n            {\n                if (_queuedControlEvents.Count > 0) e = _queuedControlEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            // If we're only caring about control events, we can quit now.\n            if (controlOnly) return false;\n\n            // Otherwise, we do the same thing with the rest of the events.\n            lock (_queuedEvents)\n            {\n                if (_queuedEvents.Count > 0) e = _queuedEvents.Dequeue();\n            }\n            if (e != null)\n            {\n                ExecuteEvent(e);\n                return true;\n            }\n\n            return false;\n        }\n\n        private void _ForceReload()\n        {\n            // Reload the object to get new state -- we do this inside the lock so that there's no race condition\n            // between this and a worker who may be working on the object\n            lock (_lockObject)\n            {\n                Guid instanceUid = Uid;\n                _instance = _data.LoadInstanceByUid(AccountId, Constants.WorkflowUser, instanceUid);\n                if (_instance == null) throw new ApplicationException(string.Format(\"Failed to reload instanceUid: {0}\", instanceUid));\n            }\n        }\n\n        private void _MarkCompleted()\n        {\n\t        if (_instance.IsCompleted)\n\t        {\n\t\t        _log.InfoNoPII($\"Instance {_instance.Uid} is already complete with status {_instance.Status}\");\n\t\t        return;\n\t        }\n\n            _PersistVariables();\n            bool endActivityFailure = _workflowMap.HasEndActivity() && !_instance.EndActivityReached;\n            Enums.WorkflowStepStatus endStatus = endActivityFailure ? Enums.WorkflowStepStatus.Failed : Enums.WorkflowStepStatus.Completed;\n            _data.SaveInstance(_instance);\n            _data.InstanceCompleted(_instance, endStatus);\n\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Complete(_instance);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar eventType = _instance.Status == Enums.WorkflowStepStatus.Failed ? ScopeEventType.WorkflowFailed : ScopeEventType.WorkflowFinished;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo()\n\t\t\t\t\t{\n\t\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\t\tPeriodStart = _instance.EndDate,\n\t\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\t\tWorkflowName = _instance.Name\n\t\t\t\t\t};\n\t\t\t\t\tWorkflowScopeEvent scopeEvent = new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t\t{\n\t\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t\t};\n\t\t\t\t\tEventRepo.FireEvent(_instance.AccountId, scopeEvent);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event {_instance.ScopeUid} for eventtype {eventType}\", ex);\n\t\t\t\t}\n\t\t\t}\n\n            if (endActivityFailure && _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                if (_lastActivityUid == Guid.Empty)\n                {\n                    _log.WarnNoPII($\"No activities for workflow.\");\n                }\n                else\n                {\n                    InstanceActivity activity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, _lastActivityUid);\n                    IWINSActivity winsActivity = _SafeGetActivity(activity);\n                    IWINSWorkflowContext ctx = _CreateContext(winsActivity, activity);\n                    LoggingHelper.LogActivityErrorNoPII(ctx, Resources.WINSResources.WorkflowExitedWithoutReachingTheEndActivity);\n                }\n\n            }\n            if (_instance.Status == Enums.WorkflowStepStatus.Completed || _instance.Status == Enums.WorkflowStepStatus.Failed)\n            {\n                _data.FireMessageQueueEvent(new WorkflowEvent(AccountId, _instance.Uid, (int)_instance.Status));\n            }\n        }\n\n        private void _MarkWaiting()\n        {\n            _PersistVariables();\n            _instance.Status = Enums.WorkflowStepStatus.Waiting;\n            _data.SaveInstance(_instance);\n        }\n\n        private void _PersistVariables()\n        {\n            InstanceVariables variables = new InstanceVariables();\n            foreach (InstanceVariable variable in _variables.Values) if (variable.IsModified) variables.Add(variable);\n            _data.SaveInstanceVariables(AccountId, Constants.WorkflowUser, variables);\n        }\n\n        private void PersistEvents()\n\t\t{\n\t\t\tlock (_queuedControlEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedControlEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedControlEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlock (_queuedEvents)\n\t\t\t{\n\t\t\t\twhile (_queuedEvents.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tPersistEvent(_queuedEvents.Dequeue());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        private void PersistEvent(Event e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (e.Uid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_data.CreateEvent(e);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventCreatedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_data.UnlockEvent(e.AccountId, e.Uid);\n\t\t\t\t\tWorkflowEventWorkload wrk = new WorkflowEventWorkload(e, \"EventUnlockedOnInstanceSave\")\n\t\t\t\t\t{\n\t\t\t\t\t\tRevisionUid = _instance.RevisionUid,\n\t\t\t\t\t\tWorkflowDB = DataStore.GetDbNameForAccount(e.AccountId)\n\t\t\t\t\t};\n\t\t\t\t\twrk.Log();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to save event {e.Uid}, for instance {e.InstanceUid}, activity {e.ActivityUid}, and callback name {e.CallbackName} to db\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate IWINSActivity _SafeGetActivity(InstanceActivity instanceActivity)\n        {\n            try\n            {\n                IWINSActivity activity;\n                if (_workflowMap.TryGetActivity(instanceActivity.Name, out activity)) return activity;\n                // There is a problem with old MWF workflow data where the name of the activity is really the type name.\n                // Don't ask.  It's a stupid and boring story.\n                // But we still should handle it, at least for awhile.  So: if we get here because we didn't match name, we should see\n                // if we match type name.\n                // This whole thing is a huge hack that should get removed when it can.\n                InstanceActivity inputActivity = null;\n                if (instanceActivity.InputActivityUid != Guid.Empty) inputActivity = _data.LoadActivityByUid(AccountId, Constants.WorkflowUser, instanceActivity.InputActivityUid);\n                if (_workflowMap.LegacyTryGetActivityByTypeName(instanceActivity.Name, inputActivity == null ? \"\" : inputActivity.Name, instanceActivity.InputActivityOutput ?? \"\", out activity))\n                {\n                    // Rename it so we get one less instance of this in the future\n                    instanceActivity.Name = activity.Name;\n                    return activity;\n                }\n                throw new ApplicationException(string.Format(\"Invalid activity name '{0}' for instanceUid '{1}'.\", instanceActivity.Name, instanceActivity.InstanceUid));\n            }\n            catch (Exception e)\n            {\n                _log.ErrorNoPII($\"_SafeGetActivity failed.\", e);\n                return null;\n            }\n        }\n\n        private bool _ShouldProcess(InstanceActivity instanceActivity)\n        {\n            switch (instanceActivity.Status)\n            {\n                case Enums.WorkflowStepStatus.Executing:\n                case Enums.WorkflowStepStatus.Pending:\n                case Enums.WorkflowStepStatus.Waiting:\n                case Enums.WorkflowStepStatus.Aborted:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private bool _ShouldProcess()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        private bool _ShouldProcessEvent()\n        {\n            lock (_lockObject)\n            {\n                switch (Model.Status)\n                {\n                    case Enums.WorkflowStepStatus.Executing:\n                    case Enums.WorkflowStepStatus.Pending:\n                    case Enums.WorkflowStepStatus.Waiting:\n                    case Enums.WorkflowStepStatus.Aborted:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        //ITrackItActivity interface is implemented by activities whose data is tracked in DocumentScope and ScopeEvent tables.\n        private bool IsTrackItActivity(IWINSActivity activity)\n        {\n            return activity is ITrackItActivity;\n        }\n\n\t\tprivate void FireWorkflowScopeEvent(UserAccount user, ScopeEventType eventType, IWINSActivity activity = null, IWINSWorkflowContext ctx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tWorkflowScopeEvent.ScopeEventInfo scopeEventData = new WorkflowScopeEvent.ScopeEventInfo\n\t\t\t\t{\n\t\t\t\t\tAccountId = _instance.AccountId,\n\t\t\t\t\tScopeUid = _instance.ScopeUid,\n\t\t\t\t\tScopeName = _instance.ScopeName,\n\t\t\t\t\tPeriodStart = DateTime.UtcNow,\n\t\t\t\t\tEventType = (int)eventType,\n\t\t\t\t\tWorkflowUid = _instance.Uid,\n\t\t\t\t\tWorkflowName = _instance.Name,\n\t\t\t\t\tEventBy = user == null ? null : new WorkflowScopeEvent.Assignee() { Email = user.EmailAddress, Name = user.FriendlyName, Uid = user.Uid }\n\t\t\t\t};\n\n\t\t\t\tif (activity != null && ctx != null)\n\t\t\t\t{\n\t\t\t\t\tscopeEventData.StepName = ctx.ActivityName;\n\t\t\t\t\tscopeEventData.StepDisplayName = GetActivityDisplayName(activity, ctx);\n\t\t\t\t\tscopeEventData.StepTypeName = ctx.ActivityTypeName;\n\t\t\t\t\tscopeEventData.StepUid = ctx.ActivityUid;\n\t\t\t\t}\n\n\t\t\t\tEventRepo.FireEvent(_instance.AccountId, new WorkflowScopeEvent(_instance.AccountId, _instance.Uid)\n\t\t\t\t{\n\t\t\t\t\tEventData = scopeEventData\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Error in saving scope event scopeUid: {_instance.ScopeUid}, instanceUid: {_instance.Uid} eventType: {eventType}\", ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate void RemoveProperties(InstanceActivity instanceActivity, IWINSActivity activity)\n\t    {\n\t\t    // We need to delete properties if this is not a human activity or WaitForNextStepAfterCompletion is not set\n\t\t    if (activity is AbstractHumanActivity && ServiceLocator.GetInstance<IWorkflowSettingRepository>().GetWaitForNextStepAfterCompletion(instanceActivity.AccountId))\n\t\t    {\n\t\t\t\t_data.DeleteActivityPropertiesWithExclusion(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid, new List<string> { nameof(AbstractHumanActivity.WaitForNextStep) });\n\t\t\t\t_log.InfoNoPII(\"Removing activity properties except WaitForNextStep\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t    _data.DeleteActivityProperties(instanceActivity.AccountId, instanceActivity.InstanceUid, instanceActivity.Uid);\n\t\t\t    _log.InfoNoPII(\"Removing activity properties\");\n\t\t    }\n\t    }\n\n\t\tprivate string[] BuildNDCTags(InstanceActivity instanceActivity) => instanceActivity != null ? new[] { $\"ActivityId:{instanceActivity.Uid}\",$\"W:{instanceActivity.InstanceUid}\" } : new string[] { };\n\t    private string[] BuildNDCTags(Event e) => e != null ? new[] { $\"ActivityId:{e.ActivityUid}\", $\"W:{e.InstanceUid}\" } : new string[] { };\n\n\t\t/// <summary>\n\t\t/// Try to send an e-mail to support when a workflow instance activity execution account exceeds configured threshold.\n\t\t/// </summary>\n\t\t/// <param name=\"pausedPurgeDays\">Number of days to purge workflow related data</param>\n\t\t/// <returns>\n\t\t/// True\t-> Success.\n\t\t/// False\t-> Fail to send email.\n\t\t/// </returns>\n\t\tprivate bool TrySendActivityExecutionLimitExceedNotification(int pausedPurgeDays)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar emailRecipients = new List<string>();\n\n\t\t\t\t// Support should get the email\n\t\t\t\tvar supportEmailAddress = WorkflowSettingRepository.GetSupportNotificationEmailAddress(AccountId);\n\t\t\t\tif (!string.IsNullOrEmpty(supportEmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(supportEmailAddress);\n\t\t\t\t}\n\n\t\t\t\t// Also send to AdvancedWorkflowNotificationUserAccountUid, if configured for account\n\t\t\t\tUserAccount notificationUser = null;\n\t\t\t\tvar notificationUserUid = new AccountSettings(AccountId, Constants.WorkflowUser).AdvancedWorkflowNotificationUserAccountUid;\n\t\t\t\tif (notificationUserUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Loading {nameof(UserAccount)} {notificationUserUid} to receive activity execution limit exceeded notification\");\n\t\t\t\t\tnotificationUser = UserAccountRepository.Instance.LoadByUid(AccountId, notificationUserUid);\n\t\t\t\t}\n\t\t\t\tif (!string.IsNullOrEmpty(notificationUser?.EmailAddress))\n\t\t\t\t{\n\t\t\t\t\temailRecipients.Add(notificationUser.EmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif (!emailRecipients.Any())\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"Email support address setting is empty, and there is no AdvancedWorkflowNotificationUser configured. Thus, not sending activity execution limit exceeded notification for account '{AccountId}' and workflow instance '{Uid}'.\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Sending activity execution limit exceeded notification to {emailRecipients.Count} {(emailRecipients.Count > 1 ? \"recipients\" : \"recipient\")} for account '{AccountId}' and workflow instance '{Uid}'.\");\n\n\t\t\t\tvar email = new WorkflowPauseActivityExecutionLimitExceededNotificationEmail\n\t\t\t\t{\n\t\t\t\t\tAccountId = AccountId,\n\t\t\t\t\tWorkflowInstanceUid = Uid,\n\t\t\t\t\tWorkflowRevisionUid = _instance.RevisionUid,\n\t\t\t\t\tNumberOfActivitiesExecuted = ActivityExecutionCount,\n\t\t\t\t\tEmailRecipients = emailRecipients,\n\t\t\t\t\tPausedPurgeDays = pausedPurgeDays\n\t\t\t\t};\n\n\t\t\t\tServiceLocator.GetInstance<IEmailDistributor>().Init(email).QueueIt();\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"An exception occurred while sending activity execution limit exceeded notification to support for account '{AccountId}' and workflow instance '{Uid}'.\", ex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprivate string GetActivityDisplayName(IWINSActivity activity, IWINSWorkflowContext ctx)\n\t\t{\n\t\t\treturn activity is AbstractHumanActivity abstractHumanActivity\n\t\t\t\t? abstractHumanActivity.ActivityDisplayName.Evaluate(ctx)\n\t\t\t\t: null;\n\t\t}\n\n\t\tprivate bool ShouldUseScopeEventHandler() => WorkflowFeatureFlags.UseScopeEventHandler &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t Model?.EngineVersion == Core.Workflow.Constants.EngineVersionV2;\n\n\t\tprivate void PauseInstance(UserAccount user, string comment, Action<UserAccount, string> pauseMethod)\n\t\t{\n\t\t\tRequires.NotNull(pauseMethod, nameof(pauseMethod));\n\t\t\tLastProcessDate = DateTime.UtcNow;\n\t\t\tlock (_lockObject)\n\t\t\t{\n\t\t\t\tpauseMethod(user, comment);\n\t\t\t\t_ForceReload();\n\t\t\t}\n\t\t\tif (ShouldUseScopeEventHandler())\n\t\t\t{\n\t\t\t\tInstanceHandler.Pause(_instance, user);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tFireWorkflowScopeEvent(user, ScopeEventType.WorkflowPaused);\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") => ServiceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{nameof(WorkflowInstance)}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, _instance.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, _instance.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, _instance.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, _instance.RevisionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, _instance.DefinitionUid);\n\n\t\tprivate void CheckAndHandleInstanceStateChanges()\n\t\t{\n\t\t\tvar environmentType = SiteConfig?.Value?.EnvironmentType;\n\t\t\tvar isGrpcEnabled = WorkflowClientConfig?.Value?.IsGrpcClientEnabled == true;\n\n\t\t\tvar isRunningOnCloudWithGrpcEnabled = environmentType == Core.Util.Config.EnvironmentType.Cloud && isGrpcEnabled;\n\n\t\t\tif (isRunningOnCloudWithGrpcEnabled && InstanceStateChangedHelper.IsInstanceStateChanged(_instance.Uid, ActivityExecutionCount, CacheRepository, WorkflowSettingRepository))\n\t\t\t{\n\t\t\t\t_ForceReload();\n\t\t\t\tInstanceStateChangedHelper.RemoveInstanceStateChanged(_instance.Uid, CacheRepository);\n\t\t\t}\n\t\t}\n    }\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
            "content": "#if NET\n#nullable enable\n\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService\n{\n    private Activity? StartActivity([CallerMemberName] string name = \"\") => _serviceInstrumentation?.ActivitySource\n                ?.StartActivity($\"{nameof(WinsService)}.{name}\")\n                ?.SetStatus(ActivityStatusCode.Error)\n                ?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n}\n\n#nullable restore\n#endif\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
            "content": "#if NET\n#nullable enable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Domain.Repository.Workflow.Mappers;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Workflow.Model;\nusing ADEXS.WINS.Telemetry;\nusing ADEXS.WINS.V1;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing Google.Protobuf.WellKnownTypes;\nusing Google.Rpc;\n\nusing Grpc.Core;\n\nusing Microsoft.Extensions.Logging;\n\nusing OpenTelemetry.Trace;\n\nusing Definition = ADEXS.Core.Domain.Model.Workflow.Definition;\nusing Design = DocuSign.CLM.Workflow.Core.Persistence.Model.Design;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing StartParameters = ADEXS.Core.Domain.Model.Workflow.StartParameters;\nusing Status = Grpc.Core.Status;\nusing StatusCode = Grpc.Core.StatusCode;\nusing ValueExpressionOneOfCase = ADEXS.WINS.V1.VariableUpdate.ValueExpressionOneofCase;\nusing VariableUpdate = ADEXS.Core.Domain.Repository.Workflow.Types.VariableUpdate;\nusing Version = ADEXS.Core.Domain.Model.Workflow.Version;\n\nnamespace ADEXS.WINS.Service.V1;\n\npublic partial class WinsService : WINS.V1.WinsService.WinsServiceBase\n{\n\tprivate static readonly Status StatusInvalidArgumentInstanceUid = new(StatusCode.InvalidArgument, \"InstanceUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentActivityUid = new(StatusCode.InvalidArgument, \"ActivityUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentVersionUid = new(StatusCode.InvalidArgument, \"VersionUid is malformed\");\n\n\tprivate static readonly Status StatusInvalidArgumentRevisionUid = new(StatusCode.InvalidArgument, \"RevisionUid is malformed\");\n\n\tprivate readonly ILogger _logger;\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate readonly IUserAccountRepository _userAccountRepository;\n\n\tprivate readonly IWorkflowClient _workflowClient;\n\n\tprivate readonly IWorkflowV1GrpcMapper _workflowV1GrpcMapper;\n\n\tpublic WinsService(\n\t\tIWorkflowClient workflowClient,\n\t\tIUserAccountRepository userAccountRepository,\n\t\tIWorkflowV1GrpcMapper workflowV1GrpcMapper,\n\t\tIServiceInstrumentation serviceInstrumentation,\n\t\tILogger<WinsService> logger)\n\t{\n\t\t_workflowClient = workflowClient;\n\t\t_userAccountRepository = userAccountRepository;\n\t\t_workflowV1GrpcMapper = workflowV1GrpcMapper;\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t_logger = logger;\n\t}\n\n\tpublic override Task<CreateNewWorkflowDefinitionResponse> CreateNewWorkflowDefinition(\n\t\t[NotNull] CreateNewWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.CreateNewWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar definitionModel = _workflowClient.CreateNewWorkflowDefinition(userAccount, request.WorkflowName);\n\n\t\t\tvar definition = _workflowV1GrpcMapper.Map<Definition, WINS.V1.Definition>(definitionModel);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new CreateNewWorkflowDefinitionResponse {Definition = definition});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.CreateNewWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ExportWorkflowDefinitionResponse> ExportWorkflowDefinition(\n\t\t[NotNull] ExportWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ExportWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar definitionXml = _workflowClient.ExportWorkflowDefinition(userAccount, request.WorkflowName);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ExportWorkflowDefinitionResponse {DefinitionXml = definitionXml});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ExportWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ImportWorkflowDefinitionResponse> ImportWorkflowDefinition(\n\t\t[NotNull] ImportWorkflowDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ImportWorkflowDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revisionModel = _workflowClient.ImportWorkflowDefinition(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.DefinitionXml,\n\t\t\t\trequest.OverwriteExistingWorkflow,\n\t\t\t\trequest.Comment,\n\t\t\t\trequest.TemplateId,\n\t\t\t\trequest.TemplateVersion);\n\n\t\t\tvar revision = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revisionModel);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ImportWorkflowDefinitionResponse {Revision = revision});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ImportWorkflowDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PublishWorkflowResponse> PublishWorkflow(\n\t\t[NotNull] PublishWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.VersionUid);\n\n\t\tif (!Guid.TryParse(request!.VersionUid, out var versionUid))\n\t\t{\n\t\t\tLogger.PublishWorkflowInvalidArgument(_logger, request.User.AccountId, ex: null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentVersionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PublishWorkflow(_logger, request.User.AccountId, request.VersionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowClient.PublishWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\tversionUid,\n\t\t\t\trequest.RevisionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar revisionResponse = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revision);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PublishWorkflowResponse {Revision = revisionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PublishWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PublishWorkflowByNameResponse> PublishWorkflowByName(\n\t\t[NotNull] PublishWorkflowByNameRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PublishWorkflowByName(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowClient.PublishWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.VersionNumber,\n\t\t\t\trequest.RevisionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar revisionResponse = _workflowV1GrpcMapper.Map<Revision, WINS.V1.Revision>(revision);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PublishWorkflowByNameResponse {Revision = revisionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PublishWorkflowByNameFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<VersionWorkflowResponse> VersionWorkflow(\n\t\t[NotNull] VersionWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.SourceVersionUid);\n\n\t\tif (!Guid.TryParse(request!.SourceVersionUid, out var sourceVersionUid))\n\t\t{\n\t\t\tLogger.VersionWorkflowInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentVersionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.VersionWorkflow(_logger, request.User.AccountId, request.SourceVersionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowClient.VersionWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\tsourceVersionUid,\n\t\t\t\trequest.SourceRevisionNumber,\n\t\t\t\trequest.NewVersionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar versionResponse = _workflowV1GrpcMapper.Map<Version, WINS.V1.Version>(version);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new VersionWorkflowResponse {Version = versionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.VersionWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<VersionWorkflowByNameResponse> VersionWorkflowByName(\n\t\t[NotNull] VersionWorkflowByNameRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.VersionWorkflowByName(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowClient.VersionWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceVersionNumber,\n\t\t\t\trequest.SourceRevisionNumber,\n\t\t\t\trequest.NewVersionNumber,\n\t\t\t\trequest.Comment);\n\n\t\t\tvar versionResponse = _workflowV1GrpcMapper.Map<Version, WINS.V1.Version>(version);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new VersionWorkflowByNameResponse {Version = versionResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.VersionWorkflowByNameFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<KillWorkflowResponse> KillWorkflow(KillWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.KillWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.KillWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.KillWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new KillWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.KillWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.KillWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.KillWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<PauseWorkflowResponse> PauseWorkflow(PauseWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.PauseWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.PauseWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.PauseWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new PauseWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.PauseWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.PauseWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.PauseWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ResumeWorkflowResponse> ResumeWorkflow(\n\t\tResumeWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.ResumeWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.ResumeWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.ResumeWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ResumeWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ResumeWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ResumeWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ResumeWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ResumeFailedWorkflowResponse> ResumeFailedWorkflow(\n\t\tResumeFailedWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.ResumeFailedWorkflow(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\t_workflowClient.ResumeFailedWorkflow(userAccount, instanceUid, request.Comment);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ResumeFailedWorkflowResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowInvalidArgument(_logger, request.User.AccountId, request.InstanceUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ResumeFailedWorkflowFailed(_logger, request.User.AccountId, request.InstanceUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SystemCallbackResponse> SystemCallback(\n\t\t[NotNull] SystemCallbackRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid);\n\n\t\tif (!Guid.TryParse(request.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (string.IsNullOrEmpty(request.CallbackName))\n\t\t{\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(StatusCode.InvalidArgument, $\"{nameof(request.CallbackName)} is null or empty\"));\n\t\t}\n\n\t\tLogger.SystemCallback(\n\t\t\t_logger,\n\t\t\trequest.AccountId,\n\t\t\trequest.InstanceUid,\n\t\t\trequest.ActivityUid,\n\t\t\trequest.CallbackName);\n\n\t\ttry\n\t\t{\n\t\t\t_workflowClient.SystemCallback(\n\t\t\t\trequest.AccountId,\n\t\t\t\tinstanceUid,\n\t\t\t\tactivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\trequest.CallbackData);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new SystemCallbackResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SystemCallbackInvalidArgument(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\targEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SystemCallbackFailed(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\tpublicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SystemCallbackFailed(\n\t\t\t\t_logger,\n\t\t\t\trequest.AccountId,\n\t\t\t\trequest.InstanceUid,\n\t\t\t\trequest.ActivityUid,\n\t\t\t\trequest.CallbackName,\n\t\t\t\tex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowResponse> StartWorkflow(StartWorkflowRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.StartWorkflow(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.StartWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowFromSourceResponse> StartWorkflowFromSource(\n\t\tStartWorkflowFromSourceRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tLogger.StartWorkflowFromSource(_logger, request.User.AccountId, request.InstanceUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar newInstanceUid = _workflowClient.StartWorkflowFromSource(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam,\n\t\t\t\tinstanceUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.AddTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, newInstanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowFromSourceResponse {InstanceUid = newInstanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowFromSourceFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartWorkflowWithParametersResponse> StartWorkflowWithParameters(\n\t\tStartWorkflowWithParametersRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\t\tValidateUser(request?.StartParameters?.Submitter);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tValidateAndParseUserUid(request.StartParameters!.Submitter.Uid, request.StartParameters.Submitter.AccountId, out var submitterUserAccountUid);\n\n\t\tLogger.StartWorkflowWithParameters(_logger, request.User.AccountId, request.InstanceUid, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar submitterUserAccount = LoadUserAccountSafe(request.StartParameters.Submitter.AccountId, submitterUserAccountUid);\n\n\t\t\tvar startParameters = new StartParameters(submitterUserAccount, null, null, null);\n\t\t\t_workflowV1GrpcMapper.Map(request.StartParameters, startParameters);\n\n\t\t\tvar newInstanceUid = _workflowClient.StartWorkflowWithParameters(\n\t\t\t\tuserAccount,\n\t\t\t\trevisionUid,\n\t\t\t\tstartParameters,\n\t\t\t\tinstanceUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.AddTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, newInstanceUid);\n\t\t\treturn Task.FromResult(new StartWorkflowWithParametersResponse {InstanceUid = newInstanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartWorkflowWithParametersFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<StartRoutingApprovalWorkflowResponse> StartRoutingApprovalWorkflow(\n\t\tStartRoutingApprovalWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.StartRoutingApprovalWorkflow(_logger, request.User.AccountId, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.StartRoutingApprovalWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trevisionUid,\n\t\t\t\trequest.RoutingApprovalName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\t\t\treturn Task.FromResult(new StartRoutingApprovalWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.StartRoutingApprovalWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SendStartWorkflowResponse> SendStartWorkflow(\n\t\tSendStartWorkflowRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateWorkflowName(request!.WorkflowName);\n\t\tValidateAndParseUserUid(request.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.SendStartWorkflow(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar instanceUid = _workflowClient.SendStartWorkflow(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.WorkflowName,\n\t\t\t\trequest.SourceType,\n\t\t\t\trequest.SourceId,\n\t\t\t\trequest.XmlParam);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, instanceUid);\n\n\t\t\treturn Task.FromResult(new SendStartWorkflowResponse {InstanceUid = instanceUid.ToString()});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SendStartWorkflowInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SendStartWorkflowFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SendStartWorkflowFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<SubmitWorkItemResponse> SubmitWorkItem(\n\t\tSubmitWorkItemRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkItemUid, request.WorkItemUid);\n\n\t\tif (!Guid.TryParse(request!.WorkItemUid, out var workItemUid))\n\t\t{\n\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, ex: null);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"WorkItemUid is malformed\"));\n\t\t}\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.SubmitWorkItem(_logger, request.User.AccountId, request.WorkItemUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables = new Dictionary<string, object>();\n\n\t\t\tforeach (var wireVariable in request.UpdatedVariables)\n\t\t\t{\n\t\t\t\tvar workflowVariableType =\n\t\t\t\t\t_workflowV1GrpcMapper.Map<WorkflowVariableType, Enums.WorkflowVariableType>(wireVariable.Type);\n\n\t\t\t\tif (!WorkflowConversion.TryParseVariableValue(\n\t\t\t\t\t    request.User.AccountId,\n\t\t\t\t\t    workflowVariableType,\n\t\t\t\t\t    wireVariable.Value.ToStringUtf8(),\n\t\t\t\t\t    out var outputValue))\n\t\t\t\t{\n\t\t\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, null);\n\t\t\t\t\tthrow new RpcException(\n\t\t\t\t\t\tnew Status(StatusCode.InvalidArgument, \"Unable to parse one of updated variables\"));\n\t\t\t\t}\n\n\t\t\t\tupdatedVariables[wireVariable.Name] = outputValue;\n\t\t\t}\n\n\t\t\t_workflowClient.SubmitWorkItem(\n\t\t\t\tuserAccount,\n\t\t\t\tworkItemUid,\n\t\t\t\trequest.Output,\n\t\t\t\trequest.Comments,\n\t\t\t\trequest.ActivityMessages,\n\t\t\t\tupdatedVariables);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new SubmitWorkItemResponse());\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.SubmitWorkItemInvalidArgument(_logger, request.User.AccountId, request.WorkItemUid, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.SubmitWorkItemFailed(_logger, request.User.AccountId, request.WorkItemUid, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.SubmitWorkItemFailed(_logger, request.User.AccountId, request.WorkItemUid, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<LoadDesignResponse> LoadDesign(LoadDesignRequest request, ServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Version.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Version.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.LoadDesign(_logger, request.User.AccountId, request.Version.Uid, request.Version.DefinitionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar version = _workflowV1GrpcMapper.Map<WINS.V1.Version, Version>(request.Version);\n\n\t\t\tvar design = _workflowClient.LoadDesign(userAccount, version);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(design);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new LoadDesignResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.LoadDesignInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.LoadDesignFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.LoadDesignFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<LoadDesignByRevisionResponse> LoadDesignByRevision(\n\t\tLoadDesignByRevisionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.Revision.Uid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowVersionUid, request.Revision.VersionUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowDefinitionUid, request.Revision.DefinitionUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.LoadDesignByRevision(_logger, request.User.AccountId, request.Revision.Uid, request.Revision.VersionUid, request.Revision.DefinitionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar revision = _workflowV1GrpcMapper.Map<WINS.V1.Revision, Revision>(request.Revision);\n\n\t\t\tvar design = _workflowClient.LoadDesign(userAccount, revision);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(design);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new LoadDesignByRevisionResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.LoadDesignByRevisionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<ConvertLegacyDefinitionResponse> ConvertLegacyDefinition(\n\t\tConvertLegacyDefinitionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tLogger.ConvertLegacyDefinition(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar oldDesign = _workflowV1GrpcMapper.Map<WINS.V1.Design, Design>(request.OldDesign);\n\n\t\t\tvar newDesign = _workflowClient.ConvertLegacyDefinition(userAccount, oldDesign);\n\n\t\t\tvar designResponse = _workflowV1GrpcMapper.Map<Design, WINS.V1.Design>(newDesign);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new ConvertLegacyDefinitionResponse {Design = designResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.ConvertLegacyDefinitionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<CompileExpressionBuilderExpressionResponse> CompileExpressionBuilderExpression(\n\t\tCompileExpressionBuilderExpressionRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (string.IsNullOrWhiteSpace(request.Code))\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"Code is null or empty\"));\n\t\t}\n\n\t\tLogger.CompileExpressionBuilderExpression(_logger, request.User.AccountId);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar output = _workflowClient.CompileExpressionBuilderExpression(\n\t\t\t\tuserAccount,\n\t\t\t\trequest.Code,\n\t\t\t\trequest.AdditionalCode,\n\t\t\t\trequest.ReturnType);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new CompileExpressionBuilderExpressionResponse {Output = output});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.CompileExpressionBuilderExpressionFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<UpdateVariablesResponse> UpdateVariables(\n\t\tUpdateVariablesRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceInstanceUid, out var sourceInstanceUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceActivityUid, out var sourceActivityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tLogger.UpdateVariables(_logger, request.User.AccountId, request.ActivityUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables =\n\t\t\t\t_workflowV1GrpcMapper\n\t\t\t\t\t.Map<List<ADEXS.WINS.V1.VariableUpdate>, List<VariableUpdate>>(\n\t\t\t\t\t\trequest.VariableUpdates.ToList());\n\n\t\t\tvar result = _workflowClient.UpdateVariables(\n\t\t\t\tuserAccount,\n\t\t\t\tactivityUid,\n\t\t\t\tupdatedVariables,\n\t\t\t\tsourceInstanceUid,\n\t\t\t\tsourceActivityUid);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new UpdateVariablesResponse {Result = result});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.UpdateVariablesFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<UpdateVariablesWithResultResponse> UpdateVariablesWithResult(\n\t\tUpdateVariablesWithResultRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tValidateUser(request?.User);\n\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request!.User.AccountId)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowActivityUid, request.ActivityUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceInstanceUid, request.SourceInstanceUid)\n\t\t\t.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowSourceActivityUid, request.SourceActivityUid);\n\n\t\tValidateAndParseUserUid(request!.User.Uid, request.User.AccountId, out var userAccountUid);\n\n\t\tif (!Guid.TryParse(request!.ActivityUid, out var activityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceInstanceUid, out var sourceInstanceUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request.SourceActivityUid, out var sourceActivityUid))\n\t\t{\n\t\t\tLogger.UpdateVariablesInvalidArgument(_logger, request.User.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentActivityUid);\n\t\t}\n\n\t\tLogger.UpdateVariablesWithResult(_logger, request.User.AccountId, request.ActivityUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar userAccount = LoadUserAccountSafe(request.User.AccountId, userAccountUid);\n\n\t\t\tvar updatedVariables =\n\t\t\t\t_workflowV1GrpcMapper\n\t\t\t\t\t.Map<List<ADEXS.WINS.V1.VariableUpdate>, List<VariableUpdate>>(\n\t\t\t\t\t\trequest.VariableUpdates.ToList());\n\n\t\t\tvar result = _workflowClient.UpdateVariablesWithResult(\n\t\t\t\tuserAccount,\n\t\t\t\tactivityUid,\n\t\t\t\tupdatedVariables,\n\t\t\t\tsourceInstanceUid,\n\t\t\t\tsourceActivityUid);\n\n\t\t\tvar resultResponse = _workflowV1GrpcMapper\n\t\t\t\t.Map<WorkflowEnums.UpdateParentVariableResult, UpdateParentVariableResult>(result);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new UpdateVariablesWithResultResponse {Result = resultResponse});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultInvalidArgument(_logger, request.User.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultFailed(_logger, request.User.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.UpdateVariablesWithResultFailed(_logger, request.User.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tpublic override Task<IsActivityExecutionLimitReachedResponse> IsActivityExecutionLimitReached(\n\t\t[NotNull] IsActivityExecutionLimitReachedRequest request,\n\t\tServerCallContext context)\n\t{\n\t\tusing var activity = StartActivity()\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, request.AccountId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowInstanceUid, request.InstanceUid)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignWorkflowRevisionUid, request.RevisionUid);\n\n\t\tif (!Guid.TryParse(request!.InstanceUid, out var instanceUid))\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentInstanceUid);\n\t\t}\n\n\t\tif (!Guid.TryParse(request!.RevisionUid, out var revisionUid))\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, null);\n\t\t\tthrow new RpcException(StatusInvalidArgumentRevisionUid);\n\t\t}\n\n\t\tLogger.IsActivityExecutionLimitReached(_logger, request.AccountId, request.InstanceUid, request.RevisionUid);\n\n\t\ttry\n\t\t{\n\t\t\tvar revisionCreatedDate = _workflowV1GrpcMapper.Map<Timestamp, DateTime>(request.RevisionCreatedDate);\n\n\t\t\tvar isLimitReached = _workflowClient.IsActivityExecutionLimitReached(\n\t\t\t\trequest!.AccountId,\n\t\t\t\tinstanceUid,\n\t\t\t\trevisionUid,\n\t\t\t\trevisionCreatedDate,\n\t\t\t\trequest.ActivityExecutionCount);\n\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\treturn Task.FromResult(new IsActivityExecutionLimitReachedResponse {IsLimitReached = isLimitReached});\n\t\t}\n\t\tcatch (ArgumentException argEx)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedInvalidArgument(_logger, request.AccountId, argEx);\n\t\t\tthrow HandleArgumentException(activity, argEx);\n\t\t}\n\t\tcatch (PublicException publicEx)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedFailed(_logger, request.AccountId, publicEx);\n\t\t\tthrow HandlePublicException(activity, publicEx);\n\t\t}\n\t\tcatch (Exception ex) when (ex is not RpcException)\n\t\t{\n\t\t\tLogger.IsActivityExecutionLimitReachedFailed(_logger, request.AccountId, ex);\n\t\t\tthrow HandleUnknownException(activity, ex);\n\t\t}\n\t}\n\n\tprivate static RpcException HandleArgumentException(Activity? activity, ArgumentException argEx)\n\t{\n\t\tactivity?.AddException(argEx);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)StatusCode.InvalidArgument,\n\t\t\tMessage = string.Empty,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(argEx.ToRpcDebugInfo())\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static RpcException HandleUnknownException(Activity? activity, Exception ex)\n\t{\n\t\tactivity?.AddException(ex);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)StatusCode.Internal,\n\t\t\tMessage = string.Empty,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(ex.ToRpcDebugInfo())\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static RpcException HandlePublicException(Activity? activity, PublicException ex)\n\t{\n\t\tactivity?.AddException(ex);\n\t\tvar statusCode = GetStatusCodeFromFailReason(ex.Reason);\n\n\t\tvar status = new Google.Rpc.Status\n\t\t{\n\t\t\tCode = (int)statusCode,\n\t\t\tMessage = ex.Message,\n\t\t\tDetails =\n\t\t\t{\n\t\t\t\tAny.Pack(ex.ToRpcDebugInfo()),\n\t\t\t\tAny.Pack(new ErrorInfo\n\t\t\t\t{\n\t\t\t\t\tDomain = nameof(PublicException),\n\t\t\t\t\tReason = ex.Reason.ToString(),\n\t\t\t\t\tMetadata =\n\t\t\t\t\t{\n\t\t\t\t\t\t{ nameof(ex.Message), ex.Message },\n\t\t\t\t\t\t{ nameof(ex.InternalMessage), ex.InternalMessage }\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t};\n\n\t\treturn status.ToRpcException();\n\t}\n\n\tprivate static StatusCode GetStatusCodeFromFailReason(PublicException.FailReason failReason)\n\t{\n\t\treturn failReason switch\n\t\t{\n\t\t\tPublicException.FailReason.NonexistentObject => StatusCode.NotFound,\n\t\t\tPublicException.FailReason.InvalidArgument => StatusCode.InvalidArgument,\n\t\t\tPublicException.FailReason.InvalidState => StatusCode.FailedPrecondition,\n\t\t\tPublicException.FailReason.InternalError => StatusCode.Internal,\n\t\t\tPublicException.FailReason.TemporarilyUnavailable => StatusCode.Unavailable,\n\t\t\tPublicException.FailReason.PermissionDenied => StatusCode.PermissionDenied,\n\t\t\tPublicException.FailReason.ObjectAlreadyExists => StatusCode.AlreadyExists,\n\t\t\t_ => StatusCode.Internal, // Default case\n\t\t};\n\t}\n\n\tprivate static void ValidateUser(UserAccount? user)\n\t{\n\t\tif (user == null)\n\t\t{\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"User is null\"));\n\t\t}\n\t}\n\n\tprivate void ValidateAndParseUserUid(string userUid, int accountId, out Guid userAccountUid)\n\t{\n\t\tif (!Guid.TryParse(userUid, out userAccountUid))\n\t\t{\n\t\t\tLogger.UserUidFormatError(_logger, userUid, accountId);\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(\n\t\t\t\t\tStatusCode.InvalidArgument,\n\t\t\t\t\t\"User.Uid is malformed\"));\n\t\t}\n\t}\n\n\tprivate void ValidateWorkflowName(string workflowName)\n\t{\n\t\tif (string.IsNullOrEmpty(workflowName))\n\t\t{\n\t\t\tLogger.WorkflowFormatError(_logger);\n\t\t\tthrow new RpcException(new Status(StatusCode.InvalidArgument, \"WorkflowName is null or empty\"));\n\t\t}\n\t}\n\n\tprivate Core.Domain.Model.UserAccount? LoadUserAccountSafe(int accountId, Guid userAccountUid)\n\t{\n\t\tvar userAccount = _userAccountRepository.LoadByUid(accountId, userAccountUid);\n\n\t\tif (userAccount == null)\n\t\t{\n\t\t\tLogger.UserAccountNotFound(_logger, userAccountUid, accountId);\n\t\t\tthrow new RpcException(\n\t\t\t\tnew Status(\n\t\t\t\t\tStatusCode.NotFound,\n\t\t\t\t\t$\"User {userAccountUid} not found in account {accountId}\"));\n\t\t}\n\n\t\treturn userAccount;\n\t}\n}\n\n#nullable restore\n#endif\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Threading;\nusing System.Web;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.RequestHeaders;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.MVC;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\nusing log4net;\n\nnamespace ADEXS.Web.Common.Profile\n{\n\tpublic class ProfileModule : IHttpModule\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(\"ADEXS.Web.Common\");\n\n\n\t\tprivate PerformanceLog _performanceLog;\n\t\tprivate IDisposable _logContext;\n\n\t\t[EventSource(\"Session Size\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Size\", \"CLM.SessionState\", DisplayUnit = CounterUnit.kilobytes,\n\t\t\tRanges = new double[10] { 1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 20000 },\n\t\t\tMeasureProperty = \"Count\", InstanceProperty = \"Description\", ShowVolume = true)]\n\t\tprivate static readonly CountEventSource _sessionSizeEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Session Serialization Timing\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Serialization Timing\", \"CLM.SessionState\", DisplayUnit = CounterUnit.milliseconds,\n\t\t\tRanges = new double[10] { 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t\tMeasureProperty = \"Duration\", SuccessProperty = \"Success\", InstanceProperty = \"Description\")]\n\t\tprivate static readonly TimingEventSource _sessionSerializationTimingEventSource = new TimingEventSource();\n\n\t\t[EventSource(\"Large Session\", \"CLM.SessionState\")]\n\t\t[Counter(\"Large Session\", \"CLM.SessionState\")]\n\t\tprivate static readonly PropertyBagEventSource _largeSessionEventSource = new PropertyBagEventSource();\n\n\t\t/// <summary>\n\t\t/// You will need to configure this module in the web.config file of your\n\t\t/// web and register it with IIS before being able to use it. For more information\n\t\t/// see the following link: http://go.microsoft.com/?linkid=8101007\n\t\t/// </summary>\n\t\t#region IHttpModule Members\n\n\t\tpublic void Dispose()\n\t\t{\n\t\t\t//clean-up code here.\n\t\t}\n\n\t\tpublic void Init(HttpApplication context)\n\t\t{\n\t\t\t// Below is an example of how you can handle LogRequest event and provide\n\t\t\t// custom logging implementation for it\n\t\t\tcontext.BeginRequest += OnBeginRequest;\n\t\t\tcontext.PreRequestHandlerExecute += OnPreRequestHandlerExecute;\n\t\t\tcontext.PostRequestHandlerExecute += OnPostRequestHandlerExecute;\n\t\t\tcontext.EndRequest += OnEndRequest;\n\t\t\tcontext.Error += OnError;\n\t\t}\n\n\t\t/* IIS request life cycle BeginRequest ->  AuthenticateRequest -> AuthorizeRequest -> ResolveRequestCache -> AcquireRequestState ->\n\t\t * PreRequestHandlerExecute -> ProcessRequest -> PostRequestHandlerExecute -> ReleaseRequestState -> UpdateRequestCache -> EndRequest */\n\n\t\tprivate void OnBeginRequest(object sender, EventArgs e)\n\t\t{\n\t\t\tif (_performanceLog == null)\n\t\t\t\t_performanceLog = new PerformanceLog();\n\n\t\t\t_performanceLog.Start(HttpContext.Current.Request);\n\t\t}\n\n\t\tprivate void OnPostRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(HttpContext.Current);\n\t\t\tLogSessionSize(HttpContext.Current?.Session);\n\t\t\t_performanceLog.SetSession(HttpContext.Current?.Session);\n\t\t}\n\n\t\tprivate void OnPreRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tHttpContext context = HttpContext.Current;\n\t\t\t\tAtlasContext.Reset();\n\n\t\t\t\t// MonitoringContext is initialized in the ScmLogRequestHttpModule module on\n\t\t\t\t// BeginRequest. This runs before this event handler. By this time the\n\t\t\t\t// CorrelationToken is set. Including getting it from the X-DocuSign-CorrelationToken header if available.\n\t\t\t\tGuid corrId = MonitoringContext.CorrelationToken ?? Guid.Empty;\n\t\t\t\tif (Guid.Empty == corrId)\n\t\t\t\t{\n\t\t\t\t\t// Only in extremely unlikely scenario\n\t\t\t\t\tGuid.TryParse(AtlasContext.Current.TransactionId, out corrId);\n\t\t\t\t\tMonitoringContext.CorrelationToken = corrId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAtlasContext.Current.TransactionId = corrId.ToString();\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t// Now we'll have TransactionId, CorrelationId, and CorrelationToken all set to the same value. Three is a crowd?...\n\t\t\t\t_logContext = LogContext.Set(AtlasContext.Current.TransactionId);\n\n\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"ServiceLocator:\\n{ServiceLocator.Container.WhatDoIHave(typeof(ILogContextStore))}\");\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Reset();\n\t\t\t\tif (context != null)\n\t\t\t\t{\n\t\t\t\t\tif (context.Request != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tAtlasContext.Current.ClientIpAddress = IPAddressUtil.FetchIpAddress(context.Request);\n\t\t\t\t\t\tAtlasContext.Current.ClientUserAgent = context.Request.UserAgent;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Similar code exists for web services, which don't use session.\n\t\t\t\t\t// That code is in SetContextIds\n\t\t\t\t\tHttpSessionState session = context.Session;\n\t\t\t\t\tif (session != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tUserAccount user = CommonData.CurrentUser;\n\t\t\t\t\t\tif (user != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAtlasContext.Current.AccountId = user.AccountId;\n\t\t\t\t\t\t\tAtlasContext.Current.UserAccountUid = user.Uid;\n\t\t\t\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = user.AccountId == int.MinValue ? \"null\" : user.AccountId.ToString();\n\n\t\t\t\t\t\t\tvar userContextSetter = AtlasWebDependencyResolver.ScopedInstance?.GetService<IUserContextSetter>();\n\t\t\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"The user's AccountId: {user.AccountId} for user id: {user.Uid} in OnPreRequestHandlerExecute.\");\n\t\t\t\t\t\t\t\t// ensure that DI consumers have access the user/account context\n\t\t\t\t\t\t\t\tuserContextSetter.AccountId = user.AccountId;\n\t\t\t\t\t\t\t\tuserContextSetter.UserId = user.Uid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII(\"No UserContextSetter is available - account context propagation will not work.\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar docusignAccountId = CommonData.DocuSignAccountId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignAccountId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignAccountId = docusignAccountId;\n\n\t\t\t\t\t\t\tvar docusignUserId = CommonData.DocuSignUserId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignUserId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignUserId = docusignUserId;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnPreRequestHandlerExecute in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Measuring session size ATL-56207\n\t\t/// </summary>\n\t\tprivate static void LogSessionSize(HttpSessionState session)\n\t\t{\n\t\t\tif (session == null || !Configuration.GetBooleanAppSetting(\"EnableSessionSizeLogging\", false))\n\t\t\t\treturn;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong totalSessionBytes = 0;\n\t\t\t\tstring largestItemKey = string.Empty;\n\t\t\t\tlong largestItemSizeBytes = 0;\n\t\t\t\tint itemCount = 0;\n\n\t\t\t\tusing (OperationTimer sessionSerializationTimer = _sessionSerializationTimingEventSource.CreateTimer())\n\t\t\t\t{\n\t\t\t\t\tBinaryFormatter formatter = new BinaryFormatter();\n\t\t\t\t\tforeach (var sessionKey in session)\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (Stream s = new MemoryStream())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring key = (string)sessionKey;\n\t\t\t\t\t\t\tvar item = session[key];\n\t\t\t\t\t\t\tif (item != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titemCount++;\n\n\t\t\t\t\t\t\t\tformatter.Serialize(s, item);\n\n\t\t\t\t\t\t\t\tif (s.Length > largestItemSizeBytes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlargestItemKey = key;\n\t\t\t\t\t\t\t\t\tlargestItemSizeBytes = s.Length;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttotalSessionBytes += s.Length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsessionSerializationTimer.SetResult(true);\n\t\t\t\t}\n\n\t\t\t\t_sessionSizeEventSource.Emit(totalSessionBytes);\n\n\t\t\t\tif (totalSessionBytes > Configuration.GetInt64AppSetting(\"LargeSessionSizeLoggingThreshold\", 1000000)) // default to 1MB\n\t\t\t\t{\n\t\t\t\t\tstring aid = AtlasContext.Current?.AccountId.ToString();\n\t\t\t\t\tstring userId = AtlasContext.Current?.UserAccountUid.ToString();\n\n\t\t\t\t\tusing (var propertyBag = _largeSessionEventSource.CreateEventPropertyBag())\n\t\t\t\t\t{\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"AccountId\", aid);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"UserAccountUid\", userId);\n\n\t\t\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionId\", session.SessionID);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionSizeInBytes\", totalSessionBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemKey\", largestItemKey);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemSizeInBytes\", largestItemSizeBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"TotalSessionItemCount\", itemCount.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"ThreadId\", Thread.CurrentThread.ManagedThreadId.ToString());\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.InfoNoPII($\"Detected Large SessionState. AccountId {aid} UserAccountUid {userId} SessionId {session.SessionID} SessionSizeInBytes {totalSessionBytes} TotalItemCount {itemCount} Largest Item Key {largestItemKey} ({largestItemSizeBytes})\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Exception occurred while attempting to measure session.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnError(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//get latest exception (top level exception is probably an HTTPUnhandledException which contains underlying exceptions via .InnerException)\n\n\t\t\t\tException baseException = null;\n\t\t\t\tvar lastError = HttpContext.Current.Server.GetLastError();\n\t\t\t\tif (lastError == null)\n\t\t\t\t{\n\t\t\t\t\tvar allError = HttpContext.Current.AllErrors;\n\t\t\t\t\tif (allError != null && allError.Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseException = allError[allError.Length - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseException = lastError.GetBaseException();\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Stop(baseException);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnError in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnEndRequest(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (_performanceLog != null)\n\t\t\t\t{\n\t\t\t\t\t_performanceLog.Stop();\n\t\t\t\t\t_performanceLog.Dispose();\n\t\t\t\t\t_performanceLog = null;\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t_logContext = null;\n\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = \"null\";\n\n\t\t\t\t// we are no longer looking for outstanding DB transactions here.\n\t\t\t\t// because the module does not have to run in the same thread as the request handler\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnEndRequest in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAtlasContext.Current.CacheClient.FlushCache();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not clear the user settings on the thread for the request.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Text;\nusing System.Threading;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Web.Common.Helpers;\n\nusing DocuSign.DynamicSettings;\nusing DocuSign.Monitoring;\n\nnamespace ADEXS.Web.Common;\n/// <summary>\n/// Temporary Base class to redirect the ASHX API call to new Controller API as part of the effort of web migration to .net6\n/// This will eventually cleaned up once we move to .net6\n/// </summary>\npublic abstract class BaseApiHandler : IHttpHandler\n{\n\t[EventSource(\"Exception\", \"CLM.FeatureFlags.PopulateFeatureFlagContext\")]\n\t[Counter(\"Exception\", \"CLM.FeatureFlags.PopulateFeatureFlagContext\", InstanceProperty = \"Description\")]\n\tprivate static ExceptionEventSource _featureFlagContextExceptionEventSource = new ExceptionEventSource();\n\n\tprivate static readonly IDiscreetLogger Logger = DiscreetLogger.GetLogger(typeof(BaseApiHandler));\n\n\t// reletive path for new controller api. ex) \"A/TileView/GetTiles\"\n\t// where full url is https://localhost/atlas/A/TileView/GetTiles\n\tprotected abstract string Path { get; }\n\n\tpublic virtual bool IsReusable { get; set; }\n\n\tpublic virtual void ProcessRequest(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tPopulateFeatureFlagContext(AtlasContext.Current.UserAccount, context);\n\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to Populate Feature Flag Context: {LogData()}\", ex);\n\t\t}\n\n\t\tif (ShouldRedirectHelper())\n\t\t{\n\t\t\tRedirect(context);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tHandleRequest(context);\n\t\t}\n\t}\n\n\tprotected abstract bool ShouldRedirect();\n\tprotected abstract void HandleRequest(HttpContext context);\n\n\tprivate string LogData()\n\t{\n\t\treturn $\"aid:{AtlasContext.Current.AccountId} uid:{AtlasContext.Current.UserAccountUid} relativeUrl: {Path}\";\n\t}\n\tprivate void Redirect(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t\t}\n\n\t\t\t// Get the original path info\n\t\t\tvar pathInfo = !string.IsNullOrEmpty(context.Request.PathInfo) ? context.Request.PathInfo : \"\";\n\n\t\t\t// Get the original query string\n\t\t\tvar queryString = context.Request.QueryString;\n\n\t\t\t// URL-encode pathInfo and queryString before building the new URL\n\t\t\tvar encodedPathInfo = HttpUtility.UrlPathEncode(pathInfo);\n\t\t\tvar encodedQueryString = ToUrlEncodedQueryString(queryString);\n\n\t\t\tvar baseUrl = AtlasUrlHelper.WebApplicationBasePath();\n\t\t\tvar newUrl = $\"{baseUrl}/{Path}{encodedPathInfo}{encodedQueryString}\";\n\n\t\t\t// Set the status code to 307 Temporary Redirect\n\t\t\tcontext.Response.StatusCode = Microsoft.AspNetCore.Http.StatusCodes.Status307TemporaryRedirect;\n\n\t\t\t// Set the Location header with the new Controller URL\n\t\t\tcontext.Response.AddHeader(\"Location\", newUrl);\n\n\t\t}\n\t\tcatch (ThreadAbortException)\n\t\t{\n\t\t\t// Do nothing intentionally.\n\t\t\t// The above Redirect call is *meant* to abort the thread with an exception and we do _not_ want it caught by the below catch block.\n\t\t\t// See this article for why we are catching it here and why we do nothing in this block.\n\t\t\t// https://learn.microsoft.com/en-us/dotnet/standard/threading/destroying-threads#handling-threadabortexception\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to Redirect: {LogData()}\", ex);\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprivate bool ShouldRedirectHelper()\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn ShouldRedirect();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to evaluate ShouldRedirect: {LogData()}\", ex);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void PopulateFeatureFlagContext(UserAccount currentUser, HttpContext context)\n\t{\n\t\tif (context == null)\n\t\t{\n\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t}\n\n\t\tif (currentUser == null || !ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId > 0)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = AtlasContext.Current.AccountId;\n\t\t\t}\n\t\t\telse if (context.Request.QueryString[Constants.QueryStringParameters.AccountIdAbbreviated] != null)\n\t\t\t{\n\t\t\t\tif (int.TryParse(context.Request.QueryString[Constants.QueryStringParameters.AccountIdAbbreviated], out var accountId))\n\t\t\t\t{\n\t\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = accountId;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = currentUser.AccountId;\n\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.UserId] = currentUser.Uid;\n\t\t\tif (currentUser.Account != null)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountType] = currentUser.Account.AccountType;\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.PlanName] = NpsUtilities.GetPlanIdName(currentUser.Account);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t_featureFlagContextExceptionEventSource.Emit(ex);\n\t\t}\n\t}\n\n\tprivate static string ToUrlEncodedQueryString(NameValueCollection collection)\n\t{\n\t\tif (collection == null || collection.Count == 0)\n\t\t{\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\tvar builder = new StringBuilder();\n\t\tvar first = true;\n\t\tfor (var i = 0; i < collection.Count; i++)\n\t\t{\n\t\t\tvar key = collection.GetKey(i);\n\t\t\tvar value = collection.Get(i);\n\t\t\tbuilder.Append(first ? '?' : '&');\n\t\t\tfirst = false;\n\t\t\tbuilder.Append(HttpUtility.UrlEncode(key));\n\t\t\tbuilder.Append('=');\n\t\t\tbuilder.Append(HttpUtility.UrlEncode(value));\n\t\t}\n\n\t\treturn builder.ToString();\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Web.Common.Helpers;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing Grpc.Core;\n\nusing Microsoft.AspNet.SessionState;\nusing Microsoft.Web.Redis;\n\nusing OpenTelemetry.Context.Propagation;\nusing OpenTelemetry.Instrumentation.AspNet;\nusing OpenTelemetry.Trace;\n\nnamespace ADEXS.Web.Common.Session\n{\n\tpublic class RedisSessionStateProviderWrapper : RedisSessionStateProvider\n\t{\n\t\t[EventSource(\"RedisSessionStateProvider\", \"CLM.SessionState\")]\n\t\t[Counter(\"RedisSessionStateProvider\", \"CLM.SessionState\",\n\t\t\tInstanceProperty = \"Description\",\n\t\t\tDisplayUnit = CounterUnit.milliseconds,\n\t\t\tRanges = new double[10] { 1, 5, 10, 25, 50, 100, 250, 500, 1000, 5000 },\n\t\t\tMeasureProperty = \"Duration\",\n\t\t\tSuccessProperty = \"Success\")]\n\t\tprivate static readonly TimingEventSource _redisSessionTimingEventSource = new TimingEventSource();\n\n\t\t[EventSource(\"Throttling errors\", \"CLM.SessionState\")]\n\t\t[Counter(\"Throttling errors\", \"CLM.SessionState\")]\n\t\tprivate static readonly SimpleEventSource _throttingErrorsEventSource = new SimpleEventSource();\n\n\t\tprivate static readonly ActivitySource SessionStateProviderActivitySource = new ActivitySource(typeof(RedisSessionStateProviderWrapper).FullName);\n\n\t\tprivate static DateTime LastConnectionResetTime = new DateTime();\n\n\t\tprivate const string SESSION_STATE_THROTTLING_KEY = \"SESSION_STATE_THROTTLING_KEY\";\n\n\t\tprivate static IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(RedisSessionStateProviderWrapper));\n\n\t\t#region Public Overridden Methods\n\n\t\tpublic override async Task CreateUninitializedItemAsync(System.Web.HttpContextBase context, string id, int timeout,\n\t\t\tCancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.CreateUninitializedItemAsync(context, id, timeout, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task SetAndReleaseItemExclusiveAsync(System.Web.HttpContextBase context, string id,\n\t\t\tSystem.Web.SessionState.SessionStateStoreData item, object lockId, bool newItem,\n\t\t\tCancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.SetAndReleaseItemExclusiveAsync(context, id, item, lockId, newItem, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task ResetItemTimeoutAsync(System.Web.HttpContextBase context, string id, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.ResetItemTimeoutAsync(context, id, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task RemoveItemAsync(System.Web.HttpContextBase context, string id, object lockId,\n\t\t\tSystem.Web.SessionState.SessionStateStoreData item, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.RemoveItemAsync(context, id, lockId, item, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task ReleaseItemExclusiveAsync(System.Web.HttpContextBase context, string id, object lockId, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.ReleaseItemExclusiveAsync(context, id, lockId, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task<GetItemResult> GetItemExclusiveAsync(System.Web.HttpContextBase context, string id, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tThrottle(context);\n\t\t\treturn await ExecuteTaskWithResult(context, () => base.GetItemExclusiveAsync(context, id, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task<GetItemResult> GetItemAsync(System.Web.HttpContextBase context, string id, CancellationToken cancellationToken)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tThrottle(context);\n\t\t\treturn await ExecuteTaskWithResult(context, () => base.GetItemAsync(context, id, cancellationToken));\n\t\t}\n\n\t\tpublic override async Task EndRequestAsync(System.Web.HttpContextBase context)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\tawait ExecuteTask(context, () => base.EndRequestAsync(context));\n\t\t}\n\n\t\tpublic void Reset(System.Web.HttpContextBase context)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t_log.WarnNoPII(\"Resetting RedisSessionState connection.\");\n\t\t\tLastConnectionResetTime = DateTime.UtcNow;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (Configuration.GetBooleanAppSetting(\"RedisSessionStateReset\", false))\n\t\t\t\t{\n\t\t\t\t\t// static internal fields that can't be access directly\n\t\t\t\t\t// have to use reflection to update the ConnectionString and SharedConnection property\n\t\t\t\t\tResetConnectionString();\n\t\t\t\t\tResetSharedConnection();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to change the connection string\", e);\n\t\t\t}\n\n\t\t\tTask.WaitAll(base.EndRequestAsync(context));\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Private Methods\n\n\t\tprivate static void ResetConnectionString()\n\t\t{\n\t\t\tvar configurationCreationLockField = typeof(RedisSessionStateProvider).GetField(\"configurationCreationLock\",\n\t\t\t\tBindingFlags.NonPublic | BindingFlags.Static);\n\n\t\t\tif (configurationCreationLockField == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get configurationCreationLockField\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar configurationCreationLockObj = configurationCreationLockField.GetValue(null);\n\n\t\t\tif (configurationCreationLockObj == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get configurationCreationLockObj\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlock (configurationCreationLockObj)\n\t\t\t{\n\t\t\t\tvar configField = typeof(RedisSessionStateProvider).GetField(\"configuration\",\n\t\t\t\t\tBindingFlags.NonPublic | BindingFlags.Static);\n\n\t\t\t\tif (configField == null)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get configField\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar configObj = configField.GetValue(null);\n\n\t\t\t\tif (configObj == null)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get configObj\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar connectionStringProperty = configObj.GetType().GetProperty(\"ConnectionString\");\n\n\t\t\t\tif (connectionStringProperty == null)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get connectionStringProperty\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconnectionStringProperty.SetValue(configObj,\n\t\t\t\t\tnew RedisSessionStateConfig().GetRedisConnectionString());\n\t\t\t}\n\t\t}\n\n\t\tprivate void ResetSharedConnection()\n\t\t{\n\t\t\tvar cacheField = typeof(RedisSessionStateProvider).GetField(\"cache\",\n\t\t\t\tBindingFlags.NonPublic | BindingFlags.Instance);\n\n\t\t\tif (cacheField == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get cacheField\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cacheObj = cacheField.GetValue(this);\n\n\t\t\tif (cacheObj == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get cacheObj\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lockForSharedConnectionField = cacheObj.GetType().GetField(\"lockForSharedConnection\",\n\t\t\t\tBindingFlags.NonPublic | BindingFlags.Static);\n\n\t\t\tif (lockForSharedConnectionField == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get lockForSharedConnectionField\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lockForSharedConnectionObj = lockForSharedConnectionField.GetValue(null);\n\n\t\t\tif (lockForSharedConnectionObj == null)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get lockForSharedConnectionObj\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlock (lockForSharedConnectionObj)\n\t\t\t{\n\t\t\t\tvar sharedConnectionField = cacheObj.GetType().GetField(\"sharedConnection\",\n\t\t\t\t\tBindingFlags.NonPublic | BindingFlags.Static);\n\t\t\t\tif (sharedConnectionField == null)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(\"RedisSessionState: Failed to get sharedConnectionField\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tsharedConnectionField.SetValue(null, null);\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task ExecuteTask(System.Web.HttpContextBase context, Func<Task> baseMethod, [CallerMemberName] string callerFunction = null)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\t\t\tvar sw = Stopwatch.StartNew();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tawait baseMethod();\n\t\t\t\tEmitTelemetry(sw, true, callerFunction);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tEmitTelemetry(sw, false, callerFunction);\n\t\t\t\tReportException(ex, callerFunction);\n\t\t\t\tif (DateTime.UtcNow > LastConnectionResetTime.AddMinutes(Configuration.GetInt32AppSetting(\"RedisSessionStateResetTimerMin\", 10)))\n\t\t\t\t{\n\t\t\t\t\tReset(context);\n\t\t\t\t}\n\n\t\t\t\tactivity\n\t\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t\t.AddException(ex);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task<T> ExecuteTaskWithResult<T>(System.Web.HttpContextBase context, Func<Task<T>> baseMethod, [CallerMemberName] string callerFunction = null)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\t\t\tvar sw = Stopwatch.StartNew();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar result = await baseMethod();\n\t\t\t\tEmitTelemetry(sw, true, callerFunction);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tEmitTelemetry(sw, false, callerFunction);\n\t\t\t\tReportException(ex, callerFunction);\n\t\t\t\tif (DateTime.UtcNow >\n\t\t\t\t    LastConnectionResetTime.AddMinutes(Configuration.GetInt32AppSetting(\"RedisSessionStateResetTimerMin\", 10)))\n\t\t\t\t{\n\t\t\t\t\tReset(context);\n\t\t\t\t}\n\n\t\t\t\tactivity\n\t\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t\t.AddException(ex);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tprivate void EmitTelemetry(Stopwatch stopWatch, bool success, string callerFunction)\n\t\t{\n\t\t\tif (ApplicationSettings.EnableSessionProviderTelemetry)\n\t\t\t{\n\t\t\t\tusing (var timer = _redisSessionTimingEventSource.CreateTimer(callerFunction, TimingPhase.Redis,\n\t\t\t\t\ttimingPhaseDetails: new TimingPhaseDetails(callerFunction, ApplicationSettings.RedisPhaseDurationThreshold, TimingPhaseProperty.Duration)))\n\t\t\t\t{\n\t\t\t\t\ttimer.SetTimer(stopWatch);\n\t\t\t\t\ttimer.SetResult(success);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void ReportException(Exception exception, string callerFunction)\n\t\t{\n\t\t\tif (ApplicationSettings.EnableSessionProviderTelemetry)\n\t\t\t\texception?.Report(callerFunction);\n\t\t}\n\n\t\tprivate void Throttle(System.Web.HttpContextBase context, [System.Runtime.CompilerServices.CallerMemberName] string callerFunction = \"\")\n\t\t{\n\t\t\tusing var activity = StartActivity()\n\t\t\t\t?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar sessionStateGovernor = GetSessionStateGovernor(context);\n\t\t\t\tsessionStateGovernor?.IncrementCallCount(callerFunction);\n\t\t\t}\n\t\t\tcatch(AtlasHttpResponseException resEx)\n\t\t\t{\n\t\t\t\tactivity\n\t\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t\t.AddException(resEx);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_throttingErrorsEventSource.Emit();\n\t\t\t\tex.Report();\n\n\t\t\t\tactivity\n\t\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t\t.AddException(ex);\n\t\t\t}\n\t\t}\n\n\t\tprivate ISessionStateGovernor GetSessionStateGovernor(System.Web.HttpContextBase context)\n\t\t{\n\t\t\tvar sessionStateGovernor = context.Items[SESSION_STATE_THROTTLING_KEY] as ISessionStateGovernor;\n\t\t\tif (sessionStateGovernor == null)\n\t\t\t{\n\t\t\t\tsessionStateGovernor = new RedisSessionStateGovernor();\n\t\t\t\tcontext.Items[SESSION_STATE_THROTTLING_KEY] = sessionStateGovernor;\n\t\t\t}\n\t\t\treturn sessionStateGovernor;\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") =>\n\t\t\tSessionStateProviderActivitySource\n\t\t\t\t.StartActivity($\"{nameof(RedisSessionStateProviderWrapper)}.{name}\")\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name);\n\n\t\t#endregion\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
            "content": "\ufeff#nullable enable\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nnamespace ADEXS.DetectTypeService.MimeLookup;\n\npublic class MimeDetectorWindows : IMimeDetector\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tpublic MimeDetectorWindows(IServiceInstrumentation serviceInstrumentation)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic string? DetectMimeType(string? filePath)\n\t{\n\t\tusing var activity = StartActivity();\n\t\ttry\n\t\t{\n\t\t\tvar result = MimeLookup.GetMimeType(filePath);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.UrlMon))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n\n\tstatic class MimeLookup\n\t{\n\t\t[DllImport(\"urlmon.dll\", CharSet = CharSet.Auto)]\n\t\tinternal static extern int FindMimeFromData(\n\t\t\tIntPtr pBC,\n\t\t\t[MarshalAs(UnmanagedType.LPWStr)] string? pwzUrl,\n\t\t\tIntPtr pBuffer,\n\t\t\tint cbSize,\n\t\t\t[MarshalAs(UnmanagedType.LPWStr)] string? pwzMimeProposed,\n\t\t\tint dwMimeFlags,\n\t\t\t[MarshalAs(UnmanagedType.LPWStr)] out string? ppwzMimeOut,\n\t\t\tint dwReserved);\n\n\t\t[MethodImpl(MethodImplOptions.Synchronized)]\n\t\tstatic public string? GetMimeType(string? filename)\n\t\t{\n\t\t\tstring? mimeType = null;\n\t\t\tFindMimeFromData(IntPtr.Zero, filename, IntPtr.Zero, 0, null, 0, out mimeType, 0);\n\t\t\treturn mimeType;\n\t\t}\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
            "content": "\ufeff#nullable enable\nusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing HeyRed.Mime;\n\nnamespace ADEXS.DetectTypeService.MimeLookup;\n\npublic class MimeDetectorCrossPlatform : IMimeDetector\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tpublic MimeDetectorCrossPlatform(IServiceInstrumentation serviceInstrumentation)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic string DetectMimeType(string filePath)\n\t{\n\t\tusing var activity = StartActivity();\n\t\ttry\n\t\t{\n\t\t\tusing var stream = File.OpenRead(filePath);\n\t\t\tvar result = MimeGuesser.GuessMimeType(stream);\n\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeType, result);\n\t\t\treturn result;\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprivate Activity? StartActivity([CallerMemberName] string name = \"\") =>\n\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t?.StartActivity($\"{InstrumentationNames.MimeDetector}.{name}\")\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignDetectTypeMimeDetectorType, nameof(MimeDetectiveType.MimeGuesser))\n\t\t\t?.SetMetricName(InstrumentationNames.MimeDetector);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\n\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.Extensions;\nusing ADEXS.DetectTypeService.Telemetry;\n\nusing DocuSign.CLM.ContentStorage;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\nusing MediaInfo;\n\nnamespace ADEXS.DetectTypeService.VideoInfo\n{\n\tpublic class VideoInfo : IVideoInfo\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(VideoInfo));\n\n\t\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\t\tpublic VideoInfo(IServiceInstrumentation serviceInstrumentation)\n\t\t{\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t}\n\n\t\tpublic VideoInfoModel GetVideoInformation(Document document)\n\t\t{\n\t\t\tusing var activity = StartActivity();\n\n\t\t\t//Test if version of DLL is compatible : 3rd argument is \"version of DLL tested;Your application name;Your application version\"\n\n\t\t\tMediaInfo.MediaInfo mediaInfo = new MediaInfo.MediaInfo();\n\n\t\t\tstring output = mediaInfo.Option(\"Info_Version\", \"0.7.0.0;MediaInfoDLL_Example_CS;0.7.0.0\");\n\t\t\tif (string.IsNullOrEmpty(output))\n\t\t\t{\n\t\t\t\tthrow new ApplicationException(\"MediaInfo.Dll: this version of the DLL is not compatible\").Trace();\n\t\t\t}\n\n\t\t\tSystemDocumentReader docReader = new SystemDocumentReader(document);\n\t\t\tlong length = docReader.GetContentLength(StorageConstants.StorageFormat.Native);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tmediaInfo.OpenBufferInit(length, 0);\n\n\t\t\t\tbyte[] mngdBuffer = new byte[81920];\n\t\t\t\tusing (var stream = docReader.OpenNativeStream())\n\t\t\t\t{\n\t\t\t\t\tint totalBytesSent = 0;\n\t\t\t\t\tint continueResult = 5; // initialize to 5, because that is what is returned when MediaInfo wants more bytes\n\t\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\t\t\tIntPtr ptrBuffer = default(IntPtr);\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tptrBuffer = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(byte)) * mngdBuffer.Length);\n\t\t\t\t\t\tint read;\n\t\t\t\t\t\twhile ((read = stream.Read(mngdBuffer, 0, mngdBuffer.Length)) > 0 && continueResult == 5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMarshal.Copy(mngdBuffer, 0, ptrBuffer, read); // Copy the array to unmanaged memory.\n\t\t\t\t\t\t\tcontinueResult = (int)mediaInfo.OpenBufferContinue(ptrBuffer, (IntPtr)read);\n\t\t\t\t\t\t\ttotalBytesSent += read;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_log.DebugNoPII(\n\t\t\t\t\t\t\t$\"Stopped sending bytes to MediaInfo in {sw.ElapsedMilliseconds} ms. Last chunk sent result: {continueResult}, total bytes sent: {totalBytesSent} of {length}\");\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ptrBuffer != default(IntPtr))\n\t\t\t\t\t\t\tMarshal.FreeHGlobal(ptrBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmediaInfo.OpenBufferFinalize();\n\n\t\t\t\tint height;\n\t\t\t\tint width;\n\t\t\t\tlong durationMs;\n\t\t\t\tif (!int.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Height\"), out height)) height = 0;\n\t\t\t\tif (!int.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Width\"), out width)) width = 0;\n\t\t\t\tif (!long.TryParse(mediaInfo.Get(StreamKind.Video, 0, \"Duration\"), out durationMs)) durationMs = 0;\n\t\t\t\tstring codec = mediaInfo.Get(StreamKind.General, 0, \"CodecID\") ?? string.Empty;\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\tvar videoInfoModel = new VideoInfoModel { Height = height, Width = width, Codec = codec, Duration = durationMs };\n\n\t\t\t\tSetVideoInfoTags(activity, videoInfoModel);\n\n\t\t\t\treturn videoInfoModel;\n\t\t\t}\n\t\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t\t{\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tmediaInfo.Close();\n\t\t\t}\n\t\t}\n\n\t\tprivate Activity StartActivity([CallerMemberName] string name = \"\") =>\n\t\t\t_serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity($\"{InstrumentationNames.MediaInfo}.{name}\")\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, name)\n\t\t\t\t?.SetMetricName(InstrumentationNames.MediaInfo);\n\n\t\tprivate Activity SetVideoInfoTags(Activity activity, VideoInfoModel videoInfoModel) =>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoWidth, videoInfoModel.Width)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoHeight, videoInfoModel.Height)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoDuration, videoInfoModel.Duration)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignVideoInfoCodec, videoInfoModel.Codec);\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
            "content": "\ufeff#nullable enable\nusing System.Diagnostics;\n\nusing ADEXS.DetectTypeService.Telemetry;\nusing ADEXS.MqWorkers.DispatchedWorker;\n\nusing CLM.MessageDefines.Interfaces;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing ServiceTraceSemanticConventions = ADEXS.MqWorkers.Telemetry.ServiceTraceSemanticConventions;\n\nnamespace ADEXS.DetectTypeService.Extensions.Telemetry;\n\npublic static class ActivityExtensions\n{\n\tpublic static Activity? SetQueueTaskTags<T>(this Activity? activity, T task)\n\t\twhere T : IQueueTask\n\t\t=>\n\t\tactivity\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessageId, task.MessageId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, task.AccountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeMessagingConversationId, task.CorrelationId)\n\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageUniqueId, task.UniqueId);\n\n\tpublic static Activity? SetQueueTaskResultTags<T>(this Activity? activity, T task, ProcessTaskResult result)\n\t\twhere T : IQueueTask\n\t\t=>\n\t\t\tactivity\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageResultMessage, result.Message)\n\t\t\t\t?.SetTag(ServiceTraceSemanticConventions.AttributeDocuSignMessageLastErrorMessage, task.LastErrorMessage);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
            "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.API.GateKeeper.Telemetry;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.API.GateKeeper.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.API.GateKeeper\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
            "content": "using System.Collections.Generic;\n\nusing ADEXS.Atlas.Workflow.Activities;\nusing ADEXS.Atlas.Workflow.Readers;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.DocuSignUrl;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow;\nusing ADEXS.ElectronicSignature;\nusing ADEXS.Etl;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.MQ;\nusing ADEXS.OrchestrationIntegration;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.SForce.Core;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.API.WorkflowActivities;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Filters;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Filters.SwaggerDoc;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.IoC;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters;\n\nusing DocuSign.CLM.SmallBenClient;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\n\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.IdentityModel.Logging;\nusing Microsoft.IdentityModel.Tokens;\nusing Microsoft.OpenApi.Models;\n\nusing OpenTelemetry.Metrics;\n\nvar builder = ScmWebApplication.CreateScmWebService(args);\n\nbuilder.ConfigureDefaultScmWebService(\n\targs,\n\t() => new List<IServiceRegistry>\n\t{\n\t\tnew CoreServiceRegistry(),\n\t\tnew CoreWorkflowRegistry(),\n\t\tnew AtlasWorkflowReadersRegistry(),\n\t\tnew MessageQueueRegistry(),\n\t\tnew SmallBenClientRegistry(),\n\t\tnew CoreDomainRegistry(),\n\t\tnew EtlRegistry(),\n\t\tnew ESignatureRegistry(),\n\t\tnew SalesForceRegistry(),\n\t\tnew MergeEngineServiceRegistry(),\n\t\tnew AtlasWorkflowActivitiesRegistry(),\n\t\tnew OrchestrationIntegrationRegistry()\n\t},\n\tWorkflowActivitiesConstants.ServiceName,\n\tconfigureMeter: options =>\n\t{\n\t\toptions.AddView(instrumentName: \"workflowactivities.api.duration\",\n\t\t\tnew ExplicitBucketHistogramConfiguration\n\t\t\t{\n\t\t\t\tBoundaries = new double[] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 }\n\t\t\t});\n\t},\n\tappConfigFileName: \"WorkflowActivitiesApiConfig.ini\");\n\nbuilder.Services.AddWebCoreBasedConfigProviders();\n\n// We only enable JwtAuth when on-prem due to MSF -> onprem communication\nif (ApplicationSettings.EnvironmentType == EnvironmentType.OnPrem)\n{\n\tbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n\t.AddJwtBearer(options =>\n\t{\n\t\toptions.RequireHttpsMetadata = builder.Configuration.GetValue<bool>(\"Jwt_PublicKeyRequireHttps\", true);\n\t\toptions.Authority = new DocuSignAccountsServerUrl().AuthorityUrl();\n#pragma warning disable CA5404 // Do not disable token validation checks\n\t\toptions.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false };\n#pragma warning restore CA5404 // Do not disable token validation checks\n\t});\n\tbuilder.Services.AddAuthorization(options =>\n\t{\n\t\toptions.AddPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopePolicyName, policy =>\n\t\t\tpolicy.RequireClaim(\n\t\t\t\tADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopeClaimKey,\n\t\t\t\tADEXS.Core.Types.Constants.DocuSignAuthenticationScopes.ClmActivitiesExecute));\n\t\toptions.DefaultPolicy = options.GetPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopePolicyName);\n\t});\n}\nelse\n{\n\tbuilder.Services.AddAuthentication();\n\tbuilder.Services.AddAuthorization(options =>\n\t{\n\t\toptions.AddPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.AllowAllPolicyName, policy =>\n\t\t\tpolicy.Requirements.Add(new AllowAnonymousRequirement()));\n\t\toptions.DefaultPolicy = options.GetPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.AllowAllPolicyName);\n\t});\n\tbuilder.Services.AddSingleton<IAuthorizationHandler, AllowAnonymousHandler>();\n}\n\nbuilder.Services.AddWorkflowActivitiesServices();\n\nbuilder.Services.AddMvc(options =>\n{\n\toptions.Filters.Add(new GlobalActionFilter());\n\toptions.Filters.Add(new AuditedRequestAttribute());\n\toptions.Filters.Add(new WorkflowActivitiesExceptionFilterAttribute());\n});\n\n// Do not remove -- this is required for proper deserialization of InstanceVariables\nbuilder.Services.AddControllers().AddNewtonsoftJson();\nbuilder.Services.AddEndpointsApiExplorer();\n\nbuilder.Services.AddSwaggerGen(options =>\n{\n\toptions.CustomOperationIds(c => $\"{c.ActionDescriptor.RouteValues[\"action\"]}\");\n\toptions.SupportNonNullableReferenceTypes();\n\toptions.UseAllOfForInheritance();\n\toptions.SwaggerDoc(WorkflowActivitiesConstants.ServiceVersion, new OpenApiInfo\n\t{\n\t\tTitle = WorkflowActivitiesConstants.ServiceName,\n\t\tVersion = WorkflowActivitiesConstants.ServiceVersion\n\t});\n\toptions.DocumentFilter<PathFormatDocumentFilter>();\n\toptions.SchemaFilter<EnumNameSchemaFilter>();\n});\n\nbuilder.Services.AddSwaggerGenNewtonsoftSupport();\n\nbuilder.Services.AddSingleton<IMetricsEmitter, WorkflowActivitiesMetricsEmitter>();\n\nbuilder.Services.AddHttpClient();\n\nbuilder.Services.AddComponentsInstrumentation();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n\tIdentityModelEventSource.ShowPII = true;\n}\n\napp.UseCommonScmServices();\n\napp.UseMiddleware<LogRequestHttpMiddleware>();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.UseStaticFiles();\napp.UseStaticFiles($\"/{WorkflowActivitiesConstants.ServiceUrlPrefixNoTrailingSlash}\");\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{WorkflowActivitiesConstants.ServiceUrlPrefix}version\");\napp.MapVersionEndpoint($\"{WorkflowActivitiesConstants.ServiceVersion}/version\");\napp.MapControllers();\n\napp.RunScmWebService();\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
            "content": "\ufeff#if NET\n#nullable enable\n\nusing ADEXS.Caching.OpenTelemetry.Extensions;\nusing ADEXS.Core.ServiceFramework.Extensions;\nusing ADEXS.Core.Util.Cache;\nusing ADEXS.CqlCorePersistence.AspNet.Logging;\nusing ADEXS.CqlCorePersistence.OpenTelemetry;\nusing ADEXS.CqlCorePersistence;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.MQ.MqConfiguration;\nusing ADEXS.ServiceFramework.Options;\n\nusing DocuSign.Msf.AspNet.HeaderPropagation.Extensions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\nusing DocuSign.Msf.AspNet.OpenTelemetry;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Options;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\n\nusing OpenTelemetry.Exporter;\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing RabbitMQ.Client;\n\nusing ConfigurationProvider = ADEXS.Core.Util.Cache.ConfigurationProvider;\nusing ADEXS.AtlasDataManipulationService.Extensions;\n\nnamespace ADEXS.AtlasDataManipulationService;\n\npublic class Startup\n{\n\tprivate const string ServiceName = \"clm-data-manipulation\";\n\n\tprivate readonly IConfiguration _configuration;\n\n\tprivate readonly IWebHostEnvironment _webHostEnvironment;\n\n\tpublic Startup(IConfiguration configuration, IWebHostEnvironment webHostEnvironment)\n\t{\n\t\t_configuration = configuration;\n\t\t_webHostEnvironment = webHostEnvironment;\n\t}\n\n\t// This method gets called by the runtime. Use this method to add services to the container.\n\t// For more information on how to configure your application, visit https://go.microsoft.com/fwlink/?LinkID=398940\n\tpublic void ConfigureServices(IServiceCollection services)\n\t{\n\t\t// We need to update config sooner than Hosting startup.\n\t\tConfigurationProvider.UseConfiguration(_configuration);\n\t\tApplicationSettingsCache.Flush();\n\n\t\tservices\n\t\t\t.Configure<ServicedComponentHostedServiceOptions>(\n\t\t\t\t_configuration.GetSection(ServicedComponentHostedServiceOptions.Section))\n\t\t\t.Configure<VersionEndpointOptions>(_configuration.GetSection(VersionEndpointOptions.Section))\n\t\t\t.Configure<ForwardedHeadersOptions>(_configuration.GetSection(\"ForwardedHeaders\"))\n\t\t\t.Configure<ForwardedHeadersOptions>(options =>\n\t\t\t{\n\t\t\t\toptions.KnownProxies.Clear();\n\t\t\t\toptions.KnownNetworks.Clear();\n\t\t\t}); ;\n\n\t\tvar telemetryConsoleTargets = _configuration\n\t\t\t.GetSection(\"Telemetry:Console:Targets\")\n\t\t\t?.Get<ConsoleExporterOutputTargets>();\n\n\t\tservices\n\t\t\t.AddHttpContextAccessor()\n\t\t\t.AddServiceHealthChecks(_configuration)\n\t\t\t.AddAtlasDataManipulationHealthChecks(_configuration);\n\n\t\tservices.AddHeaderPropagation(options => options.ConfigureMicroservices())\n\t\t\t.AddComponentsInstrumentation()\n\t\t\t.AddServiceTelemetry(\n\t\t\t\tServiceName,\n\t\t\t\tconfigureTracer: options =>\n\t\t\t\t{\n\t\t\t\t\toptions\n\t\t\t\t\t\t.AddHttpClientInstrumentation()\n\t\t\t\t\t\t.AddSqlClientInstrumentation()\n\t\t\t\t\t\t.AddRedisInstrumentation()\n\t\t\t\t\t\t.ConfigureRedisCacheInstrumentation()\n\t\t\t\t\t\t.AddScmCassandraPersistenceInstrumentation();\n\n\t\t\t\t\tif (telemetryConsoleTargets != null)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions.AddConsoleExporter(o => o.Targets = telemetryConsoleTargets.Value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tconfigureMeter: options =>\n\t\t\t\t{\n\t\t\t\t\toptions\n\t\t\t\t\t\t.AddHttpClientInstrumentation()\n\t\t\t\t\t\t.AddServiceMetrics()\n\t\t\t\t\t\t.AddProcessInstrumentation()\n\t\t\t\t\t\t.AddCassandraInstrumentation()\n\t\t\t\t\t\t.AddScmCassandraPersistenceInstrumentation()\n\t\t\t\t\t\t.AddRedisCacheMetrics();\n\n\t\t\t\t\tif (telemetryConsoleTargets != null)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions.AddConsoleExporter(o => o.Targets = telemetryConsoleTargets.Value);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t.AddVersionEndpoint()\n\t\t\t.AddSingleton<IConnectionFactory>(sp =>\n\t\t\t{\n\t\t\t\tvar configuration = sp.GetRequiredService<RabbitMessageQueueWrapperConnectionConfig>();\n\n\t\t\t\treturn new ConnectionFactory\n\t\t\t\t{\n\t\t\t\t\tUri = RabbitMessageQueueWrapperConnectionConfig.BuildUri(),\n\t\t\t\t\tClientProvidedName = configuration.GetClientDefinedConnectionName(),\n\t\t\t\t\tAutomaticRecoveryEnabled = true\n\t\t\t\t};\n\t\t\t});\n\n\t\tservices.AddSingleton<ICassandraSettings, ScmCassandraSettings>();\n\t\tservices.AddSingleton<IAtlasCassandraCluster, AtlasCassandraCluster>();\n\t}\n\tpublic void Configure(IApplicationBuilder app)\n\t{\n\t\tif (_configuration.GetValue<bool>(\"CassandraWireLogging\"))\n\t\t{\n\t\t\tapp.WireCassandraLogging();\n\t\t}\n\n\t\tif (_webHostEnvironment.IsDevelopment())\n\t\t{\n\t\t\tapp.UseDeveloperExceptionPage();\n\t\t}\n\n\t\tapp.UseHeaderPropagation();\n\n\t\tapp.UseRouting();\n\n\t\tapp.UseEndpoints(endpoints =>\n\t\t{\n\t\t\tendpoints.MapServiceHealthChecks();\n\n\t\t\tendpoints.MapVersionEndpoint($\"{ServiceName}/v1/version\");\n\n\t\t\tendpoints.MapGet(\"/\", () => $\"No WebAPI defined for {ServiceName}\");\n\t\t});\n\t}\n}\n\n#nullable restore\n#endif\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/ICoreInstrumentationLifetimeService.cs",
            "content": "\ufeff#nullable enable\n\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing OpenTelemetry.Metrics;\n\nusing OpenTelemetry.Trace;\n\nnamespace ADEXS.Core.ServiceFramework;\n\npublic interface ICoreInstrumentationLifetimeService\n{\n\tTask StartAsync(\n\t\tAssembly? assembly = null,\n\t\tAction<TracerProviderBuilder>? configureTracer = null,\n\t\tAction<MeterProviderBuilder>? configureMeter = null,\n\t\tCancellationToken cancellationToken = default);\n\n\tTask StopAsync(CancellationToken cancellationToken = default);\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/CoreInstrumentationLifetimeService.cs",
            "content": "\ufeff#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.ServiceFramework.OpenTelemetry.Extensions;\n\nusing DocuSign.OneConfig.Extensions;\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing StructureMap;\n\nnamespace ADEXS.Core.ServiceFramework;\n\npublic class CoreInstrumentationLifetimeService : ICoreInstrumentationLifetimeService\n{\n\tprivate static readonly IDiscreetLogger Log = DiscreetLogger.GetLogger(typeof(CoreInstrumentationLifetimeService));\n\n\tprivate readonly IContainer _container;\n\n\tprivate IHostedService? _openTelemetryService;\n\n\tpublic CoreInstrumentationLifetimeService(IContainer container)\n\t{\n\t\tif (container == null)\n\t\t{\n\t\t\tthrow new ArgumentNullException(nameof(container));\n\t\t}\n\n\t\t_container = container;\n\t}\n\n\tpublic async Task StartAsync(\n\t\tAssembly? assembly = null,\n\t\tAction<TracerProviderBuilder>? configureTracer = null,\n\t\tAction<MeterProviderBuilder>? configureMeter = null,\n\t\tCancellationToken cancellationToken = default)\n\t{\n\t\tvar appConfig = _container.TryGetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\n\t\tif (appConfig == null)\n\t\t{\n\t\t\tLog.ErrorNoPII($\"Unable to resolve {nameof(IAppConfig)}, OpenTelemetry won't be configured.\");\n\t\t\treturn;\n\t\t}\n\n\t\tvar configuration = _container.TryGetInstance<IConfiguration>();\n\t\tif (configuration == null)\n\t\t{\n\t\t\tLog.ErrorNoPII($\"Unable to resolve {nameof(IConfiguration)}, OpenTelemetry won't be configured.\");\n\t\t\treturn;\n\t\t}\n\n\t\tvar serviceName = appConfig.TelemetryAppName;\n\n\t\tif (string.IsNullOrWhiteSpace(serviceName))\n\t\t{\n\t\t\tLog.ErrorNoPII($\"{nameof(IAppConfig)}.{nameof(appConfig.TelemetryAppName)} is not defined, OpenTelemetry won't be configured.\");\n\t\t\treturn;\n\t\t}\n\n\t\tvar cloudNameOverride = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\");\n\n\t\tif (!string.IsNullOrWhiteSpace(cloudNameOverride))\n\t\t{\n\t\t\tserviceName = cloudNameOverride;\n\t\t}\n\n\t\tLog.InfoNoPII($\"Starting OpenTelemetry for {serviceName}.\");\n\n\t\tvar services = new ServiceCollection();\n\n\t\tvar serviceVersion = assembly?.GetName().Version?.ToString();\n\n\t\t// Add logging\n\t\tservices.AddLogging();\n\t\tservices.AddScmCoreInstrumentation(\n\t\t\tconfiguration,\n\t\t\tserviceName!,\n\t\t\tserviceVersion: serviceVersion,\n\t\t\tconfigureTracer: configureTracer,\n\t\t\tconfigureMeter: configureMeter);\n\n\t\t// Ensure original configuration is not overriten.\n\t\tforeach (var serviceDescriptor in services.Where(s => s.ServiceType == typeof(IConfiguration)).ToList())\n\t\t{\n\t\t\tservices.Remove(serviceDescriptor);\n\t\t}\n\n\t\tvar existingHostedServices = _container.GetInstance<IEnumerable<IHostedService>>();\n\n\t\tvar registry = new Registry();\n\t\tregistry.Populate(services);\n\n\t\t_container.Configure(c => c.AddRegistry(registry));\n\n\t\tvar updatedHostedServices = _container.GetInstance<IEnumerable<IHostedService>>();\n\t\t_openTelemetryService = updatedHostedServices.Except(existingHostedServices)\n\t\t\t.Where(s => s.GetType().FullName?.StartsWith(\"OpenTelemetry.\", StringComparison.OrdinalIgnoreCase) == true)\n\t\t\t.Single();\n\n\t\tvar loggerFactory = _container.GetInstance<ILoggerFactory>();\n\t\tMicrosoftLoggingAdapterAppender.Attach(loggerFactory);\n\n\t\tawait _openTelemetryService.StartAsync(cancellationToken);\n\n\t\tMicrosoftLoggingAdapterAppender.ClearLoggerCache();\n\n\t\tLog.InfoNoPII($\"OpenTelemetry started for for {serviceName}.\");\n\t}\n\n\tpublic async Task StopAsync(CancellationToken cancellationToken = default)\n\t{\n\t\tLog.InfoNoPII($\"Stopping OpenTelemetry.\");\n\n\t\tMicrosoftLoggingAdapterAppender.Dettach();\n\n\t\tif (_openTelemetryService == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tawait _openTelemetryService.StopAsync(cancellationToken);\n\n\t\tLog.InfoNoPII($\"OpenTelemetry Stopped.\");\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Net;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Web.Mvc;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Repository.DocumentRepository;\nusing ADEXS.Web.Common;\nusing ADEXS.Web.DocExplorer.Models.PanelModels;\nusing ADEXS.Web.MVC;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.Repository.MetadataRepository;\nusing ADEXS.Core.Types;\nusing ADEXS.Web.Common.Helpers;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Translation.Utilities;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.SqlCorePersistence;\nusing ADEXS.Web.AtlasUrl;\nusing ADEXS.Web.MVC.Filters;\nusing Newtonsoft.Json;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Web.Addressbook.Controls.ContactChooser;\nusing static ADEXS.Core.Types.Constants;\nusing Newtonsoft.Json.Linq;\nusing ADEXS.Web.Addressbook.MVC.Models;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Web.Telemetry;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.Web.DocExplorer.Controllers.PanelControllers\n{\n\t[RequireAuthentication(true, true, Enums.Privileges.HasGuestRights)]\n\t[SessionState(SessionStateBehavior.ReadOnly)]\n\tpublic class AttributesController : AtlasController\n\t{\n\t\t#region Properties and Variables\n\n\t\tprotected static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(AttributesController));\n\n\t\tprivate readonly IDocumentRepository _documentRepository;\n\t\tprivate readonly IFolderRepository _folderRepository;\n\t\tprivate readonly IMetadataRepository _metadataRepository;\n\t\tprivate readonly IMetadataGroupRepository _metadataGroupRepository;\n\t\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\t\tprivate IRetrieveTranslationUtility _translationUtility;\n\t\tprivate IRetrieveTranslationUtility TranslationUtility\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (_translationUtility == null)\n\t\t\t\t{\n\t\t\t\t\t_translationUtility = ServiceLocator.GetInstance<IRetrieveTranslationUtility>();\n\t\t\t\t\t_translationUtility.SetDefaultNamespace(Enums.TranslationNamespace.Attributes);\n\t\t\t\t}\n\t\t\t\treturn _translationUtility;\n\t\t\t}\n\t\t}\n\n\t\tprivate Metadatas _persistedDocMetadatas;  // make this a private variable so that it doesn't have to be passed around\n\t\tprivate HashSet<Guid> _visibleGroupUids;\n\n\t\tprivate Dictionary<string, List<string>> keys = new Dictionary<string, List<string>>();\n\n\t\t#endregion\n\n\t\t#region Constructor\n\n\t\tpublic AttributesController(\n\t\t\tIDocumentRepository documentRepository,\n\t\t\tIFolderRepository folderRepository,\n\t\t\tIMetadataRepository metadataRepository,\n\t\t\tIMetadataGroupRepository metadataGroupRepository,\n\t\t\tIServiceInstrumentation serviceInstrumentation)\n\t\t{\n\t\t\t_documentRepository = documentRepository;\n\t\t\t_folderRepository = folderRepository;\n\t\t\t_metadataRepository = metadataRepository;\n\t\t\t_metadataGroupRepository = metadataGroupRepository;\n\t\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t}\n\n\t\t#endregion\n\n\t\tpublic ActionResult Index(string id, Guid docUid, Guid folderUid, int priority = 0)\n\t\t{\n\t\t\tLoadAndValidateDocument(docUid);\n\t\t\tLoadAndValidateFolder(folderUid);\n\n\t\t\tvar currentUser = SessionData.CurrentUser;\n\n\t\t\t// don't load up the whole view model here, angular will lazy load it because the Attributes panel is not the first visible panel on the page\n\t\t\tAttributesViewModel vm = new AttributesViewModel\n\t\t\t{\n\t\t\t\tAccountId = currentUser.AccountId,\n\t\t\t\tId = id,\n\t\t\t\tdocUid = docUid,\n\t\t\t\tfolderUid = folderUid,\n\t\t\t\tPriority = priority,\n\t\t\t\tGroupType = Enums.ToStringIntDictionary<Enums.GroupType>(),\n\t\t\t\tChooserUrl = WebUrl.AddressBook.GetContacts,\n\t\t\t\tCanViewAttributes =  currentUser.Account.Settings.AllowAttributes && HasSufficientRightsToView(),\n\t\t\t\tShowDocumentDetails = ShouldShowDocumentDetails(currentUser)\n\t\t\t};\n\n\t\t\treturn PartialView(\"~/Views/DocExplorer/PanelViews/_AttributesPanel.cshtml\", vm);\n\t\t}\n\n\t\t[HttpPost]\n\t\t[CompressContentAttribute]\n\t\tpublic JsonResult SaveAttributes(string attrvm)\n\t\t{\n\t\t\tusing var saveActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(SaveAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(SaveAttributes));\n\t\t\tsaveActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar stopwatch = Stopwatch.StartNew();\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tattrvm = WebUtility.HtmlDecode(attrvm);\n\t\t\t\tvar attributes = attrvm.ToObject<AttributesViewModel>();\n\t\t\t\tsaveActivity?.SetTag(\"docusign.document.id\", attributes.docUid);\n\n\t\t\t\tvar document = LoadAndValidateDocument(attributes.docUid);\n\n\t\t\t\tif (AttributesShouldBeReadOnly(document))\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"Attributes failed to save, document is read only.\");\n\t\t\t\t}\n\n\t\t\t\t_persistedDocMetadatas = _metadataRepository.Load(SessionData.CurrentUser, document.Type, document.Uid);\n\t\t\t\tsaveActivity?.AddEvent(new ActivityEvent(\"Preparing the save\", saveActivity.StartTimeUtc.Add(stopwatch.Elapsed)));\n\n\t\t\t\t// Perform setup work before saving, compare attributes that already exist on the document vs the attributes coming in from the client.\n\t\t\t\t// If a change is found, ensure the new values are validated and then build the Metadata objects that the MetadataRepository expects for saving.\n\t\t\t\tvar result = FindMetadatasThatNeedUpdating(attributes, document);\n\t\t\t\tsaveActivity?.AddEvent(new ActivityEvent(nameof(FindMetadatasThatNeedUpdating), saveActivity.StartTimeUtc.Add(stopwatch.Elapsed)));\n\n\t\t\t\tif (result.ErrorMessages != null && result.ErrorMessages.Count > 0)\n\t\t\t\t{\n\t\t\t\t\tstatusMessages.AddErrorMessages(result.ErrorMessages);\n\t\t\t\t}\n\t\t\t\telse if (result.UpdatingMetadatas.Count == 0 && result.DeletingMetadatas.Count == 0 && result.DeletingGroups.Count == 0)\n\t\t\t\t{\n\t\t\t\t\tstatusMessages.AddInfoMessage(Resources.Admin.DocExplorer_NoChangesNothingSaved);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tusing (new DatabaseConnectionSwitch(SessionData.CurrentUser))\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (DatabaseTransaction transaction = DatabaseConnection.ThreadConnection.BeginTransaction())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar errors = new List<string>();\n\t\t\t\t\t\t\tif (result.UpdatingMetadatas.Count > 0 || result.DeletingMetadatas.Count > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/////***** Perform the Metedata SAVE here *****/////\n\t\t\t\t\t\t\t\terrors.AddRange(_metadataRepository.Save(SessionData.CurrentUser, result.UpdatingMetadatas, document, result.DeletingMetadatas));\n\n\t\t\t\t\t\t\t\tif (errors.Count == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tServiceLocator.GetInstance<IUserActionRepository>().LogUserAction(SessionData.CurrentUser, Enums.ActionType.MetadataChanged);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (errors.Count == 0 && result.DeletingGroups.Count > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/////***** Perform the Group SAVE here *****/////\n\t\t\t\t\t\t\t\terrors.AddRange(SaveDeletedGroups(result.DeletingGroups, document));\n\n\t\t\t\t\t\t\t\tif (errors.Count == 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar _userAccount = SessionData.CurrentUser;\n\t\t\t\t\t\t\t\t\tstring groups = string.Join(Resources.Atlas.js_CommaSpace, result.DeletingGroups.Select(c => c.Name));\n\t\t\t\t\t\t\t\t\tJObject dataBag = new DocumentHistoryData(_userAccount).ToJObject();\n\t\t\t\t\t\t\t\t\tdataBag.Add(Constants.HistoryData.GROUPS, new JValue(groups));\n\t\t\t\t\t\t\t\t\tServiceLocator.GetInstance<IObjectHistoryUtility>().LogDocumentAction(_userAccount, document, Enums.ActionType.MetadataChanged, dataBag, Enums.HistoryMessageIdentifiers.Deleted);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsaveActivity?.AddEvent(new ActivityEvent(nameof(SaveAttributes), saveActivity.StartTimeUtc.Add(stopwatch.Elapsed)));\n\t\t\t\t\t\t\tif (errors.Count > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstatusMessages.AddErrorMessages(errors);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttransaction.Commit();\n\n\t\t\t\t\t\t\t\tif (SessionData.CurrentUser.Settings.EnableABACSecurity && _documentRepository.GetUpdatedDocumentSecurity(SessionData.CurrentUser, document) < Enums.Security.Write)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSessionData.Messages.AddSuccessMessage(Resources.Admin.AttributesSaved);\n\t\t\t\t\t\t\t\t\tsaveActivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\t\t\t\t\t\treturn new JsonResult\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tData = new { success = true, ReloadRequired = true }\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstatusMessages.AddSuccessMessage(Resources.Admin.AttributesSaved);\n\n\t\t\t\t\t\t\t\tAttributesViewModel vm = null;\n\t\t\t\t\t\t\t\tif (SessionData.CurrentUser.Account.Settings.EnableCreateAttributeViewModelForDocExplorer)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvm = CreateAttributesViewModel(document);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tsaveActivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\t\t\t\t\treturn new JsonResult\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tData = new { success = true, messages = statusMessages, vm = vm },\n\t\t\t\t\t\t\t\t\tMaxJsonLength = int.MaxValue\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsaveActivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\treturn Json(new { success = true, messages = statusMessages });\n\t\t\t}\n\t\t\tcatch(AdexsDisplayException ex)\n\t\t\t{\n\t\t\t\tstatusMessages.AddWarningMessage(ex.Message);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t[HttpPost]\n\t\t[CompressContentAttribute]\n\t\tpublic JsonResult LoadAttributes(Guid docUid, Guid folderUid)\n\t\t{\n\t\t\tusing var loadActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadAttributes))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadAttributes))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\tif (!HasSufficientRightsToView())\n\t\t\t{\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Atlas.error_YouDoNotHaveTheRequiredSecurityToAccessThisPage);\n\t\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAttributesViewModel viewModel;\n\t\t\t\tif (docUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tvar document = LoadAndValidateDocument(docUid);\n\t\t\t\t\tviewModel = CreateAttributesViewModel(document);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar folder = LoadAndValidateFolder(folderUid);\n\t\t\t\t\tviewModel = CreateAttributesViewModel(folder);\n\t\t\t\t}\n\n\t\t\t\tloadActivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn new JsonResult\n\t\t\t\t{\n\t\t\t\t\tData = new { success = true, messages = statusMessages, vm = viewModel },\n\t\t\t\t\tMaxJsonLength = int.MaxValue\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t[HttpPost]\n\t\t[CompressContentAttribute]\n\t\tpublic JsonResult LoadGroupSchema(Guid groupUid, Guid docUid, Guid folderUid)\n\t\t{\n\t\t\tusing var loadGroupSchemaActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadGroupSchema))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadGroupSchema))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadGroupSchemaActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (groupUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tthrow new ArgumentException(\"Group Uid must be provided\");\n\t\t\t\t}\n\n\t\t\t\tvar group = _metadataGroupRepository.LoadByUid(groupUid);\n\t\t\t\tif (group == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new ArgumentException($\"Group {groupUid} not found\");\n\t\t\t\t}\n\n\t\t\t\tgroup.SetTranslationUtility(TranslationUtility);\n\n\t\t\t\tLoadAndValidateDocument(docUid);\n\t\t\t\tLoadAndValidateFolder(folderUid);\n\t\t\t\t_persistedDocMetadatas = new Metadatas();  // Important! to get the groups schema only, we fake having NO metadata info\n\t\t\t\tvar groupViewModel = CreateGroupViewModelWithoutMetadata(new Dictionary<Guid, MetadataGroup> { [groupUid] = group }, folderUid, docUid, false).First();\n\n\t\t\t\tloadGroupSchemaActivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn Json(new { success = true, messages = statusMessages, gvm = groupViewModel });\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t[HttpPost]\n\t\tpublic JsonResult Refresh(Guid docUid)\n\t\t{\n\t\t\tusing var refreshActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(Refresh))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(Refresh))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\trefreshActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\n\t\t\tif (!HasSufficientRightsToView())\n\t\t\t{\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Atlas.error_YouDoNotHaveTheRequiredSecurityToAccessThisPage);\n\t\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAttributesViewModel viewModel;\n\t\t\t\tif (docUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tvar document = LoadAndValidateDocument(docUid);\n\t\t\t\t\tviewModel = CreateAttributesViewModel(document);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception();\n\t\t\t\t}\n\n\t\t\t\trefreshActivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn new JsonResult\n\t\t\t\t{\n\t\t\t\t\tData = new { success = true, messages = statusMessages, viewModel = viewModel.ToJson() },\n\t\t\t\t\tMaxJsonLength = int.MaxValue\n\t\t\t\t};\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t[HttpPost]\n\t\t[CompressContentAttribute]\n\t\tpublic JsonResult LoadCascadingDropdownOptions(Guid metadataFieldUid, Guid metadataSetUid, Guid docUid, string keyPath)\n\t\t{\n\t\t\tusing var loadCascadingDropdownOptionsActivity = _serviceInstrumentation?.ActivitySource\n\t\t\t\t?.StartActivity(nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, nameof(LoadCascadingDropdownOptions))\n\t\t\t\t?.SetTag(\"docusign.document.id\", docUid);\n\t\t\tloadCascadingDropdownOptionsActivity?.SetTagsWithCommonFields(System.Web.HttpContext.Current);\n\n\t\t\tvar statusMessages = new Messages();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (metadataFieldUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tthrow new ArgumentException(@\"Parameter cannot be an empty guid.\", nameof(metadataFieldUid));\n\t\t\t\t}\n\n\t\t\t\tif (metadataSetUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tthrow new ArgumentException(@\"Parameter cannot be an empty guid.\", nameof(metadataSetUid));\n\t\t\t\t}\n\n\t\t\t\tif (docUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tstatusMessages.AddInfoMessage(Resources.Documents.YouMustSaveThisDocumentBeforeCascadingDropdownsCanBeLoaded);\n\t\t\t\t\treturn Json(new { success = false, messages = statusMessages});\n\t\t\t\t}\n\t\t\t\tvar keyPathList = keyPath == null ? new List<string>() : keyPath.ToObject<List<string>>();\n\n\t\t\t\tLoadAndValidateDocument(docUid);\n\n\t\t\t\tvar options = _metadataRepository.GetCascadingTypeAheadValues(metadataSetUid, metadataFieldUid, keyPathList, SessionData.CurrentAccountId);\n\n\t\t\t\tloadCascadingDropdownOptionsActivity?.SetStatus(ActivityStatusCode.Ok);\n\n\t\t\t\treturn Json(new { success = true, messages = statusMessages, options = options.Values });\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(ex);\n\t\t\t\tstatusMessages.AddErrorMessage(Resources.Documents.AnUnknownErrorHasOccurred);\n\t\t\t}\n\n\t\t\treturn Json(new { success = false, messages = statusMessages });\n\t\t}\n\n\t\t#region Private functions\n\n\t\tpublic Document LoadAndValidateDocument(Guid docUid)\n\t\t{\n\t\t\tDocument document = null;\n\t\t\tif (docUid != Guid.Empty)\n\t\t\t{\n\t\t\t\tdocument = _documentRepository.LoadByUid(SessionData.CurrentUser, docUid);\n\t\t\t\tif (document == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"Document does not exist or current user does not have permissions to view this document.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn document;\n\t\t}\n\t\tpublic Folder LoadAndValidateFolder(Guid folderUid)\n\t\t{\n\t\t\tFolder folder = null;\n\t\t\tif (folderUid != Guid.Empty)\n\t\t\t{\n\t\t\t\tfolder = _folderRepository.LoadByUid(SessionData.CurrentUser, folderUid);\n\t\t\t\tif (folder == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new Exception(\"Folder does not exist or current user does not have access to this folder.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn folder;\n\t\t}\n\n\t\tprivate bool AttributesShouldBeReadOnly(Document document)\n\t\t{\n\t\t\tif(document == null)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (document.IsViewOnly(SessionData.CurrentUser))  // checked out / locked status\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!document.HasSecurity(Enums.Security.Write))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (_documentRepository.IsTrashed(SessionData.CurrentUser, document))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate bool IsGroupAvailable(MetadataGroup metadataGroup, Guid folderUid)\n\t\t{\n\t\t\tif(_visibleGroupUids == null)\n\t\t\t{\n\t\t\t\t_visibleGroupUids = _metadataGroupRepository.LoadDisplayByAccountIdAndFolderUid(SessionData.CurrentAccountId, folderUid) ?? new HashSet<Guid>();\n\t\t\t}\n\n\t\t\tif (_visibleGroupUids.Count > 0 && !_visibleGroupUids.Contains(metadataGroup.Uid))\n\t\t\t{\n\t\t\t\treturn false;  // this group is not available because the parent folder is hiding this attribute group\n\t\t\t}\n\n\t\t\treturn !metadataGroup.Hidden;\n\t\t}\n\n\t\tprivate bool HasSufficientRightsToView()\n\t\t{\n\t\t\treturn SessionData.CurrentUser.Role <= SessionData.CurrentUser.Account.Settings.AllowToViewAttributesRole;\n\t\t}\n\n\t\t// Methods used for LOADING metadata\n\t\tprivate AttributesViewModel CreateAttributesViewModel(Folder folder)\n\t\t{\n\t\t\tMetadataGroups allGroups = _metadataGroupRepository.LoadByAccountId(SessionData.CurrentAccountId);\n\t\t\t_persistedDocMetadatas = new Metadatas(); // there is no document, so there are no metadatas\n\n\t\t\t//Start building the view model for the attributes page\n\t\t\tAttributesViewModel vm = new AttributesViewModel();\n\t\t\tvm.folderUid = folder.Uid;\n\t\t\tvm.docUid = Guid.Empty;\n\t\t\tvm.ReadOnly = false; // todo: should we check if the user has permissions to create a document in this folder?\n\t\t\tvm.CanViewAttributes = HasSufficientRightsToView();\n\t\t\tvm.ShowDocumentDetails = ShouldShowDocumentDetails(SessionData.CurrentUser);\n\t\t\tvm.groups = CreateGroupViewModelWithoutMetadata(allGroups.ToDictionary(x => x.Uid, x => x), folder.Uid, Guid.Empty, vm.ReadOnly);\n\t\t\t\n\t\t\treturn vm;\n\t\t}\n\t\tprivate AttributesViewModel CreateAttributesViewModel(Document document)\n\t\t{\n\t\t\tMetadataGroups allGroups = _metadataGroupRepository.LoadByAccountId(SessionData.CurrentAccountId);\n\t\t\t_persistedDocMetadatas = _metadataRepository.Load(SessionData.CurrentUser, document.Type, document.Uid);\n\n\t\t\t//Start building the view model for the attributes page\n\t\t\tAttributesViewModel vm = new AttributesViewModel();\n\t\t\tvm.folderUid = document.FolderUid;\n\t\t\tvm.docUid = document.Uid;\n\t\t\tvm.ReadOnly = AttributesShouldBeReadOnly(document);\n\t\t\tvm.groups = CreateGroupsViewModelWithMetadata(allGroups, document.FolderUid, document.Uid, vm.ReadOnly).ToList();\n\t\t\tvm.EnableCreateAttributeViewModelForDocExplorer =\n\t\t\t\tShouldEnableCreateAttributeViewModel(SessionData.CurrentUser);\n\n\t\t\treturn vm;\n\t\t}\n\n\t\tprivate IEnumerable<AttributeGroupViewModel> CreateGroupsViewModelWithMetadata(MetadataGroups allGroups, Guid folderUid, Guid documentUid, bool docIsReadOnly)\n\t\t{\n\t\t\tvar groupsRemaining = allGroups.ToDictionary(x => x.Uid, x => x);\n\t\t\tbool isLoadingAllAttributeGroupFieldOptions =\n\t\t\t\tDocumentAttributesFeatureFlags.EnableLoadingAllAttributeGroupFieldOptions;\n\t\t\tvar groups = ProcessMetadataIntoModels(\n\t\t\t\tmetadatas: _persistedDocMetadatas,\n\t\t\t\tgroupsRemaining: groupsRemaining,\n\t\t\t\tisAttached: true,\n\t\t\t\tdocumentUid: documentUid,\n\t\t\t\tdocIsReadOnly: docIsReadOnly,\n\t\t\t\tgroupFields: new Dictionary<Guid, MetadataFields>(),\n\t\t\t\tshouldLoadAllMetadataFieldOptions: isLoadingAllAttributeGroupFieldOptions);\n\n\t\t\tgroups.AddRange(CreateGroupViewModelWithoutMetadata(groupsRemaining, folderUid, documentUid, docIsReadOnly, isLoadingAllAttributeGroupFieldOptions));\n\n\t\t\treturn groups.OrderBy(x => x.position);\n\t\t}\n\n\t\tprivate List<AttributeGroupViewModel> CreateGroupViewModelWithoutMetadata(Dictionary<Guid, MetadataGroup> allGroups, Guid folderUid, Guid documentUid, bool docIsReadOnly, bool shouldLoadAllMetadataFieldOptions = true)\n\t\t{\n\t\t\tMetadatas groupMetadatas = new Metadatas();\n\t\t\tDictionary<Guid, MetadataFields> groupFields = new Dictionary<Guid, MetadataFields>();\n\t\t\tforeach (MetadataGroup metadataGroup in allGroups.Values.Where(x => IsGroupAvailable(x, folderUid)))\n\t\t\t{\n\t\t\t\t// the group is not attached, so lets create a Metadata object that acts as a template for a field\n\t\t\t\tgroupFields[metadataGroup.Uid] =\n\t\t\t\t\t_metadataRepository.GetMetadataFieldsByMetadataGroupUid(SessionData.CurrentAccountId,\n\t\t\t\t\t\tmetadataGroup.Uid);\n\t\t\t\tforeach (MetadataField metadataField in groupFields[metadataGroup.Uid])\n\t\t\t\t{\n\t\t\t\t\tMetadata metadataTemplate = new Metadata(SessionData.CurrentAccountId, metadataField,\n\t\t\t\t\t\tmetadataField.MetadataSetNumber, Enums.ObjectType.Document, Guid.Empty, null);\n\t\t\t\t\tgroupMetadatas.Add(metadataTemplate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn ProcessMetadataIntoModels(groupMetadatas, allGroups, false, documentUid, docIsReadOnly, groupFields, shouldLoadAllMetadataFieldOptions);\n\t\t}\n\n\t\tprivate List<AttributeGroupViewModel> ProcessMetadataIntoModels(Metadatas metadatas, Dictionary<Guid, MetadataGroup> groupsRemaining, bool isAttached, Guid documentUid, bool docIsReadOnly, Dictionary<Guid, MetadataFields> groupFields, bool shouldLoadAllMetadataFieldOptions = true)\n\t\t{\n\t\t\tList<AttributeGroupViewModel> groups = new List<AttributeGroupViewModel>();\n\t\t\t//_metadataRepository.LoadByDocumentUid shall be called only when allowAllAttributes == FALSE , in case of TRUE documentMetadataUids will not be used. Avoiding unnecessary in case of TRUE \n\t\t\tvar documentMetadataUids = shouldLoadAllMetadataFieldOptions ? new HashSet<Guid>() : _metadataRepository.LoadByDocumentUid(SessionData.CurrentAccountId, documentUid).Select(m => m.MetadataFieldUid).ToHashSet();\n\t\t\tGuid currentGroupUid = Guid.Empty;\n\t\t\tAttributeGroupViewModel currentGroupModel = null;\n\t\t\tAttributeGroupItemViewModel currentGroupItemModel = new AttributeGroupItemViewModel();\n\t\t\t// first process any groups that are already attached to the document\n\t\t\tforeach (Metadata metadata in metadatas)\n\t\t\t{\n\t\t\t\t// filter out protected AOM system metadata groups because these are made editable on the panel via DocumentDetailsController\n\t\t\t\t// metadata groups are retained on the folders/documents for use in search and reporting\n\t\t\t\tif (metadata.MetadataGroupName == SystemMetadataGroupNames.CLM_PARTY || metadata.MetadataGroupName == SystemMetadataGroupNames.CLM_AGREEMENT_DETAILS)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmetadata.SetTranslationUtility(TranslationUtility);\n\t\t\t\t// metadata is loaded ordered by group position and than name so all rows from the same group are naturally clustered together and when we see a new groupUid, we know we can are done with the previous group and can start processing the new one\n\t\t\t\tif (metadata.MetadataGroupUid != currentGroupUid)\n\t\t\t\t{\n\t\t\t\t\tcurrentGroupUid = metadata.MetadataGroupUid;\n\t\t\t\t\tcurrentGroupModel = new AttributeGroupViewModel\n\t\t\t\t\t{\n\t\t\t\t\t\tid = currentGroupUid.ToString(),\n\t\t\t\t\t\tname = metadata.LocalizedGroupName,\n\t\t\t\t\t\tposition = metadata.MetadataGroupPosition,\n\t\t\t\t\t\titems = new List<AttributeGroupItemViewModel>(),\n\t\t\t\t\t\tattached = isAttached,\n\t\t\t\t\t\tdefinitionHash = groupFields.ContainsKey(currentGroupUid) ? HashObject(Transform(groupFields[currentGroupUid])) : CreateMetadataGroupHash(currentGroupUid),\n\t\t\t\t\t\tisSystem = groupsRemaining[currentGroupUid].System\n\t\t\t\t\t};\n\t\t\t\t\tgroups.Add(currentGroupModel);\n\t\t\t\t\tgroupsRemaining.Remove(currentGroupUid);\n\t\t\t\t}\n\n\t\t\t\t// metadata loaded is further ordered by metadata set number and name which ensures that all metadata from the same set is clustered together\n\t\t\t\tif (metadata.MetadataSetUid == Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tcurrentGroupItemModel = CreateAttributeGroupItemViewModelFromField(metadata);\n\t\t\t\t\tcurrentGroupModel.items.Add(currentGroupItemModel);\n\t\t\t\t}\n\t\t\t\telse if (metadata.MetadataSetUid.ToString() != currentGroupItemModel.setid || metadata.MetadataSetPosition != currentGroupItemModel.position || (metadata.MetadataSetRepeating ? metadata.MetadataSetNumber : 0) != currentGroupItemModel.number)\n\t\t\t\t{\n\t\t\t\t\tcurrentGroupItemModel = CreateSetAttributeGroupItemViewModelFromSet(metadata);\n\t\t\t\t\tcurrentGroupModel.items.Add(currentGroupItemModel);\n\t\t\t\t}\n\t\t\t\tbool populateOptions = shouldLoadAllMetadataFieldOptions || documentMetadataUids.Contains(metadata.MetadataFieldUid);\n\t\t\t\tcurrentGroupItemModel.fields.Add(CreateAttributeFieldViewModel(metadata, documentUid, docIsReadOnly, populateOptions));\n\t\t\t}\n\n\t\t\treturn groups;\n\t\t}\n\n\t\tprivate AttributeGroupItemViewModel CreateAttributeGroupItemViewModelFromField(Metadata docMetadata)\n\t\t{\n\t\t\tAttributeGroupItemViewModel groupItemVm = new AttributeGroupItemViewModel();\n\t\t\tgroupItemVm.type = \"field\";\n\t\t\tgroupItemVm.id = Guid.NewGuid().ToString();\n\t\t\tgroupItemVm.fieldid = docMetadata.MetadataFieldUid.ToString();\n\t\t\tgroupItemVm.groupid = docMetadata.MetadataGroupUid.ToString();\n\t\t\tgroupItemVm.position = docMetadata.MetadataFieldPosition;\n\t\t\tgroupItemVm.name = docMetadata.LocalizedName;\n\t\t\tgroupItemVm.number = docMetadata.Repeating ? docMetadata.MetadataSetNumber : 0;\n\t\t\tgroupItemVm.repeating = docMetadata.Repeating;\n\t\t\tgroupItemVm.fields = new List<AttributeFieldViewModel>();\n\t\t\treturn groupItemVm;\n\t\t}\n\t\tprivate AttributeGroupItemViewModel CreateSetAttributeGroupItemViewModelFromSet(Metadata docMetadata)\n\t\t{\n\t\t\tAttributeGroupItemViewModel groupItemVm = new AttributeGroupItemViewModel();\n\t\t\tgroupItemVm.type = \"set\";\n\t\t\tgroupItemVm.id = Guid.NewGuid().ToString();\n\t\t\tgroupItemVm.setid = docMetadata.MetadataSetUid.ToString();\n\t\t\tgroupItemVm.groupid = docMetadata.MetadataGroupUid.ToString();\n\t\t\tgroupItemVm.position = docMetadata.MetadataSetPosition;\n\t\t\tgroupItemVm.name = docMetadata.LocalizedSetName;\n\t\t\tgroupItemVm.number = docMetadata.MetadataSetRepeating ? docMetadata.MetadataSetNumber : 0;\n\t\t\tgroupItemVm.repeating = docMetadata.MetadataSetRepeating;\n\t\t\tgroupItemVm.fields = new List<AttributeFieldViewModel>();\n\t\t\treturn groupItemVm;\n\t\t}\n\t\tprivate AttributeFieldViewModel CreateAttributeFieldViewModel(\n\t\t\tMetadata docMetadata,\n\t\t\tGuid documentUid,\n\t\t\tbool docIsReadonly,\n\t\t\tbool populateOptions = true)\n\t\t{\n\t\t\tvar fieldvm = new AttributeFieldViewModel();\n\t\t\tfieldvm.id = Guid.NewGuid().ToString();\n\t\t\tfieldvm.metadataid = docMetadata.Uid.ToString();\n\t\t\tfieldvm.fieldid = docMetadata.MetadataFieldUid.ToString();\n\t\t\tfieldvm.name = docMetadata.LocalizedName;\n\t\t\tfieldvm.dataType = (int)docMetadata.DataType;\n\t\t\tfieldvm.value = MetadataRepository.FormatMetaValue(docMetadata.LocalizedValue, docMetadata.DataType, SessionData.CurrentCulture);\n\t\t\tfieldvm.required = docMetadata.IsRequiredAttribute;\n\t\t\tfieldvm.readOnly = docIsReadonly || docMetadata.ReadOnly;\n\t\t\tfieldvm.customErrorMessage = docMetadata.LocalizedCustomValidationErrMsg;\n\t\t\tfieldvm.validationRegEx = docMetadata.LocalizedCustomValidation;\n\t\t\tfieldvm.position = docMetadata.MetadataFieldPosition;\n\t\t\t//String datatype and isLink check\n\t\t\tfieldvm.isLink = docMetadata.DataType == Enums.DataType.String && Uri.IsWellFormedUriString(fieldvm.value, UriKind.Absolute);\n\t\t\t//docMetadata.Definition  // what is this?\n\t\t\tif (docMetadata.DataType == Enums.DataType.Number || docMetadata.DataType == Enums.DataType.Decimal)\n\t\t\t{\n\t\t\t\tfieldvm.decimalChar = SessionData.CurrentCulture.NumberFormat.NumberDecimalSeparator;\n\t\t\t\tfieldvm.groupingChar = SessionData.CurrentCulture.NumberFormat.NumberGroupSeparator;\n\t\t\t}\n\t\t\t//Special casing for various data types\n\t\t\tif (docMetadata.DataType == Enums.DataType.Date)\n\t\t\t{\n\t\t\t\tfieldvm.value = Regex.Replace(fieldvm.value, Constants.SpecialDateTimeFormatCharactersRegexPattern, string.Empty);\n\t\t\t\tfieldvm.dateFormat = \"M/d/yyyy\"; // default value\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfieldvm.dateFormat = SessionData.CurrentCulture.DateTimeFormat.ShortDatePattern;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII(\"Unable to retrieve users date pattern\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (docMetadata.DataType == Enums.DataType.DropDown || docMetadata.DataType == Enums.DataType.MagicDropDown)\n\t\t\t{\n\t\t\t\tvar options = new List<string>();\n\t\t\t\tif (populateOptions)\n\t\t\t\t{\n\t\t\t\t\toptions.AddRange(docMetadata.LocalizedAllowedDropDownValues().Distinct());\n\t\t\t\t}\n\t\t\t\t// if the value is not in the allowed values (e.g., set via workflow), add that value to the list so the field populates\n\t\t\t\tif (!string.IsNullOrEmpty(fieldvm.value) && !options.Contains(fieldvm.value))\n\t\t\t\t{\n\t\t\t\t\toptions.Add(fieldvm.value);\n\t\t\t\t}\n\n\t\t\t\tfieldvm.options = options;\n\t\t\t}\n\t\t\tif (docMetadata.DataType == Enums.DataType.Cascade)\n\t\t\t{\n\t\t\t\tstring myKey = $\"{docMetadata.MetadataSetUid}-{docMetadata.MetadataSetNumber}\";\n\t\t\t\tif (!keys.ContainsKey(myKey))\n\t\t\t\t{\n\t\t\t\t\tkeys.Add(myKey, new List<string>());\n\t\t\t\t}\n\n\t\t\t\tvar keyPath = keys[myKey];\n\t\t\t\tif (populateOptions && (keyPath.Count <= 0 || !string.IsNullOrEmpty(keyPath.Last())))\n\t\t\t\t{\n\t\t\t\t\tbool enableCascadingAttributesCacheOptimization =\n\t\t\t\t\t\tDocumentAttributesFeatureFlags.EnableCascadingAttributesCacheOptimization;\n\t\t\t\t\tSortedList<string, string> options = new SortedList<string, string>();\n\t\t\t\t\tif (enableCascadingAttributesCacheOptimization)\n\t\t\t\t\t{\n\t\t\t\t\t\toptions = _metadataRepository.GetCascadingTypeAheadValues(docMetadata.MetadataSetUid, docMetadata.MetadataFieldUid, keyPath, docMetadata.AccountId, new Dictionary<Guid, CascadingFieldSet>());\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toptions = _metadataRepository.GetCascadingTypeAheadValues(docMetadata.MetadataSetUid, docMetadata.MetadataFieldUid, keyPath, docMetadata.AccountId);\n\t\t\t\t\t}\n\n\t\t\t\t\tfieldvm.options = options.Values.ToList();\n\t\t\t\t\t\n\t\t\t\t\tif(!string.IsNullOrEmpty(fieldvm.value))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (options.ContainsKey(fieldvm.value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldvm.value = options[fieldvm.value];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!options.ContainsValue(fieldvm.value))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfieldvm.options.Add(fieldvm.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfieldvm.options = new List<string>();\n\t\t\t\t}\n\n\t\t\t\tif(docMetadata.Value == null)\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII($\"DocMetadata value was null and added to keypath which may result in a null reference exception.\" +\n\t\t\t\t\t\t$\" DocMetadata Field Id: {docMetadata.MetadataFieldUid}, DocMetadata Field's Group Uid: {docMetadata.MetadataGroupUid}.\");\n\t\t\t\t}\n\t\t\t\tkeyPath.Add(docMetadata.Value);\n\t\t\t}\n\t\t\tif (docMetadata.DataType == Enums.DataType.Actor)\n\t\t\t{\n\t\t\t\tfieldvm.chooserDataSource = EntityDataSource.GetActorEntityDataSource(ActorAttributeRestriction.LoadFromMetadata(docMetadata.Definition, docMetadata.AccountId, docMetadata.MetadataFieldUid));\n\t\t\t}\n\t\t\treturn fieldvm;\n\t\t}\n\n\n\t\t// Methods used for SAVING metadata\n\n\t\tprivate List<string> SaveDeletedGroups(MetadataGroups deletingGroups, Document document)\n\t\t{\n\t\t\tList<string> errorMessages = new List<string>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tforeach (MetadataGroup mg in deletingGroups)\n\t\t\t\t{\n\t\t\t\t\t_metadataRepository.DeleteByMetadataGroupUid(SessionData.CurrentAccountId, mg.Uid, document.Type, document.Uid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII($\"Failed to delete attributes from document '{document.Uid}' with group uids {string.Join(\", \", deletingGroups.Select(c => c.Uid).ToList())}.\", ex);\n\t\t\t\terrorMessages.Add(Resources.Admin.AttributesSaveGroupsFailed);\n\t\t\t}\n\t\t\treturn errorMessages;\n\t\t}\n\n\t\tprivate ChangedMetadatasResult FindMetadatasThatNeedUpdating(AttributesViewModel attributes, Document document)\n\t\t{\n\t\t\tMetadatas updateMetadatas = new Metadatas();\n\t\t\tMetadatas deleteMetadatas = new Metadatas();\n\t\t\tMetadataGroups deletingGroups = new MetadataGroups();\n\t\t\tList<string> errorMessages = new List<string>();\n\t\t\tDictionary<string, List<AttributeGroupItemViewModel>> repeatingItems = new Dictionary<string, List<AttributeGroupItemViewModel>>();\n\t\t\tforeach (AttributeGroupViewModel group in attributes.groups)\n\t\t\t{\n\t\t\t\tif (IsSystemGroup(group))\n\t\t\t\t{\n\t\t\t\t\tcontinue;  // system level groups can not get modified by end users\n\t\t\t\t}\n\n\t\t\t\tswitch (GetGroupDocState(group))\n\t\t\t\t{\n\t\t\t\t\tcase GroupDocState.GroupContinueBeingDetached:\n\t\t\t\t\t\tcontinue; // no need to process this groups items, this group is NOT attached to this document\n\t\t\t\t\tcase GroupDocState.GroupDetaching:\n\t\t\t\t\t\tdeletingGroups.Add(new MetadataGroup { Uid = Guid.Parse(group.id), Name = group.name });\n\t\t\t\t\t\tcontinue; // no need to process this groups items, they will all get deleted\n\t\t\t\t\tcase GroupDocState.GroupAttaching:\n\t\t\t\t\t\tupdateMetadatas.Add(CreateMetadataPlaceHolderForGroup(group, document));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GroupDocState.GroupContinueBeingAttached:\n\t\t\t\t\t\t// nothing special here, process items below to check for updates \n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tValidateGroup(group);\n\n\t\t\t\tforeach (AttributeGroupItemViewModel item in group.items)\n\t\t\t\t{\n\t\t\t\t\t// HANDLE REPEATING ITEMS (collect repeating fields, and process them later)\n\t\t\t\t\tif (item.repeating)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring itemTypeId = item.type == \"field\" ? item.fieldid : item.setid;\n\t\t\t\t\t\tif (!repeatingItems.ContainsKey(itemTypeId))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trepeatingItems.Add(itemTypeId, new List<AttributeGroupItemViewModel>());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trepeatingItems[itemTypeId].Add(item);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// HANDLE NON-REPEATING ITEMS\n\t\t\t\t\tforeach (AttributeFieldViewModel field in item.fields)\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid metadataUid = Guid.Parse(field.metadataid);\n\t\t\t\t\t\tMetadata persistedMetadata = metadataUid == Guid.Empty\n\t\t\t\t\t\t\t? _persistedDocMetadatas.FirstOrDefault(c => c.MetadataFieldUid == Guid.Parse(field.fieldid))\n\t\t\t\t\t\t\t: _persistedDocMetadatas.SingleOrDefault(c => c.Uid == metadataUid);\n\t\t\t\t\t\tif (persistedMetadata == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// this is a field from a GROUP that is being added to the document, retrieve the MetadataField to create a Metadata object\n\t\t\t\t\t\t\tMetadataField metaField = _metadataRepository.GetMetadataField(SessionData.CurrentAccountId, Guid.Parse(field.fieldid));\n\t\t\t\t\t\t\tmetaField.SetTranslationUtility(TranslationUtility);\n\t\t\t\t\t\t\tpersistedMetadata = new Metadata(SessionData.CurrentAccountId, metaField, document.Type, document.Uid, null);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tMetadataFieldResult result;\n\t\t\t\t\t\tif (IsFieldMarkedForDelete(field, item, group))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = DeleteMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (metadataUid == Guid.Empty)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = CreateMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = UpdateMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (result.Proceed && result.ResultType == MetadataFieldResultType.Update)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tupdateMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (result.Proceed && result.ResultType == MetadataFieldResultType.Delete)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdeleteMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!string.IsNullOrEmpty(result.ErrorMessage))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terrorMessages.Add(result.ErrorMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach (KeyValuePair<string, List<AttributeGroupItemViewModel>> repeatedItem in repeatingItems)\n\t\t\t{\n\t\t\t\tList<AttributeGroupItemViewModel> items = repeatedItem.Value; // items is a list of all instances of a repeated item or set\n\n\t\t\t\t// retrieve the existing persisted metadatas on the document for the repeating items\n\t\t\t\t// this does not include synthesized rows(aka fake/non-actual rows), also these values come back in a SPECIFIC ORDER)\n\t\t\t\tList<Metadata> persistedMetadatas = GetPersistedMetadatasForRepeatableItem(items[0]);\n\n\t\t\t\tAttributeGroupViewModel group = attributes.groups.First(c => c.id == items[0].groupid);\n\n\t\t\t\tint currentMaxSetNumber = persistedMetadatas.Count == 0 ? 0 : persistedMetadatas.Max(c => c.MetadataSetNumber);\n\n\t\t\t\t// handle deleting items first! Important: remove them from the persistedMetadatas collection\n\t\t\t\tMetadataFieldResult result;\n\t\t\t\tforeach (AttributeGroupItemViewModel item in items)\n\t\t\t\t{\n\t\t\t\t\tif (!IsItemMarkedForDelete( item, group))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tforeach (AttributeFieldViewModel field in item.fields)\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid metadataUid = Guid.Parse(field.metadataid);\n\t\t\t\t\t\tif (metadataUid != Guid.Empty) // empty guid would indicate that this is a field that has yet to be created (therefore do nothing, because there is nothing to delete)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMetadata persistedMetadata = persistedMetadatas.Single(c => c.Uid == metadataUid); // this has to be here, or there is nothing to delete\n\t\t\t\t\t\t\tresult = DeleteMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t\tif (result.Proceed)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdeleteMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (!string.IsNullOrEmpty(result.ErrorMessage))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terrorMessages.Add(result.ErrorMessage);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpersistedMetadatas.Remove(persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// handle non-deleting items, existing metadatas will be used first so that we can preserve the clients order of the repeatable fields\n\t\t\t\tQueue<int> metadataSetNumbersQueue = new Queue<int>(persistedMetadatas.Select(c => c.MetadataSetNumber).Distinct().OrderBy(c => c));\n\t\t\t\tforeach (AttributeGroupItemViewModel item in items)\n\t\t\t\t{\n\t\t\t\t\tif (IsItemMarkedForDelete(item, group))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint metadataSetNumberToUse = metadataSetNumbersQueue.Count > 0 ? metadataSetNumbersQueue.Dequeue() : (currentMaxSetNumber += 1);\n\n\t\t\t\t\tforeach (AttributeFieldViewModel field in item.fields)\n\t\t\t\t\t{\n\t\t\t\t\t\t// DO NOT retrieve by metadatauid, we use the metadatasetnumber to preserve the ORDER the client wants\n\t\t\t\t\t\tMetadata persistedMetadata = persistedMetadatas.FirstOrDefault(c => c.MetadataSetNumber == metadataSetNumberToUse && (int)c.DataType == field.dataType && c.MetadataFieldUid == Guid.Parse(field.fieldid));\n\n\t\t\t\t\t\tif (persistedMetadata != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpersistedMetadatas.Remove(persistedMetadata);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (persistedMetadata == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpersistedMetadata = _persistedDocMetadatas.FirstOrDefault(c => c.MetadataFieldUid == Guid.Parse(field.fieldid) && c.Uid == Guid.Empty);\n\t\t\t\t\t\t\tif (persistedMetadata == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// this is a field from a GROUP that is being added to the document, retrieve the MetadataField to create a Metadata object\n\t\t\t\t\t\t\t\tMetadataField metaField = _metadataRepository.GetMetadataField(SessionData.CurrentAccountId, Guid.Parse(field.fieldid));\n\t\t\t\t\t\t\t\tmetaField.SetTranslationUtility(TranslationUtility);\n\t\t\t\t\t\t\t\tpersistedMetadata = new Metadata(SessionData.CurrentAccountId, metaField, document.Type, document.Uid, null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpersistedMetadata.MetadataSetNumber = metadataSetNumberToUse;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (IsFieldMarkedForDelete(field, item, group))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = DeleteMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (persistedMetadata.Uid == Guid.Empty)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = CreateMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresult = UpdateMetadataField(field, item, group, persistedMetadata);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (result.Proceed && result.ResultType == MetadataFieldResultType.Update)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tupdateMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (result.Proceed && result.ResultType == MetadataFieldResultType.Delete)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdeleteMetadatas.Add(result.ResultMetadata);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!string.IsNullOrEmpty(result.ErrorMessage))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terrorMessages.Add(result.ErrorMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new ChangedMetadatasResult\n\t\t\t{\n\t\t\t\tUpdatingMetadatas = updateMetadatas,\n\t\t\t\tDeletingMetadatas = deleteMetadatas,\n\t\t\t\tDeletingGroups = deletingGroups,\n\t\t\t\tErrorMessages = errorMessages\n\t\t\t};\n\t\t}\n\n\t\tprivate Metadata CreateMetadataPlaceHolderForGroup(AttributeGroupViewModel groupvm, Document document)\n\t\t{\n\t\t\treturn new Metadata(SessionData.CurrentAccountId, Guid.Parse(groupvm.id), Guid.Empty, document.Type, document.Uid, null) {MetadataGroupName = groupvm.name};\n\t\t}\n\n\t\tprivate GroupDocState GetGroupDocState(AttributeGroupViewModel groupvm)\n\t\t{\n\t\t\t// group is marked as attached to doc, and there are NO existing metadatas on the document\n\t\t\tGuid groupUid = Guid.Parse(groupvm.id);\n\t\t\tbool hasExistingMetadatas = _persistedDocMetadatas.Any(c => c.MetadataGroupUid == groupUid);\n\t\t\tif (groupvm.attached)\n\t\t\t{\n\t\t\t\treturn hasExistingMetadatas ? GroupDocState.GroupContinueBeingAttached : GroupDocState.GroupAttaching;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn hasExistingMetadatas ? GroupDocState.GroupDetaching : GroupDocState.GroupContinueBeingDetached;\n\t\t\t}\n\t\t}\n\n\t\tpublic enum GroupDocState\n\t\t{\n\t\t\tGroupAttaching,\n\t\t\tGroupDetaching,\n\t\t\tGroupContinueBeingAttached,\n\t\t\tGroupContinueBeingDetached\n\t\t}\n\n\t\tpublic class ChangedMetadatasResult\n\t\t{\n\t\t\tpublic Metadatas UpdatingMetadatas { get; set; }\n\t\t\tpublic Metadatas DeletingMetadatas { get; set; }\n\t\t\tpublic MetadataGroups DeletingGroups { get; set; }\n\t\t\tpublic List<string> ErrorMessages { get; set; }\n\t\t}\n\n\t\tprivate MetadataFieldResult UpdateMetadataField(AttributeFieldViewModel field, AttributeGroupItemViewModel item, AttributeGroupViewModel group, Metadata persistedMetadata)\n\t\t{\n\t\t\tstring outMessage;\n\t\t\tstring value = field.value;\n\t\t\tbool isValid = MetadataRepository.ValidateTypeAndFormat(ref value, persistedMetadata, SessionData.CurrentCulture, out outMessage);\n\n\t\t\tMetadataFieldResult rslt = new MetadataFieldResult { Proceed = true, ResultType = MetadataFieldResultType.Update};\n\n\t\t\t// is the metadata allowed to change?\n\t\t\tif (persistedMetadata.ReadOnly && !persistedMetadata.IsCalculatedDataType())\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\tif (persistedMetadata.System)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\t// did anything actually change? if metadata value and order are the same, do nothing\n\t\t\tif (value == persistedMetadata.Value)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\t// are metadata changes valid?\n\t\t\tif (rslt.Proceed && string.IsNullOrEmpty(value))\n\t\t\t{\n\t\t\t\t// this 'if' condition should be impossible, empty/null field values get marked for delete, therefore they should be going to a different code path, this is just in case\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\t\t\tif (rslt.Proceed && value.Length > Metadata.LENGTH_OBJECTMETADATAVALUES_VALUE)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t\trslt.ErrorMessage = string.Format(Resources.Admin.error_AttributeTooLong, persistedMetadata.Name, Metadata.LENGTH_OBJECTMETADATAVALUES_VALUE);\n\t\t\t}\n\t\t\tif (rslt.Proceed && !isValid)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t\trslt.ErrorMessage = outMessage;\n\t\t\t}\n\t\t\t\n\n\t\t\t// if everything is good, create the updated metadata object\n\t\t\tif (rslt.Proceed) {\n\t\t\t\trslt.ResultMetadata = new Metadata(persistedMetadata, persistedMetadata.MetadataSetNumber, value) { Uid = persistedMetadata.Uid };\n\t\t\t}\n\n\t\t\treturn rslt;\n\t\t}\n\t\tprivate MetadataFieldResult CreateMetadataField(AttributeFieldViewModel field, AttributeGroupItemViewModel item, AttributeGroupViewModel group, Metadata persistedMetadata)\n\t\t{\n\t\t\tpersistedMetadata.Uid = Guid.Empty;\n\t\t\tpersistedMetadata.Value = null;\n\t\t\treturn UpdateMetadataField(field, item, group, persistedMetadata);\n\t\t}\n\t\tprivate MetadataFieldResult DeleteMetadataField(AttributeFieldViewModel field, AttributeGroupItemViewModel item, AttributeGroupViewModel group, Metadata persistedMetadata)\n\t\t{\n\t\t\tMetadataFieldResult rslt = new MetadataFieldResult {Proceed = true, ResultType = MetadataFieldResultType.Delete};\n\t\t\tif (persistedMetadata.IsRequiredAttribute && !persistedMetadata.Repeating && !persistedMetadata.MetadataSetRepeating && !persistedMetadata.ReadOnly)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t\trslt.ErrorMessage = $\"Attribute {persistedMetadata.Name} is required\";\n\t\t\t}\n\t\t\tif (persistedMetadata.ReadOnly && !persistedMetadata.IsCalculatedDataType())\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\tif (rslt.Proceed && persistedMetadata.Uid == Guid.Empty)\n\t\t\t{\n\t\t\t\trslt.Proceed = false;\n\t\t\t}\n\n\t\t\t// everything is good, set the deletable metadata object\n\t\t\tif (rslt.Proceed)\n\t\t\t{\n\t\t\t\trslt.ResultMetadata = persistedMetadata;\n\t\t\t}\n\n\t\t\treturn rslt;\n\t\t}\n\n\t\tpublic class MetadataFieldResult\n\t\t{\n\t\t\tpublic bool Proceed { get; set; }\n\t\t\tpublic Metadata ResultMetadata { get; set; }\n\t\t\tpublic MetadataFieldResultType ResultType { get; set; }\n\t\t\tpublic string ErrorMessage { get; set; }\n\t\t}\n\n\t\tpublic enum MetadataFieldResultType\n\t\t{\n\t\t\tUpdate = 0,\n\t\t\tDelete = 1\n\t\t}\n\n\t\tprivate List<Metadata> GetPersistedMetadatasForRepeatableItem(AttributeGroupItemViewModel item)\n\t\t{\n\t\t\tList<Metadata> persistedMetadatas = new List<Metadata>();\n\t\t\tif (item.type == \"field\")\n\t\t\t{\n\t\t\t\tpersistedMetadatas = _persistedDocMetadatas.Where(c => c.Repeating && c.MetadataFieldUid == Guid.Parse(item.fieldid) && c.Uid != Guid.Empty).OrderBy(c => c.MetadataSetNumber).ToList();\n\t\t\t}\n\t\t\telse if (item.type == \"set\")\n\t\t\t{\n\t\t\t\tpersistedMetadatas = _persistedDocMetadatas.Where(c => c.MetadataSetRepeating && c.MetadataSetUid == Guid.Parse(item.setid) && c.Uid != Guid.Empty).ToList();\n\t\t\t}\n\n\t\t\treturn persistedMetadatas;\n\t\t}\n\n\t\tprivate bool IsItemMarkedForDelete(AttributeGroupItemViewModel item, AttributeGroupViewModel group)\n\t\t{\n\t\t\tif (!group.attached)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (item.isDeleting)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (item.fields.Count == item.fields.Count(f => string.IsNullOrEmpty(f.value) && f.dataType != (int)Enums.DataType.AutoNumber))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate bool IsFieldMarkedForDelete(AttributeFieldViewModel field, AttributeGroupItemViewModel item, AttributeGroupViewModel group)\n\t\t{\n\t\t\tif (!group.attached)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (item.isDeleting)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (string.IsNullOrEmpty(field.value) && field.dataType != (int)Enums.DataType.AutoNumber)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate void ValidateGroup(AttributeGroupViewModel groupvm)\n\t\t{\n\t\t\tMetadataFields groupFields = _metadataRepository.GetMetadataFieldsByMetadataGroupUid(SessionData.CurrentAccountId, Guid.Parse(groupvm.id));\n\t\t\tstring latestDefinitionHash = HashObject(Transform(groupFields));\n#pragma warning disable CA1309 // Use ordinal stringcomparison\n\t\t\tif (!string.Equals(groupvm.definitionHash, latestDefinitionHash))\n\t\t\t{\n\t\t\t\t_log.InfoNoPII(\"Attributes were modified by a different process\");\n\t\t\t\tthrow new AdexsDisplayException(Resources.Admin.AttributesConfigurationModifiedMessage);\n\t\t\t}\n#pragma warning restore CA1309 // Use ordinal stringcomparison\n\t\t}\n\n\t\tprivate bool IsSystemGroup(AttributeGroupViewModel groupvm)\n\t\t{\n\t\t\tif (groupvm.isSystem)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// can't trust the groupvm because it can be modified from the client side, have to check the db to know for sure\n\t\t\tMetadataGroup group = _metadataGroupRepository.LoadByUid(SessionData.CurrentAccountId, Guid.Parse(groupvm.id));\n\t\t\treturn group != null && group.System;\n\t\t}\n\n\t\tprivate string CreateMetadataGroupHash(Guid groupUid)\n\t\t{\n\t\t\tMetadataFields groupFields = _metadataRepository.GetMetadataFieldsByMetadataGroupUid(SessionData.CurrentAccountId, groupUid);\n\t\t\treturn HashObject(Transform(groupFields));\n\t\t}\n\n\t\tprivate static IEnumerable<object> Transform(MetadataFields groupFields)\n\t\t{\n\t\t\tforeach (MetadataField f in groupFields)\n\t\t\t{\n\t\t\t\tvar transformed = new { f.Uid, f.Name, f.Position, f.DataType, f.IsRequiredAttribute, f.ReadOnly, f.Repeating, f.CustomValidationErrMsg, f.CustomValidation, f.AllowedValues };\n\t\t\t\tyield return transformed;\n\t\t\t}\n\t\t}\n\n\t\tprivate bool ShouldShowDocumentDetails(UserAccount userAccount)\n\t\t{\n\t\t\tvar accountSettings = userAccount.Account.Settings;\n\t\t\treturn (accountSettings.EnableCounterpartyManagement || !accountSettings.ShowPartyFieldsOnDocInfoPanel)\n\t\t\t\t|| accountSettings.ShowKeywords\n\t\t\t\t|| accountSettings.ShowFileNameAndFolder;\n\t\t}\n\t\tprivate bool ShouldEnableCreateAttributeViewModel(UserAccount userAccount)\n\t\t{\n\t\t\treturn userAccount.Account.Settings.EnableCreateAttributeViewModelForDocExplorer;\n\t\t}\n\n\t\t#endregion\n\n\t\tpublic string HashObject<T>(T objectToHash)\n\t\t{\n\t\t\tif (objectToHash == null)\n\t\t\t{\n\t\t\t\treturn string.Empty;\n\t\t\t}\n\n\t\t\tstring serializedObject = JsonConvert.SerializeObject(objectToHash);\n\t\t\tbyte[] serializedObjectBytes = Encoding.UTF8.GetBytes(serializedObject);\n\t\t\tbyte[] serializedObjectHashBytes = Hash.SHA1Hash(serializedObjectBytes);\n\t\t\t// Use BitConverter to convert the raw hash bytes to a hex string. We use a hex string because it is a much easier string to work with (because it has a limited character set a-f0-9); \n\t\t\t// if we had decoded the raw hash bytes using UTF8 or something like that we could end up with bizarre or non printable characters, which are more difficult to work with.\n\t\t\tstring serializedObjectHashString = BitConverter.ToString(serializedObjectHashBytes).Replace(\"-\", \"\").ToLower();  \n\t\t\treturn serializedObjectHashString;\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Controls/FormExtensions.cs",
            "content": "\ufeff#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq.Expressions;\n\nusing ADEXS.Core.Domain.AtlasUrl;\nusing ADEXS.Core.Domain.Repository.MetadataRepository;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.ServiceLocator;\n\n#if NETFRAMEWORK\nusing System.Web;\nusing System.Web.Mvc;\nusing System.Web.Mvc.Html;\nusing System.Web.Routing;\nusing THtml = System.Web.IHtmlString;\nusing THtmlHelper = System.Web.Mvc.HtmlHelper;\nusing TTagBuilder = System.Web.Mvc.TagBuilder;\nusing TTagRenderMode = System.Web.Mvc.TagRenderMode;\n#else\nusing Microsoft.AspNetCore.Html;\nusing Microsoft.AspNetCore.Mvc.Rendering;\nusing Microsoft.AspNetCore.Mvc.ViewFeatures;\nusing Microsoft.AspNetCore.Routing;\n\nusing ADEXS.Web.CommonUI.AspNetCore.Extensions;\nusing THtml = Microsoft.AspNetCore.Html.IHtmlContent;\nusing THtmlHelper = Microsoft.AspNetCore.Mvc.Rendering.IHtmlHelper;\nusing TTagBuilder = Microsoft.AspNetCore.Mvc.Rendering.TagBuilder;\nusing TTagRenderMode = Microsoft.AspNetCore.Mvc.Rendering.TagRenderMode;\n#endif\n\nnamespace ADEXS.Web.Common.MVC.Controls\n{\n    /// <summary>\n    /// Provides a set of dual-targeted extension methods for rendering HTML controls in both ASP.NET MVC (NetFramework) and ASP.NET Core.\n    /// The class is structured to minimize code duplication by sharing logic in private helper methods.\n    /// </summary>\n    public static partial class FormExtensions\n    {\n       private const string AtlasLabelName = \"formLabel\";\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasLabel(this HtmlHelper html, string text, string customCssClass = null, bool isRequired = false, string tagName = \"div\") =>\n          new HtmlString(BuildAtlasLabelHtml(html.Encode(text), customCssClass, isRequired, tagName));\n#elif NET\n       public static IHtmlContent AtlasLabel(this IHtmlHelper html, string text, string customCssClass = null, bool isRequired = false, string tagName = \"div\") =>\n          new HtmlString(BuildAtlasLabelHtml(html.Encode(text), customCssClass, isRequired, tagName));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasTag(this HtmlHelper html, string text, string customCssClass = null, string tagName = \"div\") =>\n          new HtmlString(BuildAtlasTagHtml(html.Encode(text), customCssClass, tagName));\n#elif NET\n       public static IHtmlContent AtlasTag(this IHtmlHelper html, string text, string customCssClass = null, string tagName = \"div\") =>\n          new HtmlString(BuildAtlasTagHtml(html.Encode(text), customCssClass, tagName));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasPageHeader(this HtmlHelper html, string text, string customCssClass = null, string tagName = \"h2\") =>\n          html.AtlasTag(text, customCssClass, tagName);\n#elif NET\n       public static IHtmlContent AtlasPageHeader(this IHtmlHelper html, string text, string customCssClass = null, string tagName = \"h2\") =>\n          html.AtlasTag(text, customCssClass, tagName);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasLink(this HtmlHelper html, string text, UrlBuilder url, string id = null, bool openNewWindow = true) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureAtlasLinkTag(tag, text, url.ToString(), id, openNewWindow));\n#elif NET\n       public static IHtmlContent AtlasLink(this IHtmlHelper html, string text, UrlBuilder url, string id = null, bool openNewWindow = true) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureAtlasLinkTag(tag, text, url.ToString(), id, openNewWindow));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasLink(this HtmlHelper html, string text, Dictionary<string, string> attributes) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureAtlasLinkTag(tag, text, attributes));\n#elif NET\n       public static IHtmlContent AtlasLink(this IHtmlHelper html, string text, Dictionary<string, string> attributes) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureAtlasLinkTag(tag, text, attributes));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasImage(this HtmlHelper html, string spriteClassName, string additionalClassName = null) =>\n            BuildAndRenderTag(\"img\", tag => ConfigureAtlasImageTag(tag, spriteClassName, additionalClassName), TTagRenderMode.SelfClosing);\n#elif NET\n       public static IHtmlContent AtlasImage(this IHtmlHelper html, string spriteClassName, string additionalClassName = null) =>\n            BuildAndRenderTag(\"img\", tag => ConfigureAtlasImageTag(tag, spriteClassName, additionalClassName), TTagRenderMode.SelfClosing);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString SpriteActionLink(this HtmlHelper html, string spriteClassName, string actionName, object routeValues = null, object attributes = null) =>\n          SpriteActionLink(html, spriteClassName, actionName, null, routeValues, attributes);\n\n       public static IHtmlString SpriteActionLink(this HtmlHelper html, string spriteClassName, string actionName, string controllerName, object routeValues = null, object attributes = null)\n       {\n          var link = html.ActionLink(\"[replaceme]\", actionName, controllerName, routeValues, attributes);\n          var image = html.AtlasImage(spriteClassName);\n          return new HtmlString(link.ToHtmlString().Replace(\"[replaceme]\", image.ToHtmlString()));\n       }\n#elif NET\n       public static IHtmlContent SpriteActionLink(this IHtmlHelper html, string spriteClassName, string actionName, object routeValues = null, object attributes = null) =>\n          SpriteActionLink(html, spriteClassName, actionName, null, routeValues, attributes);\n\n       public static IHtmlContent SpriteActionLink(this IHtmlHelper html, string spriteClassName, string actionName, string controllerName, object routeValues = null, object attributes = null)\n       {\n          var link = html.ActionLink(\"[replaceme]\", actionName, controllerName, routeValues, attributes);\n          var image = html.AtlasImage(spriteClassName);\n          var linkString = link.ConvertToString().Replace(\"[replaceme]\", image.ConvertToString());\n          return new HtmlString(linkString);\n       }\n#endif\n\n#if NETFRAMEWORK\n       public static AtlasPanel AtlasPanel(this HtmlHelper html, string headerText = null, string id = null, string css = null, bool showExpandedCaretInHeader = false) =>\n          new AtlasPanel(html, headerText, id, css, showExpandedCaretInHeader);\n#elif NET\n       public static AtlasPanel AtlasPanel(this IHtmlHelper html, string headerText = null, string id = null, string css = null, bool showExpandedCaretInHeader = false) =>\n          new AtlasPanel(html, headerText, id, css, showExpandedCaretInHeader);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString SubmitButton(this HtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"input\", tag => ConfigureSubmitButtonTag(tag, text, htmlAttributes), TTagRenderMode.SelfClosing);\n#elif NET\n       public static IHtmlContent SubmitButton(this IHtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"input\", tag => ConfigureSubmitButtonTag(tag, text, htmlAttributes), TTagRenderMode.SelfClosing);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString CloseButton(this HtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureCloseButtonTag(tag, text, htmlAttributes));\n#elif NET\n       public static IHtmlContent CloseButton(this IHtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureCloseButtonTag(tag, text, htmlAttributes));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString CloseImageButton(this HtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureCloseImageButtonTag(tag, text, htmlAttributes));\n#elif NET\n       public static IHtmlContent CloseImageButton(this IHtmlHelper html, string text = null, object htmlAttributes = null) =>\n            BuildAndRenderTag(\"a\", tag => ConfigureCloseImageButtonTag(tag, text, htmlAttributes));\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString CheckboxWithLabel(this HtmlHelper html, string name, bool value, string displayName, object htmlAttributes = null, bool enabled = true)\n       {\n          string checkboxHtml = html.CheckBox(name, value, BuildAttributesDictionary(htmlAttributes, enabled)).ToHtmlString();\n          string labelHtml = BuildLabel(name, displayName).ToString();\n          return new MvcHtmlString(checkboxHtml + labelHtml);\n       }\n\n       public static IHtmlString CheckboxWithLabelFor<TModel>(this HtmlHelper<TModel> html, Expression<Func<TModel, bool>> expression, string name, string displayName, object htmlAttributes = null, bool enabled = true)\n       {\n          var attributes = BuildAttributesDictionary(htmlAttributes, enabled);\n          attributes.Add(\"name\", name);\n          string checkboxHtml = html.CheckBoxFor(expression, attributes).ToHtmlString();\n          string labelHtml = BuildLabel(name, displayName).ToString();\n          return new MvcHtmlString(checkboxHtml + labelHtml);\n       }\n#elif NET\n       public static IHtmlContent CheckboxWithLabel(this IHtmlHelper html, string name, bool value, string displayName, object htmlAttributes = null, bool enabled = true)\n       {\n          var checkbox = html.CheckBox(name, value, BuildAttributesDictionary(htmlAttributes, enabled));\n          var label = BuildLabel(name, displayName);\n          var builder = new HtmlContentBuilder();\n          return builder.AppendHtml(checkbox).AppendHtml(label);\n       }\n\n       public static IHtmlContent CheckboxWithLabelFor<TModel>(this IHtmlHelper<TModel> html, Expression<Func<TModel, bool>> expression, string name, string displayName, object htmlAttributes = null, bool enabled = true)\n       {\n          var attributes = BuildAttributesDictionary(htmlAttributes, enabled);\n          attributes.Add(\"name\", name);\n          var checkbox = html.CheckBoxFor(expression, attributes);\n          var label = BuildLabel(name, displayName);\n          var builder = new HtmlContentBuilder();\n          return builder.AppendHtml(checkbox).AppendHtml(label);\n       }\n#endif\n\n#if NETFRAMEWORK\n        public static IHtmlString AtlasDate(this HtmlHelper html, string name, object value = null, object htmlAttributes = null)\n        {\n            var textBox = html.TextBox(name, value, htmlAttributes);\n            var image = html.AtlasImage(\"sprite-calendar\");\n            return new HtmlString(BuildAtlasDateHtml(textBox.ToHtmlString(), image.ToHtmlString()));\n        }\n#elif NET\n        public static IHtmlContent AtlasDate(this IHtmlHelper html, string name, object value = null, object htmlAttributes = null)\n        {\n            var textBox = html.TextBox(name, value, htmlAttributes);\n            var image = html.AtlasImage(\"sprite-calendar\");\n            return new HtmlString(BuildAtlasDateHtml(textBox.ConvertToString(), image.ConvertToString()));\n        }\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasMetadataField(this HtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value = null, CultureInfo culture = null) =>\n            BuildAtlasMetadataField(html, name, fieldType, allowedValues, value, culture);\n#elif NET\n       public static IHtmlContent AtlasMetadataField(this IHtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value = null, CultureInfo culture = null) =>\n            BuildAtlasMetadataField(html, name, fieldType, allowedValues, value, culture);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasDropDownListFor<TModel,TValue>(this HtmlHelper<TModel> html,Expression<Func<TModel, TValue>> expression, string label, IEnumerable<SelectListItem> selectList ) =>\n          AtlasFieldFor(html, label, expression, () => html.DropDownListFor(expression, selectList));\n\n       public static IHtmlString AtlasTextBoxFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          AtlasFieldFor(html, label, expression, () => html.TextBoxFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n#elif NET\n       public static IHtmlContent AtlasDropDownListFor<TModel,TValue>(this IHtmlHelper<TModel> html,Expression<Func<TModel, TValue>> expression, string label, IEnumerable<SelectListItem> selectList ) =>\n          AtlasFieldFor(html, label, expression, () => html.DropDownListFor(expression, selectList));\n\n       public static IHtmlContent AtlasTextBoxFor<TModel, TValue>(this IHtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          AtlasFieldFor(html, label, expression, () => html.TextBoxFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasDateWithLabel(this HtmlHelper html, string name, string labelText, object value = null, object htmlAttributes = null) =>\n          AtlasDateWithLabelHelper(html, html.TextBox(name, value, htmlAttributes), labelText);\n\n       public static IHtmlString AtlasDateWithLabelFor<TModel>(this HtmlHelper<TModel> html, Expression<Func<TModel, DateTimeOffset>> expression, string name, string labelText, string dateFormat, object htmlAttributes = null)\n       {\n          IDictionary<string, object> attributesDictionary = BuildAttributesDictionary(htmlAttributes);\n          attributesDictionary.Add(\"name\", name);\n          MvcHtmlString textBox = html.TextBoxFor(expression, string.Format(\"{{0:{0}}}\", dateFormat), attributesDictionary);\n          return AtlasDateWithLabelHelper(html, textBox, labelText);\n       }\n#elif NET\n       public static IHtmlContent AtlasDateWithLabel(this IHtmlHelper html, string name, string labelText, object value = null, object htmlAttributes = null) =>\n          AtlasDateWithLabelHelper(html, html.TextBox(name, value, htmlAttributes), labelText);\n\n       public static IHtmlContent AtlasDateWithLabelFor<TModel>(this IHtmlHelper<TModel> html, Expression<Func<TModel, DateTimeOffset>> expression, string name, string labelText, string dateFormat, object htmlAttributes = null)\n       {\n          IDictionary<string, object> attributesDictionary = BuildAttributesDictionary(htmlAttributes);\n          attributesDictionary.Add(\"name\", name);\n          var textBox = html.TextBoxFor(expression, string.Format(\"{{0:{0}}}\", dateFormat), attributesDictionary);\n          return AtlasDateWithLabelHelper(html, textBox, labelText);\n       }\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString FaUxTextBoxFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          FaUxFieldFor(html, label, expression, () => html.TextBoxFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n\n       public static IHtmlString AtlasPasswordFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          AtlasFieldFor(html, label, expression, () => html.PasswordFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n\n       public static IHtmlString FaUxPasswordFor<TModel, TValue>(this HtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          FaUxFieldFor(html, label, expression, () => html.PasswordFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n#elif NET\n       public static IHtmlContent FaUxTextBoxFor<TModel, TValue>(this IHtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          FaUxFieldFor(html, label, expression, () => html.TextBoxFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n\n       public static IHtmlContent AtlasPasswordFor<TModel, TValue>(this IHtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          AtlasFieldFor(html, label, expression, () => html.PasswordFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n\n       public static IHtmlContent FaUxPasswordFor<TModel, TValue>(this IHtmlHelper<TModel> html, Expression<Func<TModel, TValue>> expression, string label, object divHtmlAttributes = null, object textboxHtmlAttributes = null) =>\n          FaUxFieldFor(html, label, expression, () => html.PasswordFor(expression, textboxHtmlAttributes), divHtmlAttributes);\n#endif\n\n#if NETFRAMEWORK\n       public static IHtmlString AtlasFieldFor<TModel,TValue>(this HtmlHelper<TModel> html, string label, Expression<Func<TModel,TValue>> expression, Func<IHtmlString> controlBuilder, object htmlAttributes = null)\n       {\n           var labelHtml = html.LabelFor(expression, label, new {@class=\"formLabel\"});\n           var controlHtml = controlBuilder();\n           return BuildAndRenderTag(\"div\", div => ConfigureAtlasFieldFor(div, expression, htmlAttributes, labelHtml, controlHtml));\n       }\n\n       public static IHtmlString FaUxFieldFor<TModel, TValue>(this HtmlHelper<TModel> html, string label, Expression<Func<TModel, TValue>> expression, Func<IHtmlString> controlBuilder, object htmlAttributes = null)\n       {\n           var labelHtml = html.LabelFor(expression, label, new { @class = \"input__label\" });\n           var controlHtml = controlBuilder();\n           return BuildAndRenderTag(\"div\", div => ConfigureFaUxFieldFor(div, expression, htmlAttributes, labelHtml, controlHtml));\n       }\n\n       public static MvcForm AtlasBeginForm(this HtmlHelper htmlHelper, string actionName, string controllerName, FormMethod method, object htmlAttributes, RouteValueDictionary routeValues = null)\n       {\n          var form = htmlHelper.BeginForm(actionName, controllerName, routeValues ?? new RouteValueDictionary(), method, HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes));\n          htmlHelper.ViewContext.Writer.Write(htmlHelper.AntiForgeryToken().ToHtmlString());\n          return form;\n       }\n#elif NET\n       public static IHtmlContent AtlasFieldFor<TModel,TValue>(this IHtmlHelper<TModel> html, string label, Expression<Func<TModel,TValue>> expression, Func<IHtmlContent> controlBuilder, object htmlAttributes = null)\n       {\n           var labelHtml = html.LabelFor(expression, label, new {@class=\"formLabel\"});\n           var controlHtml = controlBuilder();\n           return BuildAndRenderTag(\"div\", div => ConfigureAtlasFieldFor(div, expression, htmlAttributes, labelHtml, controlHtml));\n       }\n\n       public static IHtmlContent FaUxFieldFor<TModel, TValue>(this IHtmlHelper<TModel> html, string label, Expression<Func<TModel, TValue>> expression, Func<IHtmlContent> controlBuilder, object htmlAttributes = null)\n       {\n           var labelHtml = html.LabelFor(expression, label, new { @class = \"input__label\" });\n           var controlHtml = controlBuilder();\n           return BuildAndRenderTag(\"div\", div => ConfigureFaUxFieldFor(div, expression, htmlAttributes, labelHtml, controlHtml));\n       }\n\n       public static MvcForm AtlasBeginForm(this IHtmlHelper htmlHelper, string actionName, string controllerName, FormMethod method, object htmlAttributes, RouteValueDictionary routeValues = null)\n       {\n          var form = htmlHelper.BeginForm(\n             actionName,\n             controllerName,\n             routeValues ?? new RouteValueDictionary(),\n             method,\n             antiforgery: null,\n             htmlAttributes: htmlAttributes);\n          htmlHelper.ViewContext.Writer.Write(htmlHelper.AntiForgeryToken().ConvertToString());\n          return form;\n       }\n#endif\n\n       /// <summary>\n       /// Builds the raw HTML for an AtlasLabel. This logic is shared between both frameworks.\n       /// </summary>\n       private static string BuildAtlasLabelHtml(string encodedText, string customCssClass, bool isRequired, string tagName)\n       {\n           using var writer = new StringWriter();\n           writer.Write(\"<{0} class=\\\"{1}\\\">\", tagName, AtlasLabelName + (string.IsNullOrWhiteSpace(customCssClass) ? \"\" : \" \" + customCssClass));\n           if (isRequired)\n           {\n               writer.Write(\"<span class=\\\"requiredMark\\\">*</span>\");\n           }\n           writer.Write(encodedText);\n           writer.WriteLine(\"</{0}>\", tagName);\n           return writer.ToString();\n       }\n\n       /// <summary>\n       /// Builds the raw HTML for an AtlasTag. This logic is shared between both frameworks.\n       /// </summary>\n       private static string BuildAtlasTagHtml(string encodedText, string customCssClass, string tagName)\n       {\n           using var writer = new StringWriter();\n           writer.Write(\"<{0} class=\\\"{1}\\\">\", tagName, (string.IsNullOrWhiteSpace(customCssClass) ? \"\" : \" \" + customCssClass));\n           writer.Write(encodedText);\n           writer.WriteLine(\"</{0}>\", tagName);\n           return writer.ToString();\n       }\n\n       private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, string href, string id, bool openNewWindow)\n       {\n           tag.MergeAttribute(\"href\", href);\n           if (openNewWindow)\n           {\n               tag.MergeAttribute(\"target\", \"_blank\");\n           }\n           if (id != null)\n           {\n               tag.MergeAttribute(\"id\", id);\n           }\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasLinkTag(TTagBuilder tag, string text, Dictionary<string, string> attributes)\n       {\n           tag.MergeAttributes(attributes);\n           SetTagContent(tag, text);\n       }\n\n       private static void ConfigureAtlasImageTag(TTagBuilder tag, string spriteClassName, string additionalClassName)\n       {\n           tag.MergeAttribute(\"class\", $\"{additionalClassName ?? string.Empty} sprite {spriteClassName}\".Trim());\n           tag.MergeAttribute(\"src\", ServiceLocator.GetInstance<IUrlProvider>().BlankImage());\n       }\n\n       private static void ConfigureSubmitButtonTag(TTagBuilder tag, string text, object htmlAttributes)\n       {\n           tag.MergeAttributes(HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes), replaceExisting: true);\n           tag.MergeAttribute(\"value\", string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Save : text);\n           if (!tag.Attributes.ContainsKey(\"class\"))\n           {\n               tag.AddCssClass(\"SendButton\");\n           }\n           if (!tag.Attributes.ContainsKey(\"type\"))\n           {\n               tag.MergeAttribute(\"type\", \"submit\");\n           }\n       }\n\n       private static void ConfigureCloseButtonTag(TTagBuilder tag, string text, object htmlAttributes)\n       {\n           tag.ApplyHtmlAttributes(htmlAttributes);\n           tag.AddCssClass(\"LinkButton\");\n           SetTagContent(tag, string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Close : text);\n           if (!tag.Attributes.ContainsKey(\"onclick\"))\n           {\n               tag.Attributes.Add(\"onclick\", \"CloseWindoid();return false;\");\n           }\n       }\n\n       private static void ConfigureCloseImageButtonTag(TTagBuilder tag, string text, object htmlAttributes)\n       {\n           tag.Attributes.Add(\"onclick\", \"CloseWindoid();return false;\");\n           tag.AddCssClass(\"cursor-pointer\");\n\n           var imageHtml = BuildAndRenderTag(\"img\", imageTag =>\n           {\n               imageTag.ApplyHtmlAttributes(htmlAttributes);\n               if (!imageTag.Attributes.ContainsKey(\"src\"))\n               {\n                   imageTag.Attributes.Add(\"src\", ServiceLocator.GetInstance<IUrlProvider>().Image(\"blank.gif\"));\n               }\n               var title = string.IsNullOrWhiteSpace(text) ? WebCommonUI.Resources.Common.Close : text;\n               if (!imageTag.Attributes.ContainsKey(\"title\"))\n               {\n                   imageTag.Attributes.Add(\"title\", title);\n               }\n               if (!imageTag.Attributes.ContainsKey(\"alt\"))\n               {\n                   imageTag.Attributes.Add(\"alt\", title);\n               }\n           }, TTagRenderMode.SelfClosing);\n\n           SetTagContent(tag, imageHtml);\n       }\n\n       private static THtml BuildAtlasMetadataField(THtmlHelper html, string name, Enums.DataType fieldType, List<string> allowedValues, string value, CultureInfo culture)\n       {\n           if (value != null)\n               value = MetadataRepository.FormatMetaValue(value, fieldType, culture ?? CultureInfo.CurrentCulture);\n\n           switch (fieldType)\n           {\n               case Enums.DataType.String:\n               case Enums.DataType.Number:\n               case Enums.DataType.Decimal:\n               case Enums.DataType.Cascade:\n                   return html.TextBox(name, value, new { @class = \"extrawide\" });\n               case Enums.DataType.AutoNumber:\n                   return html.Hidden(name, WebCommonUI.Resources.Common.CalculatedValueDesignation);\n               case Enums.DataType.DropDown:\n               case Enums.DataType.MagicDropDown:\n                   return html.DropDownList(name, new SelectList(allowedValues, value), new { @class = \"extrawide\" });\n               case Enums.DataType.Date:\n                   return html.AtlasDate(name, value);\n               default:\n#if NETFRAMEWORK\n                   return new HtmlString(\"\");\n#else\n                   return HtmlString.Empty;\n#endif\n           }\n       }\n\n       private static string BuildAtlasDateHtml(string textBoxHtml, string imageHtml)\n       {\n           return $\"<div class=\\\"atlasDateControl\\\">{textBoxHtml}{imageHtml}</div>\";\n       }\n\n       private static THtml AtlasDateWithLabelHelper(THtmlHelper html, THtml control, string labelText)\n       {\n           var tag = new TTagBuilder(\"div\");\n           tag.AddCssClass(\"atlasDateControl\");\n           var label = html.Label(labelText);\n           var image = html.AtlasImage(\"sprite-calendar\");\n\n#if NETFRAMEWORK\n           var writer = new StringWriter();\n           writer.Write(label.ToHtmlString());\n           writer.Write(control.ToHtmlString());\n           writer.Write(image.ToHtmlString());\n           tag.InnerHtml = writer.ToString();\n           return new HtmlString(tag.ToString());\n#else\n           tag.InnerHtml.AppendHtml(label);\n           tag.InnerHtml.AppendHtml(control);\n           tag.InnerHtml.AppendHtml(image);\n           return tag;\n#endif\n       }\n\n       private static void ConfigureAtlasFieldFor<TModel, TValue>(TTagBuilder div, Expression<Func<TModel, TValue>> expression, object htmlAttributes, THtml labelHtml, THtml controlHtml)\n       {\n           var member = (MemberExpression)expression.Body;\n           div.ApplyHtmlAttributes(htmlAttributes);\n           div.AddCssClass(\"atlasfield\");\n           div.Attributes.Add(\"id\", $\"{member.Member.Name}Field\");\n           SetTagContent(div, labelHtml, controlHtml);\n       }\n\n       private static void ConfigureFaUxFieldFor<TModel, TValue>(TTagBuilder div, Expression<Func<TModel, TValue>> expression, object htmlAttributes, THtml labelHtml, THtml controlHtml)\n       {\n           var member = (MemberExpression)expression.Body;\n           div.ApplyHtmlAttributes(htmlAttributes);\n           div.AddCssClass(\"input\");\n           div.Attributes.Add(\"id\", $\"{member.Member.Name}Field\");\n\n           var icon = BuildAndRenderTag(\"springcm-icon\", t => {\n               t.AddCssClass(\"input__message-icon\");\n               t.Attributes.Add(\"icon\", \"warning\");\n           });\n\n           var spanLine = BuildAndRenderTag(\"span\", t => {\n               t.AddCssClass(\"input__line--focus\");\n               t.AddCssClass(\"theme_primary-dark_background-color\");\n           });\n\n           SetTagContent(div, icon, controlHtml, labelHtml, spanLine);\n       }\n\n       private static TTagBuilder BuildLabel(string name, string displayName)\n       {\n           var tag = new TTagBuilder(\"label\");\n           tag.Attributes[\"for\"] = name;\n           tag.AddCssClass(AtlasLabelName);\n           SetTagContent(tag, displayName);\n           return tag;\n       }\n\n       private static IDictionary<string, object> BuildAttributesDictionary(object htmlAttributes, bool enabled = true)\n       {\n           IDictionary<string, object> attributesDictionary = new RouteValueDictionary(htmlAttributes);\n\n           if (attributesDictionary.TryGetValue(\"data_bind\", out var dataBindValue))\n           {\n               attributesDictionary[\"data-bind\"] = dataBindValue;\n               attributesDictionary.Remove(\"data_bind\");\n           }\n\n           if (!enabled && !attributesDictionary.ContainsKey(\"disabled\"))\n           {\n               attributesDictionary.Add(\"disabled\", \"disabled\");\n           }\n           return attributesDictionary;\n       }\n\n       internal static void ApplyHtmlAttributes(this TTagBuilder tag, object htmlAttributes)\n       {\n           if (htmlAttributes == null) return;\n           var attributes = HtmlHelper.AnonymousObjectToHtmlAttributes(htmlAttributes);\n           tag.MergeAttributes(attributes, replaceExisting: false);\n       }\n\n       /// <summary>\n       /// Centralized helper to build a TagBuilder, configure it via a lambda, and render it to the correct framework-specific HTML type.\n       /// </summary>\n       private static THtml BuildAndRenderTag(string tagName, Action<TTagBuilder> configureAction, TTagRenderMode renderMode = TTagRenderMode.Normal)\n       {\n           var tag = new TTagBuilder(tagName);\n           configureAction(tag);\n\n#if NETFRAMEWORK\n           return new HtmlString(tag.ToString(renderMode));\n#else\n           tag.TagRenderMode = renderMode;\n           return tag;\n#endif\n       }\n\n       /// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, string content)\n       {\n#if NETFRAMEWORK\n           tag.SetInnerText(content);\n#else\n           tag.InnerHtml.Append(content);\n#endif\n       }\n\n       /// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, THtml htmlContent)\n       {\n#if NETFRAMEWORK\n           tag.InnerHtml = htmlContent.ToHtmlString();\n#else\n           tag.InnerHtml.AppendHtml(htmlContent);\n#endif\n       }\n\n       /// <summary>\n       /// Abstraction for setting tag content to handle framework differences.\n       /// </summary>\n       private static void SetTagContent(TTagBuilder tag, params THtml[] htmlContents)\n       {\n#if NETFRAMEWORK\n           using (var writer = new StringWriter())\n           {\n               foreach (var content in htmlContents)\n               {\n                   writer.Write(content.ToHtmlString());\n               }\n               tag.InnerHtml = writer.ToString();\n           }\n#else\n           foreach (var content in htmlContents)\n           {\n               tag.InnerHtml.AppendHtml(content);\n           }\n#endif\n       }\n    }\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowScopeEvents/WorkflowScopeEventsController.Trace.cs",
            "content": "\ufeff#nullable enable\n\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.WorkflowScopeEvents;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\n// ReSharper disable CheckNamespace\n// This partial class needs to be in the same namespace as the controller.\n\nnamespace DocuSign.CLM.API.WorkflowActivities.Controllers;\n\n/// <summary>\n/// Instrumentation for <see cref=\"WorkflowScopeEventsController\"/>.\n/// </summary>\npublic partial class WorkflowScopeEventsController\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity(\n\t\tint accountId,\n\t\tGuid userAccountUid,\n\t\tGuid instanceUid = default,\n\t\tGuid activityUid = default,\n\t\tGuid revisionUid = default,\n\t\t[CallerMemberName] string name = \"\")\n\t{\n\t\treturn _serviceInstrumentation.ActivitySource\n\t\t\t.StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowScopeEventsTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowActivities/WorkflowActivitiesController.Trace.cs",
            "content": "\ufeff#nullable enable\n\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.WorkflowActivities;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\n// ReSharper disable CheckNamespace\n// This partial class needs to be in the same namespace as the controller.\n\nnamespace DocuSign.CLM.API.WorkflowActivities.Controllers;\n\n/// <summary>\n/// Instrumentation for <see cref=\"WorkflowActivitiesController\"/>.\n/// </summary>\npublic partial class WorkflowActivitiesController\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity(\n\t\tint accountId,\n\t\tGuid userAccountUid,\n\t\tGuid instanceUid = default,\n\t\tGuid activityUid = default,\n\t\tGuid revisionUid = default,\n\t\t[CallerMemberName] string name = \"\")\n\t{\n\t\treturn _serviceInstrumentation.ActivitySource\n\t\t\t.StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignInstanceUid, instanceUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignActivityUid, activityUid)\n\t\t\t?.SetTag(WorkflowActivitiesTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowDefinition/WorkflowDefinitionController.Trace.cs",
            "content": "\ufeff#nullable enable\n\nusing System;\nusing System.Diagnostics;\nusing System.Runtime.CompilerServices;\n\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.WorkflowDefinition;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics.Extensions;\n\n// ReSharper disable CheckNamespace\n// This partial class needs to be in the same namespace as the controller.\n\nnamespace DocuSign.CLM.API.WorkflowActivities.Controllers;\n\n/// <summary>\n/// Instrumentation for <see cref=\"WorkflowDefinitionController\"/>.\n/// </summary>\npublic partial class WorkflowDefinitionController\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tprivate Activity? StartActivity(\n\t\tint accountId,\n\t\tGuid userAccountUid,\n\t\tGuid revisionUid = default,\n\t\t[CallerMemberName] string name = \"\")\n\t{\n\t\treturn _serviceInstrumentation.ActivitySource\n\t\t\t.StartActivity($\"{GetType().Name}.{name}\")\n\t\t\t.SetMetricName(InstrumentationNames.ActivitySourceName)\n\t\t\t?.SetStatus(ActivityStatusCode.Error)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeCodeFunction, $\"{GetType().Name}.{name}\")\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, accountId)\n\t\t\t?.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userAccountUid)\n\t\t\t?.SetTag(WorkflowDefinitionTraceSemanticConventions.AttributeDocuSignRevisionUid, revisionUid);\n\t}\n}\n#nullable restore\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs",
            "content": "\ufeffusing System.Diagnostics;\nusing System.Linq;\n\n\n#if NETFRAMEWORK\nusing System.Web;\n#else\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Http.Features;\n#endif\n\nusing DocuSign.Monitoring;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.Core.Domain.Utilities;\npublic static class ActivityEnricher\n{\n\tpublic static void SetTagsWithCommonFields(this Activity activity, HttpContext context)\n\t{\n\t\tif (activity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tSetAccountIdTag(activity);\n\t\tSetUserIdTag(activity);\n\t\tSetSessionIdTag(activity, context);\n\t}\n\n\tprivate static void SetAccountIdTag(Activity activity)\n\t{\n\t\tif (AtlasContext.Current != null && AtlasContext.Current.AccountId != 0 && AtlasContext.Current.AccountId != int.MinValue)\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, AtlasContext.Current.AccountId);\n\t\t\treturn;\n\t\t}\n\n\t\tvar dataPointCollection = ServiceContext.Current?.DataPointCollection?.GetDataPointValues(DataPoint.AccountId);\n\t\tif (dataPointCollection != null)\n\t\t{\n\t\t\tvar account = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(account))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, account);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void SetUserIdTag(Activity activity)\n\t{\n\t\tif (AtlasContext.Current != null && !System.Guid.Empty.Equals(AtlasContext.Current.UserAccountUid))\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, AtlasContext.Current.UserAccountUid);\n\t\t\treturn;\n\t\t}\n\n\t\tvar dataPointCollection = ServiceContext.Current?.DataPointCollection?.GetDataPointValues(DataPoint.UserId);\n\t\tif (dataPointCollection != null)\n\t\t{\n\t\t\tvar userId = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(userId))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userId);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\n#if NETFRAMEWORK\n\tprivate static void SetSessionIdTag(Activity activity, HttpContext context)\n\t{\n\t\tif (!string.IsNullOrEmpty(context?.Session?.SessionID))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, context?.Session?.SessionID);\n\t\t}\n\t}\n#else\n\tprivate static void SetSessionIdTag(Activity activity, HttpContext context)\n\t{\n\t\tvar session = context == null ? null : GetSession(context);\n\t\tif (!string.IsNullOrEmpty(session?.Id))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, session?.Id);\n\t\t}\n\t}\n\n\tprivate static ISession GetSession(HttpContext context)\n\t{\n\t\tvar sessionFeature = context?.Features?.Get<ISessionFeature>();\n\t\treturn sessionFeature == null ? null : context.Session;\n\t}\n#endif\n\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Constants.cs",
            "content": "\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Text.RegularExpressions;\n\nusing ADEXS.Core.Util.Core;\n\n// This is added for svn testing purposes.\n\nnamespace ADEXS.Core.Types\n{\n\t/// <summary>\n\t/// Constants not tied to any specific object.\n\t/// </summary>\n\tpublic partial class Constants\n\t{\n\t\t// Use this when dealing with documents or folders to bypass security checks, if possible.\n\t\tpublic const int AllAccounts = Int32.MinValue;\n\t\tpublic static readonly Guid SystemUser = new Guid(\"00000001-0001-0001-0001-000000000001\");\n\t\tpublic static readonly Guid WorkflowUser = new Guid(\"00000002-0002-0002-0002-000000000002\");\n\t\tpublic static readonly string WorkflowName = \"Workflow\";\n\t\tpublic static readonly Guid PublicUser = new Guid(\"00000D0E-0D0E-0D0E-0D0E-000000000D0E\");\n\t\tpublic static readonly Guid InvalidUser = new Guid(\"00000BAD-0BAD-0BAD-0BAD-000000000BAD\");\n\t\tpublic static readonly Guid UnitTestUser = new Guid(\"00000555-0555-0555-0555-000000000555\");\n\t\tpublic static readonly double RegexDefaultTimeoutMilliseconds = 500;\n\t\tpublic const Enums.UserRole ProvisioningAdminRole = Enums.UserRole.Primary;\n\n\t\t//Document Upload cloud storage settings\n\t\tpublic const int DefaultSharedStorageTTL = 604800; //7days\n\n\t\tpublic static readonly Regex InvalidDocumentNameRegex = new Regex(\"[\\\\x00-\\\\x1F\\\"*/:<>?\\\\\\\\|]\", RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds)); // proper regex without the C# escapes: [x00-x1F\"*/:<>?\\\\|]   \\\\ is needed regex escape for the \\\n\t\tpublic static readonly Regex InvalidMetadataNameRegex = new Regex(\"#[\\\\.\\\\|]#\", RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds)); // \"#.#\" and \"#|#\" are used as delimiters in the Data Review Workflow step. Regex without the C# escapes: #[\\.\\|]#\n\t\tpublic static readonly Regex ScriptInjectorRegex = new Regex(\"[<>]\", RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidFirstLastNameRegex = new Regex(FirstLastNameRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidAddressRegex = new Regex(AddressRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidCityRegex = new Regex(CityRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidEmailRegex = new Regex(EmailRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t// Email validator used by One Notification. https://github.docusignhq.com/Core/Core/blob/1c8f3b366e58135312fbfc84bde2612f3a19ad2c/NotificationPlatform/API.Notifications/src/API.Notifications.Email/EmailUtils.cs#L39\n\t\tpublic static readonly Regex ValidEmailRegexOneNotification = new Regex(@\"^(?(\"\")(\"\".+?(?<!\\\\)\"\"@)|(([0-9a-zA-Z]((\\.(?!\\.))|[-!#\\$%&'\\*\\+/=\\?\\^`\\{\\}\\|~\\w])*)(?<=[0-9a-zA-Z_])@))(?(\\[)(\\[(\\d{1,3}\\.){3}\\d{1,3}\\])|(([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]*\\.)+[a-z0-9A-Z][\\-a-z0-9A-Z]{0,22}[a-zA-Z0-9]))$\", RegexOptions.Compiled, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t// TODO: replace ValidEmailRegex with ValidEmailRegexOneNotification\n\t\tpublic static readonly Regex EmailInTextRegex = new Regex(EmailRegexPatternInText, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidFaxNumberRegex = new Regex(FaxNumberRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex AlphaNumericWhitespaceHyphens = new Regex(AlphaNumericWhitespaceHyphensRegex, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex LoginNameRegex = new Regex(LoginNameRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex FilePathRegex = new Regex(FilePathRegexPattern, RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(Constants.RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex ValidHtmlRegex = new Regex(HtmlRegexPattern, RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(Constants.RegexDefaultTimeoutMilliseconds));\n\t\tpublic static readonly Regex LineBreaksRegex = new Regex(LineBreaksRegexPattern, RegexOptions.None, TimeSpan.FromMilliseconds(Constants.RegexDefaultTimeoutMilliseconds));\n\n\t\tpublic static readonly DateTime EpochStartDateTime = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);\n\t\tpublic const string AlphaNumericWhitespaceHyphensRegex = @\"[^\\w\\-\\s]\";\n\t\tpublic const string InvalidDocumentNameChars = \"\\\" * / : < > ? \\\\ |\"; // for use in messages to the user. should match above\n\t\tpublic const string ScriptInjectorCharacters = \"< >\";\n\t\tpublic const int MaxFolderLength = 100;\n\t\tpublic const int MaxFolderPathLength = (4000 - 1);          // we use nvarchar(4000) in many path related sprocs and udf, until then keep this less than 4000\n\t\tpublic const int MaxFolderPathLevels = (100 - 1);           // we will have CTE issues when the depth reaches 100\n\n\t\tpublic const int FirstLastNameMaxLength = 128; // match database setting\n\t\t\t\t\t\t\t\t\t\t\t\t\t   //Any character up to 128 length, except <>\"\n\t\tpublic const string FirstLastNameRegexPattern = @\"^[^<>\"\"]{1,128}$\";\n\t\tpublic const string CityRegexPattern = @\"^[\\w\\'\\ \\.#&]{2,50}$\";\n\t\tpublic const string AddressRegexPattern = @\"[a-zA-Z0-9 .,#\\-&'/]+\";\n\t\t// This will match one or more of whatever EXCEPT <, >, space, or @, followed by a single @, followed by whatever and a . followed by whatever.\n\t\t// We are being very generous in our email validation intentionally.\n\t\t// We exclude < and > because the smtp server throws an error on them,\n\t\t// and require only a single @ in the whole string, and at least one . in the domain otherwise type whatever you want.\n\t\t// As long as it is ASCII only. SMTP is not there yet with non ASCII support.\n\t\t// The regex is emitted in JavaScript so it needs to work there as well.\n\t\tpublic const string EmailRegexPattern = @\"^[!-;=?A-~]+@[!-;=?A-~]+\\.[A-Za-z0-9]{2,}$\";\n\t\t// same as above but doesn't require the email to be the only thing in the text.\n\t\tpublic const string EmailRegexPatternInText = @\"[!-;=?A-~]+@[!-;=?A-~]+\\.[!-;=?A-~]+\";\n\n\t\tpublic const string EmailLocalPartRegexPattern = @\"^[0-9a-zA-Z!#$%&'*+\\-/=?\\^_`{|}~.]+$\";\n\t\t// same character set as an email without forcing the email patern.\n\t\tpublic const string LoginNameRegexPattern = @\"^[a-zA-Z0-9][!-;=?@-~]{1,99}$\";\n\n\t\tpublic const string EmailValidationRegex = @\"\\b[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}\\b\";\n\n\t\tpublic const string FaxNumberRegexPattern =\n\t\t\t@\"^(?:(?:[\\+]?([\\d]{1,3}(?:[ ]+|[\\-.])))?[(]?([\\d]{3})[\\-/)]?(?:[ ]+)?)?([2-9][0-9 \\-.]{6,})$\";\n\n\t\tpublic const string HexColorRegexPattern = \"^([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$|^([a-fA-F0-9]{1})([a-fA-F0-9]{1})([a-fA-F0-9]{1})$\";\n\n\t\tpublic const string SpecialDateTimeFormatCharactersRegexPattern = @\"\\s?'?[\u0433|\u00fd]\\.'?\";   // ie. see Bulgarian and Turkmen short date patterns\n\n\t\tpublic const string UrlSanitizerRegexPatern = @\"[^A-Za-z0-9 \\-_.]\"; // remove all special characters except space, minus, underscore and period.\n\n\t\tpublic const string PositiveIntegerRegexPattern = @\"^\\d+$\";\n\n\t\tpublic const string MisplacedTagsPattern = \"</head>(.*?)<body>\";\n\n\t\tpublic const string ScriptPattern = \"<script>(.*?)</script>\";\n\n\t\tpublic const string StylePattern = \"<style>(.*?)</style>\";\n\n\t\tpublic const string HtmlPattern = \"<html>(.*?)</html>\";\n\n\t\tpublic const string FilePathRegexPattern = \".*?([a-z]:\\\\\\\\(?:[-\\\\w\\\\.\\\\d]+\\\\\\\\)*(?:[-\\\\w\\\\.\\\\d]+)?)\";\n\n\t\tpublic const string InvalidXmlDataForMergeRegexPattern = @\"&#x([0-8BCEFbcef]|1[0-9A-Fa-f]);|[\\x01-\\x08\\x0B\\x0C\\x0E\\x0F\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]\";\n\n\t\tpublic const string HtmlRegexPattern = @\"<\\/?[a-z][\\s\\S]*>\";\n\n\t\tpublic const string LineBreaksRegexPattern = @\"(\\r\\n|\\r|\\n)+\";\n\n\t\tpublic const int KB = 1024;\n\t\tpublic const int MB = KB * KB;\n\t\tpublic const int GB = KB * KB * KB;\n\n\t\t/// <summary>\n\t\t/// This is ASCII #30, dubbed \"record separator\", it is a character that is not visible when printed out.\n\t\t/// </summary>\n\t\tpublic const char AsciiRecordSeparator = (char)30;\n\n\t\tpublic const decimal SpringMaxDecimalValue = 9999999999999999.99M;\n\n\t\tpublic const string SFLoginUrl = \"https://login.salesforce.com\";\n\t\tpublic const string SFTestLoginUrl = \"https://test.salesforce.com\";\n    \tpublic const string SalesforceGovCloudDomain = \"salesforce-gov.com\";\n\t\tpublic const string SALESFORCE = \"Salesforce\";\n\t\tpublic const string STUB = \"Stub\";\n\t\tpublic const string StubValueRegexPattern = STUB + \"(.*:.*){2}\";\n\t\tpublic const string SFProdSubdomain = \"login\";\n\t\tpublic const string SFSandboxSubdomain = \"test\";\n\t\tpublic const string ScopeEventsAggregationJobLastRunRedisKey = \"ScopeEventsAggregationJob\";\n\n\t\tpublic const string WIDGET = \"Widget\";\n\n\t\tpublic const int SpringStartYear = 2003;\n\n\t\tpublic const int DayInSeconds = 60 * 60 * 24;\n\n\t\tpublic const int WorkflowNameMaxLength = 100;\n\t\tpublic const int DocumentNameMaxLength = 255;\n\t\tpublic const int AgreementSummaryMaxLength = 65535;\n\t\tpublic const int AgreementSummaryMaxDefaultLength = 600;\n\t\tpublic const int FolderNameMaxLength = 100;\n\t\tpublic const char IllegalTrailingFolderNameCharacter = '.';\n\n\t\tpublic const int SqlTimeoutErrorCode = -2;\n\t\tpublic const int MaxTrashDaysToKeep = 365;\n\t\tpublic const int MinAutoRenewalUnit = 1;\n\t\tpublic const int MaxAutoRenewalUnit = 1000;\n\n\t\t//Page restrictions\n\t\tpublic const string NoRestriction = \"NoRestriction\";\n\n\t\tpublic const string HealthCheckRMQPath = \"healthcheck\";\n\n\t\tpublic const string EssentialsFieldLibraryName = \"System Field library\";\n\n\t\t// Skip Link\n\t\tpublic const string SkipLinkMainContentId = \"ContentContainerOuter\";\n\t\tpublic const string SkipLinkId = \"skipLink\";\n\n\t\t//DefaultImageFormat\n\t\tpublic const string DefaultPreviewOutputFormat = \"Png\";\n\n\t\tpublic class EMSPaths\n\t\t{\n\t\t\tpublic const string ModelsEsignV2BasePath = \"/models-esign/v2/private/accounts\";\n\t\t\tpublic const string DocumentsIngestPath = \"documents/clm/ingest\";\n\t\t\tpublic const string CustomAttributesPath = \"custom_attributes\";\n\t\t\tpublic const string CustomAttributesFinalizePath = \"custom_attributes_finalize\";\n\t\t\tpublic const string UpdateDocumentIdOfAgreementDocumentPath = \"documents/clm/{0}\";\n\t\t\tpublic const string HealthCheckV1Path = \"/models-esign/v1/health\";\n\t\t}\n\n\t\tpublic class DevXIamPaths\n\t\t{\n\t\t\tpublic const string ModelsIamV1BasePath = \"devx-iam/v1/accounts\";\n\t\t\tpublic const string QueryDocumentPath = \"agreements/query\";\n\t\t\tpublic const string DeleteDocumentPath = \"agreements/{1}\";\n\t\t}\n\n\t\tpublic class ABACContextKeys\n\t\t{\n\t\t\tpublic const string UserId = \"UserId\";\n\t\t\tpublic const string AccountId = \"AccountId\";\n\t\t\tpublic const string AgreementType = \"AgreementType\";\n\t\t\tpublic const string GroupMembership = \"GroupMembership\";\n\t\t\tpublic const string Role = \"Role\";\n\t\t\tpublic const string Type = \"Type\";\n\t\t\tpublic const string PartyUid = \"PartyUid\";\n\t\t\tpublic const string Region = \"Region\";\n\t\t\tpublic const string Status = \"Status\";\n\t\t\tpublic const string Uid = \"Uid\";\n\t\t\tpublic const string Name = \"Name\";\n\t\t\tpublic const string CreatedDate = \"CreatedDate\";\n\t\t\tpublic const string CreatorUid = \"CreatorUid\";\n\t\t\tpublic const string UpdatedDate = \"UpdatedDate\";\n\t\t\tpublic const string ParentUid = \"ParentUid\";\n\t\t\tpublic const string ParentType = \"ParentType\";\n\t\t\tpublic const string HasSecurityAttributes = \"HasSecurityAttributes\";\n\t\t}\n\n\t\tpublic class APIKeyProducts\n\t\t{\n\t\t\tpublic const string AtlasUploadService = \"Atlas Upload Service\";\n\t\t\tpublic const string MultipleUploadControl = \"Multiple Upload Control\";\n\t\t\tpublic const string RulesOnFolders = \"Rules On Folders\";\n\t\t\tpublic const string UnitTest = \"Unit Test\";\n\t\t\tpublic const string UnknownAPIClient = \"Unknown API Client\";\n\t\t}\n\n\t\tpublic static class ActSalesforceForClm\n\t\t{\n\t\t\tpublic static readonly Guid AppId = new Guid(\"2d576583-520a-41e2-886b-089fefe733a1\");\n\t\t\tpublic const string ChildRelationshipFieldType = \"CHILD_RELATIONSHIP\";\n\t\t\tpublic const string CurrencyFieldType = \"CURRENCY\";\n\t\t\tpublic const string CurrentDateFieldName = \"CurrentDate\";\n\t\t\tpublic const string CurrencyIsoCodeFieldName = \"CurrencyIsoCode\";\n\t\t\tpublic const string GenTemplateWorkflowMappingName = \"dfsle__ApplyCLMWorkflow__c\";\n\t\t\tpublic const string IdFieldName = \"Id\";\n\t\t\tpublic const string MalformedGenMessage = \"Malformed Gen Template. Its empty and has no children.\";\n\t\t\tpublic const string NameFieldName = \"Name\";\n\t\t\tpublic const string ObjectMappingsName = \"dfsle__ObjectMappings\";\n\t\t\tpublic const string PickListFieldType = \"PICKLIST\";\n\t\t\tpublic const string ReferenceFieldType = \"REFERENCE\";\n\t\t\tpublic const string SalesforceObjectType = \"dfsle__GenTemplate__c\";\n\t\t\tpublic static readonly string[] SalesforceFields = new string[] { \"dfsle__ObjectMappings__c\", \"dfsle__ObjectMappings2__c\", \"dfsle__ObjectMappings3__c\", \"dfsle__ObjectMappings4__c\" };\n\t\t\tpublic static readonly string SalesforceLoggingObjectName = \"dfsle__Log__c\";\n\t\t}\n#pragma warning disable CA1724 // type name conflict\n\t\tpublic class API\n#pragma warning restore // type name conflict\n\t\t{\n\t\t\tpublic const string AttributeTypePropertyName = \"AttributeType\";\n\t\t\tpublic const string AttributeRepeatingPropertyName = \"RepeatingAttribute\";\n\t\t\tpublic const string AtomContentType = \"application/atom+xml\";\n\t\t\tpublic const string AtomNamespace = \"http://www.w3.org/2005/Atom\";\n\t\t\tpublic const string JsonContentType = \"application/json\";\n\t\t\tpublic const string OpenSearchAtomRel = \"results\";\n\t\t\tpublic const string OpenSearchDescription = \"Search documents stored in SpringCM.\";\n\t\t\tpublic const string OpenSearchEncoding = \"UTF-8\";\n\t\t\tpublic const string OpenSearchShortName = \"SpringCM Search\";\n\t\t\tpublic const string OpenSearchNamespace = \"http://a9.com/-/spec/opensearch/1.1/\";\n\t\t\tpublic const string SalesforceNamespace = \"http://salesforce.com/2016/federatedsearch/1.0\";\n\t\t\tpublic const string XmlContentType = \"application/xml\";\n\t\t\tpublic const string SalesforceNamespacePrefix = \"sfdc\";\n\t\t\tpublic const string OpenSearchNamespacePrefix = \"opensearch\";\n\t\t\tpublic const string AuthenticationTime = \"authtime\";\n\t\t\tpublic const string DsAccountId = \"DsAccountId\";\n\t\t\tpublic const string RestApi = \"restapi\";\n\t\t\tpublic const string Version1 = \"1\";\n\t\t\tpublic const string SiteWarmupPingPath = \"sitewarmup/ping\";\n\t\t\tpublic const string AlivePath = \"alive\";\n\n\t\t\t//UrlPrefixes\n\t\t\tpublic const string APIUrlPrefix = \"api\";\n\t\t\tpublic const string APIDownloadUrlPrefix = \"apidownload\";\n\t\t\tpublic const string OfficeAddInPrefix = \"officeaddin\";\n\t\t\tpublic const string DsOfficeAddInPrefix = \"ds-officeaddin\";\n\t\t\tpublic const string APIUploadUrlPrefix = \"apiupload\";\n\t\t\tpublic const string OpenSearchUrlPrefix = \"opensearch\";\n\t\t\tpublic const string RestUrlPrefix = \"rest\";\n\t\t\tpublic const string RestContentUrlPrefix = \"restcontent\";\n\t\t\tpublic const string SFTPUrlPrefix = \"sftp\";\n\t\t\tpublic const string SoapUrlPrefix = \"soap\";\n\t\t\tpublic const string AllocationUrlPrefix = \"allocate\";\n\t\t\tpublic const string GatekeeperUrlPrefix = \"gatekeeper\";\n\t\t\tpublic const string ProvisioningUrlPrefix = \"provisioning\";\n\n\t\t\t//WorkflowScopes\n\t\t\tpublic const string CLMExpressionCompile = \"clm_expression_compile\";\n\t\t\tpublic const string CLMExpressionExecute = \"clm_expression_execute\";\n\n\t\t\t// OrchestrationScopes\n\t\t\tpublic const string AowManage = \"aow_manage\";\n\n\t\t\t// DocManagementService Scopes and Paths\n\t\t\tpublic const string DMSBasePath = \"/document-management-service/v1\";\n\t\t\tpublic const string DMSMetadataPath = \"accounts/{0}/documents/{1}/metadata\";\n\t\t\tpublic const string DMSInternalScopes = \"internal_api_dms\";\n\t\t\tpublic const string DMSHealthCheckPath = \"/document-management-service/v1/health\";\n\n\t\t\t//ObligationManagementService (OMS) Paths\n\t\t\tpublic const string OMSReadPath = \"/obg-mgmt-service/v2.0/workflows/accounts/{0}/document/{1}/obligations\";\n\t\t\tpublic const string OMSUpdatePath = \"/obg-mgmt-service/v2.0/workflows/accounts/{0}/document/{1}/obligations/{2}\";\n\t\t}\n\n\t\tpublic class ApplicationSettings\n\t\t{\n\t\t\t// Blob storage settings\n\t\t\tpublic const string BlobPhysicalStorageUrl = \"BlobPhysicalStorageUrl\";\n\t\t\tpublic const string EnableNgScmDeferForChooser = \"EnableNgScmDeferForChooser\";\n\t\t\tpublic const string EnableBlobSharedStorageFallback = \"EnableBlobSharedStorageFallback\";\n\t\t\tpublic const string BlobPhysicalStorageDataPlaneAppIdUri = \"BlobPhysicalStorageDataPlaneAppIdUri\";\n\t\t\tpublic const string BlobPhysicalStorageClientId = \"BlobPhysicalStorageClientId\";\n\t\t\tpublic const string BlobSharedStorageClientId = \"BlobSharedStorageClientId\";\n\t\t\tpublic const string BlobSharedStorageDataPlaneAppIdUri = \"BlobSharedStorageDataPlaneAppIdUri\";\n\t\t\tpublic const string BlobSharedStorageUrl = \"BlobSharedStorageUrl\";\n\t\t\tpublic const string BlobPhysicalStorageHttpClientTimeoutMs = \"BlobPhysicalStorageHttpClientTimeoutMs\";\n\t\t\tpublic const string BlobPhysicalStorageAuthenticationTimeoutMs = \"BlobPhysicalStorageAuthenticationTimeoutMs\";\n\t\t\tpublic const string BlobStorageBackoffFirstRetrySeconds = \"BlobStorageBackoffFirstRetrySeconds\";\n\t\t\tpublic const string BlobStorageBackoffMaxRetryCount = \"BlobStorageBackoffMaxRetryCount\";\n\t\t\t// Dms storage settings\n\t\t\tpublic const string DmsPhysicalStorageUrl = \"DmsPhysicalStorageUrl\";\n\t\t\tpublic const string DmsPhysicalStorageClientId = \"DmsPhysicalStorageClientId\";\n\t\t\tpublic const string DmsPhysicalStorageHttpClientTimeoutMs = \"DmsPhysicalStorageHttpClientTimeoutMs\";\n\t\t\tpublic const string DmsPhysicalStorageAuthenticationTimeoutMs = \"DmsPhysicalStorageAuthenticationTimeoutMs\";\n\n\t\t\t//Document Upload cloud storage settings\n\t\t\tpublic const string WriteToSharedStorageOnDocumentUpload = \"WriteToSharedStorageOnDocumentUpload\";\n\n\n\t\t\t// connection strings\n\t\t\tpublic const string ConnectionString = \"connectionString\";\n\t\t\tpublic const string AuthenticationConnectionString = \"AuthenticationConnectionString\";\n\t\t\tpublic const string AuthenticationTokenExpirationMinutes = \"AuthenticationTokenExpirationMinutes\";\n\t\t\tpublic const string AuthenticationDomainRootUrl = \"AuthenticationDomainRootUrl\";\n\t\t\tpublic const string AuthenticationApplicationRootFormat = \"AuthenticationApplicationRootFormat\";\n\t\t\tpublic const string GateKeeperUrlFormat = \"GateKeeperUrlFormat\";\n\t\t\tpublic const string GateKeeperRetryCount = \"GateKeeperRetryCount\";\n\t\t\tpublic const string GateKeeperRetryIntervalInMs = \"GateKeeperRetryIntervalInMs\";\n\t\t\tpublic const string EventForwardingRegistrationRetryCount = \"EventForwardingRegistrationRetryCount\";\n\t\t\tpublic const string EventForwardingRegistrationIntervalInMs = \"EventForwardingRegistrationIntervalInMs\";\n\t\t\tpublic const string RestAuthRootUrl = \"RestAuthRootUrl\";\n\t\t\tpublic const string RestAuthRootUrlFormatSiteSpecific = \"RestAuthRootUrlFormatSiteSpecific\";\n\t\t\tpublic const string NewAccountConnectionString = \"NewAccountConnectionString\";\n\t\t\tpublic const string NewTrialConnectionString = \"NewTrialConnectionString\";\n\t\t\tpublic const string ProfileDatabaseConnectionString = \"ProfileDatabaseConnectionString\";\n\n\t\t\t/// <summary>\n\t\t\t/// This is the database connection string used by a wins service to connect to its target DB.\n\t\t\t/// </summary>\n\t\t\tpublic const string WINSDatabaseConnectionString = \"WINSDatabaseConnectionString\";\n\n\t\t\t// This value is set only to provide a clear notification when db access is attempted,\n\t\t\t// unbeknown to a unit test writer. Even on local environment unit tests would fail if\n\t\t\t// they try to use the database.\n\t\t\t// Note that the server start with \"local\", so that site matching continues to work.\n\t\t\tpublic static string DEFAULT_CONNECTION_STRING => \"Integrated Security=SSPI;initial catalog=noDefaultDb4u;data source=localNoDefaultServer4u;\";\n\n\t\t\tpublic const string ABCpdfLicense = \"ABCpdfLicense\";\n\t\t\tpublic const string AcceptableFileExtensions = \"AcceptableFileExtensions\";\n\t\t\tpublic const string AccountStatisticOldNumDays = \"AccountStatisticOldNumDays\";\n\t\t\tpublic const string ActivePDFErrorsDirectory = \"activePDFErrorsDirectory\";\n\t\t\tpublic const string ActivePDFOutputDirectory = \"activePDFOutputDirectory\";\n\t\t\tpublic const string ActivePDFWorkDirectory = \"activePDFWorkDirectory\";\n\t\t\tpublic const string AllowInternetExplorer = \"AllowInternetExplorer\";\n\t\t\tpublic const string AllowOpenRedirect = \"AllowOpenRedirect\";\n\t\t\tpublic const string AllowedRequestSources = \"AllowedRequestSources\";\n\t\t\tpublic const string InternalEmailDomains = \"InternalEmailDomains\";\n\t\t\tpublic const string AllowUpdatingScimExternalId = \"AllowUpdatingScimExternalId\";\n\t\t\tpublic const string AllowDocuSignOrderProvisioningInPSOTool = \"AllowDocuSignOrderProvisioningInPSOTool\";\n\t\t\tpublic const string CustomerSupportEmail = \"CustomerSupportEmail\";\n\t\t\tpublic const string LegacyCustomerSupportEmail = \"LegacyCustomerSupportEmail\";\n\t\t\tpublic const string AllowTrainingAccounts = \"AllowTrainingAccounts\";\n\t\t\tpublic const string AsyncPasteThreshold = \"AsyncPasteThreshold\";\n\t\t\tpublic const string BouncebackSMTPUserNames = \"BouncebackSMTPUserNames\";\n\n\t\t\tpublic const string BrandName = \"BrandName\";\n\t\t\tpublic const string BrandStreet = \"BrandStreet\";\n\t\t\tpublic const string BrandCity = \"BrandCity\";\n\t\t\tpublic const string BrandState = \"BrandState\";\n\t\t\tpublic const string BrandZip = \"BrandZip\";\n\n\t\t\tpublic const string EnableDocLauncherAutomaticNumberFormatting = \"EnableDocLauncherAutomaticNumberFormatting\";\n\n\t\t\tpublic const string PIIHashingStrategy = \"PIIHashingStrategy\";\n\n\t\t\tpublic const string MaxItemsInFolderDisplayedInUI = \"MaxItemsInFolderDisplayedInUI\";\n\n\t\t\tpublic const string MessagingFrameworkBrandedHeaderImageUrl = \"MessagingFrameworkBrandedHeaderImageUrl\";\n\n\t\t\tpublic const string MessagingFrameworkFacebookUrl = \"MessagingFrameworkFacebookUrl\";\n\t\t\tpublic const string MessagingFrameworkLinkedinUrl = \"MessagingFrameworkLinkedinUrl\";\n\t\t\tpublic const string MessagingFrameworkTwitterUrl = \"MessagingFrameworkTwitterUrl\";\n\t\t\tpublic const string MessagingFrameworkYoutubeUrl = \"MessagingFrameworkYoutubeUrl\";\n\n\t\t\tpublic const string MessagingFrameworkFacebookImageUrl = \"MessagingFrameworkFacebookImageUrl\";\n\t\t\tpublic const string MessagingFrameworkLinkedinImageUrl = \"MessagingFrameworkLinkedinImageUrl\";\n\t\t\tpublic const string MessagingFrameworkTwitterImageUrl = \"MessagingFrameworkTwitterImageUrl\";\n\t\t\tpublic const string MessagingFrameworkYoutubeImageUrl = \"MessagingFrameworkYoutubeImageUrl\";\n\n\t\t\tpublic const string BrowseUploadTempLocation = \"BrowseUploadTempLocation\";\n\t\t\tpublic const string BuildMinorOffset = \"BuildMinorOffset\";\n\t\t\tpublic const string ChunkSize = \"chunkSize\";\n\t\t\tpublic const string LogInInfoMessage = \"LogInInfoMessage\";\n\t\t\tpublic const string UploadAuthenticationTokenTtl = \"UploadAuthenticationTokenTtl\";\n\n\t\t\t/* ABAC */\n\t\t\tpublic const string SecurityEvaluationServiceMemoryCacheEntryCountLimit = \"SecurityEvaluationServiceMemoryCacheEntryCountLimit\";\n\t\t\tpublic const string AllowAbacEnablementDuringAccountCreation = \"AllowAbacEnablementDuringAccountCreation\";\n\n\t\t\t/* Caching */\n\t\t\tpublic const string CacheName = \"CacheName\";\n\t\t\tpublic const string CacheDataItemExpirationMinutes = \"CacheDataItemExpirationMinutes\";\n\t\t\tpublic const string CacheClientElapsedMSThreshold = \"CacheClientElapsedMSThreshold\";\n\t\t\tpublic const string SignedRequestCacheSeconds = \"SignedRequestCacheSeconds\";\n\t\t\tpublic const string SfIdentityResponseCacheSeconds = \"SfIdentityResponseCacheSeconds\";\n\t\t\tpublic const string DSAccountEntitlementCacheTtlSeconds = \"DSAccountEntitlementCacheTtlSeconds\";\n\t\t\tpublic const string DSOrgUserProfileCacheTtlSeconds = \"DSOrgUserProfileCacheTtlSeconds\";\n\t\t\tpublic const string DSAccountServerAccessTokenCacheTimeout = \"DSAccountServerAccessTokenCacheTimeout\";\n\t\t\tpublic const string DSLimitedAccessTokenCacheKeyPrefix = \"DSLimitedAccessTokenCacheKeyPrefix\";\n\t\t\tpublic const string DSLimitedAccessTokenCacheLockKeyPrefix = \"DSLimitedAccessTokenCacheLockKeyPrefix\";\n\n\t\t\tpublic const string CaptchaPublicKey = \"CaptchaPublicKey\";\n\n\t\t\tpublic const string CaptchaPrivateKey = \"CaptchaPrivateKey\";\n\t\t\tpublic const string CaseCreateInProcessWaitTimeoutInSeconds = \"CaseCreateInProcessWaitTimeoutInSeconds\";\n\t\t\tpublic const string CaseCreateOutProcessWaitTimeoutInSeconds = \"CaseCreateInProcessWaitTimeoutInSeconds\";\n\n\t\t\tpublic const string BuildNumberSuffix = \"BuildNumberSuffix\";\n\n\t\t\tpublic const string MaxTransactionsPerBatch = \"MaxTransactionsPerBatch\";\n\n\t\t\t/* Cassandra */\n\t\t\tpublic const string CassandraConnectionString = \"CassandraConnectionString\";\n\t\t\tpublic const string CassandraConnectTimeoutMs = \"CassandraConnectTimeoutMs\";\n\t\t\tpublic const string CassandraDriverTraceLevel = \"CassandraDriverTraceLevel\";\n\t\t\tpublic const string CassandraEnableTracing = \"CassandraEnableTracing\";\n\t\t\tpublic const string CassandraHeartbeatInterval = \"CassandraHeartbeatInterval\";\n\t\t\tpublic const string CassandraKeyspaceName = \"CassandraKeyspaceName_\";\n\t\t\tpublic const string CassandraLocalDatacenter = \"CassandraLocalDatacenter\";\n\t\t\tpublic const string CassandraExecuteMaxAttempts = \"CassandraExecuteMaxAttempts\";\n\t\t\tpublic const string CassandraReconnectMaxMs = \"CassandraReconnectMaxMs\";\n\t\t\tpublic const string CassandraReadTimeOutMs = \"CassandraReadTimeOutMs\";\n\t\t\tpublic const string CassandraReconnectMinMs = \"CassandraReconnectMinMs\";\n\t\t\tpublic const string FolderHistoryItemsLimit = \"FolderHistoryItemsLimit\";\n\t\t\tpublic const string WriteFolderHistory = \"WriteFolderHistory\";\n\t\t\tpublic const string BucketedHistoryAlignSeconds = \"BucketedHistoryAlignSeconds\";\n\t\t\tpublic const string ObjectHistoryBucketedMaxBucketSize = \"ObjectHistoryBucketedMaxBucketSize\";\n\t\t\tpublic const string SentEmailBucketedAlignSeconds = \"SentEmailBucketedAlignSeconds\";\n\t\t\tpublic const string SentEmailBucketedMaxBucketSize = \"SentEmailBucketedMaxBucketSize\";\n\t\t\tpublic const string CassandraEnabledMaterializedViews = \"CassandraEnabledMaterializedViews\";\n\t\t\tpublic const string IsMultipleColumnsOrderBySupported = \"IsMultipleColumnsOrderBySupported\";\n\n\t\t\t/* Presto/Reporting/Analytics/ */\n\t\t\tpublic const string PrestoReportUIMaxRows = \"PrestoReportUIMaxRows\";\n\n\t\t\tpublic const string PrestoDocActivityReportMaxBuckets = \"PrestoDocActivityReportMaxBuckets\";\n\n\t\t\tpublic const string PrestoUiPreviewQueryMaxExecutionTimeSecs = \"PrestoUiPreviewQueryMaxExecutionTimeSecs\";\n\t\t\tpublic const string PrestoUiViewQueryMaxExecutionTimeSecs = \"PrestoUiViewQueryMaxExecutionTimeSecs\";\n\n\t\t\tpublic const string PrestoExportQueryMaxExecutionTimeHours = \"PrestoExportQueryMaxExecutionTimeHours\";\n\t\t\tpublic const string PrestoReportCacheTtlSecs = \"PrestoReportCacheTtlSecs\";\n\t\t\tpublic const string PrestoWorkflowOverviewReportMaxPartitions = \"PrestoWorkflowOverviewReportMaxPartitions\";\n\t\t\tpublic const string PrestoWorkflowStepReportMaxPartitions = \"PrestoWorkflowStepReportMaxPartitions\";\n\t\t\tpublic const string PrestoMaxScopeNamePartitions = \"PrestoMaxScopeNamePartitions\";\n\t\t\tpublic const string PrestoRestRequestLatencyMs = \"PrestoRestRequestLatencyMs\";\n\t\t\tpublic const string PrestoSQLHeaderEnabled = \"PrestoSQLHeaderEnabled\";\n\t\t\tpublic const string PrestoUrl = \"PrestoUrl\";\n\t\t\tpublic const string PrestoUrlFormat = \"PrestoUrlFormat\";\n\n\n\t\t\tpublic const string PrestoLogAllHttpRequests = \"PrestoLogAllHttpRequests\";\n\t\t\tpublic const string PrestoQueryLogTtlHours = \"PrestoQueryLogTtlHours\";\n\t\t\tpublic const string PrestoReportUIMaxGroups = \"PrestoReportUIMaxGroups\";\n\t\t\tpublic const string PrestoUseSeparateCassandraCatalogs = \"PrestoUseSeparateCassandraCatalogs\";\n\t\t\tpublic const string PrestoEnableAsUTC = \"PrestoEnableAsUTC\";\n\t\t\tpublic const string ReportBuilderLoadingStatusIntervalMs = \"ReportBuilderLoadingStatusIntervalMs\";\n\t\t\tpublic const string ReportBuilderLoadingStatusMaxRetries = \"ReportBuilderLoadingStatusMaxRetries\";\n\t\t\tpublic const string ReportingMaxCheckInDocumentRetryCount = \"ReportingMaxCheckInDocumentRetryCount\";\n\t\t\tpublic const string ReportingMaxSubscriberDeleteRetryCount = \"ReportingMaxSubscriberDeleteRetryCount\";\n\n\t\t\tpublic const string EnableDocumentReportAttributeFiltersPerformanceImprovement =\n\t\t\t\t\"EnableDocumentReportAttributeFiltersPerformanceImprovement\";\n\t\t\tpublic const string EnableStandardReportsSqlDynamicFiltering =\n\t\t\t\t\"EnableStandardReportsSqlDynamicFiltering\";\n\n\t\t\tpublic const string EnableDocumentReportAttributeColumnsPerformanceImprovement =\n\t\t\t\t\"EnableDocumentReportAttributeColumnsPerformanceImprovement\";\n\n\t\t\tpublic const string MaxRetryAttemptsPackageFolderMapping = \"MaxRetryAttemptsPackageFolderMapping\";\n\t\t\tpublic const string ReportingLoadingStatePollingIntervalMs = \"ReportingLoadingStatePollingIntervalMs\";\n\t\t\tpublic const string ReportingTempStoragePath = \"ReportingTempStoragePath\";\n\t\t\tpublic const string SearchFacadeBaseUrl = \"SearchFacadeBaseUrl\";\n\t\t\tpublic const string SearchIncBaseUrl = \"SearchIncBaseUrl\";\n\t\t\tpublic const string SearchUseExternalServiceOnly = \"SearchUseExternalServiceOnly\";\n\n\t\t\t/* Elastic indexing */\n\t\t\tpublic const string AzureRingShard = \"AzureRingShard\";\n\t\t\tpublic const string ElasticsearchMaxBatchSizeMBCLMClient = \"ElasticsearchMaxBatchSizeMBCLMClient\";\n\t\t\tpublic const string ElasticsearchMaxBatchSizeMBExternalClient = \"ElasticsearchMaxBatchSizeMBExternalClient\";\n\t\t\tpublic const string ElasticIndexingFolderLoadPageSize = \"ElasticIndexingFolderLoadPageSize\"; // The size of each page loaded from the database when the service is bulk indexing\n\t\t\tpublic const string ElasticIndexingDocumentLoadPageSize = \"ElasticIndexingDocumentLoadPageSize\"; // The size of each page loaded from the database when the service is bulk indexing\n\t\t\tpublic const string ElasticUseMatchPhraseForWithAllWords = \"ElasticUseMatchPhraseForWithAllWords\";\n\t\t\tpublic const string ElasticsearchMaxIndexedContentLen = \"ElasticsearchMaxIndexedContentLen\";\n\t\t\tpublic const string ElasticsearchMaxMessageSizeExternalService = \"ElasticsearchMaxMessageSizeExternalService\";\n\t\t\tpublic const string ElasticsearchScrollTtlSeconds = \"ElasticsearchScrollTtlSeconds\";\n\t\t\tpublic const string ElasticsearchHighlightFragmentSize = \"ElasticsearchHighlightFragmentSize\";\n\t\t\tpublic const string ElasticsearchHighlightPreTags = \"ElasticsearchHighlightPreTags\";\n\t\t\tpublic const string ElasticsearchHighlightPostTags = \"ElasticsearchHighlightPostTags\";\n\t\t\tpublic const string ElasticsearchIndexingBackoffFirstRetrySeconds =\n\t\t\t\t\"ElasticsearchIndexingBackoffFirstRetrySeconds\";\n\t\t\tpublic const string ElasticsearchIndexingBackoffMaxRetryCount = \"ElasticsearchIndexingBackoffMaxRetryCount\";\n\t\t\tpublic const string ElasticsearchSearchBackoffFirstRetrySeconds =\n\t\"ElasticsearchSearchBackoffFirstRetrySeconds\";\n\t\t\tpublic const string ElasticsearchSearchBackoffMaxRetryCount = \"ElasticsearchSearchBackoffMaxRetryCount\";\n\t\t\t/// <summary>\n\t\t\t/// Originally, this was BrowseUploadTempLocation, but since chunks may be\n\t\t\t/// uploaded to different web servers in a load balanced environment, the chunks\n\t\t\t/// need to be stored at some centrally accessible location.\n\t\t\t/// </summary>\n\t\t\tpublic const string ChunkUploadDirectory = \"chunkUploadDirectory\";\n\t\t\tpublic const string UiChunkUploadDirectory = \"UiChunkUploadDirectory\";\n\n\t\t\tpublic const string ApprovalReservedName = \"ApprovalReservedName\";\n\t\t\tpublic const string DocuSignDownloadsUrl = \"DocuSignDownloadsUrl\";\n\t\t\tpublic const string CommandCountWarning = \"commandCountWarning\";\n\t\t\tpublic const string CommandSecondsWarning = \"commandSecondsWarning\";\n\t\t\tpublic const string ContentRootUrl = \"ContentRootUrl\";\n\t\t\tpublic const string UxRootUrl = \"UxRootUrl\";\n\t\t\tpublic const string UxVersion = \"UxVersion\";\n\t\t\tpublic const string OAuthRefreshTokenExpirationMinutes = \"OAuthRefreshTokenExpirationMinutes\";\n\t\t\tpublic const string ApplicationOauthName = \"ApplicationOauthName\";\n\t\t\tpublic const string ObjectNameDisplayLength = \"objectNameDisplayLength\";\n\t\t\tpublic const int ObjectNameDisplayLengthDefault = 40;\n\n\t\t\tpublic const string ChunkUploadExpirationSeconds = \"ChunkUploadExpirationSeconds\";\n\t\t\tpublic const string AkamaiUploadTimeoutValue = \"AkamaiUploadTimeoutValue\";\n\t\t\tpublic const string CounterCacheSize = \"counterCacheSize\";\n\t\t\tpublic const string CustomLogoPath = \"CustomLogoPath\";\n\t\t\tpublic const string CustomLogoMaxWidth = \"CustomLogoMaxWidth\";\n\t\t\tpublic const string CustomIconMaxWidth = \"CustomIconMaxWidth\";\n\t\t\tpublic const string CustomLogoMaxHeight = \"CustomLogoMaxHeight\";\n\t\t\tpublic const string CustomIconMaxHeight = \"CustomIconMaxHeight\";\n\t\t\tpublic const string CustomLogoMaxFileSize = \"CustomLogoMaxFileSize\";\n\t\t\tpublic const string CustomLogoSupportedFileTypes = \"CustomLogoSupportedFileTypes\";\n\t\t\tpublic const string CustomChartPalette = \"CustomChartPalette\";\n\t\t\tpublic const string DBConnectInfoExpirationMinutes = \"DBConnectInfoExpirationMinutes\";\n\t\t\tpublic const string DeactivatedFaxEmailRecipients = \"DeactivatedFaxEmailRecipients\";\n\t\t\tpublic const string DeleteUnusedFileLocalStartTime = \"DeleteUnusedFileLocalStartTime\";\n\t\t\tpublic const string DefaultContractStorageGB = \"DefaultContractStorageGB\";\n\t\t\tpublic const string DefaultContractStorageGBFreeEdition = \"DefaultContractStorageGBFreeEdition\";\n\t\t\tpublic const string DefaultContractStorageGBTrialAccount = \"DefaultContractStorageGBTrialAccount\";\n\t\t\tpublic const string DefaultContractUserLimit = \"DefaultContractUserLimit\";\n\t\t\tpublic const string DefaultContractUserLimitFreeEdition = \"DefaultContractUserLimitFreeEdition\";\n\t\t\tpublic const string DefaultContractUserLimitTrialAccount = \"DefaultContractUserLimitTrialAccount\";\n\t\t\tpublic const string DefaultLogoutRedirectUrl = \"DefaultLogoutRedirectUrl\";\n\t\t\tpublic const string DefaultPremiumContractStorageGB = \"DefaultPremiumContractStorageGB\";\n\t\t\tpublic const string DefaultUserKeyExpirationMinutes = \"DefaultUserKeyExpirationMinutes\";\n\t\t\tpublic const string DebugOnStartup = \"DebugOnStartup\";\n\t\t\tpublic const string ServiceName = \"serviceName\";\n\t\t\tpublic const string AdexsServicedComponent = \"adexsServicedComponent\";\n\t\t\tpublic const string AdexsServicedComponentAssembly = \"adexsServicedComponentAssembly\";\n\t\t\tpublic const string MaxUserKeyExpirationMinutes = \"MaxUserKeyExpirationMinutes\";\n\t\t\tpublic const string DirectoryToClean = \"directoryToClean\";\n\t\t\tpublic const string DisableNotificationFramework = \"DisableNotificationFramework\";\n\t\t\tpublic const string DocumentLWDPPfailureImageBig = \"DocumentLWDPPfailureImageBig\";\n\t\t\tpublic const string DocumentLWDPPfailureImageSmall = \"DocumentLWDPPfailureImageSmall\";\n\t\t\tpublic const string DocumentLWDPRepositoryRootLegacyFallback = \"DocumentLWDPRepositoryRootLegacyFallback\";\n\t\t\tpublic const string DocumentRepositoryRootLegacyFallback = \"DocumentRepositoryRootLegacyFallback\";\n\t\t\tpublic const string DomainRootFormat = \"DomainRootFormat\";\n\t\t\tpublic const string IsFedRamp = \"IsFedRamp\";\n\t\t\tpublic const string SfGenApiRoot = \"SfGenApiRoot\";\n\t\t\tpublic const string SoapUrlFormat = \"SoapUrlFormat\";\n\t\t\tpublic const string RestUrlFormat = \"RestUrlFormat\";\n\t\t\tpublic const string RestContentUrlFormat = \"RestContentUrlFormat\";\n\t\t\tpublic const string APIBaseUrlFormat = \"APIBaseUrlFormat\";\n\t\t\tpublic const string APIBaseUploadUrlFormat = \"APIBaseUploadUrlFormat\";\n\t\t\tpublic const string APIBaseDownloadUrlFormat = \"APIBaseDownloadUrlFormat\";\n\t\t\tpublic const string OfficeAddInUrlFormat = \"OfficeAddInUrlFormat\";\n\t\t\tpublic const string DsOfficeAddInUrlFormat = \"DsOfficeAddInUrlFormat\";\n\t\t\tpublic const string SftpUrlFormat = \"SftpUrlFormat\";\n\t\t\tpublic const string OpenSearchBaseUrlFormat = \"OpenSearchBaseUrlFormat\";\n\t\t\tpublic const string SpringCMDomain = \"SpringCMDomain\";\n\t\t\tpublic const string DocusignDomain = \"DocusignDomain\";\n\t\t\tpublic const string DomainUploadRoot = \"DomainUploadRoot\";\n\t\t\tpublic const string PdfFieldExportTemporaryStoragePath = \"PdfFieldExportTemporaryStoragePath\";\n\t\t\tpublic const string ShareRootUrl = \"ShareRootUrl\";\n\t\t\tpublic const string TransientStorage = \"TransientStorage\";\n\t\t\tpublic const string TempTransientStorage = \"TempTransientStorage\";\n\t\t\tpublic const string OutboundHttpStorage = \"OutboundHttpStorage\";\n\t\t\tpublic const string DropdownMaxItems = \"DropdownMaxItems\";\n\t\t\tpublic const string GridSelectAllLimit = \"GridSelectAllLimit\";\n\t\t\tpublic const string SpringCMEditProhibitedExtensions = \"SpringCMEditProhibitedExtensions\";\n\t\t\tpublic const string SpringCMSalesEmail = \"SpringCMSalesEmail\";\n\t\t\tpublic const string SpringCMSalesPhoneNumber = \"SpringCMSalesPhoneNumber\";\n\t\t\tpublic const string EnableWorkItemNewsWorker = \"EnableWorkItemNewsWorker\";\n\t\t\tpublic const string EnableSignedRequestReplayPrevention = \"EnableSignedRequestReplayPrevention\";\n\t\t\tpublic const string AtlasEtlStorage = \"AtlasEtlStorage\";\n\t\t\tpublic const string DefaultBounceBackEmail = \"DefaultBounceBackEmail\";\n\t\t\tpublic const string DocLauncherFormsKnowledgeUrl = \"DocLauncherFormsKnowledgeUrl\";\n\t\t\tpublic const string DocLauncherOneClickKnowledgeUrl = \"DocLauncherOneClickKnowledgeUrl\";\n\t\t\tpublic const string DocLauncherOneClickKnowledgeUrlDS = \"DocLauncherOneClickKnowledgeUrlDS\";\n\t\t\tpublic const string AllowDocLauncherCanvasUrls = \"AllowDocLauncherCanvasUrls\";\n\t\t\tpublic const string UserOverageEmailIntervalInDays = \"UserOverageEmailIntervalInDays\";\n\t\t\tpublic const string EnableNewESignatureConfigurationPage = \"EnableNewESignatureConfigurationPage\";\n\t\t\tpublic const string SessionTimeoutOptions = \"SessionTimeoutOptions\";\n\t\t\tpublic const string PasswordExpirationOptions = \"PasswordExpirationOptions\";\n\t\t\tpublic const string PasswordReuseOptions = \"PasswordReuseOptions\";\n\t\t\tpublic const string FederatedSecurityPossibleCacheValuesMinutes = \"FederatedSecurityPossibleCacheValuesMinutes\";\n\t\t\tpublic const string AuthAppSessionTimeoutInSeconds = \"AuthAppSessionTimeoutInSeconds\";\n\n\t\t\t//Electronic Signatures\n\t\t\tpublic const string AdobeSignApiKey = \"AdobeSignApiKey\"; //This is the default (Application-wdie) stored value if the Account doesn't have a specifid API\n\t\t\tpublic const string EchoSignApiKey = \"EchoSignApiKey\"; //This is the default (Application-wdie) stored value if the Account doesn't have a specifid API\n\t\t\tpublic const string EchosignTestDocumentPath = \"EchosignTestDocumentPath\";\n\t\t\tpublic const string ESignatureTestRecipient = \"ESignatureTestRecipient\";\n\t\t\tpublic const string EchosignTestSignatureMessage = \"EchosignTestSignatureMessage\";\n\t\t\tpublic const string ElectronicSignatureWaitExpirationMinutes = \"ElectronicSignatureWaitExpirationMinutes\";\n\t\t\tpublic const string ElectronicSignatureMaxWaitExpirationDays = \"ElectronicSignatureMaxWaitExpirationDays\";\n\t\t\tpublic const string ESignMinPendingMinutes = \"ESignMinPendingMinutes\";\n\t\t\tpublic const string ESignMaxPendingMinutes = \"ESignMaxPendingMinutes\";\n\t\t\tpublic const string ElectronicSignatureMaxErrorCount = \"ElectronicSignatureMaxErrorCount\";\n\t\t\tpublic const string EchoSignWorkerCount = \"EchoSignWorkerCount\";\n\t\t\tpublic const string ESignPreviewWorkerCount = \"ESignPreviewWorkerCount\";\n\t\t\tpublic const string DocuSignWorkerCount = \"DocuSignWorkerCount\";\n\t\t\tpublic const string EchoSignWorkerSleepSeconds = \"EchoSignWorkerSleepSeconds\";\n\t\t\tpublic const string ESignPreviewWorkerSleepSeconds = \"ESignPreviewWorkerSleepSeconds\";\n\t\t\tpublic const string DocuSignWorkerSleepSeconds = \"DocuSignWorkerSleepSeconds\";\n\t\t\tpublic const string DocuSignMaxResponseContentBufferSize = \"DocuSignMaxResponseContentBufferSize\";\n\t\t\tpublic const string DocuSignMaxWaitExpirationDays = \"DocuSignMaxWaitExpirationDays\";\n\t\t\tpublic const string DocuSignAllowedDocExtensions = \"DocuSignAllowedDocExtensions\";\n\t\t\tpublic const string EchoSignWorkerMaxRowsPerRound = \"EchoSignWorkerMaxRowsPerRound\";\n\t\t\tpublic const string DocuSignWorkerMaxRowsPerRound = \"DocuSignWorkerMaxRowsPerRound\";\n\t\t\tpublic const string ESignRetryWorkerCount = \"ESignRetryWorkerCount\";\n\t\t\tpublic const string ESignRetryWorkerSleepSeconds = \"ESignRetryWorkerSleepSeconds\";\n\t\t\tpublic const string ESignatureRefreshActiveWorkerSleepSeconds = \"ESignatureRefreshActiveWorkerSleepSeconds\";\n\t\t\tpublic const string ESignatureRefreshActiveWorkerCount = \"ESignatureRefreshActiveWorkerCount\";\n\t\t\tpublic const string ESignatureRefreshRecordsUpdatedBeforeSeconds = \"ESignatureRefreshRecordsUpdatedBeforeSeconds\";\n\t\t\tpublic const string ESignatureRetryRefreshErrorWorkerCount = \"ESignatureRetryRefreshErrorWorkerCount\";\n\t\t\tpublic const string ESignatureRetryRefreshErrorWorkerSleepSeconds = \"ESignatureRetryRefreshErrorWorkerSleepSeconds\";\n\t\t\tpublic const string GenericCallbackPrefix = \"GenericCallbackPrefix\";\n\t\t\tpublic const string AuthCallbackPrefix = \"AuthCallbackPrefix\";\n\t\t\tpublic const string IncludeCallbackSuffixInVendorCallbackUrl = \"IncludeCallbackSuffixInVendorCallbackUrl\";\n\t\t\tpublic const string PollEchoSignStatusTimeoutInSeconds = \"PollEchoSignStatusTimeoutInSeconds\";\n\t\t\tpublic const string ElectronicSignatureLegalStatusKnowledgeUrl = \"ElectronicSignatureLegalStatusKnowledgeUrl\";\n\t\t\tpublic const string ElectronicSignatureCleanupWorkerCount = \"ElectronicSignatureCleanupWorkerCount\";\n\t\t\tpublic const string ElectronicSignatureCleanupWorkerSleepSeconds = \"ElectronicSignatureCleanupWorkerSleepSeconds\";\n\t\t\tpublic const string ElectronicSignatureCleanupWorkerMaxRetentionDays = \"ElectronicSignatureCleanupWorkerMaxRetentionDays\";\n\n\t\t\tpublic const string PlainTextExtractionMaxFileSize = \"PlainTextExtractionMaxFileSize\";\n\n\t\t\t//Document Reminders\n\t\t\tpublic const string DocumentReminderWorkerCount = \"DocumentReminderWorkerCount\";\n\t\t\tpublic const string DocumentReminderWorkerSleepSeconds = \"DocumentReminderWorkerSleepSeconds\";\n\t\t\tpublic const string DocumentReminderWorkerMaxRowsPerRound = \"DocumentReminderWorkerMaxRowsPerRound\";\n\t\t\tpublic const string DocumentReminderCleanupWorkerCount = \"DocumentReminderCleanupWorkerCount\";\n\t\t\tpublic const string DocumentReminderCleanupWorkerSleepSeconds = \"DocumentReminderCleanupWorkerSleepSeconds\";\n\t\t\tpublic const string DocumentReminderCleanupExpirationMinutes = \"DocumentReminderCleanupExpirationMinutes\";\n\n\t\t\t//SXTerms\n\t\t\tpublic const string TermMaxOptionLength = \"TermMaxOptionLength\";\n\t\t\tpublic const string TermMaxFileSize = \"TermMaxFileSize\";\n\t\t\tpublic const string Cached_Term_Key = \"CACHED_TERM_{0}_{1}\"; // CACHED_TERM_{accountId}_{termDocFileDataUid}\n\t\t\tpublic const int Cached_Term_ExpirationSeconds = 60 * 60 * 24 * 14; // 2 weeks\n\n\t\t\t//Email\n\t\t\tpublic const string AcceptedEmailDomain = \"AcceptedEmailDomain\";\n\t\t\tpublic const string OneNotificationEmailRetryCount = \"OneNotificationEmailRetryCount\";\n\t\t\tpublic const string OneNotificationEmailRetryIntervalInMs = \"OneNotificationEmailRetryIntervalInMs\";\n\t\t\tpublic const string OneNotificationCallbackUrlPath = \"OneNotificationCallbackUrlPath\";\n\t\t\tpublic const string OneNotificationIncludeCallbackUrl = \"OneNotificationIncludeCallbackUrl\";\n\t\t\tpublic const string OneNotificationCallbackUrl = \"OneNotificationCallbackUrl\";\n\t\t\tpublic const string OneNotificationEmailCacheTTLInSeconds = \"OneNotificationEmailCacheTTLInSeconds\";\n\t\t\tpublic const string OneNotificationLogErrorMessages = \"OneNotificationLogErrorMessages\";\n\t\t\tpublic const string OneNotificationEmailMaxRecipients = \"OneNotificationEmailMaxRecipients\";\n\t\t\tpublic const string OutboundEmailMaxRecipients = \"OutboundEmailMaxRecipients\";\n\t\t\tpublic const string MaxOutboundEmailsForAccountInSlidingWindow = \"MaxOutboundEmailsForAccountInSlidingWindow\";\n\t\t\tpublic const string EmailAccountIdCacheKeyPrefix = \"EmailAccountIdCacheKeyPrefix\";\n\n\t\t\t//External Review\n\t\t\tpublic const string ExternalReviewMaxPdfWaitTimeSeconds = \"ExternalReviewMaxPdfWaitTimeSeconds\";\n\t\t\tpublic const string ExternalReviewExpirationWorkerSleepSeconds = \"ExternalReviewExpirationWorkerSleepSeconds\";\n\t\t\tpublic const string EnableNewCompleteExternalReviewPage = \"EnableNewCompleteExternalReviewPage\";\n\t\t\tpublic const string ExternalReviewAttachmentCleanupTimeoutSeconds = \"ExternalReviewAttachmentCleanupTimeoutSeconds\";\n\t\t\tpublic const string ExternalReviewSafeToReplyEmailCleanupTimeoutSeconds = \"ExternalReviewSafeToReplyEmailCleanupTimeoutSeconds\";\n\t\t\tpublic const string EnableExternalReviewReplyToEmailUid = \"EnableExternalReviewReplyToEmailUid\";\n\t\t\tpublic const string ExternalReviewEmailProcessingUrl = \"ExternalReviewEmailProcessingUrl\";\n\t\t\tpublic const string ExternalReviewReplyToDomain = \"ExternalReviewReplyToDomain\";\n\t\t\tpublic const string ExternalReviewFromAddress = \"ExternalReviewFromAddress\";\n\t\t\tpublic const string EnableSetMaxTaskErrorCountWhenInvalidRecipients = \"EnableSetMaxTaskErrorCountWhenInvalidRecipients\";\n\t\t\tpublic const string ExternalReviewMaxExpirationDays = \"ExternalReviewMaxExpirationDays\";\n\t\t\tpublic const string ExternalReviewOnBehalfMaxConversionTimeInSecond = \"ExternalReviewOnBehalfMaxConversionTimeInSecond\";\n\t\t\tpublic const string EnableExternalReviewCompleteOnBehalf = \"EnableExternalReviewCompleteOnBehalf\";\n\t\t\tpublic const string EnableAssignmentInCompleteOnBehalf = \"EnableAssignmentInCompleteOnBehalf\";\n\t\t\tpublic const string ExternalReviewStatusViewList = \"ExternalReviewStatusViewList\";\n\t\t\tpublic const string UseExternalReviewDownloadableV2 = \"UseExternalReviewDownloadableV2\";\n\t\t\tpublic const string EformClientGuid = \"EformClientGuid\";\n\t\t\tpublic const string EmailFolderNotificationWaitTime = \"EmailFolderNotificationWaitTime\";\n\t\t\tpublic const string EmailSmtpServer = \"EmailSmtpServer\";\n\t\t\tpublic const string Environment = \"Environment\";\n\t\t\tpublic const string EnvironmentType = \"EnvironmentType\";\n\t\t\tpublic const string EnableRestTestClient = \"EnableRestTestClient\";\n\t\t\tpublic const string ErrorRetryMinutes = \"ErrorRetryMinutes\";\n\t\t\tpublic const string ErrorSleepMillis = \"ErrorSleepMillis\";\n\t\t\tpublic const string EventDispatcherEventQueuePath = \"EventDispatcherEventQueuePath\";\n\t\t\tpublic const string ExportSearchTTLSeconds = \"ExportSearchTTLSeconds\";\n\t\t\tpublic const string FileAgeMinutes = \"fileAgeMinutes\";\n\t\t\tpublic const string FolderCacheTimeoutSeconds = \"FolderCacheTimeoutSeconds\";\n\t\t\tpublic const string ImageOperationExtensions = \"ImageOperationExtensions\";\n\t\t\tpublic const string DocxOperationExtensions = \"DocxOperationExtensions\";\n\t\t\tpublic const string ImagePreviewExtensions = \"ImagePreviewExtensions\";\n\t\t\tpublic const string VideoExtensions = \"VideoExtensions\";\n\t\t\tpublic const string ExcelFileMaxPagesToConvert = \"ExcelFileMaxPagesToConvert\";\n\t\t\tpublic const string IPRestrictionsSpringRegex = \"IPRestrictionsSpringRegex\";\n\t\t\tpublic const string OutboundIPWhitelistRegex = \"OutboundIPWhitelistRegex\";\n\t\t\tpublic const string OutboundIPBlacklistRegex = \"OutboundIPBlacklistRegex\";\n\t\t\tpublic const string OutboundHostDenylistRegex = \"OutboundHostDenylistRegex\";\n\t\t\tpublic const string OutbountHostWarnlistRegex = \"OutboundHostWarnlistRegex\";\n\t\t\tpublic const string PDFStandInExtensions = \"PDFStandInExtensions\";\n\t\t\tpublic const string PdfOperationsConcatUseTempFile = \"PdfOperationsConcatUseTempFile\";\n\t\t\tpublic const string LWDPManipulationReservationSeconds = \"LWDPManipulationReservationSeconds\";\n\t\t\tpublic const string ImageWrapperGenerationQuality = \"ImageWrapperGenerationQuality\";\n\t\t\tpublic const string InboundEmailDomain = \"InboundEmailDomain\";\n\t\t\tpublic const string InterfaxOutboundPassword = \"InterfaxOutboundPassword\";\n\t\t\tpublic const string InterfaxOutboundUser = \"InterfaxOutboundUser\";\n\t\t\tpublic const string InterfaxInboundPassword = \"InterfaxInboundPassword\";\n\t\t\tpublic const string InterfaxInboundUser = \"InterfaxInboundUser\";\n\t\t\tpublic const string InvalidSalesforceCredentialEmailMaxFrequencySeconds = \"InvalidSalesforceCredentialEmailMaxFrequencySeconds\";\n\t\t\tpublic const string IsEchoSignEnabled = \"IsEchoSignEnabled\";\n\t\t\tpublic const string IsDocuSignEnabled = \"IsDocuSignEnabled\";\n\t\t\tpublic const string IsESignLiveEnabled = \"IsESignLiveEnabled\";\n\t\t\tpublic const string IsProntoSignEnabled = \"IsProntoSignEnabled\";\n\t\t\tpublic const string EchoSignCallbackUrlEnabled = \"EchoSignCallbackUrlEnabled\";\n\t\t\tpublic const string DocuSignCallbackUrlEnabled = \"DocuSignCallbackUrlEnabled\";\n\t\t\tpublic const string ESignLiveCallbackUrlEnabled = \"ESignLiveCallbackUrlEnabled\";\n\t\t\tpublic const string ProntoSignCallbackUrlEnabled = \"ProntoSignCallbackUrlEnabled\";\n\t\t\tpublic const string RegisterExternalReviewTokenWithAccountServer = \"RegisterExternalReviewTokenWithAccountServer\";\n\t\t\tpublic const string ExternalReviewApiBaseUrlFormat = \"ExternalReviewApiBaseUrlFormat\";\n\n\t\t\tpublic const string ShowServerStatus = \"showServerStatus\";\n\t\t\tpublic const string LogAllEvenIfCounted = \"LogAllEvenIfCounted\";\n\t\t\tpublic const string LogoPath = \"LogoPath\";\n\t\t\tpublic const string LongPollInterval = \"longPollInterval\";\n\t\t\tpublic const string LWDPThumbnailWidth = \"LWDPThumbnailWidth\";\n\t\t\tpublic const string MaxRetries = \"MaxRetries\";\n\t\t\tpublic const string MailFrom = \"mailFrom\";\n\t\t\tpublic const string MailFrom_Alternate = \"mailFrom_Alternate\";\n\t\t\tpublic const string MailFrom_OneNotification = \"MailFrom_OneNotification\";\n\t\t\tpublic const string MarketingUrlPrefix = \"MarketingUrl_\";\n\t\t\tpublic const string MarketoApiPrivateKey = \"MarketoApiPrivateKey\";\n\t\t\tpublic const string MaxBrowseDocumentBreadCrumbSize = \"maxBrowseDocumentBreadCrumbSize\";\n\t\t\tpublic const string MaxChunkUploadChunkSize = \"MaxChunkUploadChunkSize\";\n\t\t\tpublic const string MaximumAttachmentSize = \"maximumAttachmentSize\";\n\t\t\tpublic const string MaximumEmailSizeInBytes = \"maximumEmailSizeInBytes\";\n\t\t\tpublic const string UseBase64TotalEmailSize = \"useBase64TotalEmailSize\";\n\t\t\tpublic const string MaximumPaidFileSize = \"maximumPaidFileSize\";\n\t\t\tpublic const string MaximumTrialFileSize = \"maximumTrialFileSize\";\n\t\t\tpublic const string MaxDocumentsWhenAutoExpandingFolders = \"MaxDocumentsWhenAutoExpandingFolders\";\n\t\t\tpublic const string MaxloginAttempts = \"MaxloginAttempts\";\n\t\t\tpublic const string MaxSessionTimeoutMinutes = \"MaxSessionTimeoutMinutes\";\n\t\t\tpublic const string MaxUploadFailures = \"MaxUploadFailures\";\n\t\t\tpublic const string MergedDocumentViewMaxWaitMinutes = \"MergedDocumentViewMaxWaitMinutes\";\n\t\t\tpublic const string MergedDocumentViewRefreshSeconds = \"MergedDocumentViewRefreshSeconds\";\n\t\t\tpublic const string MobileUrlRoot = \"MobileUrlRoot\";\n\t\t\tpublic const string NotificationRefreshIntervalMs = \"NotificationRefreshIntervalMs\";\n\t\t\tpublic const string NDREmailBlockListLifespanInSeconds = \"NDREmailBlockListLifespanInSeconds\";\n\t\t\tpublic const string ProfileMQPathFormat = \"ProfileMQPathFormat\";\n\t\t\tpublic const string ProfileMQWorkers = \"ProfileMQWorkers\";\n\t\t\tpublic const string RestContentAllowDownload = \"RestContentAllowDownload\";\n\t\t\tpublic const string RestContentAllowUpload = \"RestContentAllowUpload\";\n\t\t\tpublic const string SFDCRowLimitForUserSync = \"SFDCRowLimitForUserSync\";\n\t\t\tpublic const string SiteTimeZoneId = \"SiteTimeZoneId\";\n\t\t\tpublic const string TabletDocumentUrlFormat = \"TabletDocumentUrlFormat\";\n\t\t\tpublic const string TabletFolderUrlFormat = \"TabletFolderUrlFormat\";\n\t\t\tpublic const string TabletHomeUrl = \"TabletHomeUrl\";\n\t\t\tpublic const string TabletLoginUrlFormat = \"TabletLoginUrlFormat\";\n\t\t\tpublic const string TabletSupportedUserAgentsRegex = \"TabletSupportedUserAgentsRegex\";\n\t\t\t/* MQ Settings */\n\t\t\tpublic const string MQAdminQueuePath = \"MQAdminQueuePath\";\n\t\t\tpublic const string MQReachQueueTimeout = \"MQReachQueueTimeout\";\n\t\t\tpublic const string MQReceiveTimeout = \"MQReceiveTimeout\";\n\t\t\tpublic const string MQReceiveWaitMS = \"MQReceiveWaitMS\";\n\t\t\tpublic const string MQResponseQueuePath = \"MQResponseQueuePath\";\n\t\t\tpublic const string MQSerializationType = \"MQSerializationType\";        // used in ScmMQ\n\t\t\tpublic const string ProfileMQ = \"ProfileMQ\";\n\t\t\tpublic const string ProfileMQEvents = \"ProfileMQEvents\";\n\t\t\tpublic const string MQUseDeadLetterQueue = \"MQUseDeadLetterQueue\";\n\t\t\tpublic const string TaskAttemptThreshold = \"_AttemptThreshold\";\n\t\t\tpublic const string TaskMaxErrorCount = \"_MaxErrorCount\";\n\t\t\tpublic const string TaskNotifyOnLastTryOnly = \"_NotifyOnLastTryOnly\";\n\t\t\t/* MQ Tasks */\n\t\t\tpublic const string ExtractOcrContentPerPageMaxThreshold = \"ExtractOcrContentPerPageMaxThreshold\";\n\t\t\tpublic const string MetadataDeleteBatchSize = \"MetadataDeleteBatchSize\";\n\t\t\tpublic const string AtlasEtl_EventMQPath = \"AtlasEtl_EventMQPath\";\n\t\t\tpublic const string CopyFolderActivity_EventMQPath = \"CopyFolderActivity_EventMQPath\";\n\t\t\tpublic const string EmailFailed_EventProcessorAQN = \"EmailFailed_EventProcessorAQN\";\n\t\t\tpublic const string ExecuteReportTask_AttemptThreshold = \"ExecuteReportTask_AttemptThreshold\";\n\t\t\tpublic const string ExecuteReportTask_MaxErrorCount = \"ExecuteReportTask_MaxErrorCount\";\n\t\t\tpublic const string LoadObjectsForReindexTask_MaxErrorCount = \"LoadObjectsForReindexTask_MaxErrorCount\";\n\t\t\tpublic const string UserAccountRemoveReferencesProcessorAutoUpdateLock = \"UserAccountRemoveReferencesProcessorAutoUpdateLock\";\n\t\t\tpublic const string UserAccountRemoveReferencesProcessorEnableLocking = \"UserAccountRemoveReferencesProcessorEnableLocking\";\n\t\t\tpublic const string UserAccountRemoveReferencesProcessorReservationTimeoutSeconds = \"UserAccountRemoveReferencesProcessorReservationTimeoutSeconds\";\n\n\t\t\t/* login throttling */\n\t\t\tpublic const string ResetPasswordRateLimitWindowDurationSeconds = \"ResetPasswordRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string ResetPasswordLimitWindowAllowedRequests = \"ResetPasswordLimitWindowAllowedRequests\";\n\t\t\tpublic const string TwoFactorRateLimitWindowDurationSeconds = \"TwoFactorRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string TwoFactorRateLimitAllowedRequests = \"TwoFactorRateLimitAllowedRequests\";\n\t\t\tpublic const string LoginReminderRateLimitWindowDurationSeconds = \"LoginRemidnerRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string LoginReminderLimitWindowAllowedRequests = \"LoginReminderLimitWindowAllowedRequests\";\n\n\t\t\t/* user email throttling */\n\t\t\tpublic const string EmailSendRateLimitWindowDurationSeconds = \"EmailSendRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string EmailSendRateLimitWindowAllowedRequests = \"EmailSendRateLimitWindowAllowedRequests\";\n\n\t\t\t/* Word Merge Settings */\n\t\t\tpublic const string MergeTempDir = \"MergeTempDir\";\n\t\t\tpublic const string CreateMergeTemplateHelpUrl = \"CreateMergeTemplateHelpUrl\";\n\n\t\t\tpublic const string NativeFaxableExtensions = \"NativeFaxableExtensions\";\n\t\t\tpublic const string OCRExtractorExtensions = \"OCRExtractorExtensions\";\n\t\t\tpublic const string TessnetOCRExtensions = \"TessnetOCRExtensions\";\n\t\t\tpublic const string PassiveEndPort = \"PassiveEndPort\";\n\t\t\tpublic const string PassiveStartPort = \"PassiveStartPort\";\n\t\t\tpublic const string PassiveTimeout = \"PassiveTimeout\";\n\t\t\tpublic const string PdfConversionMaxNativeFileSize = \"PdfConversionMaxNativeFileSize\";\n\t\t\tpublic const string PdfManipulationPassiveMode = \"PdfManipulationPassiveMode\";\n\t\t\tpublic const string PdfManipulationTempMergeLocation = \"PdfManipulationTempMergeLocation\";\n\t\t\tpublic const string PasteTaskResultTempStorage = \"PasteTaskResultTempStorage\";\n\t\t\tpublic const string PollInterval = \"pollInterval\";\n\t\t\tpublic const string PreviewImageBaseDpi = \"PreviewImageBaseDpi\";\n\t\t\tpublic const string PreviewOutputFormat = \"PreviewOutputFormat\";\n\t\t\tpublic const string PreviewReloadMaxTries = \"PreviewReloadMaxTries\";\n\t\t\tpublic const string PreviewReloadTimeout = \"PreviewReloadTimeout\";\n\t\t\tpublic const string PageCountOnDemandTimeoutMilliseconds = \"PageCountOnDemandTimeoutMilliseconds\";\n\t\t\tpublic const string Profile = \"profile\";\n\t\t\tpublic const string ProcessTimeoutMinutes = \"ProcessTimeoutMinutes\";\n\t\t\tpublic const string ProfileInsertCommandTimeout = \"ProfileInsertCommandTimeout\";\n\t\t\tpublic const string RemotePdfServiceMaxRows = \"RemotePdfServiceMaxRows\";\n\t\t\tpublic const string RemotePdfServiceNoWorkSleepInSeconds = \"RemotePdfServiceNoWorkSleepInSeconds\";\n\t\t\tpublic const string RemotePdfServiceNoAvaibleThreadsSleepInMilliSeconds = \"RemotePdfServiceNoAvaibleThreadsSleepInMilliSeconds\";\n\t\t\tpublic const string RemotePdfServiceNoAvaibleMemorySleepInMilliSeconds = \"RemotePdfServiceNoAvaibleMemorySleepInMilliSeconds\";\n\t\t\tpublic const string RemotePdfServiceMaxRuntimeFileSizeAllowed = \"RemotePdfServiceMaxRuntimeFileSizeAllowed\";\n\t\t\tpublic const string RemotePdfServicePdfSaveLocation = \"RemotePdfServicePdfSaveLocation\";\n\t\t\tpublic const string RemotePdfServicePdfTouchCount = \"RemotePdfServicePdfTouchCount\";\n\t\t\tpublic const string RemotePdfServiceThumbnailWidth = \"RemotePdfServiceThumbnailWidth\";\n\t\t\tpublic const string RegularOCREnabled = \"RegularOCREnabled\";\n\t\t\tpublic const string RelayEmail = \"RelayEmail\";\n\t\t\tpublic const string EmailPayloadSharedStorageTTLSeconds = \"EmailPayloadSharedStorageTTLSeconds\";\n\t\t\tpublic const string SaveEmailPayloadToSharedStorage = \"SaveEmailPayloadToSharedStorage\";\n\t\t\tpublic const string ReportExportDownloadDelayMs = \"ReportExportDownloadDelayMs\";\n\t\t\tpublic const string ReportingServicesCacheTimeout = \"ReportingServicesCacheTimeout\";\n\t\t\tpublic const string ReportingServicesUrl = \"ReportingServicesUrl\";\n\t\t\tpublic const string ReportingServicesExecutionUrl = \"ReportingServicesExecutionUrl\";\n\t\t\tpublic const string ReportingServicesExecutionTimeout = \"ReportingServicesExecutionTimeout\";\n\t\t\tpublic const string ReportingServicesViewerUrl = \"ReportingServicesViewerUrl\";\n\t\t\tpublic const string ReportingServicesBaseModelPath = \"ReportingServicesBaseModelPath\";\n\t\t\tpublic const string ReportingServicesMaxSet = \"ReportingServicesMaxSet\";\n\t\t\tpublic const string ReportingServicesQueryTimeout = \"ReportingServicesQueryTimeout\";\n\t\t\tpublic const string ReportingServicesScheduleID = \"ReportingServicesScheduleID\";\n\t\t\tpublic const string ResourceUrlRoot = \"ResourceUrlRoot\";\n\t\t\tpublic const string StaticResourceUrlFormat = \"StaticResourceUrlFormat\";\n\t\t\tpublic const string UseDeployedStaticResources = \"UseDeployedStaticResources\";\n\t\t\tpublic const string UseWebApplicationRootOverride = \"UseWebApplicationRootOverride\";\n\t\t\tpublic const string WebApplicationRootOverride = \"WebApplicationRootOverride\";\n\t\t\tpublic const string WebApplicationRedirectOverride = \"WebApplicationRedirectOverride\";\n\t\t\tpublic const string UseCookiePathOverride = \"UseCookiePathOverride\";\n\t\t\tpublic const string WebCookiePathOverride = \"WebCookiePathOverride\";\n\t\t\tpublic const string NonRelayDomainsRegex = \"NonRelayDomainsRegex\";\n\t\t\tpublic const string SplitEmailAddressRegex = \"SplitEmailAddressRegex\";\n\t\t\tpublic const string SplitDocumentTempLocation = \"SplitDocumentTempLocation\";\n\t\t\tpublic const string SearchStopWords = \"SearchStopWords\";\n\t\t\tpublic const string SearchQueryDefaultPageSize = \"SearchQueryDefaultPageSize\";\n\t\t\tpublic const string ShowLegacyReports = \"ShowLegacyReports\";\n\t\t\t//public const string Site = \"Site\"; //Using this with Configuration.GetStringAppSetting would return the full site name, instead use ApplicationSettings.Site for the correct short site name\n\t\t\tpublic const string SnippetsHighlightFormat = \"SnippetsHighlightFormat\";\n\t\t\tpublic const string SFBatchSize = \"SFBatchSize\";\n\t\t\tpublic const string SForceMetadataGroup = \"SForceMetadataGroup\";\n\t\t\tpublic const string SFAccountMetaDataField = \"SFAccountMetaDataField\";\n\t\t\tpublic const string SFChildIdMetadataField = \"SFChildIdMetadataField\";\n\t\t\tpublic const string SFClientId = \"SFClientId\";\n\t\t\tpublic const string SFProdApiUrl = \"SFProdApiUrl\";\n\t\t\tpublic const string SFApiUrlFormat = \"SFApiUrlFormat\";\n\t\t\tpublic const string SFAPIVersion = \"SFAPIVersion\";\n\t\t\tpublic const string SalesforceBatchSize = \"SalesforceBatchSize\";\n\t\t\tpublic const string SalesforceInstanceURITerminationString = \"SalesforceInstanceURITerminationString\";\n\t\t\tpublic const string SFIntegrationClientId = \"SFIntegrationClientId\";\n\t\t\tpublic const string SFIntegrationTokenRedirectUrlFormat = \"SFIntegrationTokenRedirectUrlFormat\";\n\t\t\tpublic const string SFManagedPackageIntegrationTokenRedirectUrlFormat = \"SFManagedPackageIntegrationTokenRedirectUrlFormat\";\n\t\t\tpublic const string SFDisplayForRefreshTokens = \"SFDisplayForRefreshTokens\";\n\t\t\tpublic const string SalesforceFileItPackageUrl = \"SalesforceFileItPackageUrl\";\n\t\t\tpublic const string SpringCMSalesforceConfigUrlPath = \"SpringCMSalesforceConfigUrlPath\";\n\t\t\tpublic const string SalesforceSpringCMConfigUrlPath = \"SalesforceSpringCMConfigUrlPath\";\n\t\t\tpublic const string SalesforceCLMConfigUrlPath = \"SalesforceCLMConfigUrlPath\";\n\t\t\tpublic const string SalesforceCLMGenTemplatesUrlPath = \"SalesforceCLMGenTemplatesUrlPath\";\n\t\t\tpublic const string SpringCMSalesforceViewerUrlPath = \"SpringCMSalesforceViewerUrlPath\";\n\t\t\tpublic const string FederatedSearchSalesforceViewerUrlPath = \"FederatedSearchSalesforceViewerUrlPath\";\n\t\t\tpublic const string SyncUseReportDb = \"SyncUseReportDb\";\n\t\t\tpublic const string SyncReportDbLatencySec = \"SyncReportDbLatencySec\";\n\t\t\tpublic const string SyncManifestTimeDriftSec = \"SyncManifestTimeDriftSec\";\n\t\t\tpublic const string SFFileItDevSecret = \"SFFileItDevSecret\";\n\t\t\tpublic const string SFFileItSecret = \"SFFileItSecret\";\n\t\t\tpublic const string SFOAuthRequestTokenURLFormat = \"SFOAuthRequestTokenURLFormat\";\n\t\t\tpublic const string SFRestAPIVersion = \"SFRestAPIVersion\";\n\t\t\tpublic const string SFOauthRedirectUrl = \"SFOauthRedirectUrl\";\n\t\t\tpublic const string GenSFOauthRedirectUrl = \"GenSFOauthRedirectUrl\";\n\t\t\tpublic const string SFFileItNamespace = \"SFFileItNamespace\";\n\t\t\tpublic const string SFPackageCNamespace = \"SFPackageCNamespace\";\n\t\t\tpublic const string SFDevFileItNamespace = \"SFDevFileItNamespace\";\n\t\t\tpublic const string SFFileItUrl = \"SFFileItUrl\";\n\t\t\tpublic const string SFFileItInstructions = \"SFFileItInstructions\";\n\t\t\tpublic const string SFCLMPackageInstructions = \"SFCLMPackageInstructions\";\n\t\t\tpublic const string SFDomains = \"SFDomains\";\n\t\t\tpublic const string SFValidateUrl = \"SFValidateUrl\";\n\n\n\t\t\tpublic const string ObsoleteCustomCustomReports = \"ObsoleteCustomCustomReports\";\n\n\t\t\tpublic const string InterFaxRequiresEndChunkEveryFile = \"InterFaxRequiresEndChunkEveryFile\";\n\t\t\tpublic const string InterFaxChunkUploadSize = \"InterFaxChunkUploadSize\";\n\t\t\tpublic const string InterFaxRetryCount = \"InterFaxRetryCount\";\n\n\t\t\tpublic const string MaxMemoryStreamSizeInBytes = \"MaxMemoryStreamSizeInBytes\";\n\t\t\tpublic const string StoreEnqueuedMergeTaskStringDataSourceInTempStorage = \"StoreEnqueuedMergeTaskStringDataSourceInTempStorage\";\n\t\t\tpublic const string MergeTaskDataSourceMaxLength = \"MergeTaskDataSourceMaxLength\";\n\t\t\tpublic const string SFAuthCacheTTLInSeconds = \"SFAuthCacheTTLInSeconds\";\n\n\t\t\t//For SAML SSO\n\t\t\tpublic const string SAMLAuthContexts = \"SAMLAuthContexts\";\n\t\t\tpublic const string SAMLEntityId = \"SAMLEntityId\";\n\t\t\tpublic const string SAMLOrgName = \"SAMLOrgName\";\n\t\t\tpublic const string SAMLLang = \"SAMLLang\";\n\t\t\tpublic const string SSOSignVerifyCert = \"SAMLSignVerifyCert\";\n\t\t\tpublic const string SSOSigningCert = \"SAMLSigningCert\";\n\t\t\tpublic const string SSOSigningCertPWD = \"SAMLSigningCertPWD\";\n\t\t\tpublic const string AuthenticationApplicationVerifyCert = \"AuthenticationApplicationVerifyCert\";\n\t\t\tpublic const string AuthenticationApplicationSigningCert = \"AuthenticationApplicationSigningCert\";\n\t\t\tpublic const string AuthenticationApplicationSigningCertPassword = \"AuthenticationApplicationSigningCertPassword\";\n\t\t\tpublic const string SAMLPublishedSpringPublicCertificate = \"SAMLPublishedSpringPublicCertificate\";\n\t\t\tpublic const string SAMLMetadataUrl = \"SAMLMetadataUrl\";\n\t\t\tpublic const string SamlEndointDomain = \"SamlEndointDomain\";\n\t\t\tpublic const string SfIssuerDomains = \"SfIssuerDomains\";\n\t\t\tpublic const string OktaIssuerDomains = \"OktaIssuerDomains\";\n\t\t\tpublic const string OneLoginIssuerDomains = \"OneLoginIssuerDomains\";\n\t\t\tpublic const string CustomSAMLNameIdentifier = \"CustomSAMLNameIdentifier\";\n\n\t\t\t/// <summary>\n\t\t\t/// For salesforce even though it doesn't allow for www.salesforce.com you\n\t\t\t/// can use na1.salesforce.com and it will redirect you on login to the correct\n\t\t\t/// subdomain.  If this ever breaks then it can no longer be an application setting\n\t\t\t/// </summary>\n\t\t\tpublic const string AppExchangeSpringCMUrl = \"AppExchangeSpringCMUrl\";\n\t\t\tpublic const string SFDocTabUrl = \"SFDocTabUrl\";\n\t\t\tpublic const string SFPackageUrl = \"SFPackageUrl\";\n\t\t\tpublic const string SFServiceUrl = \"SFServiceURL\";\n\t\t\tpublic const string SftpListenPort = \"SftpListenPort\";\n\t\t\tpublic const string DisposeSSHServer = \"DisposeSSHServer\";\n\t\t\tpublic const string DisposeSSHServerOnFinalize = \"DisposeSSHServerOnFinalize\";\n\t\t\tpublic const string SignUpPageURL = \"SignUpPageURL\";\n\t\t\tpublic const string SingleObjectCacheLifetimeSeconds = \"SingleObjectCacheLifetimeSeconds\";\n\t\t\tpublic const string SingleObjectCacheObjectLifetimeSeconds = \"SingleObjectCacheObjectLifetimeSeconds\";\n\t\t\tpublic const string SleepLong = \"SleepLong\";\n\t\t\tpublic const string SleepSeconds = \"sleepSeconds\";\n\t\t\tpublic const string SleepShort = \"SleepShort\";\n\t\t\tpublic const string SleepStandard = \"SleepStandard\";\n\t\t\tpublic const string SMTPServer = \"SMTPServer\";\n\t\t\tpublic const string SMTPServer_Alternate = \"SMTPServer_Alternate\";\n\t\t\tpublic const string SmtpServerPort = \"SmtpServerPort\";\n\t\t\tpublic const string SmtpServerPort_Alternate = \"SmtpServerPort_Alternate\";\n\t\t\tpublic const string SMTPListenPort = \"SmtpListenPort\";\n\t\t\tpublic const string SupportUrlPrefix = \"SupportUrl_\";\n\t\t\tpublic const string TemplateSourceDirectory = \"templateSourceDirectory\";\n\t\t\tpublic const string ThreadCount = \"ThreadCount\";\n\t\t\tpublic const string SFSetUpIntegrationUserRedirectUrl = \"SFSetUpIntegrationUserRedirectUrl\";\n\t\t\tpublic const string CLMSalesforcePackageUrl = \"CLMSalesforcePackageUrl\";\n\n\t\t\tpublic const string SSOIssueTimeout = \"SSOIssueTimeout\";\n\t\t\tpublic const string SSOBeforeOnOrAfterFuzzyMin = \"SSOBeforeOnOrAfterFuzzyMin\";\n\t\t\tpublic const string SSOCertificateFileName = \"SSOCertificateFileName\";\n\n\t\t\tpublic const string FolderPortalHelpUrl = \"FolderPortalHelpUrl\";\n\n\t\t\t// Feature Toggles\n\t\t\tpublic const string Toggle_DocumentReminderTemplates = \"Toggle_DocumentReminderTemplates\";\n\t\t\tpublic const string HideAlphaLanguageSettings = \"HideAlphaLanguageSettings\";\n\n\t\t\t// Number of thumbnails to get on the edit doc page per \"gulp\"\n\t\t\tpublic const string ThumbnailsPerPage = \"ThumbnailsPerPage\";\n\t\t\tpublic const int ThumbnailsPerPageDefault = 20;\n\t\t\tpublic const string TileViewPreviewRetryIntervals = \"TileViewPreviewRetryIntervals\";\n\n\n\t\t\tpublic const string UploadRootUrl = \"UploadRootUrl\";\n\t\t\tpublic const string FastUploadRootUrl = \"FastUploadRootUrl\";\n\t\t\t/* URLs in SpringCM Settings */\n\t\t\tpublic const string UrlMimeTypes = \"UrlMimeTypes\";\n\t\t\tpublic const string UrlAllowedProtocols = \"UrlAllowedProtocols\";\n\n\t\t\tpublic const string TotalSecondsWarning = \"totalSecondsWarning\";\n\t\t\tpublic const string TrashOldNumDays = \"TrashOldNumDays\";\n\t\t\tpublic const string TrialPeriod = \"TrialPeriod\";\n\t\t\tpublic const string UnlockUsersIntervalInMinutes = \"UnlockUsersIntervalInMinutes\";\n\t\t\tpublic const string UpgradeCallMeEmail = \"UpgradeCallMeEmail\";\n\t\t\tpublic const string UploadServiceNamespace = \"UploadServiceNamespace\";\n\t\t\tpublic const string UserSyncAddressBookTempStorage = \"UserSyncAddressBookTempStorage\";\n\t\t\tpublic const string UseABCpdfExtraChecks = \"UseABCpdfExtraChecks\";\n\t\t\tpublic const string ViewableFileExtensions = \"ViewableFileExtensions\";\n\t\t\tpublic const string VerifyUserExpirationIntervalDays = \"VerifyUserExpirationIntervalDays\";\n\t\t\tpublic const string ValidateEmailsBeforeSending = \"ValidateEmailsBeforeSending\";\n\n\t\t\tpublic const string PartySyncTempStorage = \"PartySyncTempStorage\";\n\t\t\tpublic const string MergeTaskTempStorage = \"MergeTaskTempStorage\";\n\t\t\tpublic const string TranslationImportTempStorage = \"TranslationImportTempStorage\";\n\t\t\tpublic const string WorkflowTaskTempStorage = \"WorkflowTaskTempStorage\";\n\n\t\t\tpublic const string WebServiceChunkSize = \"WebServiceChunkSize\";\n\t\t\tpublic const string WebServicesPathElement = \"WebServicesPathElement\";\n\t\t\tpublic const string WebServicesApiUrlFormat = \"WebServicesApiUrlFormat\";\n\t\t\tpublic const string WebServicesRestUrlFormat = \"WebServicesRestUrlFormat\";\n\t\t\tpublic const string WebServicesSyncUrlFormat = \"WebServicesSyncUrlFormat\";\n\t\t\tpublic const string WebServicesSoapUrlFormat = \"WebServicesSoapUrlFormat\";\n\t\t\tpublic const string WebServicesRestDownloadUrlFormat = \"WebServicesRestDownloadUrlFormat\";\n\t\t\tpublic const string WebServicesRestUploadUrlFormat = \"WebServicesRestUploadUrlFormat\";\n\t\t\tpublic const string WorkDirectory = \"workDirectory\";\n\n\t\t\tpublic const string WebServiceMaxObjectArrayLength = \"WebServiceMaxObjectArrayLength\";\n\n\t\t\tpublic const string WorkflowAnalyticsConfigCacheTtlSecs = \"WorkflowAnalyticsConfigCacheTtlSecs\";\n\n\t\t\tpublic const string WorkflowNotificationSupportAddress = \"WorkflowNotificationSupportAddress\";\n\t\t\tpublic const string MonitorWorkflowMaxVariableNodeCount = \"MonitorWorkflowMaxVariableNodeCount\";\n\t\t\tpublic const string WinsErrorRetrySeconds = \"WinsErrorRetrySeconds\";\n\t\t\tpublic const string WinsLockExpirationSeconds = \"WinsLockExpirationSeconds\";\n\t\t\tpublic const string WinsPurgeWorkerReservationSeconds = \"WinsPurgeWorkerReservationSeconds\";\n\t\t\tpublic const string WinsRemoteCallTimeoutMilliseconds = \"WinsRemoteCallTimeoutMilliseconds\";\n\t\t\tpublic const string WinsRemoteCallRetryDelayMilliseconds = \"WinsRemoteCallRetryDelayMilliseconds\";\n\t\t\tpublic const string WinsWaitForIdleTimeoutSeconds = \"WinsWaitForIdleTimeoutSeconds\";\n\t\t\tpublic const string WinsServiceUrl = \"WinsServiceUrl\";\n\t\t\tpublic const string WinsSlowServiceUrl = \"WinsSlowServiceUrl\";\n\t\t\tpublic const string ExplicitWinsUrlFormat = \"ExplicitWinsUrlFormat\";\n\t\t\tpublic const string EnableWorkflowSettingsCache = \"EnableWorkflowSettingsCache\";\n\t\t\tpublic const string WorkflowSettingsCacheTTLSeconds = \"WorkflowSettingsCacheTTLSeconds\";\n\n\t\t\tpublic const string EssentialsPlanDefaultWINSDatabaseConnectionString =\n\t\t\t\t\"EssentialsPlanDefaultWINSDatabaseConnectionString\";\n\n\t\t\tpublic const string EssentialsPlanDefaultRemoteWinsUrl = \"EssentialsPlanDefaultRemoteWinsUrl\";\n\n\t\t\tpublic const string ACEResourceUrlPattern = \"ACEResourceUrlPattern\";\n\n\t\t\tpublic const string VideoMaxWidth = \"VideoMaxWidth\";\n\t\t\tpublic const string VideoMaxHeight = \"VideoMaxHeight\";\n\n\t\t\t// It is expected each machine to have a local space for temporary storage.\n\t\t\t// It is expected to be the same across all machines (t:\\temp).\n\t\t\t// If not configured, the environment's TEMP location will be used.\n\t\t\tpublic const string MachineTempPath = \"MachineTempPath\";\n\n\t\t\tpublic const string GhostScriptTimeout = \"GhostScriptTimeout\";\n\t\t\tpublic const string GoogleTagManagerId = \"GoogleTagManagerId\";\n\n\t\t\t//Redis strings\n\t\t\tpublic const string RedisConnectionString = \"RedisConnectionString\";\n\t\t\tpublic const string RedisDbNum = \"RedisDbNum\";\n\t\t\tpublic const string RedisPhaseDurationThreshold = \"RedisPhaseDurationThreshold\";\n\n\t\t\tpublic const string DocuSignApiKey = \"DocuSignApiKey\";\n\t\t\tpublic const string DocuSignRestLoginUrl = \"DocuSignRestLoginUrl\";\n\t\t\tpublic const string DocuSignRestApiAccountsUrlFormat = \"DocuSignRestApiAccountsUrlFormat\";\n\t\t\tpublic const string DocuSignRestApiAccountsUrlFormatForProviderDocuments = \"DocuSignRestApiAccountsUrlFormatForProviderDocuments\";\n\n\t\t\tpublic const string DocuSignDeveloperUrl = \"DocuSignDeveloperUrl\";\n\t\t\tpublic const string DocuSignRestBaseUrl = \"DocuSignRestBaseUrl\";\n\n\t\t\tpublic const string ESignLivRestApiUrl = \"ESignLivRestApiUrl\";\n\t\t\tpublic const string ElectronicSignatureDocuSignEndpoints = \"ElectronicSignatureDocuSignEndpoints\";\n\t\t\tpublic const string ElectronicSignatureESignLiveEndpoints = \"ElectronicSignatureESignLiveEndpoints\";\n\t\t\tpublic const string AdobeSignRestApiUrl = \"AdobeSignRestApiUrl\";\n\t\t\tpublic const string ElectronicSignatureBulkRefreshProviders = \"ElectronicSignatureBulkRefreshProviders\";\n\n\t\t\t//REST API\n\t\t\tpublic const string RestApiBaseUrl = \"RestApiBaseUrl\";\n\t\t\tpublic const string RefreshTokenExpirationDays = \"RefreshTokenExpirationDays\";\n\t\t\tpublic const string RestApiPageSize = \"RestApiPageSize\";\n\t\t\tpublic const string RestApiMaxPageSize = \"RestApiMaxPageSize\";\n\t\t\tpublic const string IsWebApiTestingEnvironment = \"IsWebApiTestingEnvironment\";\n\t\t\tpublic const string RestApiErrorHandlingEnabled = \"RestApiErrorHandlingEnabled\";\n\t\t\tpublic const string ExcludeFromRateLimitClientIdsCacheDuration = \"ExcludeFromRateLimitClientIdsCacheDuration\";\n\t\t\tpublic const string RestApiLogRequests = \"RestApiLogRequests\";\n\t\t\tpublic const string EnableHttpResponseCompression = \"EnableHttpResponseCompression\";\n\t\t\tpublic const string RequestLoggingHandlerUrlContains = \"RequestLoggingHandlerUrlContains\";\n\t\t\tpublic const string ElectronicSignatureDocuSignRestApiVersion = \"ElectronicSignatureDocuSignRestApiVersion\";\n\n\t\t\tpublic const string ConcurrentRequestExpirationSeconds = \"ConcurrentRequestExpirationSeconds\";\n\n\t\t\tpublic const string SendUsingEmailRefactoring = \"SendUsingEmailRefactoring\";\n\n\t\t\tpublic const string SFUserSyncCacheTimeInSeconds = \"SFUserSyncCacheTimeInSeconds\";\n\t\t\tpublic const string SFUserSyncWorkerSleepSeconds = \"SFUserSyncWorkerSleepSeconds\";\n\t\t\tpublic const string SalesforceDowntimeStart = \"SalesforceDowntimeStart\";\n\t\t\tpublic const string SalesforceDowntimeEnd = \"SalesforceDowntimeEnd\";\n\n\t\t\tpublic const string WebApiErrorDetailPolicy = \"WebApiErrorDetailPolicy\";\n\n\t\t\tpublic const string InternalApiRootFormat = \"InternalApiRootFormat\";\n\t\t\tpublic const string EnableInternalApiSwagger = \"EnableInternalApiSwagger\";\n\t\t\tpublic const string InternalApiSwaggerScheme = \"InternalApiSwaggerScheme\";\n\t\t\tpublic const string EnableInternalApiRateLimit = \"EnableInternalApiRateLimit\";\n\t\t\tpublic const string InternalApiRateLimitWindowAllowedRequests = \"InternalApiRateLimitWindowAllowedRequests\";\n\t\t\tpublic const string InternalApiRateLimitWindowDurationSeconds = \"InternalApiRateLimitWindowDurationSeconds\";\n\t\t\tpublic const string InternalApiRateLimitCounterSyncInterval = \"InternalApiRateLimitCounterSyncInterval\";\n\t\t\tpublic const string InternalApiAiCallbackMaxLength = \"InternalApiAiCallbackMaxLength\";\n\n\t\t\t//SOAP\n\t\t\tpublic const string SoapVersionEnabled = \"SoapVersionEnabled\";\n\n\t\t\t// Extract Service Extensions\n\t\t\tpublic const string WindowsExtractorExtensions = \"WindowsExtractorExtensions\";\n\t\t\tpublic const string PdfFallBackExtensions = \"PdfFallBackExtensions\";\n\t\t\tpublic const string ExtractFromPdfRenditionExtensions = \"ExtractFromPdfRenditionExtensions\";\n\n\t\t\t//External Fonts\n\t\t\tpublic const string ExternalFontUrl = \"ExternalFontUrl\";\n\n\t\t\t//Document Package Builder\n\t\t\tpublic const string DocumentLauncherStep1InstructionsMaxCharacters = \"DocumentLauncherStep1InstructionsMaxCharacters\";\n\t\t\tpublic const string DocumentLauncherStep2InstructionsMaxCharacters = \"DocumentLauncherStep2InstructionsMaxCharacters\";\n\t\t\tpublic const string DocumentLauncherSuccessMessageMaxCharacters = \"DocumentLauncherSuccessMessageMaxCharacters\";\n\t\t\tpublic const string DocumentLauncherDataMaxDataSizeInKB = \"DocumentLauncherDataMaxDataSizeInKB\";\n\t\t\tpublic const string DocumentLauncherConfigMetadataItemsPerPage = \"DocumentLauncherConfigMetadataItemsPerPage\";\n\t\t\tpublic const string LogInTextMaxCharacterLength = \"LogInTextMaxCharacterLength\";\n\n\t\t\t//Branding\n\t\t\tpublic const string BrandingPrimaryColor = \"BrandingPrimaryColor\";\n\t\t\tpublic const string BrandingSecondaryColor = \"BrandingSecondaryColor\";\n\t\t\tpublic const string BrandingPolarisPrimaryColor = \"BrandingPolarisPrimaryColor\";\n\t\t\tpublic const string BrandingPolarisSecondaryColor = \"BrandingPolarisSecondaryColor\";\n\n\t\t\t//Swift settings\n\t\t\tpublic const string SwiftAuthUrl = \"SwiftAuthUrl\";\n\t\t\tpublic const string Swift2AuthUrl = \"Swift2AuthUrl\";\n\t\t\tpublic const string SwiftTransientAuthUrl = \"SwiftTransientAuthUrl\";\n\t\t\tpublic const string SwiftSharedStorageTTLSeconds = \"SwiftSharedStorageTTLSeconds\";\n\t\t\tpublic const string EnableSwiftSharedStorageFallback = \"EnableSwiftSharedStorageFallback\";\n\n\t\t\t//Two Factor\n\t\t\tpublic const string TwoFactorBarcodeSize = \"TwoFactorBarcodeSize\";\n\t\t\tpublic const string TwoFactorTimeToleranceMinutes = \"TwoFactorTimeToleranceMinutes\";\n\t\t\tpublic const string TwoFactorAuthenticatorLinkAndroid = \"TwoFactorAuthenticatorLinkAndroid\";\n\t\t\tpublic const string TwoFactorAuthenticatorLinkIPhone = \"TwoFactorAuthenticatorLinkIPhone\";\n\t\t\tpublic const string TwoFactorAuthenticationGracePeriodDays = \"TwoFactorAuthenticationGracePeriodDays\";\n\t\t\tpublic const string TwoFactorIssuerFormat = \"TwoFactorIssuerFormat\";\n\t\t\tpublic const string FailedLogInAuthenticationSleepRandomLowerLimitMs = \"FailedLogInAuthenticationSleepRandomLowerLimitMs\";\n\t\t\tpublic const string FailedLogInAuthenticationSleepRandomUpperLimitMs = \"FailedLogInAuthenticationSleepRandomUpperLimitMs\";\n\n\t\t\t#region Office Web Apps\n\n\t\t\tpublic const string OfficeWebAppsDiscoveryUrl = \"OfficeWebAppsDiscoveryUrl\";\n\t\t\tpublic const string OfficeWebAppsApiRoot = \"OfficeWebAppsApiRoot\";\n\t\t\tpublic const string OfficeWebAppsClientGuid = \"OfficeWebAppsClientGuid\";\n\t\t\tpublic const string OfficeWebAppsConfigurationTTL = \"OfficeWebAppsConfigurationTTL\";\n\t\t\tpublic const string OfficeWebAppsSupportsWriteRelative = \"OfficeWebAppsSupportsWriteRelative\";\n\t\t\tpublic const string OfficeWebAppsInactiveDraftVersionMinutes = \"OfficeWebAppsInactiveDraftVersionMinutes\";\n\t\t\tpublic const string EnableOfficeWebAppsRequestLogging = \"EnableOfficeWebAppsRequestLogging\";\n\t\t\tpublic const string OfficeWebAppsDocumentReservationExpireSeconds = \"OfficeWebAppsDocumentReservationExpireSeconds\";\n\t\t\tpublic const string AllowUnsupportedBrowserClientIds = \"AllowUnsupportedBrowserClientIds\";\n\n\t\t\t#endregion\n\n\t\t\tpublic const string SpackageMaxDocumentsAddedCount = \"SpackageMaxDocumentsAddedCount\";\n\t\t\tpublic const string SpackageMaxDocumentsAddedBytes = \"SpackageMaxDocumentsAddedBytes\";\n\t\t\tpublic const string SpackageV2SigningKeyReferenceName = \"SpackageV2SigningKeyReferenceName\";\n\n\t\t\t//Allocation/Propagation\n\t\t\tpublic const string MasterSite = \"MasterSite\";\n\t\t\tpublic const string AllocationRootFormat = \"AllocationRootFormat\";\n\t\t\tpublic const string ManagedSites = \"ManagedSites\";\n\t\t\tpublic const string RequestTimeToleranceMinutes = \"RequestTimeToleranceMinutes\";\n\t\t\tpublic const string AuthenticationApplicationServedSites = \"AuthenticationApplicationServedSites\";\n\t\t\tpublic const string AuthenticationSites = \"AuthenticationSites\";\n\t\t\tpublic const string AuthenticationSite = \"AuthenticationSite\";\n\n\t\t\tpublic const string ProvisioningRootFormat = \"ProvisioningRootFormat\";\n\t\t\tpublic const string ProvisioningSiteByPlanIdFormat = \"ProvisioningSiteByPlanId_{0}\";\n\t\t\tpublic const string DeniedProvisioningSiteByModuleIdFormat = \"DeniedProvisioningSiteByModuleIdFormat_{0}\";\n\n\t\t\tpublic const string CrossDomainAntiforgeryTimeToleranceMinutes = \"CrossDomainAntiforgeryTimeToleranceMinutes\";\n\n\t\t\tpublic const string AuthContentSecurityPolicy = \"AuthContentSecurityPolicy\";\n\n\t\t\t// Walkthrough\n\t\t\tpublic const string Walkthrough_NewNavigation = \"Walkthrough_NewNavigation\";\n\n\t\t\tpublic const string DocxXmlMergeProcessor_MaxRecursionCount = \"DocxXmlMergeProcessor_MaxRecursionCount\";\n\t\t\tpublic const string EditDownloadTokenLength = \"EditDownloadTokenLength\";\n\t\t\tpublic const string EditDownloadTokenTTLSeconds = \"EditDownloadTokenTTLSeconds\";\n\n\t\t\t// DocuSign\n\t\t\tpublic const string DSProvisioningApiEndpoint = \"DSProvisioningApiEndpoint\";\n\t\t\tpublic const string DSProvisioningApiVersion = \"DSProvisioningApiVersion\";\n\t\t\tpublic const string DocuSignAccountServerProtocol = \"DocuSignAccountServerProtocol\";\n\t\t\tpublic const string DocuSignAccountServerDomain = \"DocuSignAccountServerDomain\";\n\t\t\tpublic const string EnableDSLogin = \"EnableDSLogin\";\n\t\t\tpublic const string SfDSSessionKeyExpirationSeconds = \"SfDSSessionKeyExpirationSeconds\";\n\t\t\tpublic const string DocusignMagnumPageSize = \"DocusignMagnumPageSize\";\n\t\t\tpublic const string SfAutoProvisionUser_QueryFieldName = \"SfAutoProvisionUser_QueryFieldName\";\n\t\t\tpublic const string EnableProvisioningAccountAsyncProcessing = \"EnableProvisioningAccountAsyncProcessing\";\n\t\t\tpublic const string DSOrganizationApiVersion = \"DSOrganizationApiVersion\";\n\n\t\t\t// NPS Survey\n\t\t\tpublic const string AllowNpsSurvey = \"AllowNpsSurvey\";\n\t\t\tpublic const string NpsSurveyLoadDelay = \"NpsSurveyLoadDelay\";\n\t\t\tpublic const string TimesToLoginBeforeNpsSurvey = \"TimesToLoginBeforeNpsSurvey\";\n\t\t\tpublic const string AllowTargetSamplingNpsSurvey = \"AllowTargetSamplingNpsSurvey\";\n\t\t\tpublic const string DaysToCheckForUniqueActionForNpsSurvey = \"DaysToCheckForUniqueActionForNpsSurvey\";\n\t\t\tpublic const string NpsSurveyToUse = \"NpsSurveyToUse\";\n\t\t\tpublic const string WootricSdkUrl = \"WootricSdkUrl\";\n\t\t\tpublic const string WootricNpsSurveyAppToken = \"WootricNpsSurveyAppToken\";\n\t\t\tpublic const string WootricEnvironmentProperty = \"WootricEnvironmentProperty\";\n\n\t\t\tpublic const string GenSfDocusignAccountCustomField = \"GenSfDocusignAccountCustomField\";\n\t\t\tpublic const string GenSfSetupDataCustomField = \"GenSfSetupDataCustomField\";\n\t\t\tpublic const string GenInviteCallbackRoute = \"GenInviteCallbackRoute\";\n\t\t\tpublic const string GenInviteEmailBody = \"GenInviteEmailBody\";\n\t\t\tpublic const string GenInviteEmailSubject = \"GenInviteEmailSubject\";\n\t\t\tpublic static string GenInviteRedirect = \"GenInviteRedirect\";\n\t\t\tpublic const string GetAccountRolesRoute = \"GetAccountRolesRoute\";\n\n\n\t\t\t// Docusign Urls\n\t\t\tpublic const string DocuSignAccountAdminRootUrl = \"DocuSignAccountAdminRootUrl\";\n\t\t\tpublic const string DocuSignAccountProvisioningUrl = \"DocuSignAccountProvisioningUrl\";\n\t\t\tpublic const string DocusignSyncRoute = \"DocusignSyncRoute\";\n\t\t\tpublic const string DocusignNdnsSyncRoute = \"DocusignNdnsSyncRoute\";\n\t\t\tpublic const string DocusignProfileNotificationSyncRoute = \"DocusignProfileNotificationSyncRoute\";\n\t\t\tpublic const string DocusignLoginPageUrl = \"DocusignLoginPageUrl\";\n\t\t\tpublic const string DocuSignNotificationApiBaseUrl = \"DocuSignNotificationApiBaseUrl\";\n\t\t\tpublic const string DocusignInternalApiCallbackUrl = \"DocusignInternalApiCallbackUrl\";\n\n\t\t\t//Javelin\n\t\t\tpublic const string JavelinBaseUrl = \"JavelinBaseUrl\";\n\n\t\t\t//AIRE\n\t\t\tpublic const string AIREApiBaseUrl = \"AIREApiBaseUrl\";\n\n\t\t\t//APR\n\t\t\tpublic const string APRBridgeApiRootUrl = \"APRBridgeApiRootUrl\";\n\t\t\tpublic const string EnableAPRHealthCheck = \"EnableAPRHealthCheck\";\n\t\t\tpublic const string MaxAllowedDocumentsInSingleBulkCreateTransaction = \"MaxAllowedDocumentsInSingleBulkCreateTransaction\";\n\n\t\t\t//MSF\n\t\t\tpublic const string MSFInternalBaseUrl = \"MSFInternalBaseUrl_{0}\";\n\t\t\tpublic const string MSFInternalRootUrl = \"MSFInternalRootUrl\";\n\t\t\tpublic const string MSFPublicApiBaseUrl = \"MSFPublicApiBaseUrl\";\n\n\t\t\t//VendorCallback\n\t\t\tpublic const string VendorCallBackEnableTracing = \"VendorCallBackEnableTracing\";\n\n\t\t\t// Workflow\n\t\t\tpublic const string ExpressionServiceEndpointUri = \"ExpressionServiceEndpointUri\";\n\t\t\tpublic const string WorkflowDesignApiEndpointUri = \"WorkflowDesignApiEndpointUri\";\n\t\t\tpublic const int WorkflowPurgeDaysOnSuccessDefault = 30;\n\t\t\tpublic const int WorkflowPurgeDaysOnFailureDefault = 30;\n\t\t\tpublic const string MaxWorkflowNextStepWaitTime = \"MaxWorkflowNextStepWaitTime\";\n\t\t\tpublic const bool AutomaticWorkflowAbortDefault = true;\n\t\t\tpublic const bool WaitForNextStepAfterCompletionDefault = false;\n\t\t\tpublic const bool EnablePurgeOnScopeDefault = false;\n\t\t\tpublic const bool EnableWorkflowSettingsCacheDefault = true;\n\t\t\tpublic const long WorkflowSettingsCacheTTLSecondsDefault = 600;\n\t\t\tpublic const string EnableMonitorActivityCountChanges = \"EnableMonitorActivityCountChanges\";\n\t\t\tpublic const string NextWorkItemPollingIntervalInMilliSeconds = \"NextWorkItemPollingIntervalInMilliSeconds\";\n\t\t\tpublic const string WorkflowRevisionsBatchProcessingSize = \"WorkflowRevisionsBatchProcessingSize\";\n\t\t\tpublic const string EnableWorkflowRmqEventSubscribers = \"EnableWorkflowRmqEventSubscribers\";\n\t\t\tpublic const bool EnableWorkflowLimitNotificationsDefault = true;\n\n\t\t\t// BulkJob\n\t\t\tpublic const string EnableBulkJobWorkflows = \"EnableBulkJobWorkflows\";\n\t\t\tpublic const string BulkJobApiUri = \"BulkJobApiUri\";\n\t\t\tpublic const string BulkJobUseQuorumQueues = \"BulkJobUseQuorumQueues\";\n\t\t\tpublic const string BulkJobExchangeType = \"BulkJobExchangeType\";\n\t\t\tpublic const string BulkJobItemDoneQueue = \"BulkJobItemDoneQueue\";\n\t\t\tpublic const string BulkJobVirtualHost = \"BulkJobVirtualHost\";\n\n\t\t\t// Analytics\n\t\t\tpublic const string EnableMixpanel = \"EnableMixpanel\";\n\t\t\tpublic const string MixpanelToken = \"MixpanelToken\";\n\t\t\tpublic const string AnalyticsSecret = \"analyticssecret\";\n\n\t\t\t// Agreement Analyzer\n\t\t\tpublic const string CachedAnalysisProcessingStatus_Key = \"Agreement_Analysis:Extractions_Processing_Status:{0}:{1}\";  //Agreement_Analysis:Extractions_Processing_Status:{accountId}:{docFileDataUid}\n\t\t\tpublic const long CachedAnalysisProcessingStatus_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedAnalysisScorecardProcessingStatus_Key = \"Agreement_Analysis:Scorecard_Processing_Status:{0}:{1}:{2}\";  //Agreement_Analysis:Scorecard_Processing_Status:{accountId}:{docFileDataUid}:{digitalAppId}\n\t\t\tpublic const long CachedAnalysisScorecardProcessingStatus_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedClauseSmartContractProcessingStatus_Key = \"Agreement_Analysis:ClauseSmartContract_Processing_Status:{0}:{1}\";  //Agreement_Analysis:ClauseSmartContract_Processing_Status:{accountId}:{docUid}\n\t\t\tpublic const long CachedClauseSmartContractProcessingStatus_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedClauseSmartContractResponse_Key = \"Agreement_Analysis:ClauseSmartContract_Response:{0}:{1}\";  //Agreement_Analysis:ClauseSmartContract_Response:{accountId}:{docUid}\n\t\t\tpublic const long CachedClauseSmartContractResponse_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedClauseFlowResponse_Key = \"Agreement_Analysis:ClauseFlow_Response:{0}:{1}\";  //Agreement_Analysis:ClauseFlow_Response:{accountId}:{docUid}\n\t\t\tpublic const long CachedClauseFlowResponse_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedClauseSignContractResponse_Key = \"Agreement_Analysis:ClauseSignContract_Response:{0}:{1}\";  //Agreement_Analysis:ClauseSignContract_Response:{accountId}:{docUid}\n\t\t\tpublic const long CachedClauseSignContractResponse_ExpirationSeconds = 60 * 60; // 1 hour\n\t\t\tpublic const string CachedSealLabelsErrorStatus_Key = \"Agreement_Analysis:SealLabels_Error_Status:{0}:{1}\";  //Agreement_Analysis:SealLabels_Error_Status:{accountId}:{fileDataUid}\n\t\t\tpublic const string ClauseMetadataGroupName = \"Clause Integration\";\n\t\t\tpublic const string AdvancedInsightsEventQueueHost = \"AdvancedInsightsEventQueueHost\";\n\t\t\tpublic const string EnableAdvancedInsightsRegisterForEvents = \"EnableAdvancedInsightsRegisterForEvents\";\n\n\t\t\tpublic const string KickStartSecurityUILockWaitTimeoutMs = \"KickStartSecurityUILockWaitTimeoutMs\";\n\t\t\tpublic const string KickStartSecurityLockWaitTimeoutMs = \"KickStartSecurityLockWaitTimeoutMs\";\n\t\t\tpublic const string KickStartSecurityTimeoutSeconds = \"KickStartSecurityTimeoutSeconds\";\n\t\t\tpublic const string KickStartSecurityUITimeoutSeconds = \"KickStartSecurityUITimeoutSeconds\";\n\t\t\tpublic const string AccountsToSkipSecurityCalculateByUser = \"AccountsToSkipSecurityCalculateByUser\";\n\t\t\tpublic const string SecurityCalcTaskInQueueTTLSeconds = \"SecurityCalcTaskInQueueTTLSeconds\";\n\n\t\t\tpublic const string DefaultMaintenanceWorkerReservationTimeout = \"DefaultMaintenanceWorkerReservationTimeout\";\n\n\t\t\tpublic const string TempFileSwiftContainerName = \"TempFileSwiftContainerName\";\n\n\t\t\tpublic const string DocumentTypesNotAllowedToBeDisplayedInline = \"DocumentTypesNotAllowedToBeDisplayedInline\";\n\n\t\t\tpublic const string ClauseIntegrationClientId = \"ClauseIntegrationClientId\";\n\t\t\tpublic const string ClauseLoginUrl = \"ClauseLoginUrl\";\n\n\t\t\tpublic const string GlyphExtractionTTLHours = \"GlyphExtractionTTLHours\";\n\t\t\tpublic const string GlyphReconciliationReservationExpireSeconds = \"GlyphReconciliationReservationExpireSeconds\";\n\t\t\tpublic const string ShouldOptimizeBrushInfoUse = \"ShouldOptimizeBrushInfoUse\";\n\t\t\tpublic const string TrackedTermsXmlTTLSeconds = \"TrackedTermsXmlTTLSeconds\";\n\t\t\tpublic const string SealDigitalAppsCacheExpirationSeconds = \"SealDigitalAppsCacheExpirationSeconds\";\n\t\t\tpublic const string SealModelListCacheExpirationSeconds = \"SealModelListCacheExpirationSeconds\";\n\t\t\tpublic const string SealUserViewsCacheExpirationSeconds = \"SealUserViewsCacheExpirationSeconds\";\n\n\t\t\tpublic const string IntellegoModelListExpirationSeconds = \"IntellegoModelListExpirationSeconds\";\n\n\t\t\tpublic const string EnableQueueSeparationForBulkBackgroundTasks = \"{0}_EnableQueueSeparationForBulkBackgroundTasks\";\n\n\t\t\tpublic const int SealClauseSyncMaxFolderTreeLevel = 10;\n\n\t\t\tpublic const string KazmonEnableSealExtractionCompleted = \"Kazmon_EnableScmTaskProcessor_SealExtraction\";\n\t\t\tpublic const string KazmonEnableSealScorecardCompleted = \"Kazmon_EnableScmTaskProcessor_SealScorecard\";\n\t\t\tpublic const string KazmonEnableAITransactionCheckStatus = \"Kazmon_EnableScmTaskProcessor_AITransactionCheckStatus\";\n\t\t\tpublic const string KazmonEnableAITransactionTelemetry = \"Kazmon_EnableAITransactionTelemetry\";\n\t\t\tpublic const string KazmonEnableAIAgreementSummaryTelemetry = \"Kazmon_EnableAIAgreementSummaryTelemetry\";\n\t\t\tpublic const string KazmonEnableAIBatchTelemetry = \"Kazmon_EnableAIBatchTelemetry\";\n\t\t\tpublic const string KazmonEnableCommentsReconcileWorkload = \"Kazmon_EnableWorkload_CommentsReconcile\";\n\t\t\tpublic const string KazmonEnableGetSearchablePdfWorkload = \"Kazmon_EnableScmTaskProcessor_GetSearchablePdf\";\n\t\t\tpublic const string AITransactionCheckStatusWorkerSleepSeconds = \"AITransactionCheckStatusWorkerSleepSeconds\";\n\t\t\tpublic const string AITransactionCheckStatusWorkflowWorkerSleepSeconds = \"AITransactionCheckStatuWorkflowWorkerSleepSeconds\";\n\t\t\tpublic const string AITransactionCheckStatusWorkerBucketInDays = \"AITransactionCheckStatusWorkerBucketInDays\";\n\t\t\tpublic const string AITransactionCheckStatusWorkflowWorkerBucketInDays = \"AITransactionCheckStatusWorkflowWorkerBucketInDays\";\n\t\t\tpublic const string AITransactionCheckStatusWorkerReservationInSecs = \"AITransactionCheckStatusWorkerReservationInSecs\";\n\t\t\tpublic const string AITransactionExtractionsCompletionBufferTimeInHours = \"AITransactionExtractionsCompletionBufferTimeInHours\";\n\t\t\tpublic const string AITransactionExtractionsCompletionWorkflowBufferTimeInHours = \"AITransactionExtractionsCompletionWorkflowBufferTimeInHours\";\n\t\t\tpublic const string AITransactionCheckStatusWorkerEnabled = \"AITransactionCheckStatusWorkerEnabled\";\n\t\t\tpublic const string AITransactionCheckStatusWorkflowWorkerEnabled = \"AITransactionCheckStatusWorkflowWorkerEnabled\";\n\t\t\tpublic const string LogicAppProgressStatusCheckedMaxCount = \"LogicAppProgressStatusCheckedMaxCount\";\n\t\t\tpublic const string AprRetryableErrorCodes = \"AprRetryableErrorCodes\";\n\n\t\t\tpublic const string AiAutofillSealExtractionContextLength = \"AiAutofillSealExtractionContextLength\";\n\t\t\tpublic const string AttributeDetailsPageNumberCacheExpirationSeconds = \"AttributeDetailsPageNumberCacheExpirationSeconds\";\n\t\t\tpublic const string CancelBatchMaxNumberOfTransactionToLoadInSingleCall = \"CancelBatchMaxNumberOfTransactionToLoadInSingleCall\";\n\n\t\t\tpublic const string AiAutofillBatchReportSharedStorageTTLSeconds = \"AiAutofillBatchReportSharedStorageTTLSeconds\";\n\t\t\tpublic const string AiAutofillBatchReportFilePathCacheTTLSeconds = \"AiAutofillBatchReportFilePathCacheTTLSeconds\";\n\n\t\t\tpublic const string DocLauncherMergePackageTTLInSeconds = \"DocLauncherMergePackageTTLInSeconds\";\n\n\t\t\tpublic const string EnableSessionProviderTelemetry = \"EnableSessionProviderTelemetry\";\n\n\t\t\tpublic const string SaveQueueStateToCache = \"SaveQueueStateToCache\";\n\n\t\t\t// Intellego integration\n\t\t\tpublic const string IntellegoAIFrontendApiBaseUrl = \"IntellegoAIFrontendApiBaseUrl\";\n\t\t\tpublic const string IntellegoLabelDisplayNames = \"IntellegoLabelDisplayNames\";\n\t\t\tpublic const string IntellegoContractValueModelName = \"IntellegoContractValueModelName\";\n\t\t\tpublic const string ProvideFeedbackForMissedExtractions = \"ProvideFeedbackForMissedExtractions\";\n\n\t\t\tpublic const string ZipConstructionTempDir = \"ZipConstructionTempDir\";\n\t\t\tpublic const string MaxZipFileBytes = \"MaxZipFileBytes\";\n\n\t\t\t//Agreement Object Model and Counterparties\n\t\t\tpublic const string AOMRestApiUrl = \"AOMRestApiUrl\";\n\t\t\tpublic const string AgreementRelationshipMaxHierarchyLevel = \"AgreementRelationshipMaxHierarchyLevel\";\n\n\t\t\t//Agreement Document Model\n\t\t\tpublic const string ADMRestApiUrl = \"ADMRestApiUrl\";\n\n\t\t\tpublic const string AdmDocumentTypeEnumId = \"AdmDocumentTypeEnumId\";\n\t\t\tpublic const string DocumentTypesSupportPageUrl = \"DocumentTypesSupportPageUrl\";\n\n\t\t\tpublic const string DocuSignNegotiationApiBaseUrl = \"DocuSignNegotiationApiBaseUrl\";\n\n\t\t\tpublic const string ABACRootFormat = \"ABACRootFormat\";\n\t\t\tpublic const string MaxSecurityAttributeCount = \"MaxSecurityAttributeCount\";\n\t\t\tpublic const string JITRepostRootFormat = \"JITRepostRootFormat\";\n\t\t\tpublic const string JITRootFormat = \"JITRootFormat\";\n\n\t\t\tpublic const string ABACRetrySleepSecondsSchedule = \"ABACRetrySleepSecondsSchedule\";\n\t\t\tpublic const string SecurityEvaluationRequestTimeoutMs = \"SecurityEvaluationRequestTimeoutMs\";\n\t\t\tpublic const string AdmSecretHeaderValue = \"AdmSecretHeaderValue\";\n\t\t\tpublic const string AdmSecretHeaderKey = \"AdmSecretHeaderKey\";\n\n\t\t\tpublic const string SearchReadDataFromSearchInc = \"SearchReadDataFromSearchInc\";\n\t\t\tpublic const string SearchSendDataToFacadeService = \"SearchSendDataToFacadeService\";\n\t\t\t// ACT Integration\n\t\t\tpublic const string DocuSignActUIBaseUrl = \"DocuSignActUIBaseUrl\";\n\t\t\tpublic const string DocuSignActAppsBaseUrl = \"DocuSignActAppsBaseUrl\";\n\t\t\tpublic const string DocusignActClientApplicationId = \"DocusignActClientApplicationId\";\n\t\t\tpublic const string DocuSignActClientTimeOutInSeconds = \"DocuSignActClientTimeOutInSeconds\";\n\t\t\tpublic const string DocuSignActRequestUseAppToken = \"DocuSignActRequestUseAppToken\";\n\n\t\t\t// Agreement List\n\t\t\tpublic const string ElasticAgreementRepositoryLoadRecentDocumentOffsetInMonths = \"ElasticAgreementRepositoryLoadRecentDocumentOffsetInMonths\";\n\t\t\tpublic const string ElasticAgreementSearchDelayMs = \"ElasticAgreementSearchDelayMs\";\n\n\t\t\t//Support URL\n\t\t\tpublic const string SlackHelpUrl = \"SlackHelpUrl\";\n\t\t\tpublic const string AdminConversionInfoUrl = \"AdminConversionInfoUrl\";\n\t\t\tpublic const string UserConversionInfoUrl = \"UserConversionInfoUrl\";\n\t\t\tpublic const string SfdcConversionInfoUrl = \"SfdcConversionInfoUrl\";\n\t\t\tpublic const string SfdcDalAppLink = \"SfdcDalAppLink\";\n\t\t\tpublic const string TranslationHelpUrl = \"TranslationHelpUrl\";\n\t\t\tpublic const string FederatedSecuritySandboxUrl = \"FederatedSecuritySandboxUrl\";\n\t\t\tpublic const string FederatedSecuritySandboxUrlDS = \"FederatedSecuritySandboxUrlDS\";\n\t\t\tpublic const string FederatedSecurityUrlDS = \"FederatedSecurityUrlDS\";\n\t\t\tpublic const string FederatedSecurityUrl = \"FederatedSecurityUrl\";\n\t\t\tpublic const string FederatedSecurityAccessMapping = \"FederatedSecurityAccessMapping\";\n\t\t\tpublic const string FederatedSecurityAccessMappingDS = \"FederatedSecurityAccessMappingDS\";\n\t\t\tpublic const string OrgCreationGuideUrl = \"OrgCreationGuideUrl\";\n\t\t\tpublic const string AdminIntroUrl = \"AdminIntroUrl\";\n\t\t\tpublic const string ClmKickoffGuideForAdmins = \"ClmKickoffGuideForAdmins\";\n\t\t\tpublic const string WorkflowCreate = \"WorkflowCreate\";\n\t\t\tpublic const string Upload = \"Upload\";\n\t\t\tpublic const string SupportedBrowsers = \"SupportedBrowsers\";\n\t\t\tpublic const string SendDocuments = \"SendDocuments\";\n\t\t\tpublic const string SAMLSSO = \"SAMLSSO\";\n\t\t\tpublic const string Reports = \"Reports\";\n\t\t\tpublic const string NodeSecurity = \"NodeSecurity\";\n\t\t\tpublic const string MetadataImportMappings = \"MetadataImportMappings\";\n\t\t\tpublic const string ManageAttributes = \"ManageAttributes\";\n\t\t\tpublic const string ImportUsers = \"ImportUsers\";\n\t\t\tpublic const string Forms = \"Forms\";\n\t\t\tpublic const string FolderSettings = \"FolderSettings\";\n\t\t\tpublic const string DocuSignCommunityScmTopic = \"DocuSignCommunityScmTopic\";\n\t\t\tpublic const string DocuSignCommunity = \"DocuSignCommunity\";\n\t\t\tpublic const string DocuSignSupportCenter = \"DocuSignSupportCenter\";\n\t\t\tpublic const string DocumentReviewer = \"DocumentReviewer\";\n\t\t\tpublic const string DocumentRules = \"DocumentRules\";\n\t\t\tpublic const string DeviceManagement = \"DeviceManagement\";\n\t\t\tpublic const string NewDashboard = \"NewDashboard\";\n\t\t\tpublic const string Developer = \"Developer\";\n\t\t\tpublic const string CutCopyPaste = \"CutCopyPaste\";\n\t\t\tpublic const string CustomizeMenu = \"CustomizeMenu\";\n\t\t\tpublic const string CreateUser = \"CreateUser\";\n\t\t\tpublic const string CreateContact = \"CreateContact\";\n\t\t\tpublic const string BrowseDocuments = \"BrowseDocuments\";\n\t\t\tpublic const string AdvancedSearch = \"AdvancedSearch\";\n\t\t\tpublic const string AddressBook = \"AddressBook\";\n\t\t\tpublic const string Index = \"Index\";\n\t\t\tpublic const string IndexDS = \"IndexDS\";\n\t\t\tpublic const string EnableNewDelegateAccess = \"EnableNewDelegateAccess\";\n\t\t\tpublic const string HideDelegateAccess = \"HideDelegateAccess\";\n\t\t\tpublic const string HideExternalReviewCompletionByEmailSetting = \"HideExternalReviewCompletionByEmailSetting\";\n\t\t\tpublic const string SecurityEvaluationApiMaxNodes = \"SecurityEvaluationApiMaxNodes\";\n\t\t\tpublic const string UpdatableSupportUserProperties = \"UpdatableSupportUserProperties\";\n\t\t\tpublic const string ABACPDPServerList = \"ABACPDPServerList\";\n\n\t\t\tpublic const string DocuSignCollaborationApiBaseUrl = \"DocuSignCollaborationApiBaseUrl\";\n\t\t\tpublic const string AssignmentsApiBaseUrl = \"AssignmentsApiBaseUrl\";\n\t\t\tpublic const string AssignmentsApiPageSize = \"AssignmentsApiPageSize\";\n\t\t\tpublic const string EnableCommentsInPreview = \"EnableCommentsInPreview\";\n\t\t\tpublic const string EnableCommentAssignmentsInPreview = \"EnableCommentAssignmentsInPreview\";\n\t\t\tpublic const string EnableCommentsTaskGroups = \"EnableCommentsTaskGroups\";\n\t\t\tpublic const string EnableGraphQLGzipCompression = \"EnableGraphQLGzipCompression\";\n\t\t\tpublic const string EnableCommentsReconciliation = \"EnableCommentsReconciliation\";\n\t\t\tpublic const string CommentsReconcilePreAndPostCharLimit = \"CommentsReconcilePreAndPostCharLimit\";\n\t\t\tpublic const string ExternalMapCacheTimeout = \"ExternalMapCacheTimeout\";\n\t\t\tpublic const string EnableContextMenuInTasks = \"EnableContextMenuInTasks\";\n\n\t\t\tpublic const string InsightsAllowedProtocols = \"InsightsAllowedProtocols\";\n\t\t\tpublic const string InsightsAllowedDomains = \"InsightsAllowedDomains\";\n\n\t\t\tpublic const string EnableAdvancedPreview = \"EnableAdvancedPreview\";\n\t\t\tpublic const string CollapseStandardAttributePanelByDefault = \"CollapseStandardAttributePanelByDefault\";\n\t\t\tpublic const string EnableReactDocLauncherPreview = \"EnableReactDocLauncherPreview\";\n\t\t\tpublic const string EnableChatNotifications = \"EnableChatNotifications\";\n\t\t\tpublic const string EnableInteractiveChatNotificationPayloads = \"EnableInteractiveChatNotificationPayloads\";\n\t\t\tpublic const string DisableExternalMapCaching = \"DisableExternalMapCaching\";\n\t\t\tpublic const string CLMUIBaseUrl = \"CLMUIBaseUrl\";\n\t\t\tpublic const string OliveImagesCdnUrl = \"OliveImagesCdnUrl\";\n\t\t\tpublic const string OliveImagesCdnVersion = \"OliveImagesCdnVersion\";\n\t\t\tpublic const string CLMUIVersion = \"CLMUIVersion\";\n\n\t\t\tpublic const string EnableDesiredWorkerCountFromFeatureFlags = \"EnableDesiredWorkerCountFromFeatureFlags\";\n\n\t\t\tpublic const string EnableCommentsWordIngestion = \"EnableCommentsWordIngestion\";\n\t\t\tpublic const string EnableRebrand2024 = \"EnableRebrand2024\";\n\n\t\t\tpublic const string EnableCLMSitemap = \"EnableCLMSiteMap\";\n\n\t\t\tpublic const string DisableDsUserIdCaching = \"DisableDsUserIdCaching\";\n\t\t\tpublic const string DsUserIdCacheExpirationSeconds = \"DsUserIdCacheExpirationSeconds\";\n\n\t\t\t//Data review\n\t\t\tpublic const string DataReviewCustomAttributesAllowedAttributeTypes = \"DataReviewCustomAttributesAllowedAttributeTypes\";\n\t\t\tpublic const string DataReviewCustomAttributesEnableRepeatable = \"DataReviewCustomAttributesEnableRepeatable\";\n\t\t\tpublic const string KazmonEnableDataReviewTelemetry = \"Kazmon_EnableDataReviewTelemetry\";\n\t\t\tpublic const string DataReviewFuzzyMatchMinScore = \"DataReviewFuzzyMatchMinScore\";\n\n\t\t\t// Account Conversion\n\t\t\tpublic const string EnableCLMAccountConversion = \"EnableCLMAccountConversion\";\n\t\t\tpublic const string EnableCLMAccountMigrationForm = \"EnableCLMAccountMigrationForm\";\n\t\t\tpublic const string EnableRollbackAllSettings = \"EnableRollbackAllSettings\";\n\t\t\tpublic const string EnableConversionMixedMode = \"EnableConversionMixedMode\";\n\t\t\tpublic const string ConversionMixedModeSettings = \"ConversionMixedModeSettings\";\n\t\t\tpublic const string EnableCLMBeginAccountConversion = \"EnableCLMBeginAccountConversion\";\n\t\t\tpublic const string AddUpdateUserTimeout = \"AddUpdateUserTimeout\";\n\n\t\t\tpublic const string EnableCertificateValidator = \"EnableCertificateValidator\";\n\n\t\t\tpublic const string EnableHasSecurityChangeEvaluationWorkflow = \"EnableHasSecurityChangeEvaluationWorkflow\";\n\n\t\t\tpublic const string DocumentDeletedMaxRetries = \"DocumentDeletedMaxRetries\";\n\t\t\tpublic const string FolderDeletedMaxRetries = \"FolderDeletedMaxRetries\";\n\t\t\tpublic const string EnableAssignmentDelete = \"EnableAssignmentDelete\";\n\t\t\tpublic const string NotificationEmailRegex = \"NotificationEmailRegex\";\n\t\t\tpublic const string TaskGroupDeletedEventMaxRetries = \"TaskGroupDeletedEventMaxRetries\";\n\n\t\t\tpublic const string EnableProfileNotificationMessageHandling = \"EnableProfileNotificationMessageHandling\";\n\t\t\tpublic const string AllowedClientIds_ProfileNotification = \"AllowedClientIds_ProfileNotification\";\n\t\t\tpublic const string EnableSFDCPermissionSetAssignment = \"EnableSFDCPermissionSetAssignment\";\n\t\t\tpublic const string EnableSFDCStopUserSyncForConvertedAccounts = \"EnableSFDCStopUserSyncForConvertedAccounts\";\n\t\t\tpublic const string EnableSFDCApisForSalesforceLedConversion = \"EnableSFDCApisForSalesforceLedConversion\";\n\n\t\t\t//DotVVM\n\t\t\tpublic const string DotVVMEnablePages = \"DotVVMEnablePages\";\n\n\t\t\t// CLM Max\n\t\t\tpublic const string APRIntegratorKeyWhitelist = \"APRIntegratorKeyWhitelist\";\n\t\t\tpublic const string BatchManagementIntegratorKeyWhitelist = \"BatchManagementIntegratorKeyWhitelist\";\n\n\t\t\t//ServiceProtection\n\t\t\tpublic const string ServProtEnableRequestFiltering = \"ServProtEnableRequestFiltering\";\n\t\t\tpublic const string ServProtEnableExternalActionRulesUpdater = \"ServProtEnableExternalActionRulesUpdater\";\n\t\t\tpublic const string ServProtLoadSecretsFromVault = \"ServProtLoadSecretsFromVault\";\n\t\t\tpublic const string ServProtEnableVNextSmartSetFetching = \"ServProtEnableVNextSmartSetFetching\";\n\t\t\tpublic const string ServProtAccountHost = \"ServProtAccountHost\";\n\t\t\tpublic const string ServProtClientId = \"ServProtClientId\";\n\t\t\tpublic const string ServProtContextTypes = \"ServProtContextTypes\";\n\t\t\tpublic const string ServProtInstanceName = \"ServProtInstanceName\";\n\t\t\tpublic const string ServProtJwtBearerAudience = \"ServProtJwtBearerAudience\";\n\t\t\tpublic const string ServProtPrivateKey = \"ServProtPrivateKey\";\n\t\t\tpublic const string ServProtProtectUri = \"ServProtProtectUri\";\n\t\t\tpublic const string ServProtRuleRefreshSeconds = \"ServProtRuleRefreshSeconds\";\n\t\t\tpublic const string ServProtRuleRefreshWrapperSeconds = \"ServProtRuleRefreshWrapperSeconds\";\n\t\t\tpublic const string ServProtTimeoutMs = \"ServProtTimeoutMs\";\n\t\t\tpublic const string ServProtEnableClientLogging = \"ServProtEnableClientLogging\";\n\t\t\tpublic const string ServProtEnableDynamicThrottling = \"ServProtEnableDynamicThrottling\";\n\t\t\tpublic const string ServProtDynamicThrottlingRefreshRateSeconds = \"ServProtDynamicThrottlingRefreshRateSeconds\";\n\n\n\t\t\t// Atlas Context Provider settings\n\t\t\tpublic const string UseAsyncAtlasContextProvider = \"UseAsyncAtlasContextProvider\";\n\n\t\t\tpublic const string DocLauncherMaxUserConversionTaskQueueTimeInSeconds = \"DocLauncherMaxUserConversionTaskQueueTimeInSeconds\";\n\t\t\tpublic const string SfMergeProcessorMaxTimeWaitingForPdfInSeconds = \"SfMergeProcessor_MaxTimeWaitingForPdfInSeconds\";\n\t\t\tpublic const string OneConfigIniPath = \"OneConfigIniPath\";\n\n\t\t\t// Bulk Review\n\t\t\tpublic const string UploadCenterUrl = \"UploadCenterUrl\";\n\n\t\t\t// Rate limit counting\n\t\t\tpublic const string UseSlidingWindowForRateLimitAcrossAccounts = \"UseSlidingWindowForRateLimitAcrossAccounts\";\n\n\t\t\t// API Content Integrator Key Rate Limit\n\t\t\tpublic const string ApiContentIntegratorKeyRateLimitAllowedRequests = \"ApiContentIntegratorKeyRateLimitAllowedRequests_{0}\";\n\t\t\tpublic const string ApiContentIntegratorKeyRateLimitDurationSeconds = \"ApiContentIntegratorKeyRateLimitDurationSeconds_{0}\";\n\t\t\tpublic const string ApiContentIntegratorKeyRateLimitSyncStep = \"ApiContentIntegratorKeyRateLimitSyncStep_{0}\";\n\t\t\tpublic const string ApiContentIntegratorKeyRateLimitEnabledKeys = \"ApiContentIntegratorKeyRateLimitEnabledKeys\";\n\n\t\t\t// Orchestration Workflow Integration\n\t\t\tpublic const string OrchestrationWorkflowStartTaskTempStorage = \"OrchestrationWorkflowStartTaskTempStorage\";\n\t\t\tpublic const string OrchestrationIntegrationRetryCount = \"OrchestrationIntegrationRetryCount\";\n\t\t\tpublic const string OrchestrationIntegrationRetryIntervalInMs = \"OrchestrationIntegrationRetryIntervalInMs\";\n\t\t\tpublic const string OrchestrationManageApiEndpoint = \"OrchestrationManageApiEndpoint\";\n\n\t\t\t// Obligation Management Integration\n\t\t\tpublic const string ObligationManagementIntegrationRetryCount = \"ObligationManagementIntegrationRetryCount\";\n\t\t\tpublic const string ObligationManagementIntegrationRetryIntervalInMs = \"ObligationManagementIntegrationRetryIntervalInMs\";\n\n\t\t\t// AI Agreement Summary\n\t\t\tpublic const string AIAgreementSummaryMaxFailures = \"AIAgreementSummaryMaxFailures\";\n\t\t\tpublic const string AIAgreementSummaryMaxFileSizeBytes = \"AIAgreementSummaryMaxFileSizeBytes\";\n\t\t\tpublic const string AIAgreementSummaryProcessingThresholdInSeconds = \"AIAgreementSummaryProcessingThresholdInSeconds\";\n\n\t\t\t// New Tasks list performance improvements\n\t\t\tpublic const string WorkItemLoadByWorkerPoolUidsMaxCount = \"WorkItemLoadByWorkerPoolUidsMaxCount\";\n\t\t\tpublic const string WorkItemLoadByAssignedUserUidsMaxCount = \"WorkItemLoadByAssignedUserUidsMaxCount\";\n\n\t\t\t// Account behavior\n\t\t\tpublic const string UseSiteColumnForSiteName = \"UseSiteColumnForSiteName\";\n\t\t\tpublic const string UseDbNameColumnForDbName = \"UseDbNameColumnForDbName\";\n\n\t\t\tpublic const string WatermarkEventTimeoutMinutes = \"WatermarkEventTimeoutMinutes\";\n\n\t\t\t// Unified Repository\n\t\t\tpublic const string UnifiedRepositoryUrl = \"UnifiedRepositoryUrl\";\n\t\t\tpublic const string PermissionServiceMaxEventsAllowedPerRequest = \"PermissionServiceMaxEventsAllowedPerRequest\";\n\t\t\tpublic const string UnifiedRepositoryHistoricalLoadNextMaxRows = \"UnifiedRepositoryHistoricalLoadNextMaxRows\";\n\t\t\tpublic const string DocumentExtensionsSupportedForIAMIngestion = \"DocumentExtensionsSupportedForIAMIngestion\";\n\t\t\tpublic const string CachedAttributeMappingsExistsStatusKey = \"AttributeMappingsExists_Status_{0}\";  //AttributeMappingExists_Status_{accountId}\n\t\t\tpublic const string CachedAttributeMappingsExistsStatusExpirationSecond = \"CachedAttributeMappingsExistsStatusExpirationSecond\";\n\t\t\tpublic const string UnifiedRepositoryPartiesUrl = \"UnifiedRepositoryPartiesUrl\";\n\n\t\t\t// Audit Service API\n\t\t\tpublic const string AuditServiceMaxEventsAllowedPerRequest = \"AuditServiceMaxEventsAllowedPerRequest\";\n\t\t\tpublic const string KazmonEnableAuditServiceTelemetry = \"Kazmon_EnableAuditServiceTelemetry\";\n\t\t\tpublic const string AuditServiceMaxNumberOfRetries = \"AuditServiceMaxNumberOfRetries\";\n\t\t\tpublic const string AuditServiceWaitTimeInMsBeforeNextAttempt = \"AuditServiceWaitTimeInMsBeforeNextAttempt\";\n\n\t\t\t// UR Permission Service\n\t\t\tpublic const string KazmonEnablePermissionServiceTelemetry = \"Kazmon_EnablePermissionServiceTelemetry\";\n\n\t\t\t//WebContent\n\t\t\tpublic const string EnableSessionForWebContent = \"EnableSessionForWebContent\";\n\n\t\t\tpublic const string SiteSpecificDomainRoot = \"DomainRoot_{0}\";\n\t\t\tpublic const string CrossPlatformSites = \"CrossPlatformSites\";\n\t\t\tpublic const string CrossPlatformAppUrlFormat = \"CrossPlatformAppUrlFormat_{0}\";\n\t\t\tpublic const string StandardCrossPlatformAppUrlFormat = \"StandardCrossPlatformAppUrlFormat\";\n\t\t\tpublic const string AppUrlFormat = \"AppUrlFormat\";\n\t\t\tpublic const string AuthAppFormat = \"AuthAppFormat\";\n\n\t\t\t//API Request Headers\n\t\t\tpublic const string EnableCheckXForwardedFor = \"EnableCheckXForwardedFor\";\n\t\t\tpublic const string EnableCheckXForwardedForBehindProxy = \"EnableCheckXForwardedForBehindProxy\";\n\t\t\tpublic const string EnableTrueClientIp = \"EnableTrueClientIP\";\n\t\t\tpublic const string DefaultEnableCheckXForwardedForForwardLimit = \"DefaultEnableCheckXForwardedForForwardLimit\";\n\t\t\tpublic const string DefaultEnableCheckXForwardedForForwardLimitBehindProxy = \"DefaultEnableCheckXForwardedForForwardLimitBehindProxy\";\n\t\t\tpublic const string UseTrueClientIp = \"UseTrueClientIP\";\n\t\t\tpublic const string UseXForwardedFor = \"UseXForwardedFor\";\n\t\t\tpublic const string UseXForwardedForBehindProxy = \"UseXForwardedForBehindProxy\";\n\n\t\t\t//MaintenanceService AccessReservation\n\t\t\tpublic const string EnableAccessReservationForMaintenanceWorkers = \"EnableAccessReservationForMaintenanceWorkers\";\n\t\t\tpublic const string EnableWorkerLevelLocksDocumentNamingService = \"EnableWorkerLevelLocksDocumentNamingService\";\n\n\t\t\tpublic const string MaxNumberOfAIExtractionResults = \"MaxNumberOfAIExtractionResults\";\n\n\t\t\t// All Applications\n\t\t\tpublic const string ServicePointConnectionLimit = \"ServicePointConnectionLimit\";\n\n\t\t\t// SetResponseHeadersAttribute\n\t\t\tpublic const string DSSessionControllerEnterEndpointEnableCors = \"DSSessionControllerEnterEndpointEnableCors\";\n\t\t\tpublic const string DSSessionControllerEnterEndpointEnableUserId = \"DSSessionControllerEnterEndpointEnableUserId\";\n\n\t\t\t// UserTokenAuth\n\t\t\tpublic const string EnableSingleUseUserToken = \"EnableSingleUseUserToken\";\n\t\t\tpublic const string SessionCookiesSameSiteMode = \"SessionCookiesSameSiteMode\";\n\n\t\t\t// Lexion\n\t\t\tpublic const string LexionAppVersion = \"LexionAppVersion\";\n\t\t\tpublic const string LexionAppSourceId = \"LexionAppSourceId\";\n\n\t\t\t// DMS Migration\n\t\t\tpublic const string DmsMigrationIntegratorKeyWhitelist = \"DmsMigrationIntegratorKeyWhitelist\";\n\n\t\t\tpublic const string DSEditProhibitedFileTypes = \"DSEditProhibitedFileTypes\";\n\n\t\t\t//  Maximum file size in MB for Tracked Content Extractions & Content Replacement Tasks\n\t\t\tpublic const string TrackedContentExtractionsTaskMaxFileSizeMB = \"TrackedContentExtractionsTaskMaxFileSizeMB\";\n\t\t\tpublic const string ContentReplacementTaskMaxFileSizeMB = \"ContentReplacementTaskMaxFileSizeMB\";\n\n\t\t\t// User handler\n\t\t\tpublic const string UserHandlerUseContextAccessor = \"UserHandlerUseContextAccessor\";\n\n\t\t\tpublic const string DeleteFoldersWithEmptyParent = \"DeleteFoldersWithEmptyParent\";\n\t\t}\n\n\t\tpublic class AutoNumber\n\t\t{\n\t\t\tpublic const int NUM_WIDTH_MAX_VALUE = 19;\n\t\t}\n\n\t\tpublic class Cassandra\n\t\t{\n\t\t\tpublic const string HistoryKeyspace = \"history\";\n\t\t\tpublic const string DefaultKeyspace = \"atlas\";\n\t\t\tpublic const string AnalyticsKeyspace = \"analytics\";\n\t\t\tpublic const string EventsKeyspace = \"events\";\n\t\t\tpublic const string DefaultCatalog = \"cassandra\";\n\t\t\tpublic const string AnalyticsCatalog = \"cassandra_analytics\";\n\t\t\tpublic const string HistoryCatalog = \"cassandra_history\";\n\t\t}\n\n\n\t\tpublic class ClientScriptBlock\n\t\t{\n\t\t\tpublic const string AutoRefresh = \"auto-refresh\";\n\t\t\tpublic const string CloseWindoid = \"CloseWindoid\";\n\t\t\tpublic const string CloseWindow = \"CloseWindow\";\n\t\t\tpublic const string ClosePopupWindow = \"ClosePopupWindow\";\n\t\t\tpublic const string CollaborationStartupVariables = \"CollaborationStartupVariables\";\n\t\t\tpublic const string ColorPickerCss = \"ColorPickerCss\";\n\t\t\tpublic const string dirtyflag = \"dirtyflag\";\n\t\t\tpublic const string ForceLogger = \"ForceScriptLogger\";\n\t\t\tpublic const string InitiallyCollapseLeftNavigation = \"InitiallyCollapseLeftNavigation\";\n\t\t\tpublic const string logicaldocumentblock = \"logicaldocumentblock\";\n\t\t\tpublic const string NoPreviewAvaliable = \"NoPreviewAvaliable\";\n\t\t\tpublic const string NoDisplayWhenReadOnly = \"NoDisplayWhenReadOnly\";\n\t\t\tpublic const string OnKeyDownBody = \"OnKeyDownBody\";\n\t\t\tpublic const string RadGridColumnWidthFix = \"RadGridColumnWidthFix\";\n\t\t\tpublic const string RefreshOpener = \"RefreshOpener\";\n\t\t\tpublic const string RequiredPrepend = \"RequiredPrepend\";\n\t\t\tpublic const string RequiredPrependAndHideSections = \"RequiredPrependAndHideSections\";\n\t\t\tpublic const string SalesForceContainerCssOverride = \"SalesForceContainerCssOverride\";\n\t\t\tpublic const string SalesForceJavascriptlet = \"SalesForceJavascriptlet\";\n\t\t\tpublic const string SelectNodesJSVariables = \"SelectNodesJSVariables\";\n\t\t\tpublic const string SFReport = \"SFReport\";\n\t\t\tpublic const string toggleWexExSettings = \"toggleWexExSettings\";\n\t\t\tpublic const string ToolbarScript = \"toolbarScript\";\n\t\t\tpublic const string WizardPricingTableHook = \"WizardPricingTableHook\";\n\t\t\tpublic const string WorkflowConfigurationStepInitialization = \"WorkflowConfigurationStepInitialization\";\n\t\t}\n\n\t\tpublic class CustomHeaders\n\t\t{\n\t\t\tpublic const string RateLimitAllowed = \"X-RateLimit-Allowed\";\n\t\t\tpublic const string RateLimitRemaining = \"X-RateLimit-Remaining\";\n\t\t\tpublic const string RateLimitReset = \"X-RateLimit-Reset\";\n\t\t}\n\n\t\tpublic class DateFormatString\n\t\t{\n\t\t\tprivate static readonly object DateFormatListLocker = new object();\n\t\t\tprivate static volatile IReadOnlyList<string> _dateFormats;\n\n\t\t\tpublic static IReadOnlyList<string> DateFormats\n\t\t\t{\n\t\t\t\tget\n\t\t\t\t{\n\t\t\t\t\tif (_dateFormats != null) return _dateFormats;\n\n\t\t\t\t\tlock (DateFormatListLocker)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (_dateFormats != null) return _dateFormats;\n\n\t\t\t\t\t\tvar tempDateFormats = new List<string>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"MMMM dd, yyyy\",\n\t\t\t\t\t\t\t\"MMMM d, yyyy\",\n\t\t\t\t\t\t\t\"MMMM-dd\",\n\t\t\t\t\t\t\t\"MMMM-yy\",\n\t\t\t\t\t\t\t\"MMMM yyyy\",\n\t\t\t\t\t\t\t\"MMMM\",\n\t\t\t\t\t\t\t\"MMM-dd\",\n\t\t\t\t\t\t\t\"MMM-yy\",\n\t\t\t\t\t\t\t\"MM-dd\",\n\t\t\t\t\t\t\t\"MM/dd/yyyy\",\n\t\t\t\t\t\t\t\"MM/dd/yy\",\n\t\t\t\t\t\t\t\"MM\",\n\t\t\t\t\t\t\t\"dd\",\n\t\t\t\t\t\t\t\"dd/MM/yy\",\n\t\t\t\t\t\t\t\"dd/MM/yyyy\",\n\t\t\t\t\t\t\t\"dd.MM.yyyy\",\n\t\t\t\t\t\t\t\"dd MMMM yyyy\",\n\t\t\t\t\t\t\t\"dd 'day of' MMMM yyyy\",\n\t\t\t\t\t\t\t\"yyyy-MM-dd\",\n\t\t\t\t\t\t\t\"yyyy\",\n\t\t\t\t\t\t\t\"yy-MMM\",\n\t\t\t\t\t\t\t\"yy-MMM-dd\"\n\t\t\t\t\t\t}.AsReadOnly();\n\n\t\t\t\t\t\t_dateFormats = tempDateFormats;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn _dateFormats;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic class DocuSignAgreementStatus\n\t\t{\n\t\t\tpublic const string AgreementStatus = \"Agreement Status\";\n\t\t\tpublic const string StatusChangedDate = \"Agreement Status Timestamp\";\n\t\t}\n\n\t\tpublic class DocuSignAuthenticationScopes\n\t\t{\n\t\t\tpublic const string Signature = \"signature\";\n\t\t\tpublic const string Impersonation = \"impersonation\";\n\t\t\tpublic const string AccountProductRead = \"account_product_read\";\n\t\t\tpublic const string ProvisionRead = \"provision_read\";\n\t\t\tpublic const string CreateManagedToken = \"create_managed_token\";\n\t\t\tpublic const string ProvisionWrite = \"provision_write\";\n\t\t\tpublic const string ProvisionPendingOrders = \"provision_order_pending_orders\";\n\t\t\tpublic const string UserRead = \"user_read\";\n\t\t\tpublic const string UserWrite = \"user_write\";\n\t\t\tpublic const string AccountSyncWrite = \"accountsync_write\";\n\t\t\tpublic const string PublicKeyApi = \"public_key_api\";\n\t\t\tpublic const string GroupManagementRead = \"group_management_read\";\n\t\t\tpublic const string GroupManagementWrite = \"group_management_write\";\n\t\t\tpublic const string MeProfile = \"me_profile\";\n\t\t\tpublic const string InviteCallback = \"invite_callback\";\n\t\t\tpublic const string ClmAppRestrictedScope = \"clm_app_restricted\";\n\t\t\tpublic const string NegotiationReview = \"negotiation_review\";\n\t\t\tpublic const string ActRead = \"act_read\";\n\t\t\tpublic const string ActWrite = \"act_write\";\n\t\t\tpublic const string ActExecute = \"act_execute\";\n\t\t\tpublic const string ActFirstParty = \"act_first_party\";\n\t\t\tpublic const string AnalyzerCallback = \"analyzer_callback\";\n\t\t\tpublic const string AisAnalyze = \"ais_analyze\";\n\t\t\tpublic const string AprRead = \"apr_read\";\n\t\t\tpublic const string AprWrite = \"apr_write\";\n\t\t\tpublic const string DcfWrite = \"dcf_write\";\n\t\t\tpublic const string RealTimeApiCreateToken = \"rtm_token_create\";\n\t\t\tpublic const string SearchRead = \"search_read\";\n\t\t\tpublic const string SearchWrite = \"search_write\";\n\t\t\tpublic const string RealTimeApiChannelAccess = \"rtm_channel_access\";\n\t\t\tpublic const string CollaborationApi = \"collaboration\";\n\t\t\tpublic const string TasksApi = \"task_api\";\n\t\t\tpublic const string ProfileNotificationClm = \"profile_notification_CLM\";\n\t\t\tpublic const string ProfileNotificationGen = \"profile_notification_Gen\";\n\t\t\tpublic const string ProfileNotificationNegotiate = \"profile_notification_Negotiate\";\n\t\t\tpublic const string ProvisionAccountRead = \"provision_account_read\";\n\t\t\tpublic const string ClmAiBatchWrite = \"clm_ai_batch_write\";\n\t\t\tpublic const string ClmCallback = \"clm_processing_status_callback\";\n\t\t\tpublic const string NotificationService = \"notification_service\";\n\t\t\tpublic const string DocGenWrite = \"docgen_write\";\n\t\t\tpublic const string SpringWriteScope = \"spring_write\";\n\t\t\tpublic const string SpringReadScope = \"spring_read\";\n\t\t\tpublic const string SpringContentScope = \"spring_content\";\n\t\t\tpublic const string ClmUI = \"clm_ui\";\n\t\t\tpublic const string ClmCommunityUserAccess = \"clm_community_user_access\";\n\t\t\tpublic const string AomRead = \"agreement_object_model_read\";\n\t\t\tpublic const string AomWrite = \"agreement_object_model_write\";\n\t\t\tpublic const string AIRulesEngineExecuteScope = \"ai_rules_engine_execute\";\n\t\t\tpublic const string AIRulesEngineReadScope = \"ai_rules_engine_read\";\n\t\t\tpublic const string AIRulesEngineWriteScope = \"ai_rules_engine_write\";\n\t\t\tpublic const string EmailProcessing = \"email_processing\";\n\t\t\tpublic const string AuditServer = \"audit_server\";\n\t\t\tpublic const string ModelsESignManage = \"models_esign_manage\";\n\t\t\tpublic const string ModelsRead = \"models_read\";\n\t\t\tpublic const string ModelsWrite = \"models_write\";\n\t\t\tpublic const string AdmStoreUnifiedRepoRead = \"adm_store_unified_repo_read\";\n\t\t\tpublic const string AdmStoreUnifiedRepoWrite = \"adm_store_unified_repo_write\";\n\t\t\tpublic const string AccessRead = \"access_read\";\n\t\t\tpublic const string AccessWrite = \"access_write\";\n\t\t\tpublic const string Doc2PdfClient = \"msf_doc2pdf\";\n\t\t\tpublic const string AdmDotRead = \"adm_dot_read\";\n\t\t\tpublic const string AdmDotWrite = \"adm_dot_write\";\n\t\t\tpublic const string ClmActivitiesExecute = \"clm_activities_execute\";\n\t\t\tpublic const string ObligationManagementRead = \"obligation_management_read\";\n\t\t\tpublic const string ObligationManagementWrite = \"obligation_management_write\";\n\t\t\tpublic const string ClmIngestion = \"clm_ingestion\";\n\t\t    public const string IntegrationsExtensionRead = \"ie_sf_read\";\n\t\t\tpublic const string IntegrationsExtensionWrite = \"ie_sf_write\";\n\t\t}\n\n\t\tpublic class DocuSignCustomHeaders\n\t\t{\n\t\t\tpublic const string CorrelationToken = \"X-DocuSign-CorrelationToken\";\n\t\t\tpublic const string ClmAccountId = \"X-Clm-Account-Id\";\n\t\t\tpublic const string ClmSiteName = \"X-Clm-SiteName\";\n\t\t\tpublic const string ClmAccountGuid = \"X-Clm-Account-Guid\";\n\t\t\tpublic const string ClmUserId = \"X-Clm-User-Id\";\n\t\t\tpublic const string ClmAccountType = \"X-Clm-Account-Type\";\n\t\t\tpublic const string SourceContext = \"X-Source-Context\";\n\t\t\tpublic const string TraceToken = \"X-DocuSign-TraceToken\";\n\t\t\tpublic const string TraceParent = \"traceparent\";\n\t\t\tpublic const string IsRepost = \"X-DocuSign-Repost\";\n\t\t\tpublic const string AppId = \"X-Act-App-Id\";\n\t\t\tpublic const string ClientTransactionId = \"X-DocuSign-ClientTransactionId\";\n\t\t\tpublic const string DocuSignAccountId = \"X-DocuSign-AccountId\";\n\t\t\tpublic const string DocuSignUserId = \"X-DocuSign-UserId\";\n\t\t\tpublic const string WorkflowActivityId = \"X-DocuSign-WorkflowActivityId\";\n\t\t\tpublic const string WorkflowInstanceId = \"X-DocuSign-WorkflowInstanceId\";\n\t\t\tpublic const string DocusignShardId = \"Docusign-Shard-Id\";\n\t\t}\n\n\t\tpublic class ActCustomHeaders\n\t\t{\n\t\t\tpublic const string DocuSignAccountIdGuid = \"X-DS-Account-Id-Guid\";\n\t\t\tpublic const string DocuSignAccountIdNumber = \"X-DS-Account-Id\";\n\t\t\tpublic const string DocuSignSiteName = \"X-DS-Site-Name\";\n\t\t\tpublic const string DocuSignUserId = \"X-DS-User-Id\";\n\t\t}\n\n\t\tpublic class Entitlements\n\t\t{\n\t\t\tpublic const string Gen = \"gen\";\n\t\t\tpublic const string Clm = \"clm\";\n\t\t\tpublic const string Negotiate = \"negotiate\";\n\t\t}\n\n\t\tpublic class ExternalReview\n\t\t{\n\t\t\tpublic const int CommentMaxCharLength = 750;\n\t\t\tpublic const string ReplyToEmail = \"review-clm\";\n\t\t\tpublic const int ReplyToEmailParts = 3;\n\t\t\tpublic const string EmbeddedDocumentPropertyId = \"DocId\";\n\t\t\tpublic static readonly string ReplyToEmailAddressFormat = $\"{ReplyToEmail}+{{0}}@{{1}}\";\n\t\t}\n\n\t\t// TODO: The human workflow activities method LegacyElementName() should use these constants, also HumanActivityHelper should use these as well.\n\t\tpublic class HumanActivity\n\t\t{\n\t\t\tpublic const string ApproveDocumentsActivity = \"Approve Documents\";\n\t\t\tpublic const string ChoiceActivity = \"Choice\";\n\t\t\tpublic const string RoutingActivity = \"Routing\";\n\t\t\tpublic const string ChooseDocumentsActivity = \"Choose Documents\";\n\t\t\tpublic const string ChooseUsersActivity = \"Choose Users\";\n\t\t\tpublic const string CreateDocumentActivity = \"Create or Upload Doc\";\n\t\t\tpublic const string EditDocumentsActivity = \"Edit Documents\";\n\t\t\tpublic const string FillFormActivity = \"Fill Form\";\n\t\t\tpublic const string FullPageFillFormActivity = \"Full Page Fill Form\";\n\t\t\tpublic const string EditFormActivity = \"Edit Form\";\n\t\t\tpublic const string FullPageEditFormActivity = \"Full Page Edit Form\";\n\t\t\tpublic const string ReviewAndSendForExternalReviewActivity = \"Review and Send for External Review\";\n\t\t\tpublic const string ReviewAndSendForSignatureActivity = \"Review and Send for Signature\";\n\t\t\tpublic const string DataReview = \"Data Review\";\n\t\t\tpublic const string DataReconciliationActivity = \"Data Reconciliation\";\n\t\t\tpublic const string ReviewData = \"Review Data\";\n\t\t}\n\n\t\tpublic class HelpKeys\n\t\t{\n\t\t\t// Total char length of MainKey plus any individual key's string should not exceed 50 chars.\n\t\t\tpublic const string MainKey = \"HelpMessageDismissed_\"; //Length=21\n\n\t\t\tpublic const string AccountClone = MainKey + \"AccountClone\";\n\t\t\tpublic const string AccountContact = MainKey + \"AccountContact\";\n\t\t\tpublic const string AddressBook = MainKey + \"AddressBook\";\n\t\t\tpublic const string APIUsers = MainKey + \"APIUsers\";\n\t\t\tpublic const string AutoNumbers = MainKey + \"AutoNumbers\";\n\t\t\tpublic const string BPMEditDocuments = MainKey + \"BPMEditDocuments\";\n\t\t\tpublic const string BPMWorkList = MainKey + \"BPMWorkList\";\n\t\t\tpublic const string BrowseDocuments = MainKey + \"BrowseDocuments\";\n\t\t\tpublic const string BrowseForms = MainKey + \"BrowseForms\";\n\t\t\tpublic const string CaseViewer = MainKey + \"CaseViewer\";\n\t\t\tpublic const string CheckIn = MainKey + \"CheckIn\";\n\t\t\tpublic const string ConfigureToolbars = MainKey + \"ConfigureToolbars\";\n\t\t\tpublic const string ConfigureMenus = MainKey + \"ConfigureMenus\";\n\t\t\tpublic const string ConfigureMetadata = MainKey + \"ConfigureMetadata\";\n\t\t\tpublic const string ConfigureMetadataRelation = MainKey + \"ConfigureMetadataRelation\";\n\t\t\tpublic const string CreateContact = MainKey + \"CreateContact\";\n\t\t\tpublic const string CreateFolder = MainKey + \"CreateFolder\";\n\t\t\tpublic const string CreateFolderEditMode = MainKey + \"CreateFolderEditMode\";\n\t\t\tpublic const string CreateFolderLink = MainKey + \"CreateFolderLink\";\n\t\t\tpublic const string CreateFolderLinkEditMode = MainKey + \"CreateFolderLinkEditMode\";\n\t\t\tpublic const string CreateUser = MainKey + \"CreateUser\";\n\t\t\tpublic const string Dashboard = MainKey + \"Dashboard\";\n\t\t\tpublic const string DeviceManagement = MainKey + \"DeviceManagement\";\n\t\t\tpublic const string DocumentHistory = MainKey + \"DocumentHistory\";\n\t\t\tpublic const string DocumentRules = MainKey + \"DocumentRules\";\n\t\t\tpublic static string ElectronicSignature = MainKey + \"ElectronicSignature\";\n\t\t\tpublic const string Forms = MainKey + \"Forms\";\n\t\t\tpublic const string HelpMenu = MainKey + \"HelpMenu\";\n\t\t\tpublic const string ImportAddressBook = MainKey + \"ImportAddressBook\";\n\t\t\tpublic const string ImportGuests = MainKey + \"ImportGuests\";\n\t\t\tpublic const string ManageInboundEmail = MainKey + \"ManageInboundEmail\";\n\t\t\tpublic const string ManageKeywords = MainKey + \"ManageKeywords\";\n\t\t\tpublic const string MergedDocumentView = MainKey + \"MergedDocumentView\";\n\t\t\tpublic const string MetadataImportMappings = MainKey + \"MetadataImportMappings\";\n\t\t\tpublic const string MoveDocuments = MainKey + \"MoveDocuments\";\n\t\t\tpublic const string Packaging = MainKey + \"Packaging\";\n\t\t\tpublic const string PdfDelete = MainKey + \"PdfDelete\";\n\t\t\tpublic const string PdfRotate = MainKey + \"PdfRotate\";\n\t\t\tpublic const string PdfSplit = MainKey + \"PdfSplit\";\n\t\t\tpublic const string Preview = MainKey + \"Preview\";\n\t\t\tpublic const string QueryDesigner = MainKey + \"QueryDesigner\";\n\t\t\tpublic const string ReminderTemplates = MainKey + \"ReminderTemplates\";\n\t\t\tpublic const string ReportViewer = MainKey + \"ReportViewer\";\n\t\t\tpublic const string ReportCriteria = MainKey + \"ReportCriteria\";\n\t\t\tpublic const string Schedules = MainKey + \"Schedules\";\n\t\t\tpublic const string Search = MainKey + \"Search\";\n\t\t\tpublic const string Security = MainKey + \"Security\";\n\t\t\tpublic const string SecurityProgress = MainKey + \"SecurityProgress\";\n\t\t\tpublic const string SendDocuments = MainKey + \"SendDocuments\";\n\t\t\tpublic const string SendDocumentLinks = MainKey + \"SendDocumentLinks\";\n\t\t\tpublic const string SAMLSSOLinks = MainKey + \"SAMLSSOLinks\";\n\t\t\tpublic const string UploadContent = MainKey + \"UploadContent\";\n\t\t\tpublic const string VarAccountsManagement = MainKey + \"VarAccountsManagement\";\n\t\t\tpublic const string WorkflowConfirmSetup = MainKey + \"WorkflowConfirmSetup\";\n\t\t\tpublic const string WorkflowCreate = MainKey + \"WorkflowCreate\";\n\t\t\tpublic const string WorkflowConfiguration = MainKey + \"WorkflowConfiguration\";\n\t\t\tpublic const string WorkflowStart = MainKey + \"WorkflowStart\";\n\t\t\tpublic const string WorkflowWorklist = MainKey + \"WorkflowWorklist\";\n\t\t\tpublic const string WorkflowTemplates = MainKey + \"WorkflowTemplates\";\n\t\t}\n\n\t\tpublic class HttpContextCache\n\t\t{\n\t\t\tpublic const string ReportingServicesModel = \"ReportingServicesModel\";\n\t\t\tpublic const string RouteTemplate = \"RouteTemplate\";\n\t\t\tpublic const string RouteDictionary = \"RouteDictionary\";\n\t\t}\n\n\t\tpublic class HttpContextCookie\n\t\t{\n\t\t\tpublic const string COOKIE_NAME = \"SpringCMAtlas\";\n\t\t\tpublic const string AccountId = \"aid\";\n\t\t\tpublic const string UserId = \"uid\";\n\t\t\tpublic const string AlertPreference = \"AlertPreference\";\n\t\t\tpublic const string NewDocumentsReceivedPreference = \"NewDocumentsReceivedPreference\";\n\t\t\tpublic const string NavigationSplitter = \"Splitter\";\n\t\t\tpublic const string NavigationSplitterWidth = \"SplitterWidth\";\n\t\t\tpublic const string NavigationSplitterCollapsed = \"SplitterCollapsed\";\n\t\t\tpublic const string SESSION_ID = \"random\";\n\t\t\tpublic const string SESSION_IDPartitioned = \"randomPartitioned\";\n\t\t\tpublic const string LogoutToken = \"LogoutToken\";\n\t\t\tpublic const string FederatedAccountID = \"FederatedAccountID\";\n\t\t\tpublic const string UserAgeInHours = \"UserAge\";\n\t\t\tpublic const string AccountType = \"AccountType\";\n\t\t\tpublic const string SFDC = \"SFDC\";\n\t\t\tpublic const string Trial = \"Trial\";\n\t\t\tpublic const string SCMUser = \"SCM\";\n\t\t\tpublic const string AspNetSessionId = \"ASP.NET_SessionId\";\n\t\t\tpublic const string Language = \"_language\";\n\t\t\tpublic const string BTCookie = \"bt\";\n\t\t\tpublic const string SamlCookie = \"SamlCookie\";\n\t\t\tpublic const string SamlCookiePartitioned = \"SamlCookiePartitioned\";\n\t\t\tpublic const string IE11DeprecationOAuthClient = \"IE11DeprecationOAuthClient\";\n\t\t\tpublic const string IE11DeprecationOAuthClientPartitioned = \"IE11DeprecationOAuthClientPartitioned\";\n\t\t}\n\n\t\tpublic class IntellegoIntegration\n\t\t{\n\t\t\tpublic const string DocumentReferenceFormat = \"{0}_{1}_{2}\"; // {AccountId}_{DocumentUid}_{FileDataUid}\n\t\t}\n\n\t\tpublic class JavaScriptVars\n\t\t{\n\t\t\tpublic const string TempFileName = \"TempFileName\";\n\t\t\tpublic const string MimeType = \"mimeType\";\n\t\t\tpublic const string FileName = \"name\";\n\t\t\tpublic const string Size = \"size\";\n\t\t\tpublic const string Chunked = \"chunked\";\n\t\t\tpublic const string Error = \"error\";\n\t\t\tpublic const string JsonMimeType = \"application/json\";\n\t\t\tpublic const string LegacyHistoryPropertyName = \"__legacyMessage\";\n\t\t\tpublic const string LegacyHistoryRelatedDocumentUid = \"__legacyRelatedDocumentUid\";\n\t\t\tpublic const string LegacyHistoryRelatedDocumentVersion = \"__legacyReatedDocumentVersion\";\n\t\t\tpublic const string LegacyHistoryWorkflowInstanceUid = \"__legacyHistoryWorkflowInstanceUid\";\n\t\t\tpublic const string DocumentHistoryFolderPath = \"FolderPath\";\n\t\t\tpublic const string HistoryJsonData = \"__jsonData\";\n\t\t}\n\n\t\tpublic class SalesforceIntegration\n\t\t{\n\t\t\tpublic const string DefaultSFSubDomain = \"login\";\n\t\t}\n\n\t\tpublic class SparkJobVars\n\t\t{\n\t\t\tpublic const string Cassandra = \"cassandra\";\n\t\t\tpublic const string KespaceNames = \"keyspaceNames\";\n\t\t\tpublic const string History = \"history\";\n\t\t\tpublic const string AccountId = \"accountId\";\n\t\t\tpublic const string AllUsers = \"allUsers\";\n\t\t\tpublic const string UserAccountUid = \"userAccountUid\";\n\t\t\tpublic const string Email = \"email\";\n\t\t\tpublic const string StartDate = \"startDate\";\n\t\t\tpublic const string EndDate = \"endDate\";\n\t\t\tpublic const string BucketType = \"bucketType\";\n\t\t\tpublic const string SaveType = \"saveType\";\n\t\t\tpublic const string SqlConnectionString = \"sqlConnectionString\";\n\t\t\tpublic const string ReportUid = \"reportUid\";\n\t\t\tpublic const string UploadActionTypes = \"uploadActionTypes\";\n\t\t\tpublic const string Columns = \"columns\";\n\t\t\tpublic const string Filters = \"filters\";\n\t\t\tpublic const string Threshold = \"threshold\";\n\t\t\tpublic const string TimeZone = \"timezoneid\";\n\t\t\tpublic const string Limit = \"limit\";\n\t\t\tpublic const string userName = \"spark.cassandra.auth.username\";\n\t\t\tpublic const string password = \"spark.cassandra.auth.password\";\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Values here must be public const strings. These are read using reflection in MetadataGroupRepository.cs\n\t\t/// </summary>\n\t\tpublic class SystemMetadataGroupNames\n\t\t{\n\t\t\tpublic const string EMAIL = \"Email\";\n\t\t\tpublic const string FAX = \"Fax\";\n\t\t\tpublic const string SFORCE = \"SForce\";\n\t\t\tpublic const string METAGROUP_ATTACHMENT = \"Document Attachment Set\";\n\t\t\tpublic const string XOBJECT = \"Spring External Object Reference\";\n\t\t\tpublic const string VIDEO_INFO = \"SpringCM-VideoInfo\";\n\t\t\tpublic const string OCR_SPLIT = \"SpringOCRSplitStatus\";\n\t\t\tpublic const string TERM_SYNC = \"SpringCM Term Sync\";\n\t\t\tpublic const string DOCUSIGN_AGREEMENT_STATUS = \"DocuSign Agreement Group\";\n\t\t\tpublic const string CLM_AGREEMENT_DETAILS = \"CLM Agreement Details\";\n\t\t\tpublic const string CLM_PARTY = \"CLM Party\";\n\t\t}\n\n\t\t//TODO combine w/PostVariables as RequestParameters\n\t\t//TODO refactor multiple different things into same one (eg. AccountIdAbbreviated, AccountId)-> AccountId\n\t\tpublic class QueryStringParameters\n\t\t{\n\t\t\tpublic const string AccessKey = \"ak\";\n\t\t\tpublic const string AccountId_LEGACY_DONT_USE = \"accountId\";\n\t\t\tpublic const string AccountIdAbbreviated = \"aid\";\n\t\t\tpublic const string AccountIdToClone = \"accountIdToClone\";\n\t\t\tpublic const string Action = \"action\";\n\t\t\tpublic const string ActionType = \"actionType\";\n\t\t\tpublic const string AdvancedSearchQuery = \"asq\";\n\t\t\tpublic const string AdvanceStyle = \"AdvanceStyle\";\n\t\t\tpublic const string AgreementAnalyzer = \"AgreementAnalyzer\";\n\t\t\tpublic const string ApiKey = \"apikey\";\n\t\t\tpublic const string ApiServerUrl = \"apiServerURL\";\n\t\t\tpublic const string ApprovalWorkflowUid = \"approvalWorkflowUid\";\n\t\t\tpublic const string Attributes = \"attributes\";\n\t\t\tpublic const string AuthorizationToken = \"authz\";\n\t\t\tpublic const string BPMExecutionId = \"wid\";\n\t\t\tpublic const string BPMMultipleWorkflows = \"multiple\";\n\t\t\tpublic const string BPMWorkItemId = \"wiid\";\n\t\t\tpublic const string BPMWorkflowName = \"bpmwn\";\n\t\t\tpublic const string BPMWorkflowVersion = \"bpmwv\";\n\t\t\tpublic const string CancelRename = \"cancelRename\";\n\t\t\tpublic const string CancelTransaction = \"CancelTransaction\";\n\t\t\tpublic const string CancelUrl = \"cu\";\n\t\t\tpublic const string CanSelectFolders = \"CanSelectFolders\";\n\t\t\tpublic const string CanSelectUrls = \"CanSelectUrls\";\n\t\t\tpublic const string CaseUid = \"caseUid\";\n\t\t\tpublic const string ClientId = \"client_id\";\n\t\t\tpublic const string code = \"code\";\n\t\t\tpublic const string CollaborationId = \"collaborationId\";\n\t\t\tpublic const string CollaborationUid = \"collaborationUid\";\n\t\t\tpublic const string Columns = \"columns\";\n\t\t\tpublic const string ColumnWrap = \"ColumnWrap\";\n\t\t\tpublic const string Comments = \"comments\";\n\t\t\tpublic const string CompleteExternalReview = \"CompleteExternalReview\";\n\t\t\tpublic const string ConfigUid = \"configUid\";\n\t\t\tpublic const string Confirmation = \"confirmation\";\n\t\t\tpublic const string ConfirmationType = \"type\";\n\t\t\tpublic const string ContactUid = \"contactUid\";\n\t\t\tpublic const string CorrelationId = \"correlationId\";\n\t\t\tpublic const string Cid = \"cid\";\n\t\t\tpublic const string Culture = \"cul\";\n\t\t\tpublic const string CurrentTab = \"CurrentTab\";\n\t\t\tpublic const string CurrentUrl = \"CurrentUrl\";\n\t\t\tpublic const string CustomReportUid = \"customReportUid\";\n\t\t\tpublic const string CustomRuleUid = \"RuleUid\";\n\t\t\tpublic const string CustomRuleKind = \"RuleKind\";\n\t\t\tpublic const string Default = \"default\";\n\t\t\tpublic const string Degrees = \"degrees\";\n\t\t\tpublic const string Dev = \"dev\";\n\t\t\tpublic const string DocumentAttributeTypeId = \"LDTID\";\n\t\t\tpublic const string DocumentIdAbbreviated = \"ldid\";\n\t\t\tpublic const string DocumentId = \"documentId\";\n\t\t\tpublic const string SelectedDocumentIds = \"documentIds\";\n\t\t\tpublic const string DocumentUid = \"ldUid\";\n\t\t\tpublic const string DocumentUidExpanded = \"documentUid\";\n\t\t\tpublic const string DocumentUids = \"DocumentUids\";\n\t\t\tpublic const string Download = \"download\";\n\t\t\tpublic const string DocumentTitle = \"title\";\n\t\t\tpublic const string DocumentHistoryFilter = \"historyfilter\";\n\t\t\tpublic const string DPBUid = \"dpbuid\";\n\t\t\tpublic const string Ds = \"ds\";\n\t\t\tpublic const string DocuSignAccountId = \"accountId\";\n\t\t\tpublic const string DocuSignAccountIdAbbreviated = \"dsaid\";\n\t\t\tpublic const string DocuSignGroupId = \"dsgroupId\";\n\t\t\tpublic const string DocuSignUserId = \"dsuserId\";\n\t\t\tpublic const string ElectronicSignature = \"ElectronicSignature\";\n\t\t\tpublic const string DocumentExtract = \"DocumentExtract\";\n\t\t\tpublic const string DocumentDeletePages = \"DocumentDeletePages\";\n\t\t\tpublic const string DocumentRotate = \"DocumentRotate\";\n\t\t\tpublic const string EnableGuests = \"enableGuests\";\n\t\t\tpublic const string EnableMultiselection = \"EnableMultiselection\";\n\t\t\tpublic const string EosParamsToken = \"eostoken\";\n\t\t\tpublic const string DPI = \"DPI\";\n\t\t\tpublic const string Draft = \"draft\";\n\t\t\tpublic const string EditMode = \"EditMode\";\n\t\t\tpublic const string Email = \"email\";\n\t\t\tpublic const string EnableContacts = \"enableContacts\";\n\t\t\tpublic const string EnableDistributionGroups = \"enableDistGroups\";\n\t\t\tpublic const string EnableFullSubscribers = \"enableFS\";\n\t\t\tpublic const string EnableLimitedSubscribers = \"enableLS\";\n\t\t\tpublic const string EnableSecurityGroups = \"enableSecurityGroups\";\n\t\t\tpublic const string EnableQueue = \"enableQueue\";\n\t\t\tpublic const string EnableSuperAdministrators = \"enableSuperAdminis\";\n\t\t\tpublic const string EnableUserAdministrators = \"enableUserAdmins\";\n\t\t\tpublic const string EnableUsers = \"enableUsers\";\n\t\t\tpublic const string EndDate = \"enddate\";\n\t\t\tpublic const string EosPath = \"eosPath\";\n\t\t\tpublic const string ESignatureUid = \"ESignatureUid\";\n\t\t\tpublic const string DocuSignEvent = \"event\";\n\t\t\tpublic const string ExpandedValues = \"ExpandedValues\";\n\t\t\tpublic const string Expired = \"expired\";\n\t\t\tpublic const string ExternalReviewUid = \"ERUid\";\n\t\t\tpublic const string ExternalReview = \"ExternalReview\";\n\t\t\tpublic const string ExternalReviewAttachmentUid = \"XrAttachmentUid\";\n\t\t\tpublic const string CompleteInternally = \"CompleteInternally\";\n\t\t\tpublic const string DlcName = \"dlcname\";\n\t\t\tpublic const string Fax = \"fax\";\n\t\t\tpublic const string FeelLucky = \"FeelLucky\";\n\t\t\tpublic const string Filetype = \"Filetype\";\n\t\t\tpublic const string Forms = \"forms\";\n\t\t\tpublic const string SingleResultShowPreview = \"SingleResultShowPreview\";\n\t\t\tpublic const string FileDataUid = \"fdUid\";\n\t\t\tpublic const string FileMoveStyle = \"FileMoveStyle\";\n\t\t\tpublic const string FindLargerThan = \"largerThan\";\n\t\t\tpublic const string FolderId = \"fid\";\n\t\t\tpublic const string FolderLinkUid = \"flUid\";\n\t\t\tpublic const string FolderPath = \"folderPath\";\n\t\t\tpublic const string FolderUid = \"fUid\";\n\t\t\tpublic const string ForceReturn = \"forceReturn\";\n\t\t\tpublic const string RootFolderUid = \"rootFolderUid\";\n\t\t\tpublic const string ForAdvancedWorkflowUse = \"ForAdvancedWorkflowUse\";\n\t\t\tpublic const string ForceNewSearch = \"forceNewSearch\";\n\t\t\tpublic const string ForceScriptLogger = \"scriptlog\";\n\t\t\tpublic const string FormContainer = \"FormContainer\";\n\t\t\tpublic const string FormUid = \"FormUid\";\n\t\t\tpublic const string Format = \"Format\";\n\t\t\tpublic const string Forwarded = \"forwarded\";\n\t\t\tpublic const string GroupUid = \"groupUid\";\n\t\t\tpublic const string GroupDataUids = \"groupDataUids\";\n\t\t\tpublic const string HideAddressBookFilters = \"hideAddressBookFilters\";\n\t\t\tpublic const string ShowContinueButton = \"scb\";\n\t\t\tpublic const string HideInboxes = \"HideInboxes\";\n\t\t\tpublic const string HideTrash = \"HideTrash\";\n\t\t\tpublic const string HidePdfToolbar = \"hideToolbar\";\n\t\t\tpublic const string Id = \"Id\";\n\t\t\tpublic const string Ids = \"Ids\";\n\t\t\tpublic const string Uid = \"Uid\";\n\t\t\tpublic const string SetUid = \"SetUid\";\n\t\t\tpublic const string IncludeComments = \"IncludeComments\";\n\t\t\tpublic const string IncludeLexionMetadata = \"IncludeLexionMetadata\";\n\t\t\tpublic const string IncludeDocuments = \"IncludeDocuments\";\n\t\t\tpublic const string IncludeFolders = \"IncludeFolders\";\n\t\t\tpublic const string IncludeChildren = \"IncludeChildren\";\n\t\t\tpublic const string IncludeFolderPath = \"IncludeFolderPath\";\n\t\t\tpublic const string IncludeSource = \"IncludeSource\";\n\t\t\tpublic const string IncludeTrashed = \"IncludeTrashed\";\n\t\t\tpublic const string Inline = \"inline\";\n\t\t\tpublic const string InSubFolders = \"inSubfolders\";\n\t\t\tpublic const string IsApproved = \"isApproved\";\n\t\t\tpublic const string IsAggregate = \"isAggregate\";\n\t\t\tpublic const string IsMobile = \"ismobile\";\n\t\t\tpublic const string IsPassiveSearch = \"isPassiveSearch\";\n\t\t\tpublic const string IsProcessInsights = \"isProcessInsights\";\n\t\t\tpublic const string IsSavedSearch = \"isSavedSearch\";\n\t\t\tpublic const string ItemActionXml = \"iax\";\n\t\t\tpublic const string Iterator = \"iter\";\n\t\t\tpublic const string IsPopup = \"popup\";\n\t\t\tpublic const string Key = \"Key\";\n\t\t\tpublic const string Keyword = \"Keyword\";\n\t\t\tpublic const string Language = \"ln\";\n\t\t\tpublic const string Libraries = \"libraries\";\n\t\t\tpublic const string LimitToGroups = \"limitToGroupUids\";\n\t\t\tpublic const string LimitToTaskGroups = \"limitToTaskGroupUids\";\n\t\t\tpublic const string LoadingRoot = \"loadingRoot\";\n\t\t\tpublic const string LoadExisting = \"LoadExisting\";\n\t\t\tpublic const string LoadWriteAccessOnly = \"LoadWriteAccessOnly\";\n\t\t\tpublic const string LogHistory = \"lh\";\n\t\t\tpublic const string LoginDelegationId = \"delid\";\n\t\t\tpublic const string LoginClear = \"lc\";\n\t\t\tpublic const string LoginUid = \"LoginUid\";\n\t\t\tpublic const string LogOut = \"LogOut\";\n\t\t\tpublic const string MemberOf = \"MemberOf\";\n\t\t\tpublic const string MenuId = \"menuId\";\n\t\t\tpublic const string MergeUid = \"mergeuid\";\n\t\t\tpublic const string MetadataGroupUid = \"MetadataGroupUid\";\n\t\t\tpublic const string MetadataGroupUids = \"MetadataGroupUids\";\n\t\t\tpublic const string MergeSuccess = \"MergeSuccess\";\n\t\t\tpublic const string MergeError = \"MergeError\";\n\t\t\tpublic const string MergeInfo = \"MergeInfo\";\n\t\t\tpublic const string MessageRef = \"MessageRef\";\n\t\t\tpublic const string Mode = \"mode\";\n\t\t\tpublic const string ModifiedBy = \"modifiedBy\";\n\t\t\tpublic const string ModifiedDateStart = \"modifiedDateStart\";\n\t\t\tpublic const string ModifiedDateEnd = \"modifiedDateEnd\";\n\t\t\tpublic const string Name = \"Name\";\n\t\t\tpublic const string Nav = \"nav\";\n\t\t\tpublic const string NewAccount = \"newaccount\";\n\t\t\tpublic const string NewTrial = \"newtrial\";\n\t\t\tpublic const string NewReport = \"newReport\";\n\t\t\tpublic const string NotComplete = \"nc\";\n\t\t\tpublic const string NoCopy = \"NoCopy\";\n\t\t\tpublic const string NotifyFrequency = \"nf\";\n\t\t\tpublic const string ObjectUid = \"oUid\";\n\t\t\tpublic const string ObjectType = \"oType\";\n\t\t\tpublic const string ObligationId = \"obligationId\";\n\t\t\tpublic const string OneClickDocGen = \"oneclickdocgen\";\n\t\t\tpublic const string OnlyAPIUsers = \"onlyAPIUsers\";\n\t\t\tpublic const string OnlyWorkflow = \"onlyWF\";\n\t\t\tpublic const string OrgId = \"orgid\";\n\t\t\tpublic const string OwnedByUser = \"OwnedByUser\";\n\t\t\tpublic const string Page = \"page\";\n\t\t\tpublic const string PageNumber = \"PageNumber\";\n\t\t\tpublic const string PageSize = \"PageSize\";\n\t\t\tpublic const string PartyId = \"partyId\";\n\t\t\tpublic const string PasswordStrengthInvalid = \"psInvalid\";\n\t\t\tpublic const string Pdf = \"pdf\";\n\t\t\tpublic const string PDFView = \"PDFView\";\n\t\t\tpublic const string PreviousDocumentUid = \"prevldUid\";\n\t\t\tpublic const string PreviousObjectUid = \"prevoUid\";\n\t\t\tpublic const string PreviousObjectType = \"prevotype\";\n\t\t\tpublic const string ProcessUid = \"processUid\";\n\t\t\tpublic const string Prompt = \"prompt\";\n\t\t\tpublic const string PublicShareLinkUid = \"pslUid\";\n\t\t\tpublic const string QA = \"qa\"; // Query-Attributes for search...\n\t\t\tpublic const string Q = \"q\";\n\t\t\tpublic const string Query = \"query\";\n\t\t\tpublic const string QueryExclude = \"queryExclude\";\n\t\t\tpublic const string QueryAny = \"queryAny\";\n\t\t\tpublic const string QueryPhase = \"queryPhrase\";\n\t\t\tpublic const string QueueId = \"qid\";\n\t\t\tpublic const string ReadOnly = \"readonly\";\n\t\t\tpublic const string Reload = \"reload\";\n\t\t\tpublic const string RenderPartial = \"renderPartial\";\n\t\t\tpublic const string ReminderUid = \"ReminderUid\";\n\t\t\tpublic const string ReportExportFormat = \"reportExportFormat\";\n\t\t\tpublic const string ReportName = \"reportName\";\n\t\t\tpublic const string ReportKey = \"reportKey\";\n\t\t\tpublic const string ReportPath = \"ReportPath\";\n\t\t\tpublic const string ReportSortInfo = \"reportSortInfo\";\n\t\t\tpublic const string ReportSearchQuery = \"reportSearchQuery\";\n\t\t\tpublic const string ReportViewType = \"reportViewType\";\n\t\t\tpublic const string ReportType = \"reportType\";\n\t\t\tpublic const string ReportUid = \"reportUid\";\n\t\t\tpublic const string ReportContext = \"rptctx\";\n\t\t\tpublic const string RequestMode = \"requestMode\";\n\t\t\tpublic const string Required = \"required\";\n\t\t\tpublic const string Resume = \"resume\";\n\t\t\tpublic const string ResxRef = \"resxref\";\n\t\t\tpublic const string ReturnUrl = \"ru\";\n\t\t\tpublic const string relayState = \"relayState\";\n\t\t\tpublic const string Role = \"role\";\n\t\t\tpublic const string RuleId = \"ruleId\";\n\t\t\tpublic const string SavedSearchUid = \"ssUid\";\n\t\t\tpublic const string SavedSearchId = \"savedSearchId\";\n\t\t\tpublic const string ScmEosPath = \"ScmPath\";\n\t\t\tpublic const string ScheduleUid = \"schedUid\";\n\t\t\tpublic const string SearchAllAttributes = \"searchAllAttributes\";\n\t\t\tpublic const string SearchId = \"searchId\";\n\t\t\tpublic const string SearchContent = \"searchContent\";\n\t\t\tpublic const string SearchDescription = \"searchDescription\";\n\t\t\tpublic const string SearchMode = \"SearchMode\";\n\t\t\tpublic const string SearchName = \"searchName\";\n\t\t\tpublic const string SearchSource = \"searchSource\";\n\t\t\tpublic const string SearchType = \"SearchType\";\n\t\t\tpublic const string Secure = \"secure\";\n\t\t\tpublic const string SelectedAccountId = \"said\";\n\t\t\tpublic const string SelectedNamespace = \"SelectedNamespace\";\n\t\t\tpublic const string SelectedNavTab = \"SelectedNavTab\";\n\t\t\tpublic const string Selection = \"Selection\";\n\t\t\tpublic const string SendForApproval = \"SendForApproval\";\n\t\t\tpublic const string ServerIP = \"ServerIP\";\n\t\t\tpublic const string SFAccountId = \"sfaid\";\n\t\t\tpublic const string SFAccountName = \"sfaname\";\n\t\t\tpublic const string SFAPIUrl = \"sfapiurl\";\n\t\t\tpublic const string SFChildId = \"sfchildid\";\n\t\t\tpublic const string SFObjectId = \"sfoid\";\n\t\t\tpublic const string SFObjectName = \"sfon\";\n\t\t\tpublic const string SFObjectType = \"sfot\";\n\t\t\tpublic const string SFRetURL = \"sfreturl\";\n\t\t\tpublic const string SFSessionId = \"sfsid\";\n\t\t\tpublic const string SFSpringView = \"springview\";\n\t\t\tpublic const string ShareType = \"ShareType\";\n\t\t\tpublic const string ShowDisabledUsers = \"ShowDisabledUsers\";\n\t\t\tpublic const string ShowSuccessOnSave = \"ShowSuccessOnSave\";\n\t\t\tpublic const string SignedRequest = \"signed_request\";\n\t\t\tpublic const string SAMLResponse = \"SAMLResponse\";\n\t\t\tpublic const string SAMLRequest = \"SAMLRequest\";\n\t\t\tpublic const string SAMLMetadata = \"SAMLMetadata\";\n\t\t\tpublic const string TargetRestriction = \"TargetRestriction\";\n\t\t\tpublic const string Size = \"size\";\n\t\t\tpublic const string Sort = \"sort\";\n\t\t\tpublic const string StartDate = \"startdate\";\n\t\t\tpublic const string SSOMode = \"SSOMode\";\n\t\t\tpublic const string StartMigration = \"startMigration\";\n\t\t\tpublic const string State = \"state\";\n\t\t\tpublic const string SuppressNavigation = \"SuppressNavigation\";\n\t\t\tpublic const string SUri = \"suri\";\n\t\t\tpublic const string SwitchToAccountId = \"switchaid\";\n\t\t\tpublic const string SwitchFromSiteName = \"switchfromsitename\";\n\t\t\tpublic const string Tab = \"tab\";\n\t\t\tpublic const string TabWas = \"TabWas\";\n\t\t\tpublic const string Target = \"Target\";\n\t\t\tpublic const string TargetFolderUid = \"tfUid\";\n\t\t\tpublic const string TaskUid = \"taskUid\";\n\t\t\tpublic const string TermSync = \"termSync\";\n\t\t\tpublic const string TimeStamp = \"ts\"; //generic time stamp\n\t\t\tpublic const string Token = \"token\";\n\t\t\tpublic const string Tour = \"tour\";\n\t\t\tpublic const string TransDocUid = \"transDocUid\";\n\t\t\tpublic const string TransReportName = \"transReportName\";\n\t\t\tpublic const string TransUid = \"transUid\";\n\t\t\tpublic const string TransType = \"transtype\";\n\t\t\tpublic const string TreeViewType = \"TreeViewType\";\n\t\t\tpublic const string TreeViewVisible = \"TreeViewVisible\";\n\t\t\tpublic const string Type = \"Type\";\n\t\t\tpublic const string UniqueKey = \"uk\";\n\t\t\tpublic const string Upgrade = \"upgrade\";\n\t\t\tpublic const string UploadToken = \"uploadToken\";\n\t\t\tpublic const string Url = \"url\";\n\t\t\tpublic const string UserId = \"userId\";\n\t\t\tpublic const string UserAccountUid = \"userAccountUid\";\n\t\t\tpublic const string UseInternalSSOCert = \"useInternalSSOCert\";\n\t\t\tpublic const string UserIds = \"UserIds\";\n\t\t\tpublic const string UserKey = \"userkey\";\n\t\t\tpublic const string UserLoginEmail = \"uEmail\";\n\t\t\tpublic const string UserName = \"username\";\n\t\t\tpublic const string UserPassword = \"uPwd\";\n\t\t\tpublic const string Viewer = \"view\";\n\t\t\tpublic const string VisibleColumns = \"visibleColumns\";\n\t\t\tpublic const string WaitForNextStep = \"wait\";\n\t\t\tpublic const string WidgetUid = \"widgetUid\";\n\t\t\tpublic const string WorkflowInbox = \"workflowinbox\";\n\t\t\tpublic const string WorkflowItemId = \"wfid\";\n\t\t\tpublic const string WorkflowInstanceUid = \"workflowinstanceuid\";\n\t\t\tpublic const string WorkFlowStepUid = \"WorkFlowStepUid\";\n\t\t\tpublic const string WorkFlowParams = \"params\";\n\t\t\tpublic const string WorkflowName = \"workflowname\";\n\t\t\tpublic const string WorkflowDefinition = \"workflowdefinition\";\n\t\t\tpublic const string WorkflowVersion = \"workflowversion\";\n\t\t\tpublic const string WorkflowRevision = \"workflowrevision\";\n\t\t\tpublic const string WorkflowTemplateId = \"templateId\";\n\t\t\tpublic const string Zoom = \"Zoom\";\n\t\t\tpublic const string SearchPayloadId = \"searchPayloadId\";\n\t\t\tpublic const string ForceReauth = \"force_reauth\";\n\n\t\t\tpublic class OAuth2\n\t\t\t{\n\t\t\t\tpublic const string Code = \"code\";\n\t\t\t\tpublic const string State = \"state\";\n\t\t\t\tpublic const string AccessToken = \"access_token\";\n\t\t\t\tpublic const string TokenType = \"token_type\";\n\t\t\t\tpublic const string ExpiresIn = \"expires_in\";\n\t\t\t}\n\t\t}\n\n\t\t//TODO combine w/QueryStringParameters as RequestParameters\n\t\tpublic class PostVariables\n\t\t{\n\t\t\tpublic const string EventTarget = \"__EVENTTARGET\";\n\t\t\tpublic const string iRole = \"iRole\";\n\t\t\tpublic const string BasicSearchSide = \"BasicSearchSide\";\n\t\t\tpublic const string BasicSearchMain = \"BasicSearchMain\";\n\t\t\tpublic const string txtCompany = \"txtCompany\";\n\t\t\tpublic const string txtContent = \"txtContent\";\n\t\t\tpublic const string txtEmail = \"txtEmail\";\n\t\t\tpublic const string txtFirstName = \"txtFirstName\";\n\t\t\tpublic const string txtFromDate = \"txtFromDate\";\n\t\t\tpublic const string txtKeywords = \"txtKeywords\";\n\t\t\tpublic const string txtLastName = \"txtLastName\";\n\t\t\tpublic const string txtSentFrom = \"txtSentFrom\";\n\t\t\tpublic const string txtTitle = \"txtTitle\";\n\t\t\tpublic const string txtToDate = \"txtToDate\";\n\t\t\tpublic const string RenameText = \"RenameText\";\n\t\t\tpublic const string tbxDocumentName = \"tbxDocumentName\";\n\t\t\tpublic const string ckbExpDate = \"ckbExpDate\";\n\t\t\tpublic const string tbxExpDate = \"tbxExpDate\";\n\t\t\tpublic const string ckbReminderDate = \"ckbReminderDate\";\n\t\t\tpublic const string tbxReminderDate = \"tbxReminderDate\";\n\t\t\tpublic const string tbxDocumentKeywords = \"tbxDocumentKeywords\";\n\t\t\tpublic const string Pages = \"pages\";\n\t\t\tpublic const string SFObjectXml = \"ObjectXml\";\n\t\t}\n\n\t\tpublic class ReportRegexStrings\n\t\t{\n\t\t\tpublic const string RegexDateOffsetsBegin = \"^[+-]{0,1}[0-9]+\";\n\t\t\tpublic const string RegexDateOffsetsEnd = \"[dmywq]\";\n\t\t\tpublic const string RegexDateOffsets = RegexDateOffsetsBegin + RegexDateOffsetsEnd;\n\t\t}\n\n\n\t\tpublic class ExtractService\n\t\t{\n\t\t\tpublic const string TextExtractorExtensions = \"TextExtractorExtensions\";\n\t\t\tpublic const string OCRExtractorExtensions = \"OCRExtractorExtensions\";\n\n\t\t\tpublic const string ExtractMaxRetries = \"ExtractMaxRetries\";\n\t\t\tpublic const string ExtractSleepSeconds = \"ExtractSleepSeconds\";\n\t\t\tpublic const string MaxFileSize = \"MaxFileSize\";\n\t\t\tpublic const string ExtractOcrPdfImageThresholdPercentHeight = \"ExtractOcrPdfImageThresholdPercentHeight\";\n\t\t\tpublic const string ExtractOcrPdfImageThresholdPercentWidth = \"ExtractOcrPdfImageThresholdPercentWidth\";\n\t\t\tpublic const string ExtractOcrContentPerPageThreshold = \"ExtractOcrContentPerPageThreshold\";\n\t\t\tpublic const string ExtractOcrContentPerPageMaxThreshold = \"ExtractOcrContentPerPageMaxThreshold\";\n\t\t\tpublic const string MinPriority = \"MinPriority\";\n\t\t\tpublic const string ExtractOcrPdfContentThreshold = \"ExtractOcrPdfContentThreshold\";\n\t\t\tpublic const string PdfFallBackFileSizeThreshold = \"PdfFallBackFileSizeThreshold\";\n\t\t\tpublic const string PdfFallBackMinutesThreshold = \"PdfFallBackMinutesThreshold\";\n\n\t\t\tpublic const string OCRDefaultEngineProfile = \"OCRDefaultEngineProfile\";\n\t\t\tpublic const string OCRAccurateEngineProfile = \"OCRAccurateEngineProfile\";\n\t\t\tpublic const string LicenseNumberFlexiCapture = \"LicenseNumberFlexiCapture\";\n\t\t\tpublic const string LicenseNumber = \"LicenseNumber\";\n\t\t\tpublic const string SerialNumber = \"SerialNumber\";\n\t\t\tpublic const string OCREnginePath = \"OCREnginePath\";\n\t\t\tpublic const string OCRConfigLocation = \"OCRConfigLocation\";\n\t\t\tpublic const string OCREngineProfileLoadAttempts = \"OCREngineProfileLoadAttempts\";\n\n\t\t\tpublic const string ExtractTaskTempStorageLocation = \"ExtractTaskTempStorageLocation\";\n\t\t}\n\n\t\tpublic class DocumentCompare\n\t\t{\n\t\t\tpublic const string RequestNamePrefix = \"DocumentCompareRequest_\";\n\t\t\tpublic const string CompareResultDeafultFilename = \"Compare-\";\n\t\t}\n\n\t\tpublic class OliveImageAssetNames\n\t\t{\n\t\t\tpublic const string docusignLogoDefault = \"ds-logo-default.svg\";\n\t\t\tpublic const string docusignFaviconDefault = \"ds-icons-favicon-default-64x64.svg\";\n\t\t\tpublic const string docusignEmailLogoDefault = \"email-templates/email-logo.png\";\n\t\t}\n\n\t\tpublic static class DocGen\n\t\t{\n\t\t\tpublic const string AllPagesExpression = \"all\";\n\t\t\tpublic const string DocxExtension = \"docx\";\n\t\t\tpublic const string PdfExtension = \"pdf\";\n\t\t\tpublic const string XmlExtension = \"xml\";\n\n\t\t\t// field names\n\t\t\tpublic const string SectionFieldName = \"Section\";\n\t\t\tpublic const string TextFieldFieldName = \"Text Field\";\n\t\t\tpublic const string TextBoxFieldName = \"Text Box\";\n\t\t\tpublic const string RichTextFieldName = \"Rich Text Box\";\n\t\t\tpublic const string DateFieldName = \"Date Field\";\n\t\t\tpublic const string AttachmentFieldName = \"Attachment\";\n\t\t\tpublic const string CheckboxFieldName = \"Check Box\";\n\t\t\tpublic const string NumberFieldName = \"Number\";\n\t\t\tpublic const string CurrencyFieldName = \"Currency\";\n\t\t\tpublic const string RadioButtonsFieldName = \"Radio Buttons\";\n\t\t\tpublic const string DropdownFieldName = \"Dropdown\";\n\n\t\t\tpublic const string DateFormatProperty = \"DateFormat\";\n\t\t\tpublic const string NumberFormatProperty = \"NumberFormat\";\n\t\t\tpublic const string CurrencyFormatProperty = \"CurrencyFormat\";\n\t\t\tpublic const string FormatProperty = \"Format\";\n\t\t\tpublic const string TargetIdentifierProperty = \"TargetIdentifier\";\n\n\t\t\t// API data source/target property keys\n\t\t\tpublic const string SalesforceRootObjectKey = \"SalesforceRootObject\";\n\n\t\t\t//field configuration transformers\n\t\t\tpublic const string TypeConvertToDecimal = \"TypeConvertToDecimal\";\n\t\t\tpublic const string NumericFormatTransformer = \"NumericFormatTransformer\";\n\n\t\t\t//field configuration default value\n\t\t\tpublic const string ExactNumberOfDigitsDefaultValue = \"6\";\n\t\t\tpublic const string DecimalPlacesDefaultValue = \"2\";\n\t\t\tpublic const string ThousandSeparatorDefaultValue = \",\";\n\t\t\tpublic const string DecimalSeparatorDefaultValue = \".\";\n\t\t\tpublic const string DigitGroupingIndexDefaultValue = \"0\";\n\n\t\t\t//validation parameters\n\t\t\tpublic const string Percent = \"percent\";\n\t\t\tpublic const string Decimal = \"decimal\";\n\t\t\tpublic const string Number = \"number\";\n\t\t\tpublic const string Dollar = \"dollar\";\n\n\t\t\t//Field Format Properties\n\t\t\tpublic const string DecimalSeparator = \"DecimalSeparator\";\n\t\t\tpublic const string ThousandSeparator = \"ThousandSeparator\";\n\t\t\tpublic const string ExactNumberOfDigits = \"ExactNumberOfDigits\";\n\t\t\tpublic const string DecimalPlaces = \"DecimalPlaces\";\n\n\t\t\t//field configuration format min max values\n\t\t\tpublic const int MinimumNumberOfDecimals = 0;\n\t\t\tpublic const int MaximumNumberOfDecimals = 15;\n\t\t\tpublic const int MaximumNumberOfDigits = 15;\n\n\t\t\t// radio buttons constants\n\t\t\tpublic const string OptionsRegexPattern = \"[a-zA-Z0-9]\";\n\t\t\tpublic const int OptionsLimit = 50;\n\n\t\t\t//Merge tag types\n\t\t\tpublic const string MergeTagTypeContent = \"Content\";\n\t\t\tpublic const string MergeTagTypeRichText = \"RichText\";\n\n\t\t\t/// <summary>\n\t\t\t/// See <a href=\"http://www.websupergoo.com/helppdf6net/source/3-concepts/2-objectinfo.htm\">here</a>.\n\t\t\t/// </summary>\n\t\t\tpublic const string ROTATE_INFO_TYPE = \"/Rotate\";\n\n\t\t\tpublic const string MERGE_ENGINE_OVERRIDE_GROUP_NAME = \"springcm merge engine\";\n\t\t\tpublic const string MERGE_ENGINE_OVERRIDE_FIELD_NAME_CURRENT = \"use current\";\n\t\t\tpublic const string MERGE_ENGINE_OVERRIDE_FIELD_NAME_LEGACY = \"use legacy\";\n\t\t}\n\n\t\tpublic static class FieldConfigTemplateIds\n\t\t{\n\t\t\tpublic const string Textfield = \"textfield\";\n\t\t\tpublic const string Numberfield = \"numberfield\";\n\t\t\tpublic const string Currencyfield = \"currencyfield\";\n\t\t\tpublic const string Textbox = \"textbox\";\n\t\t\tpublic const string Checkbox = \"checkbox\";\n\t\t\tpublic const string Sxterm = \"sxterm\";\n\t\t\tpublic const string Dropdown = \"dropdown\";\n\t\t\tpublic const string MultiSelectDropdown = \"multi-select-dropdown\";\n\t\t\tpublic const string RadioButton = \"radio-button\";\n\t\t\tpublic const string DateField = \"date-field\";\n\t\t\tpublic const string Section = \"section\";\n\t\t\tpublic const string Heading = \"heading\";\n\t\t\tpublic const string Table = \"table\";\n\t\t\tpublic const string CustomTable = \"custom-table\";\n\t\t\tpublic const string Column = \"column\";\n\t\t\tpublic const string AdvancedMode = \"advanced-mode\";\n\t\t\tpublic const string TableRecord = \"table-record\";\n\t\t\tpublic const string Record = \"record\";\n\t\t\tpublic const string LibraryFile = \"library-file\";\n\t\t\tpublic const string CsvRowChooser = \"csv-row-chooser\";\n\t\t\tpublic const string CsvField = \"csv-field\";\n\t\t\tpublic const string Attachment = \"attachment\";\n\t\t\tpublic const string Actor = \"actor\";\n\t\t\tpublic const string CustomTableColumn = \"custom-table-column\";\n\t\t}\n\n\t\tpublic class AgreementCloudEditor\n\t\t{\n\t\t\tpublic const string AdftExtension = \".adft\";\n\t\t\tpublic const string HtmlExtension = \".html\";\n\t\t}\n\n\t\tpublic static class FieldConfigLibraryFields\n\t\t{\n\t\t\tpublic const string LibraryField = \"Library Field\";\n\t\t\tpublic const string External = \"External\";\n\t\t}\n\n\t\tpublic class SmartSuggestions\n\t\t{\n\t\t\tpublic const string SuggestionKeyword = \"SmartSuggestions\";\n\t\t\tpublic const string Wildcard = \"*\";\n\t\t\tpublic const string JsonPath = \"JSONPATH:\";\n\t\t}\n\n\t\tpublic class Delimiters\n\t\t{\n\t\t\tpublic const string ArraySplit = \"|\";\n\t\t}\n\t\tpublic class DataBase\n\t\t{\n\t\t\t//Used to not overflow the ids being sent to an sp.\n\t\t\tpublic const int MaxTextLengthForBuildingArraySplit = 900;\n\t\t}\n\n\t\tpublic class HtmlAttributes\n\t\t{\n\t\t\tpublic const string GuestView = \"GuestView\";\n\t\t\tpublic const string Class = \"class\";\n\t\t}\n\n\t\tpublic class Allocation\n\t\t{\n\t\t\tpublic const string DateName = \"RequestDate\";\n\t\t\tpublic const string AuthSchema = \"SCMSignature\";\n\t\t\tpublic const string ForwardingType = \"ForwardingType\";\n\t\t}\n\n\t\tpublic class ABAC\n\t\t{\n\t\t\tpublic const string DateName = \"RequestDate\";\n\t\t\tpublic const string AuthSchema = \"SCMSignature\";\n\t\t\tpublic const string MaxNodesCustomHeader = \"X-Security-Evaluation-Max-Nodes\";\n\t\t}\n\n\t\tpublic static class PagingAndFiltering\n\t\t{\n\t\t\tpublic const string OrderBy = \"OrderBy\";\n\t\t\tpublic const string OrderByDescending = \"OrderByDescending\";\n\t\t\tpublic const string ThenBy = \"ThenBy\";\n\t\t\tpublic const string ThenByDescending = \"ThenByDescending\";\n\t\t\tpublic const string Descending = \"Descending\";\n\t\t}\n\n\t\tpublic class VaultKeyNames\n\t\t{\n\t\t\tpublic const string Audience = \"audience\";\n\t\t\tpublic const string ClientId = \"clientid\";\n\t\t\tpublic const string Host = \"host\";\n\t\t\tpublic const string Instance = \"instance\";\n\t\t\tpublic const string License = \"license\";\n\t\t\tpublic const string Password = \"password\";\n\t\t\tpublic const string PrivateKey = \"privatekey\";\n\t\t\tpublic const string SecureBlackBox = \"blackbox16\";\n\t\t\tpublic const string ServiceProtectionClient = \"serviceprotectionclient\";\n\t\t\tpublic const string SFTPSSHKeys = \"sftp_sshkeys\";\n\t\t\tpublic const string SwiftAuth = \"swiftauth\";\n\t\t\tpublic const string SwiftTransientAuth = \"swifttransientauth\";\n\t\t\tpublic const string Username = \"username\";\n\t\t}\n\n\t\tpublic class WorkflowDesignApi\n\t\t{\n\t\t\tpublic const string AuthSchema = \"Basic\";\n\t\t}\n\n\t\tpublic class WorkflowActivitiesApi\n\t\t{\n\t\t\tpublic const string ScopePolicyName = \"RequireScope\";\n\t\t\t// Why is it a URL? Ref here https://learn.microsoft.com/en-us/dotnet/api/microsoft.identity.web.claimconstants?view=msal-model-dotnet-latest\n\t\t\tpublic const string ScopeClaimKey = \"http://schemas.microsoft.com/identity/claims/scope\";\n\t\t\tpublic const string AllowAllPolicyName = \"AllowAll\";\n\t\t\tpublic const string AllowAnonymousSchemeName = \"AllowAnonymous\";\n\t\t}\n\n\t\t[Serializable]\n\t\tpublic class FileDataSource\n\t\t{\n\t\t\tprivate string _srcDbLabel = \"\";\n\t\t\tprivate static readonly Dictionary<string, FileDataSource> _srcMap = new Dictionary<string, FileDataSource>();\n\n\t\t\t// use only predefined statics\n\t\t\tprivate FileDataSource(string srcDbLabel, bool isSourceInteractive)\n\t\t\t{\n\t\t\t\t_srcDbLabel = srcDbLabel;\n\t\t\t\t_srcMap[srcDbLabel] = this;\n\t\t\t\tIsSourceInteractive = Configuration.GetBooleanAppSetting($\"{srcDbLabel}_IsSourceInteractive\", isSourceInteractive);\n\t\t\t}\n\n\t\t\tprivate FileDataSource()\n\t\t\t{\n\t\t\t}\n\n\t\t\t// these are to be used in code\n\t\t\tpublic static implicit operator string(FileDataSource src)\n\t\t\t{\n\t\t\t\treturn src._srcDbLabel;\n\t\t\t}\n\n\t\t\t// mostly for the benefit of Core.Domain.Command class\n\t\t\t// it means you can assign a plain string to a variable of this type\n\t\t\tpublic static implicit operator FileDataSource(string dbLabel)\n\t\t\t{\n\t\t\t\treturn Get(dbLabel);\n\t\t\t}\n\n\t\t\tpublic static FileDataSource Get(string dbLabel)\n\t\t\t{\n\t\t\t\tif (String.IsNullOrEmpty(dbLabel))\n\t\t\t\t\treturn Unset;\n\t\t\t\tif (!_srcMap.ContainsKey(dbLabel))\n\t\t\t\t\treturn new FileDataSource { _srcDbLabel = dbLabel }; // on the fly - not put in dictionary\n\t\t\t\treturn _srcMap[dbLabel];\n\t\t\t}\n\n\t\t\tpublic override bool Equals(object o)\n\t\t\t{\n\t\t\t\tif (null == o || !(o is FileDataSource))\n\t\t\t\t\treturn false;\n\t\t\t\treturn _srcDbLabel == ((FileDataSource)o)._srcDbLabel;\n\t\t\t}\n\n\t\t\tpublic override int GetHashCode()\n\t\t\t{\n\t\t\t\treturn _srcDbLabel.GetHashCode();\n\t\t\t}\n\n\t\t\tpublic bool IsSourceInteractive { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// Returns a friendly and localized name for the end user's benefit\n\t\t\t/// </summary>\n\t\t\tpublic string Name\n\t\t\t{\n\t\t\t\tget\n\t\t\t\t{\n\t\t\t\t\tstring loc = Resources.CoreTypes.ResourceManager.GetString(String.Format(\"documentsource_{0}\", _srcDbLabel));\n\t\t\t\t\tif (!String.IsNullOrEmpty(loc))\n\t\t\t\t\t\treturn loc;\n\n\t\t\t\t\treturn _srcDbLabel;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]\n\t\t\tpublic class UploadSourceAttribute : Attribute\n\t\t\t{\n\t\t\t\tpublic int Order = 0;\n\t\t\t\tpublic UploadSourceAttribute(int order)\n\t\t\t\t{\n\t\t\t\t\tOrder = order;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Important: Do not modify the string value for the source if it has already been deployed to production. Doing so will cause\n\t\t\t// failures in loading a Document or FileData object.\n\n\t\t\tpublic static FileDataSource AccountCloning { get; } = new FileDataSource(\"AccountCloning\", false);\n\t\t\t[UploadSource(18)]\n\t\t\tpublic static FileDataSource AdvancedWorkflow { get; } = new FileDataSource(\"AdvancedWorkflow\", false);\n\t\t\tpublic static FileDataSource AdvancedWorkflowMerge { get; } = new FileDataSource(\"AdvancedWorkflowMerge\", true);\n\t\t\t[UploadSource(2)]\n\t\t\tpublic static FileDataSource AtlasInboundEmail { get; } = new FileDataSource(\"AtlasInboundEmail\", false);\n\t\t\t[UploadSource(7)]\n\t\t\tpublic static FileDataSource AtlasUploadService { get; } = new FileDataSource(\"AtlasUploadService\", false);\n\t\t\t[UploadSource(11)]\n\t\t\tpublic static FileDataSource AutoSplit { get; } = new FileDataSource(\"AutoSplit\", false);  // ocr bar code processing\n\t\t\t[UploadSource(1)]\n\t\t\tpublic static FileDataSource BrowseUpload { get; } = new FileDataSource(\"BrowseUpload\", true);\n\t\t\tpublic static FileDataSource CheckIn { get; } = new FileDataSource(\"CheckIn\", true);\n\t\t\tpublic static FileDataSource CheckInFile { get; } = new FileDataSource(\"CheckInFile\", true);\n\t\t\tpublic static FileDataSource CollaborationCheckIn { get; } = new FileDataSource(\"CollaborationCheckIn\", true);\n\t\t\tpublic static FileDataSource CollaborationSave { get; } = new FileDataSource(\"CollaborationSave\", true);\n\t\t\tpublic static FileDataSource CollaborationSetup { get; } = new FileDataSource(\"CollaborationSetup\", true);\n\t\t\tpublic static FileDataSource ContentReplacement { get; } = new FileDataSource(\"ContentReplacement\", true);\n\t\t\tpublic static FileDataSource Copy { get; } = new FileDataSource(\"Copy\", true);\n\t\t\tpublic static FileDataSource DocumentCompare { get; } = new FileDataSource(\"DocumentCompare\", true);\n\t\t\tpublic static FileDataSource DocumentPackageBuilder { get; } = new FileDataSource(\"DocumentPackageBuilder\", true);\n\t\t\tpublic static FileDataSource DocLauncherAttachment { get; } = new FileDataSource(\"DocLauncherAttachment\", true);\n\t\t\tpublic static FileDataSource DraftDocument { get; } = new FileDataSource(\"DraftDocument\", false);\n\t\t\t[UploadSource(15)]\n\t\t\tpublic static FileDataSource ESignature { get; } = new FileDataSource(\"ESignature\", false);\n\t\t\t[UploadSource(12)]\n\t\t\tpublic static FileDataSource FormPublicSubmit { get; } = new FileDataSource(\"FormPublicSubmit\", false);\n\t\t\t[UploadSource(13)]\n\t\t\tpublic static FileDataSource FormSubmit { get; } = new FileDataSource(\"FormSubmit\", true);\n\t\t\t[UploadSource(14)]\n\t\t\tpublic static FileDataSource FormUpdate { get; } = new FileDataSource(\"FormUpdate\", false);\n\t\t\t[UploadSource(3)]\n\t\t\tpublic static FileDataSource InboundFax { get; } = new FileDataSource(\"InboundFax\", false);\n\t\t\tpublic static FileDataSource Merge { get; } = new FileDataSource(\"Merge\", false);\n\t\t\tpublic static FileDataSource DocxMerge { get; } = new FileDataSource(\"DocxMerge\", false);\n\t\t\tpublic static FileDataSource OfficeUploaderEditInline { get; } = new FileDataSource(\"OfficeUploaderEditInline\", true);\n\t\t\tpublic static FileDataSource GoogleUploaderEditInline { get; } = new FileDataSource(\"GoogleUploaderEditInline\", true);\n\t\t\tpublic static FileDataSource ProofOfDelivery { get; } = new FileDataSource(\"ProofOfDelivery\", false);\n\t\t\tpublic static FileDataSource Packaging { get; } = new FileDataSource(\"Packaging\", false);\n\t\t\t[UploadSource(17)]\n\t\t\tpublic static FileDataSource PdfMerge { get; } = new FileDataSource(\"PdfMerge\", true);\n\t\t\tpublic static FileDataSource Received { get; } = new FileDataSource(\"Received\", false);\n\t\t\tpublic static FileDataSource RestContentService { get; } = new FileDataSource(\"RestContentService\", false);\n\t\t\tpublic static FileDataSource SFTPProxyService { get; } = new FileDataSource(\"SFTPProxyService\", false); // the SouthOaks \"stop gap\" solution with OpenSSH and SpringFolderWatchService\n\t\t\t[UploadSource(5)]\n\t\t\tpublic static FileDataSource SFTPServer { get; } = new FileDataSource(\"SFTPServer\", false);\n\t\t\t[UploadSource(6)]\n\t\t\tpublic static FileDataSource SpringCMService { get; } = new FileDataSource(\"SpringCMService\", false);\n\t\t\tpublic static FileDataSource Support { get; } = new FileDataSource(\"Support\", false);\n\t\t\tpublic static FileDataSource TermUpdate { get; } = new FileDataSource(\"TermUpdate\", false);\n\t\t\tpublic static FileDataSource Test { get; } = new FileDataSource(\"Test\", true);      // considered an interactive source since integrations tests will wait for a result\n\t\t\tpublic static FileDataSource Unset { get; } = new FileDataSource(\"Unset\", false);\n\t\t\tpublic static FileDataSource UpdateDocument { get; } = new FileDataSource(\"UpdateDocument\", true);\n\t\t\t[UploadSource(10)]\n\t\t\tpublic static FileDataSource UserSplit { get; } = new FileDataSource(\"UserSplit\", true);  // pdf manipulations\n\t\t\tpublic static FileDataSource DocumentRuleCopy { get; } = new FileDataSource(\"DocumentRuleCopy\", false);\n\t\t\t[UploadSource(16)]\n\t\t\tpublic static FileDataSource XmlMerge { get; } = new FileDataSource(\"XMLMerge\", false);\n\t\t\tpublic static FileDataSource BusinessSync { get; } = new FileDataSource(\"DesktopSync\", false);\n\t\t\tpublic static FileDataSource Mobile { get; } = new FileDataSource(\"Mobile\", false);\n\t\t\tpublic static FileDataSource ScanToSpring { get; } = new FileDataSource(\"ScanToSpring\", false);\n\t\t\t[UploadSource(8)]\n\t\t\tpublic static FileDataSource SalesforceMigration { get; } = new FileDataSource(\"SalesforceMigration\", false);\n\t\t\t[UploadSource(9)]\n\t\t\tpublic static FileDataSource ApiContent { get; } = new FileDataSource(\"ApiContent\", false);\n\t\t\tpublic static FileDataSource ExportSearch { get; } = new FileDataSource(\"ExportSearch\", false);\n\t\t\tpublic static FileDataSource ExternalReview { get; } = new FileDataSource(\"ExternalReview\", false);\n\t\t\tpublic static FileDataSource ReportJob { get; } = new FileDataSource(\"ReportJob\", false);\n\t\t\tpublic static FileDataSource ProcessBuilderHtmlToDocxRendition { get; } = new FileDataSource(\"ProcessBuilderHtmlToDocxRendition\", false);\n\t\t\tpublic static FileDataSource ProcessBuilderUpdateACEAdfHtmlFiles { get; } = new FileDataSource(\"ProcessBuilderUpdateACEAdfHtmlFiles\", false);\n\n\t\t}\n\n\n\t\tpublic class MetadataHtmlAttributes\n\t\t{\n\t\t\tpublic const string CNTR_ATTR_FIELD_ID = \"metadatafieldid\";\n\t\t\tpublic const string CNTR_ATTR_SET_ID = \"metadatasetid\";\n\t\t\tpublic const string CNTR_ATTR_GROUP_ID = \"metadatagroupid\";\n\t\t\tpublic const string CNTR_ATTR_FIELD_NAME = \"fieldname\";\n\t\t\tpublic const string CNTR_ATTR_GROUP_NAME = \"groupname\";\n\t\t\tpublic const string CNTR_ATTR_DATA_TYPE = \"datatype\";\n\t\t\tpublic const string CNTR_ATTR_REQUIRED = \"required\";\n\t\t\tpublic const string CNTR_ATTR_TAB_INDEX = \"tabindex\";\n\t\t\tpublic const string CNTR_ATTR_CHECK_NUMBER = \"checknumber\";\n\t\t\tpublic const string CNTR_ATTR_CHECK_DECIMAL = \"checkdecimal\";\n\t\t\tpublic const string CNTR_ATTR_CHECK_DATE = \"checkdate\";\n\t\t\tpublic const string CNTR_ATTR_FIELDSET_NUMBER = \"fieldsetnumber\";\n\t\t\tpublic const string CNTR_ATTR_UX_ATTRS = \"attrs\";\n\t\t\t/// <summary>\n\t\t\t/// Used as JS selector to disable automatic validation of UX components and process using components' built-in validate methods\n\t\t\t/// </summary>\n\t\t\tpublic const string CNTR_ATTR_UX_VALIDATE_CUSTOM = \"data-validator-custom\";\n\t\t\tpublic const string CNTR_ATTR_DATA_DEFINITION = \"ChooserDataDefinition\";\n\t\t\tpublic const string CNTR_ATTR_ACTOR_METADATA_FIELD_ID = \"ActorMetadataFiledId\";\n\t\t\tpublic const string CNTR_ATTR_ACTOR_CHOOSER_PLACEHOLDER = \"actor-chooser-placeholder\";\n\t\t}\n\n\t\t// aka \"CLM Agreement Details\"\n\t\tpublic static class AomMetadata\n\t\t{\n\t\t\tpublic const string NAME = \"Name\";\n\t\t\tpublic const string AGREEMENT_ID = \"Agreement ID\";\n\t\t\tpublic const string AUTOMATIC_RENEWAL = \"Automatic Renewal\";\n\t\t\tpublic const string PARTY_NAME = \"Party Name\";\n\t\t\tpublic const string PARTY_ID = \"Party ID\";\n\t\t\tpublic const string TYPE = \"Type\";\n\t\t\tpublic const string VALUE = \"Value\";\n\t\t\tpublic const string REQUESTOR = \"Requestor\";\n\t\t\tpublic const string EFFECTIVE_DATE = \"Effective Date\";\n\t\t\tpublic const string EXPIRATION_DATE = \"Expiration Date\";\n\t\t\tpublic const string RENEWAL_TERM = \"Renewal Term\";\n\t\t\tpublic const string RENEWAL_TERM_UNIT = \"Renewal Term Unit\";\n\t\t\tpublic const string SIGNED = \"Signed\";\n\t\t\tpublic const string TERMINATION_NOTICE = \"Termination Notice\";\n\t\t\tpublic const string TERMINATION_NOTICE_UNIT = \"Termination Notice Unit\";\n\t\t\tpublic const string TERMINATION_NOTICE_DATE = \"Termination Notice Date\";\n\t\t\tpublic const string PAYMENT_TERMS = \"Payment Terms\";\n\t\t\tpublic const string PAYMENT_LATE_FEES = \"Payment Late Fees\";\n\t\t\tpublic const string TERMINATION_CONVENIENCE = \"Termination Convenience\";\n\t\t\tpublic const string LIMITATION_OF_LIABILITY = \"Limitation of Liability\";\n\t\t\tpublic const string TERMINATION_CAUSE = \"Termination Cause\";\n\t\t\tpublic const string ASSIGNABLE = \"Assignable\";\n\t\t\tpublic const string INDEMNITY = \"Indemnity\";\n\t\t\tpublic const string RENEWAL_NOTICE_PERIOD = \"Renewal Notice Period\";\n\t\t\tpublic const string RENEWAL_NOTICE_PERIOD_UNIT = \"Renewal Notice Period Unit\";\n\t\t\tpublic const string PAYMENT_DURATION = \"Payment Duration\";\n\t\t\tpublic const string PAYMENT_DURATION_UNIT = \"Payment Duration Unit\";\n\t\t\tpublic const string DESCRIPTION = \"Description\";\n\t\t\tpublic const string CHANGE_OF_CONTROL = \"Change of Control\";\n\t\t\tpublic const string PAYMENT_EARLY_DISCOUNT = \"Payment Early Discount\";\n\t\t\tpublic const string FORCE_MAJEURE = \"Force Majeure\";\n\t\t}\n\n\t\t// these fields have no underlying field / values, there are implied via the existence of another field\n\t\t// eg. \"Automatic Renewal\" is implied via the existence of the \"Renewal Term\" field\n\t\t// we need to keep track of their guids so that we know how to filter on these\n\t\tpublic static class AgreementDetailsImpliedMetadataGuids\n\t\t{\n\t\t\tpublic static readonly Guid AUTOMATIC_RENEWAL = new Guid(\"81c76ed8-d9be-4091-b32e-96193033b5cd\");\n\t\t}\n\n\t\tpublic static class DurationUnits\n\t\t{\n\t\t\tpublic const string DAYS = \"Days\";\n\t\t\tpublic const string WEEKS = \"Weeks\";\n\t\t\tpublic const string MONTHS = \"Months\";\n\t\t\tpublic const string YEARS = \"Years\";\n\t\t}\n\n\t\tpublic static class NonTranslatedFields\n\t\t{\n\t\t\tpublic const string PARTY_NAME = \"Party Name\";\n\t\t\tpublic const string TYPE = \"Type\";\n\t\t\tpublic const string CONTRACT_VALUE = \"Contract Value\";\n\t\t}\n\n\t\tpublic static class AomApi\n\t\t{\n\t\t\tpublic static string PartiesObjectTypeName = \"Parties\";\n\t\t\tpublic static string AgreementsObjectTypeName = \"Agreements\";\n\t\t\tpublic static string AgreementRelationshipsObjectTypeName = \"AgreementRelationships\";\n\t\t\tpublic static string ObligationsObjectTypeName = \"Obligations\";\n\t\t\tpublic static string ExternalId = \"ExternalId\";\n\t\t\tpublic static string ExternalIds = \"ExternalIds\";\n\t\t}\n\n\t\tpublic static class AdmApi\n\t\t{\n\t\t\tpublic const string PartiesObjectTypeName = \"parties\";\n\t\t\tpublic const string AgreementsObjectTypeName = \"agreements\";\n\t\t\tpublic const string AgreementEnumsObjectTypeName = \"agreements/enums\";\n\t\t\tpublic const string AgreementEnumsSubObjectTypeName = \"values\";\n\t\t\tpublic const string ObligationsObjectTypeName = \"obligations\";\n\t\t\tpublic const string AgreementRelationshipsObjectTypeName = \"AgreementRelationships\";\n\t\t\tpublic const string ContactsObjectTypeName = \"contacts\";\n\t\t\tpublic const string DocumentsObjectTypeName = \"documents\";\n\t\t\tpublic const string SubObjectName_Filter = \"filter\";\n\t\t}\n\n\t\tpublic class TranslationExportField\n\t\t{\n\t\t\tpublic const string ATTR_NAME = \"Name\";\n\t\t\tpublic const string ATTR_NAMING_TEMPLATE = \"NamingTemplate\";\n\t\t\tpublic const string ATTR_VALIDATION_MESSAGE = \"ValidationMessage\";\n\t\t\tpublic const string ATTR_VALIDATION_REGEX = \"ValidationRegex\";\n\t\t\tpublic const string ATTR_VALUE = \"Value\";\n\t\t\tpublic const string DOCGEN_NAME = ATTR_NAME;\n\t\t\tpublic const string DOCGEN_DESCRIPTION = \"Description\";\n\t\t\tpublic const string DOCGEN_HELP_TEXT = \"HelpText\";\n\t\t\tpublic const string DOCGEN_VALUE = ATTR_VALUE;\n\t\t\tpublic const string DOCGEN_DEFAULT_VALUE = \"DefaultValue\";\n\t\t\tpublic const string DOCGEN_VALIDATION_MESSAGE = \"ValidationMessage\";\n\t\t\tpublic const string DOCGEN_CSV_OPTIONS = \"CsvOption\";\n\t\t\tpublic const string DOCGEN_STEP1INSTRUCTIONS = \"Step1Instructions\";\n\t\t\tpublic const string DOCGEN_STEP2INSTRUCTIONS = \"Step2Instructions\";\n\t\t\tpublic const string DOCGEN_SUCCESSMESSAGE = \"SuccessMessage\";\n\t\t}\n\n\t\t// form related stuff\n\t\tpublic class Forms\n\t\t{\n\t\t\t// custom form tag generation and parsing\n\t\t\tpublic const string SPRING_TAG_METAGROUP_LABEL = \"springcm:MetaGroupLabel\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_LABEL = \"springcm:MetaFieldLabel\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_INPUT = \"springcm:MetaFieldInput\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_UX_COMPONENT = \"springcm:MetaFieldUxComponent\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_UX_CUSTOM = \"springcm:MetaFieldUxCustom\";\n\t\t\tpublic const string SPRING_TAG_METAFIELD_UX_DROPDOWN = \"springcm:MetaFieldUxDropdown\";\n\t\t\tpublic const string SPRING_TAG_FILEATTACH_INPUT = \"springcm:FileAttachmentInput\";\n\t\t\tpublic const string SPRING_TAG_NAMED_PROPERTY = \"springcm:property\";\n\n\t\t\t//Internal values\n\t\t\tpublic const string SPRING_TAG_INTERNAL_PREFIX = \"springcm:internal_\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL = \"InternalDataCode\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_UID = \"uid\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_DOCUMENTNAME = \"documentname\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_CREATEDBY = \"createdby\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_CREATEDDATE = \"createddate\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_UPDATEDBY = \"updatedby\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_UDPATEDDATE = \"updateddate\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_USERKEY = \"userkey\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_USEREMAIL = \"useremail\";\n\t\t\tpublic const string SPRING_TAG_INTERNAL_RAWCUSTOMDATA = \"rawcustomdata\";\n\n\t\t\tpublic const string LINK_STYLE = \"pseudoLink\";\n\t\t\tpublic const string SET_STYLE = \"set\";\n\t\t\tpublic const string REPEATINGROW_STYLE = \"repeatingRow\";\n\n\t\t\tpublic const string SXFORM_ATTR_RPT_ROW = \"repeatingrow\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_CONTAINER = \"repeatingcontainer\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_ADD_ANCHOR = \"addanchorelement\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_ADD_HANDLER = \"addrepeatinghandlerelement\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_DEL_ANCHOR = \"removeanchorelement\";\n\t\t\tpublic const string SXFORM_ATTR_RPT_DEL_HANDELER = \"removerepeatinghandlerelement\";\n\n\n\t\t\tpublic const string SPRING_TAG_INITATTACH_COUNT = \"InitialAttachmentCount\";\n\t\t\tpublic const string BOOL_REGEX = @\"[true|false]+\";\n\t\t\tpublic const string GUID_REGEX = @\"[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}\";\n\t\t\tpublic const string NAME_REGEX = @\"[a-z0-9_-]{1,}\";\n\n\t\t\t// Two named groups are used. id tags where the id for the attribute field or group is. cstyle tags where an optional custom styling should be.\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_ID = \"id\";\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_NAME = \"name\";\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_REPEATING = \"repeating\";      // used for repeating custom UX fields\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_CUSTOMSTYLE = \"cstyle\";\n\t\t\tpublic const string SPRING_TAG_REGEXGROUP_INITATTACH = \"initAttach\";\n\n\t\t\tpublic static readonly Regex springMetafieldInputElementRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{5})\\\"(?<{4}>{1}+.+)?{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_INPUT, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, SPRING_TAG_REGEXGROUP_ID, SPRING_TAG_REGEXGROUP_CUSTOMSTYLE, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\tpublic static readonly Regex springFileAttachElementRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>[0-9-]+)\\\"(?<{4}>{1}+.+)?{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_FILEATTACH_INPUT, \"\\\\s\", SPRING_TAG_INITATTACH_COUNT, SPRING_TAG_REGEXGROUP_INITATTACH, SPRING_TAG_REGEXGROUP_CUSTOMSTYLE), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\t// these don't need to accept custom styling\n\t\t\tpublic static readonly Regex springMetagroupLabelElementRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAGROUP_LABEL, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_GROUP_ID, SPRING_TAG_REGEXGROUP_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\tpublic static readonly Regex springMetafieldLabelElementRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_LABEL, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, SPRING_TAG_REGEXGROUP_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\t// matches only the attribute for input - \"springcm:MetaFieldInput MetaDataFieldId = 4\"\n\t\t\tpublic static readonly Regex springMetafieldInputAttributeRx = new Regex(String.Format(\"{0}{1}+{2}{1}*={1}*\\\"{3}\\\"\", SPRING_TAG_METAFIELD_INPUT, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\n\t\t\tpublic static readonly Regex springMetafieldUxComponentRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_UX_COMPONENT, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, SPRING_TAG_REGEXGROUP_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\tpublic static readonly Regex springMetafieldUxCustomRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"({1}+{5}{1}*={1}*\\\"(?<{5}>{6})\\\")?{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_UX_CUSTOM, \"\\\\s\", SPRING_TAG_REGEXGROUP_NAME, SPRING_TAG_REGEXGROUP_NAME, NAME_REGEX, SPRING_TAG_REGEXGROUP_REPEATING, BOOL_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\t\t\tpublic static readonly Regex springMetafieldUxDropdownRx = new Regex(String.Format(\"<{0}{1}+{2}{1}*={1}*\\\"(?<{3}>{4})\\\"{1}*(/>|>{1}*</{0}>)\", SPRING_TAG_METAFIELD_UX_DROPDOWN, \"\\\\s\", MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID, SPRING_TAG_REGEXGROUP_ID, GUID_REGEX), RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(RegexDefaultTimeoutMilliseconds));\n\n\t\t\tpublic static string EmitMetafieldLabelElement(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"<{0} {2}=\\\"{1}\\\"/>\", SPRING_TAG_METAFIELD_LABEL, uid, MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID);\n\t\t\t}\n\n\t\t\tpublic static string EmitMetafieldInputAttribute(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"{0} {2}=\\\"{1}\\\"\", SPRING_TAG_METAFIELD_INPUT, uid, MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID);\n\t\t\t}\n\n\t\t\tpublic static string EmitMetafieldUxComponent(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"{0} {2}=\\\"{1}\\\"\", SPRING_TAG_METAFIELD_UX_COMPONENT, uid, MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID);\n\t\t\t}\n\t\t\tpublic static string EmitMetafieldUxDropdownComponent(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"{0} {2}=\\\"{1}\\\"\", SPRING_TAG_METAFIELD_UX_DROPDOWN, uid, MetadataHtmlAttributes.CNTR_ATTR_FIELD_ID);\n\t\t\t}\n\n\t\t\tpublic static string EmitMetafieldInputElement(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"<{0}/>\", EmitMetafieldInputAttribute(uid));\n\t\t\t}\n\n\t\t\tpublic static string EmitAttachmentInputElement()\n\t\t\t{\n\t\t\t\treturn String.Format(\"<{0} {1}=\\\"1\\\"/>\", SPRING_TAG_FILEATTACH_INPUT, SPRING_TAG_INITATTACH_COUNT);\n\t\t\t}\n\n\t\t\tpublic static string EmitMetagroupLabelElement(Guid uid)\n\t\t\t{\n\t\t\t\treturn String.Format(\"<{0} {2}=\\\"{1}\\\"/>\", SPRING_TAG_METAGROUP_LABEL, uid, MetadataHtmlAttributes.CNTR_ATTR_GROUP_ID);\n\t\t\t}\n\t\t}\n\n\t\tpublic static class ItemTables\n\t\t{\n\t\t\tpublic const string CustomReport = \"CustomReport\";\n\t\t\tpublic const string CustomReportToLower = \"customreport\";\n\t\t}\n\n\t\tpublic static class DocLauncher\n\t\t{\n\t\t\tpublic const int ConfigNameMaxLength = 100;\n\t\t\tpublic const string RecordType = \"RecordType\";\n\t\t\tpublic const string CustomEosRedirectAuthorization = \"CustomEosRedirectAuthorization\";\n\t\t\tpublic static readonly string[] Clm360AllowedSfObjects = { SalesforceObjectType.Account, SalesforceObjectType.Opportunity };\n\t\t\tpublic const string FieldType = \"FieldType\";\n\t\t\tpublic const string CustomTable = \"CustomTable\";\n\t\t}\n\n\t\tpublic static class SalesforceObjectType\n\t\t{\n\t\t\tpublic const string Account = \"Account\";\n\t\t\tpublic const string Opportunity = \"Opportunity\";\n\t\t\tpublic const string User = \"User\";\n\t\t}\n\n\t\tpublic static class UI\n\t\t{\n\t\t\tpublic static class UIWorkflowConstants\n\t\t\t{\n\t\t\t\tpublic const string TYPE_INBOX = \"i\";\n\t\t\t}\n\n\t\t\tpublic const string Days = \"d\";\n\t\t\tpublic const string Hours = \"h\";\n\t\t}\n\n\t\tpublic static class OAuth\n\t\t{\n\t\t\tpublic const int TOKEN_LENGTH = 128;\n\t\t\tpublic const int ACCESS_TOKEN_EXPIRATION_MINUTES = 60;\n\t\t\tpublic const int AUTHORIZATION_TOKEN_EXPIRATION_MINUTES = 1;\n\t\t\tpublic const string AUTHORIZATION_HEADER_NAME = \"Authorization\";\n\t\t\tpublic const string API_APPNAME = \"api\";\n\t\t\tpublic const string ACCESS_TOKEN_SERVICE = \"AccessTokenService\";\n\t\t}\n\n\t\tpublic static class Authentication\n\t\t{\n\t\t\tpublic const string AUTHENTICATION_APPLICATION_ISSUER = \"Atlas.AuthenticationApplication\";\n\t\t\tpublic const string SHOW_ANNOUNCEMENT_KEY = \"ShowAnnouncement\";\n\t\t\tpublic const int SALT_CHARLENGTH = 32;          // should always be an even number greater than or equal to 16 (8 bytes of salt)\n\t\t\tpublic const int PW_ITERATIONS = 77436;\n\t\t\tpublic const string ACCOUNT_ID_USER_ID_CACHE_KEY_PREFIX = \"AccountIdUserIdForSession\";\n\t\t\tpublic const string AUTH_APP_CROSS_PLATFORM_FETCH = \"authapp\";\n\t\t\tpublic const string RESTAUTH_APP_CROSS_PLATFORM_FETCH = \"auth\";\n\t\t}\n\n\t\tpublic static class GridConfigKey\n\t\t{\n\t\t\tpublic const string FOLDER_PORTAL_KO = \"resultsGridKo\";\n\t\t\tpublic const string DYNAMIC_SEARCH_KO = \"dynamicSearchKo\";\n\t\t}\n\n\t\tpublic class PageNames\n\t\t{\n\t\t\tpublic const string BROWSE_DOCUMENTS = \"BrowseDocuments.aspx\";\n\t\t\tpublic const string BROWSE_DOCUMENTS_WITHOUT_EXTENSION = \"BrowseDocuments\";\n\t\t\tpublic const string PREVIEW = \"Preview.aspx\";\n\t\t\tpublic const string DOC_EXPLORER = \"DocExplorer\";\n\t\t}\n\n\t\tpublic class VideoInfo\n\t\t{\n\t\t\tpublic const string METADATA_FIELD_NAME_HEIGHT = \"Height\";\n\t\t\tpublic const string METADATA_FIELD_NAME_WIDTH = \"Width\";\n\t\t\tpublic const string METADATA_FIELD_NAME_CODEC = \"Codec\";\n\t\t\tpublic const string METADATA_FIELD_NAME_DURATION = \"Duration\";\n\t\t}\n\n\t\tpublic class WorkerPool\n\t\t{\n\t\t\tpublic const string UserOwnerDefaultAccessRightsXml = \"<accessrights><queuerights><queueelements name=\\\"View Queue?\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Put Back in Same Queue\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Plan Queue Item\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can View Dispatched Item\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Ad Hoc Pick Task\\\" checked=\\\"True\\\" /><queueelements name=\\\"Queue Owner\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Put Back in Diff Queue\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Change Priority level\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Do Pattern Based Allocation\\\" checked=\\\"True\\\" /><queueelements name=\\\"Disable Participant\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Recall Allocated Items\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Do User Based Allocation\\\" checked=\\\"True\\\" /><queueelements name=\\\"Can Do Time Based Allocation\\\" checked=\\\"True\\\" /><queueelements name=\\\"Consider Queue Owner as Participant for Automatic Dispatch\\\" checked=\\\"False\\\" /></queuerights><queuepagerights><queueelements name=\\\"Participants\\\" checked=\\\"True\\\" /><queueelements name=\\\"Fields\\\" checked=\\\"True\\\" /><queueelements name=\\\"Dispatch Patterns\\\" checked=\\\"True\\\" /><queueelements name=\\\"Access Rights\\\" checked=\\\"True\\\" /><queueelements name=\\\"Settings\\\" checked=\\\"True\\\" /><queueelements name=\\\"Escalation\\\" checked=\\\"True\\\" /></queuepagerights></accessrights>\";\n\t\t}\n\n\t\tpublic const string BulkUserImportDelimitedExtractionSourceName = \"UserSyncCsv\";\n\n\t\tpublic class MenuAction\n\t\t{\n\t\t\t// menu keys\n\t\t\tpublic const string ACCOUNT_DEFAULT_KEY = \"AccountDefault\";\n\t\t\tpublic const string DEFAULT_BROWSE_KEY = \"Browse\";\n\t\t\tpublic const string BROWSE_KEY = \"BrowseDocumentActions\";\n\t\t\tpublic const string DOCEXPLORER_KEY = \"DocExplorerActions\";\n\t\t\tpublic const string DOCEXPLORER_MOBILE_KEY = \"DocExplorerMobileActions\";\n\t\t\tpublic const string DOCEXPLORER_KEY_OLD = \"DocExplorerToolbar\";\n\t\t\tpublic const string DOCUMENTTASK_KEY = \"DocumentTaskActions\";\n\t\t\tpublic const string FILE_IT_KEY = \"NodeActionsGridPortal\";\n\t\t\tpublic const string DOCUMENT_ACTIONS_KEY = \"StandardDocumentActions\";\n\t\t\tpublic const string DOCUMENT_ACTIONS_MOBILE_KEY = \"StandardDocumentActions_Mobile\";\n\t\t\tpublic const string DOCUMENT_ACTIONS_KEY_OLD = \"FolderAndDocumentToolbar\";\n\t\t\tpublic const string FILEWIDGET_ACTIONS_KEY = \"FileWidgetActions\";\n\t\t\tpublic const string NAVIGATION_KEY = \"Navigation\";\n\t\t\tpublic const string NAVIGATIONACTIONS_KEY = \"NavigationActions\";\n\t\t\tpublic const string NAVIGATIONHELP_KEY = \"NavigationHelp\";\n\t\t\tpublic const string DEFAULT_PREVIEW_KEY = \"Preview\";\n\t\t\tpublic const string PREVIEW_KEY = \"PreviewActions\";\n\t\t\tpublic const string DOCUMENTMANAGEMENTACTIONS_KEY = \"DocumentManagementActions\";\n\t\t\tpublic const string DOCUMENTMANAGEMENTCUSTOMACTIONS_KEY = \"DocumentManagementCustomActions\";\n\t\t\tpublic const string CLMFILESACTIONS_KEY = \"ClmFilesActions\";\n\t\t\tpublic const string CLMFILESCUSTOMACTIONS_KEY = \"ClmFilesCustomActions\";\n\t\t\tpublic const string NEW_PERSONA = \"NewPersona\";\n\t\t\tpublic const string REPORT_LANDING = \"ReportLanding\";\n\t\t\tpublic const string RECENTDOCUMENTSWIDGET_ACTIONS_KEY = \"RecentDocumentsWidgetActions\";\n\t\t\tpublic const string RECENTDOCUMENTSWIDGET_ACTIONS_MOBILE_KEY = \"RecentDocumentsWidgetActions_Mobile\";\n\t\t\tpublic const string SEARCH_ACTIONS_KEY = \"SearchActions\";\n\t\t\tpublic const string WORKFLOWINBOXWIDGET_ACTIONS_KEY = \"WorkflowInboxWidgetToolbar\";\n\t\t\tpublic const string WORKFLOWTASK_ACTIONS_KEY = \"WorkflowTaskToolbarMultiLevel\";\n\t\t\tpublic const string FILE_IT_FOLDER_WIDGET_CUSTOM_ACTIONS_KEY = \"FileItFolderWidgetCustomActions\";\n\n\t\t\t// action keys\n\t\t\tpublic const string DOCUMENT_EDIT_KEY = \"DocumentEdit\";\n\t\t\tpublic const string DOCUMENT_EDIT_REDLINES_KEY = \"DocumentEditWithRedlines\";\n\t\t\tpublic const string DOCUSIGN_DOCUMENT_EDIT_KEY = \"DocuSignDocumentEdit\";\n\t\t\tpublic const string DOCUSIGN_DOCUMENT_EDIT_REDLINES_KEY = \"DocuSignDocumentEditWithRedlines\";\n\n\t\t\t//Custom Menu Action\n\t\t\tpublic const string CUSTOM_ACTION_LANGUAGE_PREFIX = \"language:\";\n\t\t\tpublic const string CUSTOM_ACTION_LANGUAGE_DEFAULT = \"any\";\n\n\t\t\t// Context menu keys\n\t\t\tpublic const string NODE_CONTEXT_MENU_KEY = \"NodeContextMenu\";\n\t\t\tpublic const string NODE_CONTEXT_MENU_EXTENDED_KEY = \"NodeContextMenuExtended\";\n\t\t}\n\n\t\tpublic class HistoryData\n\t\t{\n\t\t\tpublic const string HISTORYCREATEDDATE = \"HistoryCreatedDate\";\n\t\t\tpublic const string HISTORYUSEREMAIL = \"HistoryUserEmail\";\n\t\t\tpublic const string HISTORYUSERFIRSTNAME = \"HistoryUserFirstName\";\n\t\t\tpublic const string HISTORYUSERLASTNAME = \"HistoryUserLastName\";\n\t\t\tpublic const string HISTORYUSERNAME = \"HistoryUserName\";\n\t\t\tpublic const string HISTORYNAME = \"HistoryName\";\n\t\t\tpublic const string HISTORYUID = \"HistoryUid\";\n\t\t\tpublic const string USER = \"User\";\n\t\t\tpublic const string EMAIL = \"Email\";\n\t\t\tpublic const string FIRSTNAME = \"FirstName\";\n\t\t\tpublic const string LASTNAME = \"LastName\";\n\t\t\tpublic const string USERNAME = \"UserName\";\n\t\t\tpublic const string FRIENDLYNAME = \"FriendlyName\";\n\t\t\tpublic const string UID = \"Uid\";\n\t\t\tpublic const string DATETIME = \"DateTime\";\n\t\t\tpublic const string ACTION_NAME = \"actionName\";\n\t\t\tpublic const string APPROVERS = \"Approvers\";\n\t\t\tpublic const string COMMENTS = \"Comments\";\n\t\t\tpublic const string COMMENTLIST = \"CommentList\";\n\t\t\tpublic const string CONTENTVERSIONID = \"ContentVersionId\";\n\t\t\tpublic const string DESTINATIONOBJECTID = \"DestinationObjectId\";\n\t\t\tpublic const string DOCUMENT = \"Document\";\n\t\t\tpublic const string DOCUMENTUID = \"DocumentUid\";\n\t\t\tpublic const string DOCUMENTNAME = \"DocumentName\";\n\t\t\tpublic const string DOCUMENTOLDNAME = \"DocumentOldName\";\n\t\t\tpublic const string DUEDATE = \"DueDate\";\n\t\t\tpublic const string EMAILADDRESS = \"EmailAddress\";\n\t\t\tpublic const string EMAILMESSAGE = \"EmailMessage\";\n\t\t\tpublic const string EMAILSUBJECT = \"EmailSubject\";\n\t\t\tpublic const string IPADDRESS = \"IpAddress\";\n\t\t\tpublic const string REFID = \"RefId\";\n\t\t\tpublic const string REVIEWER = \"Reviewer\";\n\t\t\tpublic const string VERSIONNUMBER = \"VersionNumber\";\n\t\t\tpublic const string ACTOR = \"Actor\";\n\t\t\tpublic const string FULLNAME = \"FullName\";\n\t\t\tpublic const string SENDER = \"Sender\";\n\t\t\tpublic const string METADATA = \"Metadata\";\n\t\t\tpublic const string GROUPS = \"Groups\";\n\t\t\tpublic const string VALUE = \"Value\";\n\t\t\tpublic const string OLDDESCRIPTION = \"OldDescription\";\n\t\t\tpublic const string NEWDESCRIPTION = \"NewDescription\";\n\t\t\tpublic const string TO_EMAILADDRESS = \"toAddress\";\n\t\t\tpublic const string RECIPIENTS = \"Recipients\";\n\t\t\tpublic const string ISONBEHALFOF = \"IsOnBehalfOf\";\n\t\t\tpublic const string ONBEHALFOFUSER = \"OnBehalfOfUser\";\n\t\t\tpublic const string ATTACHMENTS = \"Attachments\";\n\t\t\tpublic const string ORIGINALDOCUMENT = \"OriginalDocument\";\n\t\t\tpublic const string ORIGINALDOCUMENTUID = \"originalDocumentUid\";\n\t\t\tpublic const string ORIGINALDOCUMENTNAME = \"originalDocumentName\";\n\t\t\tpublic const string ORIGINALFOLDERUID = \"originalFolderUid\";\n\t\t\tpublic const string ORIGINALFOLDERNAME = \"originalFolderName\";\n\t\t\tpublic const string NEWDOCUMENTUID = \"newDocumentUid\";\n\t\t\tpublic const string NEWDOCUMENTNAME = \"newDocumentName\";\n\t\t\tpublic const string NEWFOLDERUID = \"newFolderUid\";\n\t\t\tpublic const string NEWFOLDERNAME = \"newFolderName\";\n\t\t\tpublic const string CURRENTVERSION = \"CurrentVersion\";\n\t\t\tpublic const string PREVIOUSVERSION = \"PreviousVersion\";\n\t\t\tpublic const string PREVIOUSDOCUMENTUID = \"PreviousDocumentUid\";\n\t\t\tpublic const string CHECKEDINDOCUMENT = \"checkedInDocument\";\n\t\t\tpublic const string EDITORS = \"editors\";\n\t\t\tpublic const string UPLOADEDFILENAME = \"uploadedFileName\";\n\t\t\tpublic const string SOURCE = \"source\";\n\t\t\tpublic const string METADATAFIELD_ = \"MetadataField_\";\n\t\t\tpublic const string METADATAGROUP_ = \"MetadataGroup_\";\n\t\t\tpublic const string MULTILINESETTING = \"MultilineSetting\";\n\t\t\tpublic const string FIELDCOUNT = \"FieldCount\";\n\t\t\tpublic const string NOTFIELDCOUNT = \"NotFieldCount\";\n\t\t\tpublic const string FIELDNAME = \"FieldName\";\n\t\t\tpublic const string GROUPCOUNT = \"GroupCount\";\n\t\t\tpublic const string RULE = \"Rule\";\n\t\t\tpublic const string DOCXPATH = \"DocXPath\";\n\t\t\tpublic const string MANIFEST = \"Manifest\";\n\t\t\tpublic const string ROWNUMBER = \"RowNumber\";\n\t\t\tpublic const string CANDOWNLOADPDF = \"CanDownloadPdf\";\n\t\t\tpublic const string CANDOWNLOADNATIVE = \"CanDownloadNative\";\n\t\t\tpublic const string PREVIEWBEHAVIOR = \"PreviewBehavior\";\n\t\t\tpublic const string FAXNUMBER = \"FaxNumber\";\n\t\t\tpublic const string FAXCOUNT = \"FaxCount\";\n\t\t\tpublic const string COMMENT_IDENTIFIER = \"CommentIdentifier\";\n\t\t\tpublic const string EFORM_DESIGN_NAME = \"eformDesignName\";\n\t\t\tpublic const string EXTERNAL_REVIEW = \"ExternalReview\";\n\t\t\tpublic const string EXTERNAL_REVIEW_DOCUMENT = \"ExternalReviewDocument\";\n\t\t\tpublic const string REMINDERNAME = \"ReminderName\";\n\t\t\tpublic const string WATCHERS = \"Watchers\";\n\t\t\tpublic const string CC = \"cc\";\n\t\t\tpublic const string WORKFLOW = \"Workflow\";\n\t\t\tpublic const string WORKFLOW_ACTION = \"WorkflowAction\";\n\t\t\tpublic const string WORKFLOW_ACTIVITY_NAME = \"WorkflowActivityName\";\n\t\t\tpublic const string WORKFLOW_NAME = \"workflowName\";\n\t\t\tpublic const string WORKITEM_DISPLAYNAME = \"workitemDisplayName\";\n\t\t\tpublic const string WORKFLOW_UID = \"WorkflowUid\";\n\t\t\tpublic const string WORKFLOWINSTANCEUID = \"WorkflowInstanceUid\";\n\t\t\tpublic const string WORKFLOWACTIVITYUID = \"WorkflowActivityUid\";\n\t\t\tpublic const string RESULT = \"Result\";\n\t\t\tpublic const string CLIENT_APP_NAME = \"ClientAppName\";\n\t\t\tpublic const string CHATTER_GROUPS = \"ChatterGroups\";\n\t\t\tpublic const string CHATTER_MESSAGE = \"ChatterMessage\";\n\t\t\tpublic const string CHATTER_SFOBJECTID = \"ChatterSfObjectId\";\n\t\t\tpublic const string URL = \"Url\";\n\t\t\tpublic const string RULEUID = \"RuleUid\";\n\t\t\tpublic const string OLD_RULEUID = \"OldRuleUid\";\n\t\t\tpublic const string OLD_FILTER_ID = \"OldFilterId\";\n\t\t\tpublic const string NEW_FILTER_ID = \"NewFilterId\";\n\t\t\tpublic const string OLD_FILTER_VAL = \"OldFilterValue\";\n\t\t\tpublic const string NEW_FILTER_VAL = \"NewFilterValue\";\n\t\t\tpublic const string REMOVED_CONDITIONS = \"RemovedConditions\";\n\t\t\tpublic const string ADDED_CONDITIONS = \"AddedConditions\";\n\t\t\tpublic const string REMOVED_STATUS_SECURITY = \"RemovedStatusSecurity\";\n\t\t\tpublic const string ADDED_STATUS_SECURITY = \"AddedStatusSecurity\";\n\t\t\tpublic const string REMOVED_SECURITY_GROUPS = \"RemovedSecurityGroups\";\n\t\t\tpublic const string ADDED_SECURITY_GROUPS = \"AddedSecurityGroups\";\n\t\t\tpublic const string OLD_ACCESS_LEVEL = \"OldAccessLevel\";\n\t\t\tpublic const string NEW_ACCESS_LEVEL = \"NewAccessLevel\";\n\t\t\tpublic const string OLD_RULE_NAME = \"OldRuleName\";\n\t\t\tpublic const string NEW_RULE_NAME = \"NewRuleName\";\n\t\t\tpublic const string ALL_USERS = \"All Users\";\n\t\t\tpublic const string EMAIL_BOUNCE = \"EmailBounce\";\n\t\t\tpublic const string EMAIL_BOUNCE_DETAILS = \"EmailBounceDetails\";\n\t\t\tpublic const string FROMEMAIL = \"FromEmail\"; // From Email address from email ingestion\n\t\t\tpublic const string OLD_SUMMARY = \"OldSummary\";\n\t\t}\n\n\t\tpublic class ResourceTokenResources\n\t\t{\n\t\t\tpublic const string RESOURCEID = \"resource_id\";\n\t\t\tpublic const string RESOURCETYPE = \"resource_type\";\n\t\t\tpublic const string RESOURCEREQUESTTYPE = \"resource_request_type\";\n\t\t\tpublic const string CONTENTTYPE = \"content_type\";\n\t\t}\n\n\t\tpublic class SCIM\n\t\t{\n\t\t\tpublic const int RetryIntervalSeconds = 5;\n\t\t\tpublic const int RetryAttempts = 5;\n\t\t}\n\n\t\tpublic class SupportIndicators\n\t\t{\n\t\t\tpublic const string CLMIndicator = \"CLM\";\n\t\t\tpublic const string LegacyIndicator = \"CLM.CM\";\n\t\t\tpublic const string CLMEssentialsIndicator = \"CLM Essentials\";\n\t\t}\n\n\t\tpublic class SharedStorageOperations\n\t\t{\n\t\t\tpublic const string SaveFileFromStream = \"SaveFileFromStream\";\n\t\t\tpublic const string GetFileStream = \"GetFileStream\";\n\t\t\tpublic const string GetPartialStream = \"GetPartialStream\";\n\t\t\tpublic const string GetChunk = \"GetChunk\";\n\t\t\tpublic const string GetContentLength = \"GetContentLength\";\n\t\t\tpublic const string DeleteFile = \"DeleteFile\";\n\t\t\tpublic const string GetObject = \"GetObject\";\n\t\t\tpublic const string FileExists = \"FileExists\";\n\t\t}\n\n\t\tpublic class Status\n\t\t{\n\t\t\tpublic const string Success = \"Success\";\n\t\t\tpublic const string Failure = \"Failure\";\n\t\t}\n\n\t\tpublic static class ActGoogleForClm\n\t\t{\n\t\t\tpublic const string AppId = \"059ab90c-2cc6-4055-8361-49b1c0c8b4fe\";\n\t\t\tpublic const string DeleteActionId = \"daa5d01d-e053-41ce-84fb-736006902732\";\n\t\t\tpublic const string DownloadActionId = \"314f1fc7-9e68-4d0b-89a4-8c5353aa6854\";\n\t\t\tpublic const string UploadActionId = \"f34dd178-66af-44ea-8fa8-502c8f4c6be9\";\n\t\t\tpublic const string PermissionSetActionId = \"74b97b0d-bc7c-4999-a5ca-e0c78c857798\";\n\t\t}\n\n\t\tpublic static class ActAribaForClm\n\t\t{\n\t\t\tpublic const string ContractWorkspaceAppId = \"d00d0679-1fc3-45fc-b870-f6bb05caee81\";\n\t\t\tpublic const string SPMAppId = \"01a1b779-8dac-402f-afc4-178582760580\";\n\t\t\tpublic const string ACTv1ConnectionsDefaultResponse = \"{\\\"result\\\":\\\"SUCCESS\\\",\\\"error\\\":null,\\\"data\\\":[]}\";\n\t\t\tpublic const string AvailableActionsPropertyKey = \"crud\";\n\t\t\tpublic static readonly string[] LegacyActionNames = new string[] { \"get-contract-line-items\", \"get-contract-workspace\", \"get-contract-documents-metadata\", \"update-contract-workspace\", };\n\t\t}\n\n\t\tpublic static class DataIOV6ActionNames\n\t\t{\n\t\t\tpublic const string SearchRecords = \"search-records\";\n\t\t\tpublic const string GetTypeNames = \"get-type-names\";\n\t\t\tpublic const string GetTypeDefinitions = \"get-type-definitions\";\n\t\t\tpublic const string PatchRecord = \"patch-record\";\n\t\t\tpublic const string CreateRecord = \"create-record\";\n\t\t\tpublic const string GetSfOrgData = \"get-org-data\";\n\n\t\t\tpublic const string READABLE = \"Readable\";\n\t\t\tpublic const string CREATEABLE = \"Createable\";\n\t\t\tpublic const string UPDATEABLE = \"Updateable\";\n\t\t}\n\n\t\tpublic enum DataIOV6Action\n\t\t{\n\t\t\tSearchRecords,\n\t\t\tGetTypeNames,\n\t\t\tGetTypeDefinitions,\n\t\t\tPatchRecord,\n\t\t\tCreateRecord,\n\t\t\tGetSfOrgData\n\t\t}\n\n\t\tpublic static class ActIntegrationProviders\n\t\t{\n\t\t\tpublic const string NetSuite = \"netsuite\";\n\t\t\tpublic const string Workday = \"workday\";\n\t\t\tpublic const string Ariba = \"ariba\";\n\t\t\tpublic const string AribaSCW = \"aribascw\";\n\t\t\tpublic const string AribaSPM = \"aribaspm\";\n\t\t\tpublic const string AribaMDS = \"aribamds\";\n\t\t\tpublic const string AribaEMA = \"aribaema\";\n\t\t\tpublic const string AribaRMA = \"aribarma\";\n\t\t\tpublic const string AribaSCA = \"aribasca\";\n\t\t\tpublic const string AribaDMA = \"aribadma\";\n\t\t\tpublic const string AribaSDA = \"aribasda\";\n\t\t\tpublic const string Coupa = \"coupa\"; //ACT V1 app\n\t\t\tpublic const string CoupaCore = \"coupacore\"; //ACT V2 app\n\t\t\tpublic const string WorkdayFinancials = \"workdayfinancials\";\n\t\t\tpublic readonly static Dictionary<string, Guid> ProviderToAppId = new Dictionary<string, Guid>\n\t\t\t{\n\t\t\t\t{ AribaSCW, Guid.Parse(\"d00d0679-1fc3-45fc-b870-f6bb05caee81\") },\n\t\t\t\t{ AribaSPM, Guid.Parse(\"01a1b779-8dac-402f-afc4-178582760580\") },\n\t\t\t\t{ AribaMDS, Guid.Parse(\"44a96013-5326-4f09-bf2e-e3da77a67eda\") },\n\t\t\t\t{ AribaEMA, Guid.Parse(\"3eb4175e-10de-4baa-ae99-247bff678e36\") },\n\t\t\t\t{ AribaRMA, Guid.Parse(\"42a450bd-0b01-44bb-9606-a515fee248e9\") },\n\t\t\t\t{ AribaSCA, Guid.Parse(\"d86801cf-c318-4ac0-9ebd-427ac5a3c41d\") },\n\t\t\t\t{ AribaDMA, Guid.Parse(\"ee1e604c-55ae-4310-a467-e49c799be5d7\") },\n\t\t\t\t{ AribaSDA, Guid.Parse(\"db352637-e09e-40cb-a274-2ca2c1c44565\") },\n\t\t\t\t{ CoupaCore, Guid.Parse(\"4d4b08e6-f9bd-4f82-97df-6804aea2ee58\")},\n\t\t\t\t{ WorkdayFinancials, Guid.Parse(\"0260e028-8554-4f13-a314-27dca49a0a01\")}\n\t\t\t};\n\t\t}\n\n\t\tpublic enum ActExecutionStatus\n\t\t{\n\t\t\tEXECUTION_STATUS_UNSPECIFIED,\n\t\t\tEXECUTION_STATUS_CREATED,\n\t\t\tEXECUTION_STATUS_EXECUTING,\n\t\t\tEXECUTION_STATUS_FAILED,\n\t\t\tEXECUTION_STATUS_SUCCEEDED\n\t\t}\n\n\t\tpublic static class ActIntegrationPaths\n\t\t{\n\t\t\tpublic const string ProviderConfigPath = \"api/v2/providerConfig\";\n\t\t\tpublic const string ProviderPath = \"api/v2/providers\";\n\t\t\tpublic const string AppPath = \"api/v2/apps\";\n\t\t\tpublic const string AllProvidersAppsPath = \"api/v2/providersAndApps\";\n\t\t\tpublic const string ConnectedAppsPath = \"api/v2/connectedApps\";\n\t\t\tpublic const string IntegrationsPath = \"api/v2/integrations\";\n\t\t\tpublic const string ChatNotificationPath = \"api/v2/notifications/slack/message\";\n\t\t}\n\n\t\tpublic static class ActPlatformPaths\n\t\t{\n\t\t\tpublic const string AppsPath = \"apps\";\n\t\t\tpublic const string AccountAppsPath = \"accounts/{0}/apps\";\n\t\t\tpublic const string AccountAppsAppIdPath = \"accounts/{0}/apps/{1}\";\n\t\t\tpublic const string AccountExecutionsPath = \"accounts/{0}/executions\";\n\t\t\tpublic const string GetExecutionPath = \"accounts/{0}/executions/{1}\";\n\t\t}\n\n\t\tpublic static class AgreementAnalyzerConstants\n\t\t{\n\t\t\tpublic struct CustomMetadtaItemNames\n\t\t\t{\n\t\t\t\tpublic const string LogicAppNames = \"dsclm_LogicAppNames\";\n\t\t\t}\n\n\t\t\tpublic struct MetadataValueAttributeNames\n\t\t\t{\n\t\t\t\tpublic const string ConfidenceScore = \"score\";\n\t\t\t\tpublic const string DateIso8601Format = \"ISO_8601\";\n\t\t\t\tpublic const string DateOriginalValue = \"originalValue\";\n\t\t\t}\n\n\t\t\tpublic struct MetadataValueTypes\n\t\t\t{\n\t\t\t\tpublic const string Date = \"Date\";\n\t\t\t\tpublic const string String = \"String\";\n\t\t\t\tpublic const string Text = \"Text\";\n\t\t\t\tpublic const string Integer = \"Integer\";\n\t\t\t\tpublic const string Boolean = \"Boolean\";\n\t\t\t}\n\n\t\t\tpublic struct OriginApps\n\t\t\t{\n\t\t\t\tpublic const string PreExecution = \"dsclm_analyzer\";\n\t\t\t\tpublic const string PostExecution = \"dsclm_insight\";\n\t\t\t}\n\n\t\t\tpublic const double SealAttributeDefaultConfidenceScore = 100;\n\t\t}\n\n\t\tpublic static class AiAutofillConstants\n\t\t{\n\t\t\tpublic const int MaximumUserDefinedLabelNameLength = 5000;\n\n\t\t\tpublic const string AiAufofillBatchReportFilePath_Key = \"AiAutofill:BatchReport_FilePath:{0}:{1}\"; // AiAutofill:BatchReport_FilePath:{accountId}:{requestToken}\n\t\t}\n\n\t\tpublic static class NpsSurveyConstants\n\t\t{\n\t\t\tpublic static class Grouping\n\t\t\t{\n\t\t\t\tpublic const string DocumentGeneration = \"Document Generation\";\n\t\t\t\tpublic const string Report = \"Report\";\n\t\t\t\tpublic const string Task = \"Task\";\n\t\t\t\tpublic const string Workflow = \"Workflow\";\n\t\t\t}\n\t\t}\n\n\t\tpublic static class AdHocTask\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// This is a unique id to identify ad-hoc tasks in elastic work item index.\n\t\t\t/// It is a UUID v5 guid [ns:OID with name 'API.Assignments.Tasks.v1'].\n\t\t\t/// </summary>\n\t\t\tpublic static readonly Guid TypeId = new Guid(\"509c9a1a-e82a-5beb-950f-c4772fbb7645\");\n\t\t}\n\n\t\tpublic static class CacheKeys\n\t\t{\n\t\t\tpublic const string ForwardEventRegistrations = \"ForwardEventRegistrations\";\n\t\t}\n\n\t\tpublic static class SiteNames\n\t\t{\n\t\t\tpublic const string loca = \"loca\";\n\t\t\tpublic const string us11 = \"us11\";\n\t\t\tpublic const string us12 = \"us12\";\n\t\t\tpublic const string us13 = \"us13\";\n\t\t}\n\n\t\tpublic static class OfficeWebApps\n\t\t{\n\t\t\tpublic const string DocumentReservationKeyFormat = \"OwaDocument_{0}_{1}\"; // OwaDocument_{AccountId}_{DocumentUid}\n\t\t}\n\n\t\tpublic struct AisPropertyNames\n\t\t{\n\t\t\tpublic const string ContractType = \"ContractType\";\n\t\t\tpublic const string ContractingParties = \"ContractingParties\";\n\t\t\tpublic const string ContractValue = \"ContractValue\";\n\t\t\tpublic const string StartDate = \"StartDate\";\n\t\t\tpublic const string TerminationDate = \"TerminationDate\";\n\t\t\tpublic const string AutoRenewal = \"AutoRenewal\";\n\t\t\tpublic const string RenewalTerm = \"RenewalTerm\";\n\t\t\tpublic const string TerminationNoticePeriod = \"TerminationNoticePeriod\";\n\t\t\tpublic const string RenewalNotice = \"RenewalNotice\";\n\t\t\tpublic const string PaymentTerms = \"PaymentTerms\";\n\t\t\tpublic const string PaymentDuration = \"PaymentTermsDue\";\n\t\t\tpublic const string PaymentLateFees = \"PaymentLateFeeSent\";\n\t\t\tpublic const string LimitationOfLiability = \"LimitationOfLiability\";\n\t\t\tpublic const string Assignable = \"Assignable\";\n\t\t\tpublic const string Indemnity = \"Indemnity\";\n\t\t\tpublic const string TerminationCause = \"TerminationCause\";\n\t\t\tpublic const string TerminationConvenience = \"TerminationConvenience\";\n\t\t\tpublic const string ChangeOfControl = \"ChangeOfControl\";\n\t\t\tpublic const string PaymentEarlyDiscount = \"PaymentEarlyDiscount\";\n\t\t\tpublic const string ForceMajeure = \"ForceMajeure\";\n\t\t}\n\n\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Enums.cs",
            "content": "\nusing ADEXS.Core.Util.Loggers;\nusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Collections.Specialized;\nusing System.ComponentModel;\nusing System.Globalization;\nusing System.Linq;\nusing System.Reflection;\nusing System.Resources;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Converters;\n\n\nnamespace ADEXS.Core.Types\n{\n\tpublic class Enums : ADEXS.Globals.ScmEnums\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(Enum));\n\n\t\t#region A\n\n\t\tpublic enum ABACAttributeSource\n\t\t{\n\t\t\tBase, // native properties of an object\n\t\t\tAOM, // properties that come from Agreement Object/Document Model\n\t\t\tAttribute // Metadata on the object\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ABACAccessLevel\n\t\t{\n\t\t\tAttributeBased = -1,\n\t\t\tDefault = 0,\n\t\t\tView = 1,\n\t\t\tEdit = 2,\n\t\t\tManage = 3\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum  ABACDocumentStatus\n\t\t{\n\t\t\tActive = AgreementStatus.Active,\n\t\t\tInactive = AgreementStatus.Inactive,\n\t\t\tPending = AgreementStatus.Pending,\n\t\t\tUnknown = AgreementStatus.Unknown\n\t\t}\n\n\t\tpublic enum Access\n\t\t{\n\t\t\tNone = 0,\n\t\t\tReadOnly = 1,\n\t\t\tWrite = 2\n\t\t}\n\n\t\tpublic enum AccountStatus\n\t\t{\n\t\t\tSuspended = -3, // Temporary status used to stop all activity in an account for maintenance purposes\n\t\t\tCancelled = -2, // Account that was paid for, but is now cancelled\n\t\t\tDeleted = -1, // Account is deleted\n\t\t\tTrial = 0, // Trial account, within it's 30 days\n\t\t\tPaid = 1, // Account that is paid for\n\t\t\tExpiredTrial = 2, // Trial account, expired, after it's 30 days are up\n\t\t\tUnpaid = 3, // Account that was paid for, but is now behind\n\t\t}\n\n\t\tpublic enum AccountBrandingImageStatus\n\t\t{\n\t\t\tHasImage = 1,\n\t\t\tDoesNotHaveImage = 2,\n\t\t\tUnknown = 3\n\t\t}\n\n\t\tpublic enum AccountBrandingImageType\n\t\t{\n\t\t\tLogo,\n\t\t\tIcon\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Allow account types, used so we can allow different types of accounts to have different feature sets available and also enact behaviors based on account type.\n\t\t/// </summary>\n\t\tpublic enum AccountType\n\t\t{\n\t\t\t[Description(\"Unknown\")]\n\t\t\tUnknown = 0,\n\t\t\t[Description(\"Free Edition (Deprecated)\")]\n\t\t\tFreeEdition = 2,\n\t\t\t[Description(\"DocuSign Gen\")]\n\t\t\tGen = 1000,\n\t\t\t[Description(\"Classic Business\")]\n\t\t\tBusiness = 2000,\n\t\t\t[Description(\"Docusign CLM\")]\n\t\t\tCLM = 2200,\n\t\t\t[Description(\"DocuSign Negotiate\")]\n\t\t\tNegotiate = 2300,\n\t\t\t[Description(\"Classic Contracts\")]\n\t\t\tContracts = 2500,\n\t\t\t[Description(\"Classic Enterprise\")]\n\t\t\tEnterprise = 3000,\n\t\t\t[Description(\"Classic Premium\")]\n\t\t\tPremium = 4000\n\t\t}\n\n\t\tpublic enum ActionGroupType\n\t\t{\n\t\t\tSimple = 0,\n\t\t\tTop = 1,\n\t\t\tSubmenu = 2,\n\t\t\tHeader = 3\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ActorRestrictedTo\n\t\t{\n\t\t\t[Description(\"All Users and Groups\")]\n\t\t\tUsersAndGroups = 0,\n\t\t\t[Description(\"All Users\")]\n\t\t\tUsers = 2,\n\t\t\t[Description(\"All Groups\")]\n\t\t\tGroups = 3,\n\t\t\t[Description(\"Users in Specific Groups\")]\n\t\t\tUsersInGroups = 4,\n\t\t\t[Description(\"Specific Groups\")]\n\t\t\tSpecificGroups = 5\n\t\t}\n\n\t\t//Used in reporting\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AggregateType\n\t\t{\n\t\t\tNone,\n\t\t\tAverage,\n\t\t\tTotal,\n\t\t\tMin,\n\t\t\tMax,\n\t\t\tCount\n\t\t}\n\n\t\tpublic enum AIDocumentStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tScheduled = 1,\n\t\t\tInProgress = 2,\n\t\t\tSuccessful = 3,\n\t\t\tCancelled = 4\n\t\t}\n\n\t\tpublic enum AIDocumentSubStatus\n\t\t{\n\t\t\tFailedGeneratingPDF = -12,\n\t\t\tEmptyFileNotSupported = -11,\n\t\t\tDuplicateDocumentUpload = -10,\n\t\t\tFailedProcessingByAIEngine = -9,\n\t\t\tFailedToAuthenticateWithAIEngine = -8,\n\t\t\tFailedUploadDocumentToAIEngine = -7,\n\t\t\tPasswordProtectedFileNotSupported = -6,\n\t\t\tFailedLogicAppRun = -5,\n\t\t\tFailedGeneratingGlyphs = -4,\n\t\t\tFailedGettingExtractions = -3,\n\t\t\tFailedWaitingForCallback = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tScheduled = 1,\n\t\t\tWaitingForCallback = 2,\n\t\t\tGettingExtractions = 3,\n\t\t\tWaitingForGlyphExtraction = 4,\n\t\t\tSuccessful = 5,\n\t\t\tWaitingForGlyphReconciliation = 6,\n\t\t\tCompletingTheTransaction = 7,\n\t\t\tCompletedRetryForTransaction = 8,\n\t\t\tWaitingForPdfGeneration = 9,\n\t\t\tScheduledForAiIngestionRetry = 10\n\t\t}\n\n\t\tpublic enum AIProviderType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tSeal = 1,\n\t\t\tAIS = 2,\n\t\t\tAPR = 3\n\t\t}\n\n\t\tpublic enum AIProviderExtractionType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tLabels = 1,\n\t\t\tScorecard = 2\n\t\t}\n\n\t\tpublic enum AIDocumentUploadStatus\n\t\t{\n\t\t\tPasswordProtectedFile = -7,\n\t\t\tBatchNotFound = -6,\n\t\t\tTransactionNotFound = -5,\n\t\t\tFileTypeNotSupported = -4,\n\t\t\tDuplicateDocument = -3,\n\t\t\tDocumentNotFound = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tBatchInCancelledStatus = 2,\n\t\t}\n\n\t\tpublic enum AISIngestionStatus\n\t\t{\n\t\t\tEmptyFile = -6,\n\t\t\tPasswordProtectedFile = -5,\n\t\t\tBatchNotFound = -4,\n\t\t\tUnlock = -3,\n\t\t\tFileTypeNotSupported = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tPending = 1,\n\t\t\tSuccess = 2,\n\t\t\tTransactionNotFound = 3,\n\t\t\tDocumentNotFound = 4,\n\t\t\tBatchInCancelledStatus = 5,\n\t\t\tWaitingForPdfCreation = 6\n\t\t}\n\n\t\tpublic enum APRAIIngestionStatus\n\t\t{\n\t\t\tEmptyFile = -6,\n\t\t\tPasswordProtectedFile = -5,\n\t\t\tBatchNotFound = -4,\n\t\t\tUnlock = -3,\n\t\t\tFileTypeNotSupported = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tPending = 1,\n\t\t\tSuccess = 2,\n\t\t\tTransactionNotFound = 3,\n\t\t\tDocumentNotFound = 4,\n\t\t\tBatchInCancelledStatus = 5,\n\t\t\tWaitingForPdfCreation = 6,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Object type to be used for Target system where atttributes will be mapped.\n\t\t/// </summary>\n\t\tpublic enum AIRulesEngineMappingObjectType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tCLMAttributes = 1,\n\t\t\tAOM = 2,\n\t\t\tClauseLibrary = 3,\n\t\t\tCLMAttributesGroup =4,\n\t\t\tAOMAttributesGroup = 5\n\t\t}\n\n\t\tpublic enum AIAttributeReviewProgressStatus\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tNotStarted = 1,\n\t\t\tInProgress = 2,\n\t\t\tCompleted = 3\n\t\t}\n\n\t\tpublic enum AIBatchReportStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tNotStarted = 1,\n\t\t\tInProgress = 2,\n\t\t\tCompleted = 3,\n\t\t}\n\n\t\tpublic enum AIDocumentStatisticsCounterType\n\t\t{\n\t\t\tTotalTransactions = 1,\n\t\t\tTotalTransactionsProcessed = 2\n\t\t}\n\n\t\tpublic enum AIReviewStatus\n\t\t{\n\t\t\tUnreviewed = 0,\n\t\t\tPartiallyReviewed = 1,\n\t\t\tReviewed = 2\n\t\t}\n\n\t\tpublic enum AllowedValueResultStatus\n\t\t{\n\t\t\tCascadingPrevFieldNotSet = -5,\n\t\t\tNonDropdownDataTypeFound = -4,\n\t\t\tMetadataFieldNotFound = -3,\n\t\t\tInvalidObjectId = -2,\n\t\t\tObjectTypeNotSupported = -1,\n\t\t\tSuccess = 0\n\t\t}\n\n\t\t//Lists All Api Versions\n\t\tpublic enum APIVersion\n\t\t{\n\t\t\tv1 = 1,\n\t\t\tv2 = 2,\n\t\t\tv201411 = 201411,\n\t\t\tv201708 = 201708\n\t\t}\n\n\t\t[Obsolete(\"Please use AttachmentFileSource enum instead\")]\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AttachmentSource\n\t\t{\n\t\t\tAny = 0,\n\t\t\tSpringCM = 1,\n\t\t\tUpload = 2\n\t\t}\n\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AttachmentFileSource\n\t\t{\n\t\t\tAny = 0,\n\t\t\tCLM = 1,\n\t\t\tUpload = 2\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AuthenticationType\n\t\t{\n\t\t\tNone = 0,\n\t\t\tSMS = 1,\n\t\t\tKBA = 2,\n\t\t\tAccessCode = 3,\n\t\t\tPhone = 4\n\t\t}\n\n\t\tpublic enum EmailActionType\n\t\t{\n\t\t\tNone,\n\t\t\tCheckin,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Acceptable values for the Document State property.\n\t\t/// </summary>\n\t\tpublic enum AddressBookEntryStatus\n\t\t{\n\t\t\tDeleted = -1,\n\t\t\tUnknown = 0,\n\t\t\tActive = 1\n\t\t}\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AllowedChoices\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// User must choose at least one thing\n\t\t\t/// </summary>\n\t\t\tOneOrMore,\n\t\t\t/// <summary>\n\t\t\t/// User can *only* choose one thing\n\t\t\t/// </summary>\n\t\t\tOne,\n\t\t\t/// <summary>\n\t\t\t/// User can choose any number of things\n\t\t\t/// </summary>\n\t\t\tZeroOrMore,\n\t\t}\n\n\t\tpublic enum CompareType\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// User does not compare\n\t\t\t/// </summary>\n\t\t\tNone,\n\t\t\t/// <summary>\n\t\t\t/// User compares against the previous version of the document\n\t\t\t/// </summary>\n\t\t\tPrevious,\n\t\t\t/// <summary>\n\t\t\t/// User compares against the first version of the document\n\t\t\t/// </summary>\n\t\t\tFirst\n\t\t}\n\n\t\tpublic enum MergeOutputType\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// Merge creates a .pdf document\n\t\t\t/// </summary>\n\t\t\tPdf,\n\n\t\t\t/// <summary>\n\t\t\t/// Merge creates a .docx document\n\t\t\t/// </summary>\n\t\t\tWord\n\t\t}\n\n\t\tpublic enum MergeTargetLocation\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// Merged file(s) are uploaded to salesforce.\n\t\t\t/// </summary>\n\t\t\tSalesforce,\n\n\t\t\t/// <summary>\n\t\t\t/// Merged file(s) are saved in clm.\n\t\t\t/// </summary>\n\t\t\tClm\n\t\t}\n\n\n\t// AtlasEtlFactory creates instance of class based on enum name.\n\t\t// Make sure if you add a entry the name is same as class name in AtlasEtlService\n\t\tpublic enum AtlasEtlType\n\t\t{\n\t\t\tEtlExcel = 0,\n\t\t\tEtlSalesforce = 1\n\t\t}\n\n\t\tpublic enum AtlasEtlResultStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tCompleted = 0\n\t\t}\n\n\t\tpublic enum AdminPage\n\t\t{\n\t\t\tNone = 0,\n\n\t\t\tResetPassword = 10,\n\t\t\tMyPreferences = 11,\n\t\t\tDownloads = 12,\n\t\t\tMyProfile = 13,\n\t\t\tSupportAccounts = 14,\n\n\t\t\tAccountPreferences = 20,\n\t\t\tAccountSecurity = 21,\n\t\t\tInboundEmailAddresses = 23,\n\t\t\tManageFaxLines = 24,\n\t\t\tAttributes = 25,\n\t\t\tDocumentRules = 26,\n\t\t\tAttributeImportMappings = 27,\n\t\t\tSchedules = 28,\n\t\t\tResellerAccounts = 29,\n\t\t\tCreatePackage = 30,\n\t\t\tPermissionSetManagement = 31,\n\t\t\tElectronicSignature = 32,\n\n\t\t\tBranding = 50,\n\t\t\tAddLogInToMyWebsite = 51,\n\n\t\t\tDeviceManagement = 54,\n\t\t\tNotificationPreference = 55,\n\t\t\tSFConfiguration = 56,\n\t\t\tSSO = 57,\n\t\t\tAutoNumbers = 58,\n\t\t\tAPIUsers = 59,\n\t\t\tReminderTemplates = 60,\n\t\t\tSFTPAuthentication = 61,\n\t\t\tDocLauncherConfig = 62,\n\t\t\tTwoFactorAuthentication = 63,\n\t\t\tMenuActions = 64,\n\t\t\tSiteInfo = 65,\n\t\t\tDocFolderSettings = 66,\n\t\t\tLegacyCustomActionsReport = 67,\n\t\t\tUsers = 68,\n\t\t\t//SecurityGroups = 69,\n\t\t\tContacts = 70,\n\t\t\tQueues = 71,\n\t\t\tGroups = 72,\n\t\t\tConnectedApps = 73,\n\t\t\tSealConfiguration = 74,\n\t\t\tClauseConfiguration = 75,\n\t\t\tPartyManagement = 76,\n\t\t\tActIntegrationManagement = 77,\n\t\t\tPartyAdminDocUpload = 78,\n\t\t\tAttributeAutofill = 79,\n\t\t\tConnections = 80,\n\t\t\tDocumentAccess = 81,\n\t\t\tProcessBuilder = 82,\n\t\t\tConvertUsers = 83,\n\t\t\tConvertGroups = 84,\n\t\t\tConversionDashboard = 85,\n\t\t\tObjectMapping = 86,\n\t\t\tAllDocuments = 87,\n\t\t\tBeginConversion = 88,\n\t\t\tDocumentSettings = 89,\n\t\t\tDocumentTypes = 90,\n\t\t\t//Nav Tabs used as Admin Tabs: Mapping to 100 + Enums.Tabs for these in case we add others.\n\t\t\tNavForms = 109,\n\t\t\tNavWorkflow = 102\n\t\t}\n\n\t\tpublic enum AlertCategory\n\t\t{\n\t\t\tInternal = 0,\n\t\t\tCollaboration = 1,\n\t\t\tSystem = 2,\n\t\t\tSharedFolder = 3\n\t\t}\n\n\t\tpublic enum AlertType\n\t\t{\n\t\t\tUnknown = -1,\n\n\t\t\tPlannedDowntime = 1,\n\t\t\tNewFeatures = 2,\n\t\t\tSystemMessage = 3,\n\n\t\t\t/*No longer used\n\t\t\tNewCollaboration = 21,\n\t\t\tEndCollaboration = 22,\n\t\t\tRevisionRequest = 23,\n\t\t\tWorkFlowStepRejected = 24,\n\t\t\tWorkFlowActionRequired = 25,\n\t\t\tWorkFlowStepFinalized = 26,\n\t\t\tWorkFlowsCompleted = 27,\n\t\t\tWorkFlowStepOverdue = 28,\n\t\t\tWorkFlowStepReminder = 29,\n\t\t\tDocumentNudge = 30,\n\t\t\tDocumentCheckIn = 31,\n\t\t\tWorkFlowNudge = 33,\n\t\t\tWorkFlowActionNotRequired = 34,*/\n\n\t\t\tAccountCapacity = 41,\n\t\t\tFailedEmail = 42,\n\t\t\tFailedFax = 43,\n\t\t\tStatusChange = 44,\n\t\t\tFileExpiration = 45,\n\n\t\t\tSharedFolderNudge = 61,\n\t\t\tSharedDocumentUndoCheckout = 62\n\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AnalyticsChartOrientation\n\t\t{\n\t\t\tHorizontal = 0,\n\t\t\tVertical = 1\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AnalyticsChartType\n\t\t{\n\t\t\tTable = 0,\n\t\t\tBar = 1,\n\t\t\tDonut = 2\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AnalyticsReportType\n\t\t{\n\t\t\tNone = -1,\n\t\t\tSummary = 0,\n\t\t\tDetail = 1,\n\t\t\tDocument = 3,\n\t\t\tStepDetail = 4,\n\t\t\tDocumentActivity = 5,\n\t\t\tWorkflowProcesses = 6,\n\t\t\tUsers = 7,\n\t\t\tAgreementsExpiring = 8,\n\t\t\tObligations = 9,\n\t\t\tPublicDocumentsAndFolders = 10,\n\t\t\tAgreementsApproachingRenewal = 11\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum AnalyticsReportAccessLevel\n\t\t{\n\t\t\tNone = 0,\n\t\t\tView = 1,\n\t\t\tExport = 2,\n\t\t\tEdit = 4\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ReportAccessType\n\t\t{\n\t\t\tNone = 0,\n\t\t\tDefault = 1,\n\t\t\tPublic = 2,\n\t\t\tPrivate = 3\n\t\t}\n\n\t\tpublic enum AtlasScriptBuilds\n\t\t{\n\t\t\tNone = 0,\n\t\t\tAtlas = 1,\n\t\t\tEforms = 2,\n\t\t\tInteractivePreview = 3,\n\t\t\tGlobalHeader = 4,\n\t\t\tReports = 5,\n\t\t\tSearch = 6,\n\t\t\tAnalytics = 7,\n\t\t\tConfigureWorkflowTemplates = 8,\n\t\t\tWorkflowTemplate = 9,\n\t\t\tTasks = 10,\n\t\t\tCounterpartyManagement = 11,\n\t\t\tTaskList = 12,\n\t\t\tActUI = 13,\n\t\t\tSessionTimeout = 14,\n\t\t\tDocExplorer = 15,\n\t\t\tAgreementSummary = 16,\n\t\t\tTranslationManagement = 17,\n\t\t\tDelegateAccess = 18,\n\t\t\tSupportAccounts = 19,\n\t\t\tObligationManagement = 20,\n\t\t\tSmartAgreement = 21,\n\t\t\tAgreementTemplate = 22,\n\t\t\tDocumentAccess = 23,\n\t\t\tPublicDocumentsAndFoldersReport = 24,\n\t\t\tProcessBuilder = 25,\n\t\t\tAgreementList = 26,\n\t\t\tDocExplorerWidgets = 27,\n\t\t\tDocAttribute = 28,\n\t\t\tIE11DeprecationNotice = 29,\n\t\t\tAccountMigrationBanner = 30,\n\t\t\tGlobalFooter = 31,\n\t\t\tAccountMigration = 32,\n\t\t\tLogin = 33,\n\t\t\tAdmin = 34,\n\t\t\tDocumentTypes = 35,\n\t\t\tDocGenPartySelectModal = 36,\n\t\t\tSearchApp = 37,\n\t\t\tSecureForm = 39,\n\t\t\tCopyShareLink = 40,\n\t\t\tClassicDashboardDeprecationNotice = 41,\n\t\t\tDocReviewMigrationBanner = 42,\n\n\t\t\t//DotVVM Scripts\n\t\t\tDotVVMModule = 100,\n\t\t\tDotVVMAddressBook = 101,\n\t\t\tDotVVMAttributeGroups = 102,\n\t\t\tDotVVMNodeGrid = 103,\n\t\t\tConnectionChooser = 104\n\t\t}\n\n\t\tpublic enum AnalyzerInsightsIngestionStatus\n\t\t{\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tSuccess = 1,\n\t\t\tFileTypeNotSupported = 2,\n\t\t\tDuplicateDocument = 3,\n\t\t\tDocumentNotFound = 4\n\t\t}\n\n\t\tpublic enum AIAutofillPostProcessingTaskStatus\n\t\t{\n\t\t\tFailedToUpdateTransaction = -3,\n\t\t\tFailedToSaveStagedMetadata = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tTransactionNotFound = 2,\n\t\t\tBatchNotFound = 3,\n\t\t\tZeroRuleModels = 4,\n\t\t\tZeroInputLabels = 5,\n\t\t\tZeroMappings = 6,\n\t\t\tProblemGettingExtractions = 7,\n\t\t\tBatchInCancelledStatus = 8,\n\t\t\tTransactionInCancelledStatus = 9\n\t\t}\n\n\t\tpublic enum AIAutofillAvailableLabelTypes\n\t\t{\n\t\t\tCoreLabels = 0,\n\t\t\tLogicApps = 1,\n\t\t\tIntellego = 2,\n\t\t}\n\n\t\tpublic enum AIBatchInitiatorSource\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tCLM = 1,\n\t\t\tUC = 2\n\t\t}\n\n\t\tpublic enum AgreementStatus\n\t\t{\n\t\t\tActive = 0,\n\t\t\tInactive = 1,\n\t\t\tPending = 2,\n\t\t\tUnknown = 3\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Views of Agreement List.\n\t\t/// See Views in Web.CommonUI\\resources\\js\\react\\packages\\agreementList\\enums.ts\n\t\t/// </summary>\n\t\tpublic enum AgreementListAssignType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tUnassigned = 1,\n\t\t\tAssignedToMe = 2,\n\t\t\tAssignedToMyReports = 3,\n\t\t\tAll = 4,\n\t\t\tSearch = 5,\n\t\t\tActive =6\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum AccountConversionStatus\n\t\t{\n\t\t\tFailure = -1,\n\t\t\tNotSet = 0,\n\t\t\tValidated = 1,\n\t\t\tInProgress = 2,\n\t\t\tDsMappingComplete = 3,\n\t\t\tComplete = 4,\n\t\t\tRollback = 5\n\t\t}\n\n\t\tpublic enum AccountConversionAction\n\t\t{\n\t\t\tDefault = 0,\n\t\t\tAccountValidation = 1,\n\t\t\tConversionStatusChange = 2,\n\t\t\tPropertyChange = 3,\n\t\t\tGroupConversion = 4,\n\t\t\tUserConversion = 5,\n\t\t\tAccountHealth = 6,\n\t\t\tMigrationComplete = 7,\n\t\t\tRollback = 8,\n\t\t\tPSOConversion = 9,\n\t\t\tAccountSnapshot = 10,\n\t\t\tInitialConversionRequest = 11,\n\t\t\tAccountConversion = 12,\n\t\t\tMixedMode = 13,\n\t\t\tNotificationAction = 14\n\t\t}\n\n\t\t#endregion\n\t\t#region B\n\t\tpublic enum BillingHistoryItemType\n\t\t{\n\t\t\tInboundFax = 1,\n\t\t\tOutboundFax = 2,\n\t\t\tPrintOnDemand = 3,\n\t\t\tMonthlySubscription = 4\n\t\t}\n\n\t\tpublic enum BillingHistoryStatus\n\t\t{\n\t\t\tEstimated = 0,\n\t\t\tOutstanding = 1,\n\t\t\tPaid = 2,\n\t\t\tReverted = 3,\n\t\t\tAppealed = 4\n\t\t}\n\n\t\tpublic enum BPMExecutionStatus\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// Execution Pending\n\t\t\t/// </summary>\n\t\t\tEP,\n\t\t\t/// <summary>\n\t\t\t/// Finished With Errors\n\t\t\t/// </summary>\n\t\t\tFE,\n\t\t\t/// <summary>\n\t\t\t/// Finished Successfully\n\t\t\t/// </summary>\n\t\t\tFN,\n\t\t\t/// <summary>\n\t\t\t/// Executing\n\t\t\t/// </summary>\n\t\t\tEX,\n\t\t\t/// <summary>\n\t\t\t/// Paused\n\t\t\t/// </summary>\n\t\t\tPA,\n\t\t\t/// <summary>\n\t\t\t/// Aborted\n\t\t\t/// </summary>\n\t\t\tAB,\n\t\t\t/// <summary>\n\t\t\t/// Waiting\n\t\t\t/// </summary>\n\t\t\tSL,\n\t\t}\n\n\t\tpublic enum BreadCrumbLinkType\n\t\t{\n\t\t\tNoLinks,\n\t\t\tBrowse,\n\t\t\tPublicBrowse\n\t\t}\n\n\t\tpublic enum BulkImportUsersType\n\t\t{\n\t\t\tAddressBook,\n\t\t\tSmartRule,\n\t\t\tSalesforce\n\t\t}\n\n\t\t#endregion\n\t\t#region C\n\t\tpublic enum CancelBatchStatus\n\t\t{\n\t\t\tBatchAlreadyCancelled = -3,\n\t\t\tFailed = -2,\n\t\t\tBatchNotFound = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum CalcSecurityByUserOptimizationMode\n\t\t{\n\t\t\tUnset = 0,\n\t\t\tOnlySecurityNodes = 1,\n\t\t\tAllDescendants = 2\n\t\t}\n\n\t\tpublic enum ApprovalTemplateAction\n\t\t{\n\t\t\tEdit = 0,\n\t\t\tViewTemplate = 1,\n\t\t\tUseTemplate = 2,\n\t\t\tDeleteTemplate = 3\n\t\t}\n\n\t\tpublic enum ContactStatus\n\t\t{\n\t\t\tDeleted = -1,\n\t\t\tUnknown = 0,\n\t\t\tEnabled = 1,\n\t\t\tDisabled = 2 //only used for UserAccount Status\n\t\t}\n\n\t\tpublic enum CompareRequestStatus\n\t\t{\n\t\t\tCancelled = 0,\n\t\t\tCompleted = 1,\n\t\t\tFailed = 2,\n\t\t\tProcessing = 3,\n\t\t\tQueued = 4,\n\t\t\tQueuedCacheFailed = 5,\n\t\t\tTimeout = 6\n\t\t}\n\n\t\tpublic enum CommentsConfiguration\n\t\t{\n\t\t\tRequired = 0,\n\t\t\tOptional = 1,\n\t\t\tHidden = 2\n\t\t}\n\n\t\tpublic enum WorkflowAutoAssignUser\n\t\t{\n\t\t\tLeaveUnassigned = 0,\n\t\t\tNoProvider = 1,\n\t\t\tRandom = 2,\n\t\t\tLeastUsedResource = 3,\n\t\t\tRoundRobin = 4\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Used to categorize items in the central queue\n\t\t/// </summary>\n\t\tpublic enum CentralQueueActionType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tFolderDocumentRemoved = 1,\n\t\t\tFolderDocumentAdded = 2,\n\t\t\tFolderAccessChange = 3,\n\t\t\tDocumentAdd = 4,\n\t\t\tDocumentMove = 5,\n\t\t\tDocumentMetadataChange = 6,\n\t\t\tDocumentRevise = 7\n\t\t}\n\t\t// The reason for cancel a checkout\n\t\tpublic enum UndoCheckoutContext\n\t\t{\n\t\t\tNormal = 0,\t\t\t// day to day processing\n\t\t\tSystem = 1,\t\t\t// when undoing system checkout for workflow, signature, etc.\n\t\t\tLegalHold = 2,\t\t// when placing a legal hold\n\t\t\tRecord = 3,\t\t\t// when the document is made a record\n\t\t}\n\n\t\tpublic enum CheckoutStatus\n\t\t{\n\t\t\t[Description(\"Available\")]\n\t\t\tNotCheckedOut = 0,\n\t\t\t[Description(\"Checked Out\")]\n\t\t\tCheckedOut = 1,\n\t\t\t[Description(\"Waiting\")]\n\t\t\tHandOff = 2, //used when assigning the next user\n\n\t\t\t// Every CheckoutStatus >= SystemForCollaboration is for a system checkout\n\t\t\t// sprocs are aware of the magic value for SystemForCollaboration == 3\n\t\t\t[Description(\"System Checked Out\")]\n\t\t\tSystemForCollaboration = 3, // checked out by the system; only the system can check it in\n\t\t\t// INDEXTODO: When Indexing in batches happens, bring this back, along with code in NodeGrid.cs...\n\t\t\t//[Description(\"Batch Indexing\")]\n\t\t\t//Indexing = 4\n\t\t\t[Description(\"System Checked Out for Workflow\")]\n\t\t\tSystemForAdvancedWorkflow = 5, // checked out by the system as part of an Advanced Workflow; only the system can check it in\n\t\t\t[Description(\"System Checked Out for Signature\")]\n\t\t\tSystemForSignature = 6, // checked out by the system for a signature operation; only the system can check it in\n\t\t\t[Description(\"Checked Out\")]\n\t\t\tCheckoutExternalReview = 7,\n\t\t\t[Description(\"Locked by OWA\")]\n\t\t\tLockedByOfficeWebApps = 8,\n\t\t\t[Description(\"Checked Out for Approval\")]\n\t\t\tCheckoutApproval = 9,\n\t\t\t[Description(\"Checked Out for Data Reconciliation\")]\n\t\t\tCheckoutDataReconciliation = 10,\n\t\t\t[Description(\"Locked by Google Docs\")]\n\t\t\tLockedByGoogleDocs = 11\n\t\t}\n\n\t\tpublic enum CheckOutAllowed\n\t\t{\n\t\t\tDisplayError = 0,\n\t\t\tAllowed = 1,\n\t\t\tAllowedCheckedOutByCurrentUser = 2\n\t\t}\n\n\t\t//ClauseIncluded is an enum of valid state for acceptance\n\t\tpublic enum ClauseIncluded\n\t\t{\n\t\t\t[Description(\"Yes\")]\n\t\t\tYes,\n\t\t\t[Description(\"No\")]\n\t\t\tNo,\n\t\t\t[Description(\"NotApplicable\")]\n\t\t\tNotApplicable\n\t\t}\n\n\t\t[Serializable]\n\t\tpublic enum ClipboardOperation\n\t\t{\n\t\t\tCopy,\n\t\t\tCut\n\t\t}\n\n\t\tpublic enum ColumnDataType\n\t\t{\n\t\t\tString = 0,\n\t\t\tDate = 1,\n\t\t\tActionType = 2,\n\t\t\tDocument = 3,\n\t\t\tFolderPath = 4\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Acceptable values for the Document State property.\n\t\t/// </summary>\n\t\tpublic enum CompanyStatus\n\t\t{\n\t\t\tDeleted = -1,\n\t\t\tUnknown = 0,\n\t\t\tActive = 1,\n\t\t\tInactive = 2\n\t\t}\n\n\t\tpublic enum DocLauncherConfigEvent\n\t\t{\n\t\t\t[Description(\"DocumentGenerationConfigCreated\")]\n\t\t\tCreated,\n\t\t\t[Description(\"DocumentGenerationConfigModified\")]\n\t\t\tModified,\n\t\t\t[Description(\"DocumentGenerationConfigDeleted\")]\n\t\t\tDeleted\n\t\t}\n\n\t\tpublic enum CustomRuleEventType\n\t\t{\n\t\t\t[Description(\"\")]\n\t\t\tUndefined = -1,\n\t\t\t[Description(\"Document Added\")]\n\t\t\tDocumentAdded = 0,\n\t\t\t[Description(\"Document Checked In\")]\n\t\t\tDocumentCheckedIn = 1,\n\t\t\t[Description(\"Document Entered Folder\")]\n\t\t\tEnteredFolder = 2,\n\t\t\t[Description(\"Attribute Group Assigned\")]\n\t\t\tAttributeGroupAssigned = 3,\n\t\t\t[Description(\"Document Indexed\")]\n\t\t\tAttributeValueChanged = 4,\n\n\t\t\t[Description(\"Chained\")]\n\t\t\tChained = 6,\n\n\t\t\t[Description(\"Outbound Fax Delivery\")]\n\t\t\tFaxDelivery = 7,\n\t\t\t[Description(\"Document Reminder Processed\")]\n\t\t\tDocumentReminderProcessed = 8,\n\t\t\t[Description(\"Document Deleted\")]\n\t\t\tDocumentDeleted = 9,\n\n\t\t\t[Description(\"Folder Created\")]\n\t\t\tFolderCreated = 2000,\n\t\t\t[Description(\"Folder Entered Folder\")]\n\t\t\tFolderEnteredFolder = 2001,\n\n\t\t\t[Description(\"Document Obligation Extraction\")]\n\t\t\tDocumentObligationExtractionEvent = 3000,\n\t\t}\n\n\t\t// The enum declared name must match the name of the class that implements it\n\t\tpublic enum CustomRuleActionType\n\t\t{\n\t\t\t[Description(\"\")]\n\t\t\tUndefined = -1,\n\n\t\t\t[Description(\"Move Document\")]\n\t\t\tMoveDocument = 0,\n\t\t\t[Description(\"Start Workflow\")]\n\t\t\tStartWorkflow = 1,\n\t\t\t[Description(\"Assign Attribute Group\")]\n\t\t\tSetAttributeGroup = 2,\n\t\t\t[Description(\"Assign Attribute Value\")]\n\t\t\tSetAttributeValue = 3,\n\t\t\t[Description(\"Send Email\")]\n\t\t\tSendEmail = 4,\n\t\t\t[Description(\"Bulk Attribute Import\")]\n\t\t\tBulkMetadataImport = 5,\n\t\t\t[Description(\"Start Approval Template\")]\n\t\t\tStartApprovalTemplate = 6,\n\t\t\t[Description(\"Notify Web Service\")]\n\t\t\tNotifyWebService = 7,\n\t\t\t//[Description(\"Make Record\")]\n\t\t\t//MakeRecord = 8,\n\t\t\t[Description(\"Move To Trash\")]\n\t\t\tDeleteDocument = 9,\n\t\t\t[Description(\"Send Report\")]\n\t\t\tSendReport = 10,\n\t\t\t[Description(\"Set Security\")]\n\t\t\tSetSecurity = 11,\n\t\t\t[Description(\"Create Folder\")]\n\t\t\tCreateFolder = 12,\n\t\t\t[Description(\"Bulk Import Users\")]\n\t\t\tUserSyncFromFile = 13,\n\t\t\t[Description(\"Update Description\")]\n\t\t\tUpdateDescription = 14,\n\t\t\t[Description(\"Rename\")]\n\t\t\tRename = 15,\n\t\t\t[Description(\"Copy Document\")]\n\t\t\tCopyDocument = 16,\n\t\t\t[Description(\"Run Rule\")]\n\t\t\tRunRule = 17,\n\t\t\t[Description(\"Send Chatter Post\")]\n\t\t\tSendChatterPost = 18,\n\t\t\t[Description(\"Schedule Document Reminder\")]\n\t\t\tScheduleReminder = 19,\n\t\t\t[Description(\"Deliver Report to Folder\")]\n\t\t\tDeliverReportToFolder = 20,\n\t\t\t[Description(\"Bulk User Update\")]\n\t\t\tLimitedUserSyncFromFile = 21,\n\n\t\t\t[Description(\"Rename\")]\n\t\t\tRenameFolder = 2000,\n\t\t\t[Description(\"Move Folder\")]\n\t\t\tMoveFolder = 2001,\n\t\t}\n\n\t\t// The enum declared name must match the name of the class that implements it\n\t\tpublic enum CustomRuleFilterType\n\t\t{\n\t\t\t[Description(\"\")]\n\t\t\tUndefined = -1,\n\n\t\t\t[Description(\"In Folder\")]\n\t\t\tInFolder = 0,\n\t\t\t[Description(\"In Subfolder\")]\n\t\t\tInSubfolder = 1,\n\t\t\t[Description(\"Upload Source\")]\n\t\t\tUploadSource = 2,\n\t\t\t[Description(\"Has Attribute Group\")]\n\t\t\tHasAttributeGroup = 3,\n\t\t\t[Description(\"Has Attribute Value\")]\n\t\t\tHasAttributeValue = 4,\n\t\t\t[Description(\"Has Name Like\")]\n\t\t\tHasNameLike = 5,\n\t\t\t[Description(\"Changed Attribute Field\")]\n\t\t\tChangedAttributeField = 6,\n\t\t\t[Description(\"Assigned Group\")]\n\t\t\tAssignedGroup = 7,\n\t\t\t[Description(\"Fax Delivery Status\")]\n\t\t\tFaxDeliveryStatus = 8\n\t\t}\n\n\t\tpublic enum CustomRuleLogStatus\n\t\t{\n\t\t\t[Description(\"Error\")]\n\t\t\tError = -1,\n\t\t\t[Description(\"Success\")]\n\t\t\tSuccess = 0,\n\t\t\t[Description(\"Warning\")]\n\t\t\tWarning = 1,\n\t\t}\n\n\t\tpublic enum CustomActionType\n\t\t{\n\t\t\tUrl = 1,\n\t\t\tForm = 2,\n\t\t\tWorkflow = 3,\n\t\t\tDocLauncher = 4\n\t\t}\n\n\t\tpublic enum APIClientType\n\t\t{\n\t\t\t[Description(\"Webserver\")]\n\t\t\tWebserver = 0,\n\t\t\t[Description(\"User-agent\")]\n\t\t\tUseragent = 1,\n\t\t\t[Description(\"Client Credentials - API Users\")]\n\t\t\tClientCredentials = 2\n\t\t}\n\n\t\tpublic enum CoilSprocketType\n\t\t{\n\t\t\t//TrackingList = 1, //unused, retain to prevent value reuse.\n\t\t\tPreview = 2,\n\t\t\tWatchlist = 3,\n\t\t\tFolderWatchlist = 4,\n\t\t\tFolder = 5,\n\t\t\tWorkflowInbox = 6,\n\t\t\tRecentDocuments = 7,\n\t\t\tWorkflowQueue = 8,\n\t\t\tReport = 9,\n\t\t\tLegacyReport = 10,\n\t\t\tSavedSearch = 11\n\t\t}\n\n\t\tpublic enum CompareTrackedContentTaskInitiateResult\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tSubmitted = 1,\n\t\t\tComparisionTypeNotSupported = 2,\n\t\t\tDocumentToCompareNotFound = 3,\n\t\t\tSourceDocumentFormatNotSupported = 4,\n\t\t\tDocumentToCompareFormatNotSupported = 5\n\t\t}\n\n\t\tpublic enum CompareTrackedContentTaskProcessingStatus\n\t\t{\n\t\t\tDocumentCorrupt = -6,\n\t\t\tDocumentToCompareNotSupportedFormat = -5,\n\t\t\tDocumentToCompareNotFound = -4,\n\t\t\tOriginalDocumentNotSupportedFormat = -3,\n\t\t\tOriginalDocumentNotFound = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tNoTrackedContentFound = 2,\n\t\t}\n\n\t\t#endregion\n\t\t#region D\n\n\t\tpublic enum DashboardGridInterval\n\t\t{\n\t\t\tLastLogin,\n\t\t\tToday,\n\t\t\tYesterday,\n\t\t\tThisWeek,\n\t\t\tLastWeek,\n\t\t\tTwoWeeks,\n\t\t\tThisMonth,\n\t\t\tLast30\n\t\t}\n\n\t\tpublic enum DashboardLayout\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tOneColumn = 1,\n\t\t\tTwoColumns = 2,\n\t\t\tThreeColumns = 3,\n\t\t\tOneThirdTwoThirds = 4,\n\t\t\tTwoThirdsOneThird = 5,\n\t\t\tDynamic = 6 //aka Coil, used on Command Center Dashboard\n\t\t}\n\n\t\tpublic enum DashboardViewerType\n\t\t{\n\t\t\tAccount = 0,\n\t\t\tPersona = 1,\n\t\t\tUser = 2,\n\t\t\tMultiple = 99\n\t\t}\n\n\t\t//TODO This should be replaced by a registry of valid widget types.\n\t\tpublic enum DashboardWidgetType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tAlerts,\n\t\t\tLiteral,\n\t\t\tMessages,\n\t\t\tRecentDocuments,\n\t\t\tReport,\n\t\t\tWorkflowInbox,\n\t\t\tChart,\n\t\t\tFolderViewer\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum DataType\n\t\t{\n\t\t\t[Description(\"Text\")]\n\t\t\tString = 0,\n\t\t\t[Description(\"Number\")]\n\t\t\tNumber = 1,     // integers\n\t\t\t[Description(\"Date\")]\n\t\t\tDate = 2,\n\t\t\t[Description(\"Selection\")]\n\t\t\tDropDown = 3,   // for strings only\n\t\t\t[Description(\"Decimal\")]\n\t\t\tDecimal = 4,     // fixed decimal point, 2 decimal places.\n\t\t\t[Description(\"Dynamic Drop Down\")]\n\t\t\tMagicDropDown = 5,\n\t\t\t[Description(\"Cascade\")]\n\t\t\tCascade = 6,\n\t\t\t[Description(\"Auto Number\")]\n\t\t\tAutoNumber = 7,\n\t\t\t[Description(\"Users and Groups\")]\n\t\t\tActor = 8, // user or group\n\t\t\t[Description(\"Duration\")]\n\t\t\tDuration = 9,\n\t\t\t[Description(\"Currency\")]\n\t\t\tCurrency = 10,\n\t\t\t[Description(\"Boolean\")]\n\t\t\tBoolean = 11,\n\t\t}\n\n\t\tpublic enum DataReconciliationMode\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tSalesForce = 1,\n\t\t\tAttributeAutofill = 2\n\t\t}\n\n\t\tpublic enum DataReviewFieldType\n\t\t{\n\t\t\tField = 0,\n\t\t\tSet = 1\n\t\t}\n\n\t\tpublic enum DataReviewFuzzyMatcherMatchType\n\t\t{\n\t\t\tNotAMatch = 0,\n\t\t\tFuzzyMatch = 1,\n\t\t\tContains = 2,\n\t\t\tStartsWith = 3,\n\t\t\tExactMatch = 4,\n\t\t\tSentenceLevel = 5\n\t\t}\n\n\t\tpublic enum DataReviewObjectType\n\t\t{\n\t\t\tCLMCustomMetadataAttribute,\n\t\t\tStandardFields\n\t\t}\n\n\t\tpublic enum DateInterval\n\t\t{\n\t\t\t[Description(\"d\")]\n\t\t\tDay = 0,\n\t\t\t[Description(\"w\")]\n\t\t\tWeek = 1,\n\t\t\t[Description(\"m\")]\n\t\t\tMonth = 2,\n\t\t\t[Description(\"y\")]\n\t\t\tYear = 3\n\t\t}\n\n\t\tpublic enum NoticePeriodTimeUnit\n\t\t{\n\t\t\tDay = 1,\n\t\t\tWeek = 2,\n\t\t\tMonth = 3,\n\t\t\tYear = 4\n\t\t}\n\n\t\tpublic enum DayOfWeek\n\t\t{\n\t\t\t[Description(\"Sunday\")]\n\t\t\tSunday = 0,\n\t\t\t[Description(\"Monday\")]\n\t\t\tMonday = 1,\n\t\t\t[Description(\"Tuesday\")]\n\t\t\tTuesday = 2,\n\t\t\t[Description(\"Wednesday\")]\n\t\t\tWednesday = 3,\n\t\t\t[Description(\"Thursday\")]\n\t\t\tThursday = 4,\n\t\t\t[Description(\"Friday\")]\n\t\t\tFriday = 5,\n\t\t\t[Description(\"Saturday\")]\n\t\t\tSaturday = 6\n\t\t}\n\n\t\t[JsonConverter(typeof(StringEnumConverter))]\n\t\tpublic enum DocGenFieldType\n\t\t{\n\t\t\tBoolean = 0,\n\t\t\tText = 1,\n\t\t\tLongText = 2,\n\t\t\tRichText = 3,\n\t\t\tNumber = 4,\n\t\t\tCurrency = 5,\n\t\t\tDate = 6,\n\t\t\tCollection = 7,\n\t\t\tSignature = 8,\n\t\t\tAttachment = 9,\n\t\t\tCheckbox = 10,\n\t\t\tRadioButtons = 11,\n\t\t\tDropdown = 12 ,\n\t\t\tMultiSelectDropdown = 13\n\t\t}\n\n\t\tpublic enum DocumentSelectionType\n\t\t{\n\t\t\tAll = 0,\n\t\t\tHighlight = 1,\n\t\t\tComment = 2,\n\t\t\tSeal = 3,\n\t\t\tTrackedContent = 4,\n\t\t\tScorecard = 5,\n\t\t\tObligation = 6,\n\t\t\tAIS = 7,\n\t\t\tAPR = 8\n\t\t}\n\n\t\tpublic enum DocuSignResourceTokenResourcesType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tSfCommunityUser = 1,\n\t\t\tDelegateAccess = 2\n\t\t}\n\n\t\tpublic enum DeleteDocumentReminderStatus\n\t\t{\n\t\t\tDocumentIsTrashed = -3,\n\t\t\tNotAuthorizedWriteDocument = -2,\n\t\t\tNotAuthorizedReadDocument = -1,\n\t\t\tSuccess = 0,\n\t\t}\n\n\t\tpublic enum DeleteAIObjectMappingResultStatus\n\t\t{\n\t\t\tStandardAttributesGroupCannotBeDeleted = -3,\n\t\t\tRulesConfigInUse = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum SaveTermStatus\n\t\t{\n\t\t\tFolderUidNotSpecified = -14,\n\t\t\tTermDocumentCheckedOutBySomeoneElse = -12,\n\t\t\tExceededCharacterLimitForDescription = -11,\n\t\t\tExceededCharacterLimitForTermName = -10,\n\t\t\tExceededCharacterLimitForNotes = -9,\n\t\t\tUnauthorized = -8,\n\t\t\tTermOptionNameCannotBeBlank = -7,\n\t\t\tTermNameIsInvalid = -6,\n\t\t\tTermNameCannotBeBlank = -5,\n\t\t\tExceededFileSizeLimit = -4,\n\t\t\tDuplicateOptionName = -3,\n\t\t\tExceededCharacterLimitForOption = -2,\n\t\t\tUnknown = -1,\n\t\t\tSuccess = 0,\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum DeliveryPrefsFlags\n\t\t{\n\t\t\tNone = 0x0000,\n\t\t\tSecure = 0x0001,\n\t\t\tEmailPDF = 0x0002,\n\t\t\tEbinder = 0x0004, /* Obsolete */\n\t\t\tEmailNative = 0x0008,\n\t\t\tMail = 0x0010,\n\t\t\tFax = 0x0020,\n\t\t\tPrint = 0x0040,\n\t\t\tAll = Secure | EmailPDF | EmailNative | Mail | Fax | Print\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enumeration for Delivery Status in the adexs system\n\t\t/// </summary>\n\t\tpublic enum DeliveryStatus : short\n\t\t{\n\t\t\t[Description(\"Failed\")]\n\t\t\tFailed = -1,\n\t\t\t[Description(\"Unknown\")]\n\t\t\tUnknown = 0,\n\t\t\t[Description(\"In Progress\")]\n\t\t\tInprogress = 1,\n\t\t\t[Description(\"Success\")]\n\t\t\tSuccessful = 2,\n\t\t\t[Description(\"None\")]\n\t\t\tNone = 3,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enumeration for Delivery Types in the adexs system\n\t\t/// </summary>\n\t\tpublic enum DeliveryType\n\t\t{\n\t\t\t[Description(\"Unset\")]\n\t\t\tUnset = 0,\n\t\t\t[Description(\"Email PDF\")]\n\t\t\tEmailPDF = 1,\n\t\t\tMail = 2,\t// No longer used\n\t\t\t[Description(\"Fax\")]\n\t\t\tFax = 3,\n\t\t\tPrint = 4, // Not used in Atlas.\n\t\t\t/* Obsoleted eBinder = 5 , // This really means online.  Maybe we should change it someday.  2.0 terminology. */\n\t\t\t[Description(\"Email Native\")]\n\t\t\tEmailNative = 6,\n\t\t\t[Description(\"Email Native External\")]\n\t\t\tEmailNativeExternal = 7,\n\t\t\t[Description(\"Email Native and PDF\")]\n\t\t\tEmailNativeAndPdf = 8,\n\t\t}\n\t\tpublic enum DeleteRulesConfigAndMappingStatus\n\t\t{\n\t\t\tRulesConfigNotFound = -3,\n\t\t\tRulesConfigInUse = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum DigitGroupingStyle\n\t\t{\n\t\t\tAny = 0,\n\t\t\tCLM = 1,\n\t\t\tUpload = 2\n\t\t}\n\n\t\tpublic enum DistributionGroupCreationMode\n\t\t{\n\t\t\tUnknown = -1,\n\t\t\tNormal = 0,\n\t\t\tFolderSecurity\n\t\t}\n\n\t\tpublic enum DocToPdfConverterType\n\t\t{\n\t\t\tMicrosoftOffice = 0,\n\t\t\tLibreOffice = 1,\n\t\t\tAsposeNet = 2\n\t\t}\n\n\t\tpublic enum DocHistoryReportBucketType\n\t\t{\n\t\t\tMonthAndYear,\n\t\t\tTenDaysPeriod,\n\t\t\tDayOfTheYear\n\t\t}\n\n\t\tpublic enum DocHistoryReportSaveType\n\t\t{\n\t\t\tSpark,\n\t\t\tCassandra\n\t\t}\n\n\t\tpublic enum DocumentEmailStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tNotSent = 0,\n\t\t\tSent = 1\n\t\t}\n\n\t\tpublic enum DocumentAssemblyFollowupAction\n\t\t{\n\t\t\tNone = 0,\n\t\t\tWorkflow = 1,\n\t\t\tHumanActivityStep = 2\n\t\t}\n\n\t\tpublic enum DocumentBuilderOutputType\n\t\t{\n\t\t\tPdf = 0,\n\t\t\tDocx = 1\n\t\t}\n\n\t\tpublic enum DocumentLauncherLocation\n\t\t{\n\t\t\tDefault = 0,\n\t\t\t[Description(\"Salesforce\")]\n\t\t\tSalesforce = 1,\n\t\t\t[Description(\"SpringCM\")]\n\t\t\tSpringCM = 2\n\t\t}\n\n\t\tpublic enum DataTargetProviderType\n\t\t{\n\t\t\tCLM = 0,\n\t\t\tSalesforce = 1\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum DocumentBuilderDocsToSave\n\t\t{\n\t\t\tNotSpecified = 0x0, // default value\n\t\t\tMergedDocuments = 0x1,\n\t\t\tCombinedDocument = 0x2,\n\t\t\tAll = 0x3\n\t\t}\n\n\t\tpublic enum DocuSignSyncOperation\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\t[Description(\"Insert\")]\n\t\t\tI = 1,\n\t\t\t[Description(\"Update\")]\n\t\t\tU = 2,\n\t\t\t[Description(\"Delete\")]\n\t\t\tD = 3\n\t\t}\n\n\t\tpublic enum DocuSignNdnsSyncOperation\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tCreate = 1,\n\t\t\tUpdate = 2,\n\t\t\tDelete = 3\n\t\t}\n\n\t\tpublic enum DocuSignNdnsSyncEventType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tDSGroup = 1,\n\t\t\tDSGroupUsers = 2\n\t\t}\n\n\t\tpublic enum CompareProvider\n\t\t{\n\t\t\tOffice = 1,\n\t\t\tAspose = 2\n\t\t}\n\n\t\tpublic enum CompareDocumentTypes\n\t\t{\n\t\t\tNone = 0,\n\t\t\tWord = 1,\n\t\t\tAll = 99\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum DocumentCompareSettings\n\t\t{\n\t\t\t[Description(\"None\")]\n\t\t\tNone = 0x00,\n\t\t\t[Description(\"Compare formatting\")]\n\t\t\tCompareFormatting = 0x01,\n\t\t\t[Description(\"Compare comments\")]\n\t\t\tCompareComments = 0x02,\n\t\t\t[Description(\"Compare headers/footers\")]\n\t\t\tCompareHeadersFooters = 0x04,\n\t\t\t[Description(\"Show text moves\")]\n\t\t\tShowTextMoves = 0x08,\n\t\t\t[Description(\"Show summary\")]\n\t\t\tShowSummary = 0x10,\n\t\t\t[Description(\"Show speaker notes\")]\n\t\t\tCompareSpeakerNotes = 0x20,\n\t\t\t[Description(\"Compare images\")]\n\t\t\tCompareImages = 0x40,\n\t\t\t[Description(\"All Word Processor\")]\n\t\t\tAllWordProcessor = CompareFormatting | CompareComments | CompareHeadersFooters | ShowTextMoves | ShowSummary\n\t\t}\n\n\t\tpublic enum DocumentCompareSpreadsheetImagesCodes\n\t\t{\n\t\t\tDoNotCompare = 0,\n\t\t\tCompare = 1,\n\t\t\tRemoveFromFiles = 2,\n\t\t\tCompareShowingInsertsDeletesOnly = 3\n\t\t}\n\n\t\t/// <summary>\n\t\t///\n\t\t/// </summary>\n\t\tpublic enum DocumentCompareResultType\n\t\t{\n\t\t\tNewDocument = 0,\n\t\t\tVersionOriginalDocument = 1,\n\t\t\tAdHoc = 2\n\t\t}\n\n\t\tpublic enum DocumentCompareSourceType\n\t\t{\n\t\t\t[Description(\"First\")]\n\t\t\tOriginal = 0,\n\t\t\t[Description(\"Previous\")]\n\t\t\tLatest = 1\n\t\t}\n\n\t\tpublic enum DocumentLinkAction\n\t\t{\n\t\t\tDownload,\n\t\t\tEdit,\n\t\t\tExplore, //Explore is the same as Edit but proiritizes DocExplorer over Preview instead of vice versa\n\t\t\tSForce,\n\t\t\tPopupWindow,\n\t\t\tPublicDownload,\n\t\t\tNone\n\t\t};\n\n\t\t/// <summary>\n\t\t/// Type of document list\n\t\t/// </summary>\n\t\tpublic enum DocumentListType\n\t\t{\n\t\t\tUpload,\n\t\t\tConfirmReceipt,\n\t\t\tConfirmUpload,\n\t\t\tQuery\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum DocumentLauncherFieldType\n\t\t{\n\t\t\tAny = 0,\n\t\t\tText = 1,\n\t\t\tDate = 2,\n\t\t\tCurrency = 4,\n\t\t\tNumber = 8,\n\t\t\tPickList = 17, //we want picklist to show up if we are looking for text, but not the other way around\n\t\t\tMultiSelectPickLst = 33,  //we want MultiSelectPickLst to show up if we are looking for text, but not the other way around\n\t\t\tAll = -1\n\t\t}\n\n\t\tpublic enum DocumentLauncherInputFieldType\n\t\t{\n\t\t\tText = 1,\n\t\t\tDate = 2,\n\t\t\tNumber = 3,\n\t\t\tDropdown = 4,\n\t\t\tCheckbox = 5,\n\t\t\tTextArea = 6,\n\t\t\tMultiSelectDropdown = 7\n\t\t}\n\n\t\tpublic enum DocumentMatchType\n\t\t{\n\t\t\t[Description(\"None\")]\n\t\t\tNone,\n\t\t\t[Description(\"Metadata\")]\n\t\t\tMetadata,\n\t\t\t[Description(\"Name\")]\n\t\t\tName,\n\t\t\t[Description(\"Manual\")]\n\t\t\tManual,\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum DocumentPermissionsFlags\n\t\t{\n\t\t\tNone = 0,\n\t\t\tPDFPrintAndSave = 1,\n\t\t\tPDFCopyAndSave = 2,\n\t\t\tForward = 4,\n\t\t\tAll = -1, // All bits set\n\n\t\t\tDummy1 = 3, // our persistence layer is kind of crappy here;\n\t\t\tDummy2 = 5, // it doesn't properly know how to handle flags\n\t\t\tDummy3 = 6, // enums; hence these fake values\n\t\t\tDummy4 = 7\n\t\t}\n\n\t\tpublic enum DocumentReceivedMethod\n\t\t{\n\t\t\tInboundFax = 0,\n\t\t\tInboundEmail = 1,\n\t\t\tPublish = 2,\n\t\t\tSharedFolder = 3\n\t\t}\n\n\t\t//Leave the actionscope as None unless user has completed the step\n\t\tpublic enum DocumentScopeActorAction\n\t\t{\n\t\t\tNone = 0,\n\t\t\tCompleted = 1,\n\t\t\t//Used explicitly when user is reassigned\n\t\t\tReAssigned = 2,\n\t\t\t//Used explicitly for unassigning the user from the interface\n\t\t\tUnAssigned = 3\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Stores document search information.\n\t\t/// There are three types of searches:\n\t\t/// 1) Show all documents (minus those deleted, in trash, or expired)\n\t\t/// 2) Show all documents in a folder (minus those deleted or expired)\n\t\t/// 3) Show all documents from a search (minus those deleted or expired)\n\t\t/// This holds the criteria used to do one of those searches.  Additionally, it\n\t\t/// either holds the results, or can fetch them.\n\t\t/// </summary>\n\t\tpublic enum DocumentSearchQuerySource\n\t\t{\n\t\t\tBrowse,\t\t\t\t// Browsing folders\n\t\t\tAdvancedSearch,\t\t// Advanced search\n\t\t\tBasicSearch,\t\t// Basic search\n\t\t}\n\n\t\tpublic enum DocumentStatus\n\t\t{\n\n\t\t\t[Description(\"Active\")]\n\t\t\tDefault = 0,\n\t\t\t[Description(\"Deleted\")]\n\t\t\tDeleted = -1, // Indicates the that document has been deleted marked as deleted\n\t\t\t[Description(\"Revised\")]\n\t\t\tRevised = -3, // The document has been superseded by another\n\t\t\t//[Description(\"Marked as record\")]\n\t\t\t//MarkedAsRecord = -10,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Defines the error types for the document log.\n\t\t/// </summary>\n\t\tpublic enum DocumentLogErrorType\n\t\t{\n\t\t\tNone = 0,\n\t\t\tUpload = 1,\n\t\t\tReceive = 2,\n\t\t\tUnbundle = 3,\n\t\t\tConvert = 4,\n\t\t\tRepository = 5,\n\t\t\tInsert = 6,\n\t\t\tIndex = 7,\n\t\t\tOCR = 8\n\t\t}\n\n\t\tpublic enum DueDateRange\n\t\t{\n\t\t\t[Enums.StringValue(\"all\")]\n\t\t\tAll = 0,\n\t\t\t[Enums.StringValue(\"none\")]\n\t\t\tNone = 1,\n\t\t\t[Enums.StringValue(\"today\")]\n\t\t\tToday = 2,\n\t\t\t[Enums.StringValue(\"tomorrow\")]\n\t\t\tTomorrow = 3,\n\t\t\t[Enums.StringValue(\"future\")]\n\t\t\tFuture = 4,\n\t\t}\n\n\t\tpublic enum DuplicateHandling\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tAllow = 1,\n\t\t\tRename = 2,\n\t\t\tFail = 3,\n\t\t\tUpdateNoDuplicateCheck = 4\n\t\t}\n\n\t\tpublic enum DocuSignSfUserStatus\n\t\t{\n\t\t\tInactive,\n\t\t\tPending,\n\t\t\tActive\n\t\t}\n\n\t\t#endregion\n\t\t#region E\n\t\t[EnumJavaScriptResourceAttribute(false)]\n\t\tpublic enum ElectronicSignatureIntegrationType\n\t\t{\n\t\t\tNone = 0,\n\t\t\tMasterEchosignAccount = 1, // this is SpringCM's internal echosign account. we get billed for this.\n\t\t\tExternalEchosignAccount = 2, // this is to be used if they have an external echosign account.  we do not get billed for this.\n\t\t\tExternalDocuSignAccount = 3,\n\t\t\tExternalESignLiveAccount = 4,\n\t\t\tExternalProntoSignAccount = 5, // AlphaTrust's PRONTOSign\n\t\t\tDocuSignCLMAccount = 6\n\t\t}\n\n\t\tpublic enum ElectronicSignatureProvider\n\t\t{\n\t\t\tNone = 0,\n\t\t\tEchoSign = 1,\n\t\t\tDocuSign = 2,\n\t\t\tESignLive = 3,\n\t\t\tProntoSign = 4\n\t\t}\n\n\t\tpublic enum ESignatureCancelMessageEmailType\n\t\t{\n\t\t\tSendCancelled = 0,\n\t\t\tSentOnDifferentProvider = 1,\n\t\t\tSendAlreadyCompleted = 2\n\t\t}\n\n\t\tpublic enum ESignatureTransactionNotSignedEmailType\n\t\t{\n\t\t\tCancelled = 0,\n\t\t\tTimedOut = 1,\n\t\t\tRejected = 2,\n\t\t\tFailed = 3,\n\t\t\tCancelFailed = 4\n\t\t}\n\n\t\t/*\n\t\t * ATL-41097 - Move from ADEXS.ElectronicSignature.DomainModel.Enums\n\t\t */\n\t\tpublic enum ESignatureTaskAction\n\t\t{\n\t\t\tNone = 0,\n\t\t\tSend = 1,\n\t\t\tReminder = 2,\n\t\t\tRefresh = 3,\n\t\t\tPreviewCancel = 4,\n\t\t\tBulkRefresh = 5\n\t\t}\n\n\t\t/*\n\t\t * ATL-41097 - Move from ADEXS.ElectronicSignature.DomainModel.Enums\n\t\t */\n\t\tpublic enum ESignatureUserTaskAction\n\t\t{\n\t\t\tNone = 0,\n\t\t\tRetrieveAuditDocument = 1,\n\t\t\tCancel = 2,\n\t\t}\n\n\t\tpublic enum ErrorPageCodes\n\t\t{\n\t\t\t//One = 1,\n\t\t\t//Two = 2,\n\t\t\tSFBadLogin = 3,\n\t\t}\n\n\t\tpublic enum EtlType\n\t\t{\n\t\t\tNotSet = 0,\n\t\t\tAddressBook = 1,\n\t\t\tSmartRule = 2,\n\t\t\tSFDC = 3,\n\t\t\tDocuSign = 4,\n\t\t\tContact = 5,\n\t\t\tParties = 6,\n\t\t\tAttributes = 7\n\t\t}\n\n\t\tpublic enum ExtractFormOCRStatus\n\t\t{\n\t\t\tNotSet = 0,\n\t\t\tFailure = -1,\n\t\t\tSuccess = 1,\n\t\t\tPartialSuccess = 2,        // not all of the fields in the template were returned\n\t\t}\n\n\t\tpublic enum ExtractionsDataType\n\t\t{\n\t\t\tString = 0,\n\t\t\tDate = 1,\n\t\t\tInteger = 2,\n\t\t\tDouble = 3,\n\t\t\tBoolean = 4,\n\t\t\tDuration = 5,\n\t\t\tCurrency = 6,\n\t\t}\n\n\t\tpublic enum ExtractStatus\n\t\t{\n\t\t\tFailedToSaveDocument = -4,\n\t\t\tOcrExpired = -3, // Set when ABBYY complains that the number of pages has been exceeded.\n\t\t\tDeleted = -2,\n\t\t\tError = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1,\n\t\t\tSuccessNoContent = 2, // Binary converter\n\t\t\tSuccessOcrNoContent = 3, // Converted via OCR, but found no content.  If this is set, it's an indication that the file is not OCRable.\n\t\t\tSuccessOcr = 4, // Converted via OCR\n\t\t\tPendingFormOCR = 5, // Item back into the queue pending processing by a form OCR capable service\n\t\t\tPendingRegularOCR = 6,\n\t\t\tPendingPDFRendition = 7,\n\t\t\tNoConfidenceOCR = 8,\n\t\t}\n\n\t\tpublic enum ExternalAccountFlag\n\t\t{\n\t\t\tNone = 0,\n\t\t\tSFIntegrated = 0x0001, // 2 ^ 0\n\n\t\t}\n\n\t\tpublic enum ExternalReviewStatus\n\t\t{\n\t\t\tSent = 0,\n\t\t\t//Approved = 1, decided not to have approved/rejected\n\t\t\t//Rejected = 2, decided not to have approved/rejected\n\t\t\tCanceled = 3,\n\t\t\tComplete = 4,\n\t\t\tExpired = 5,\n\t\t\tError = 6,\n\t\t\tEmailBounced = 8,\n\t\t\tPreparing = 9, // used by workflow when the External Review is set up but has not yet been sent for the recipient\n\t\t\tPreparationComplete = 10,\n\t\t\tPendingManualDocumentMatching = 11, // used when reviewer emails back attachments but the system cannot map them to the appropriate document\n\t\t\tPendingEmailApproval = 12 // used while waiting for the xr recipient to approve/reject an unknown email address.\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum EmailAppearance\n\t\t{\n\t\t\tHtml = 0,\n\t\t\tPlainText = 1,\n\t\t\tDocuSignBranded = 2\n\t\t}\n\n\t\tpublic enum ExternalReviewEvent\n\t\t{\n\t\t\t[Description(\"XrSent\")]\n\t\t\tSent = 0,\n\t\t\t[Description(\"XrResent\")]\n\t\t\tResent = 1,\n\t\t\t[Description(\"XrCanceled\")]\n\t\t\tCanceled = 2,\n\t\t\t[Description(\"XrExpired\")]\n\t\t\tExpired = 3,\n\t\t\t[Description(\"XrMatchFailed\")]\n\t\t\tMatchFailed = 4,\n\t\t\t[Description(\"XrCompleted\")]\n\t\t\tCompleted = 5,\n\t\t\t[Description(\"ErrorEmailSent\")]\n\t\t\tErrorEmailSent = 6,\n\t\t\t[Description(\"ConfirmationEmailSent\")]\n\t\t\tConfirmationEmailSent = 7,\n\t\t\t[Description(\"EmailApproved\")]\n\t\t\tEmailApproved = 8\n\t\t}\n\n\t\tpublic enum ExternalReviewCompleteUserType\n\t\t{\n\t\t\t[Description(\"Internal\")]\n\t\t\tInternal,\n\t\t\t[Description(\"Receiver\")]\n\t\t\tReceiver,\n\t\t\t[Description(\"ThirdParty\")]\n\t\t\tThirdParty,\n\t\t}\n\n\t\tpublic enum ExternalReviewCancelReason\n\t\t{\n\t\t\t[Description(\"UserCancelled\")]\n\t\t\tUserCancelled,\n\t\t\t[Description(\"Security\")]\n\t\t\tSecurity,\n\t\t\t[Description(\"UnknownEmailRejected\")]\n\t\t\tUnknownEmailRejected\n\t\t}\n\t\tpublic enum ExternalReviewSource\n\t\t{\n\t\t\t[Description(\"Manual\")]\n\t\t\tManual,\n\t\t\t[Description(\"WF Send for XR\")]\n\t\t\tSendForXrWorkflow,\n\t\t\t[Description(\"WF Review & Send for XR\")]\n\t\t\tReviewAndSendForXrWorkflow,\n\t\t\t[Description(\"Public API\")]\n\t\t\tPublicApi\n\t\t}\n\t\tpublic enum ExternalReviewReturnMethod\n\t\t{\n\t\t\t[Description(\"Upload/Link\")]\n\t\t\tUpload,\n\t\t\t[Description(\"Email\")]\n\t\t\tEmail,\n\t\t\t[Description(\"Public API\")]\n\t\t\tPublicApi\n\t\t}\n\n\t\tpublic enum ExternalReviewApprovedEmailDomainType\n\t\t{\n\t\t\tEmail = 0,\n\t\t\tDomain = 1\n\t\t}\n\n\t\tpublic enum ExternalReviewCompletionMethod\n\t\t{\n\t\t\t[Description(\"Auto-Match\")]\n\t\t\tAutoMatch,\n\t\t\t[Description(\"WebPortal\")]\n\t\t\tWebPortal,\n\t\t\t[Description(\"PublicAPI\")]\n\t\t\tPublicApi\n\t\t}\n\n\t\tpublic enum ExternalReviewOnBehalfCompleteDocHistoryLogType\n\t\t{\n\t\t\tNewDocument,\n\t\t\tNewAttachment,\n\t\t\tReplaceDocument\n\t\t}\n\n\t\tpublic enum EmailPayloadSuppressBranding\n\t\t{\n\t\t\tInheritAccountValue = 0,\n\t\t\tDisable = -1,\n\t\t\tEnable = 1\n\t\t}\n\n\t\tpublic enum EmailLayout\n\t\t{\n\t\t\tSpringCmLegacy = 0,\n\t\t\tPolaris = 1,\n\t\t}\n\n\n\t\tpublic enum EmailErrorMessageType\n\t\t{\n\t\t\tNone = 0,\n\t\t\tAttachmentTooLarge = 1,\n\t\t\tEmailTooLarge = 2\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Use Enums.GetName utility instead of to ToString() method when\n\t\t/// saving these values as the System value in the ExternalDataMap\n\t\t/// </summary>\n\t\tpublic enum ExternalSystemType\n\t\t{\n\t\t\t[Description(\"\")]\n\t\t\tUnknown = int.MinValue,\n\t\t\t[Description(\"SalesForce\")]\n\t\t\tSalesForce = 0, /*Sync User*/\n\t\t\t[Description(\"SalesforceRefreshToken\")]\n\t\t\tSalesforceRefreshToken = 1,\n\t\t\t[Description(\"TwoFactorAuthentication\")]\n\t\t\tTwoFactorAuthentication = 2,\n\t\t\t[Description(\"salesforce\")]\n\t\t\tSalesforceIdentity = 3,\n\t\t\t[Description(\"onelogin\")]\n\t\t\tOneLogin = 4,\n\t\t\t[Description(\"okta\")]\n\t\t\tOkta = 5,\n\t\t\t[Description(\"docusign\")]\n\t\t\tDocuSign = 6,\n\t\t\t[Description(\"Seal\")]\n\t\t\tSeal = 7,\n\t\t\t[Description(\"ClauseIORefreshToken\")]\n\t\t\tClauseIORefreshToken = 8,\n\t\t\t[Description(\"AgreementObjectModelApi\")]\n\t\t\tAgreementObjectModelApi = 9,\n\t\t\t[Description(\"ClmCMAccountUid\")]\n\t\t\tClmCMAccountUid = 10,\n\t\t\t[Description(\"MSFShardId\")]\n\t\t\tMSFShardId = 11\n\t\t}\n\n\t\tpublic enum ExternalSystemSaveDataStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tStarted = 1,\n\t\t\tProcessingSalesforce = 101,\n\t\t\tProcessingCLMAttributes = 102,\n\t\t\tCompleted = 200\n\t\t}\n\n\t\tpublic enum ExternalSystemGetDataStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tStarted = 1,\n\t\t\tProcessingSalesforce = 101,\n\t\t\tProcessingCLMAttributes = 102,\n\t\t\tCompleted = 200\n\t\t}\n\n\t\tpublic enum ExternalDataType\n\t\t{\n\t\t\tnone = 0,\n\t\t\taccount = 1,\n\t\t\texternalidentity = 2,\n\t\t\tExternalUserid = 3,\n\t\t\tExternalGroupid = 4,\n\t\t\tFileItSecret = 5,\n\t\t\tAuthData = 6\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enumeration for ExternalReviewReconciliationStatus.\n\t\t/// </summary>\n\t\tpublic enum ExternalReviewReconciliationStatus\n\t\t{\n\t\t\tValidationError = -1,\n\t\t\tUnknown = 0,\n\t\t\tAutoReconciled = 1,\n\t\t\tRequiresManualReconciliation = 2\n\t\t}\n\n\t\tpublic enum ExternalReviewReturnedEmailValidationStatus\n\t\t{\n\t\t\t[Description(\"Invalid Account\")]\n\t\t\tInvalidAccount,\n\t\t\t[Description(\"Invalid External Review\")]\n\t\t\tInvalidReview,\n\t\t\t[Description(\"Invalid User\")]\n\t\t\tInvalidUser,\n\t\t\t[Description(\"Cannot accept documents for this external review at this time\")]\n\t\t\tInvalidReviewStatus,\n\t\t\t[Description(\"Invalid Email Domain\")]\n\t\t\tInvalidEmailDomain,\n\t\t\t[Description(\"Invalid Access Key\")]\n\t\t\tInvalidAccessKey,\n\t\t\tSuccess,\n\t\t\t[Description(\"Insufficiant Account Storage Space Available\")]\n\t\t\tInvalidAccountStorageSpace,\n\t\t\t[Description(\"External Review email ingestion is not enabled for this account\")]\n\t\t\tEmailIngestionNotEnabled,\n\t\t\t[Description(\"Unknown Email Address\")]\n\t\t\tUnknownEmailDomain,\n\t\t}\n\t\t#endregion\n\t\t#region F\n\t\tpublic class FailureReason\n\t\t{\n\t\t\tpublic enum Base\n\t\t\t{\n\t\t\t\tUnset = 0,\t\t\t\t// Unset, of course.  This should never occur.\n\t\t\t\tException,\t\t\t\t// Some sort of exception -- nothing the user can really do about it\n\t\t\t\tExpiredTrial,\t\t\t// The user's trial account has expired\n\t\t\t\tFileTooLarge,\t\t\t// The user is not allowed to upload files this large.\n\t\t\t\tGuest,\t\t\t\t\t// The user is a guest (and thus cannot upload files)\n\t\t\t\tInsufficientSpace,\t\t// The user doesn't have sufficient space to upload this file (not currently used)\n\t\t\t\tInvalidCredentials,\t// The user failed to login with a valid username or password.\n\t\t\t\tInvalidDocument,\t\t// The document does not exist\n\t\t\t\tInvalidFolder,\t\t\t// The folder does not exist\n\t\t\t\tReadOnlyDocument,\t\t// The document exists, but is readonly\n\t\t\t\tReadOnlyFolder,\t\t// The folder exists, but is readonly\n\t\t\t\tResendChunk,\t\t\t// Part of the file needs to be resent.\n\t\t\t\tResendFile,\t\t\t// The entire file needs to be resent.\n\t\t\t\tTooManyFailures,\t\t// The server is aborting the upload because of too many failures\n\t\t\t\tTooManyFiles \t\t\t// The user has already uploaded too many files (not currently used)\n\t\t\t}\n\n\t\t\tpublic enum Legacy\n\t\t\t{\n\t\t\t\tUnset = 0,\t\t\t\t// Unset, of course.  This should never occur.\n\t\t\t\tException,\t\t\t\t// Some sort of exception -- nothing the user can really do about it\n\t\t\t\tExpiredTrial,\t\t\t// The user's trial account has expired\n\t\t\t\tFileTooLarge,\t\t\t// The user is not allowed to upload files this large.\n\t\t\t\tGuest,\t\t\t\t\t// The user is a guest (and thus cannot upload files)\n\t\t\t\tInsufficientSpace,\t\t// The user doesn't have sufficient space to upload this file (not currently used)\n\t\t\t\tInvalidCredentials,\t// The user failed to login with a valid username or password.\n\t\t\t\tResendChunk,\t\t\t// Part of the file needs to be resent.\n\t\t\t\tResendFile,\t\t\t// The entire file needs to be resent.\n\t\t\t\tTooManyFailures,\t\t// The server is aborting the upload because of too many failures\n\t\t\t\tTooManyFiles, \t\t\t// The user has already uploaded too many files (not currently used)\n\t\t\t\tNoPrivilege             // The user does not have enough privileges for the requested operation\n\t\t\t}\n\t\t}\n\n\t\tpublic enum FileDataStatus\n\t\t{\n\t\t\tDefault = 0,\n\t\t\tDeleted = -1, // Indicates the that file has been deleted from the SAN.\n\t\t\tMissing = -8\t// file was lost or quarentined\n\t\t}\n\n\t\tpublic enum FileMetaDataType\n\t\t{\n\t\t\tTrackedChangesStatus = 1,\n\t\t\tTrackedContentStatus = 2,\n\t\t\tGlyphExtractionStatus = 3,\n\t\t\tSealLabelExtractionStatus = 4,\n\t\t\tSealScorecardStatus = 5,\n\t\t\tAnalyzerDocumentStatus = 6,\n\t\t\tIntellegoExtractionStatus = 7,\n\t\t\tEncryptionStatus = 8,\n\t\t\tUnencryptedFileSize = 9,\n\t\t\tAPRExtractionStatus = 10,\n\t\t\tSearchablePdfGlyphExtractionStatus = 11,\n\t\t\tSearchablePdfStatus = 12,\n\t\t\tCommentsReconciliationCompleted = 13,\n\t\t\tAgreementSummaryStatus = 14,\n\t\t\tUnifiedRepositoryPermissionsIngestionStatus = 15,\n\t\t\tUnifiedRepositoryCustomAttributesIngestionStatus = 16,\n\t\t\tUnifiedRepositoryDocumentHistoryIngestionStatus = 17,\n\t\t\tUnifiedRepositoryIngestionCompletion = 18,\n\t\t\tUnifiedRepositoryDmsMetadataCreationStatus = 19,\n\t\t\tHasAttributeAiHistory = 20,\n\t\t\tHasAgreementSummaryAiHistory = 21\n\t\t}\n\n\t\tpublic enum AttributeFieldType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tBoolean = 1,\n\t\t\tText = 2,\n\t\t\tDate = 3,\n\t\t\tNumber = 4,\n\t\t\tDropDown = 5,\n\t\t\tDuration = 6,\n\t\t\tCurrency  = 7,\n\t\t\tDecimal = 8\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum FilterType : short\n\t\t{\n\t\t\t[Description(\"\")]\n\t\t\tInvalid = 0,\n\t\t\t[Description(\"Equals\")]\n\t\t\tEquals = 1,\n\t\t\t[Description(\"Greater Than\")]\n\t\t\tGreaterThan = 2,\n\t\t\t[Description(\"Less Than\")]\n\t\t\tLessThan = 3,\n\t\t\t[Description(\"Greater Than or Equal\")]\n\t\t\tGreaterThanEqual = 4,\n\t\t\t[Description(\"Less Than or Equal\")]\n\t\t\tLessThanEqual = 5,\n\t\t\t[Description(\"Contains\")]\n\t\t\tContains = 6,\n\t\t\t[Description(\"Not Equal\")]\n\t\t\tNotEquals = 7,\n\t\t\t[Description(\"Doesn't Contain\")]\n\t\t\tNotContains = 8,\n\t\t\t[Description(\"Range\")]\n\t\t\tRange = 9,\n\t\t\t[Description(\"Is Null\")]\n\t\t\tIsNull = 10,\n\t\t\t[Description(\"Is Not Null\")]\n\t\t\tIsNotNull = 11,\n\t\t\t[Description(\"In\")]\n\t\t\tIn = 12,\n\t\t\t[Description(\"Not in\")]\n\t\t\tNotIn = 13,\n\t\t}\n\n\t\tpublic enum FolderContainerStatus\n\t\t{\n\t\t\tNormal,\n\t\t\tOverFull,\n\t\t\tIgnored\n\t\t}\n\n\t\tpublic enum FolderCreationMode\n\t\t{\n\t\t\tUnknown,\n\t\t\tCreate,\n\t\t\tEdit\n\t\t}\n\n\t\tpublic enum FolderLinkAction\n\t\t{\n\t\t\tBrowseDocuments,\n\t\t\tPublicBrowseDocuments,\n\t\t\tAjaxNavigate,\n\t\t\tNone\n\t\t}\n\n\t\t[EnumJavaScriptResource(true)]\n\t\tpublic enum FormContainerEvents\n\t\t{\n\t\t\tUnknown = 0,\n\n\t\t\t// Error events\n\t\t\tError = -1,\n\n\t\t\t// Client-side events\n\t\t\tReady = 10,\n\t\t\tCancel = 11,\n\t\t\tSubmit = 12,\n\n\t\t\t// Postback events\n\t\t\tComplete = 20\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum FormTask\n\t\t{\n\t\t\tFillForm,\n\t\t\tEditForm,\n\t\t}\n\n\t\t#endregion\n\t\t#region G\n\n\t\tpublic enum GlyphExtractionStatus\n\t\t{\n\t\t\tExpired = -3,\n\t\t\tFailed = -2,\n\t\t\tNotApplicable = -1,\n\t\t\tNotExtracted = 0,\n\t\t\tExtracted = 1\n\t\t}\n\n\t\tpublic enum GetAIExtractionsServiceStatus\n\t\t{\n\t\t\tBatchNotFound = -7,\n\t\t\tLogicAppsNotCompletedAfterMaxRetries = -6,\n\t\t\tLogicAppsNotCompleted = -5,\n\t\t\tUnableToGetDocumentUid = -4,\n\t\t\tInvalidTransactionUid = -3,\n\t\t\tAuthenticationFailed = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tBatchInCancelledStatus = 2,\n\t\t}\n\n\t\tpublic enum GetAvailableModelsStatus\n\t\t{\n\t\t\tUnknownProviderType = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum GetObjectMappingDetailStatus\n\t\t{\n\t\t\tMappingNotFound = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum GetRulesConfigBasicDetailsStatus\n\t\t{\n\t\t\tRulesConfigNotFound = -3,\n\t\t\tRulesConfigUidIsEmpty = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum GetRulesConfigUsageAnalyticsStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum GetAttributeGroupsStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum GridSelectionType\n\t\t{\n\t\t\t// corresponds to the valid value for the grid 'selection-type'\n\t\t\tNone = 0,\n\t\t\tSingle = 1,\n\t\t\tMulti = 2\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum GroupType\n\t\t{\n\t\t\tWorkflowQueue = -4,\n\t\t\tUserAccount = -3,\n\t\t\tContact = -2,\t\t// types that are not exactly group types are less than zero\n\t\t\tUnknown = -1,       // these types are used in Atlas.Angular.325.doc-explorer-attributes-controller.js to map actor attribtue type\n\t\t\t[Description(\"Group\")]\n\t\t\tSecurity = 0,       // please keep in sync\n\t\t\t[Description(\"Mailing List\")]\n\t\t\tDistribution = 1,\n\t\t}\n\t\t#endregion\n\n\t\t#region H\n\n\t\tpublic enum HistoryFilter\n\t\t{\n\t\t\tAllHistory = 0,\n\t\t\tVersions = 1,\n\t\t\tPreviews = 2,\n\t\t\tMetadataChanges = 3,\n\t\t\tSignatures = 4,\n\t\t\tWorkflows = 5,\n\t\t\tLegalHolds = 6,\n\t\t\tDownloads = 7,\n\t\t\tEMailActivity = 8,\n\t\t\tDocumentActivity = 9,\n\t\t\tFaxActivity = 10,\n\t\t\tShareActivity = 11,\n\t\t\tDocumentReminders = 12,\n\t\t\tExternalReview = 13,\n\t\t\t//Folder filters: if you add more, make sure to exclude them from the dropdownlist in DocumentHistoryControl.ascx.cs\n\t\t\tFolderAttributeChanges = 14,\n\t\t\tFolderActivity = 15,\n\t\t\tFolderSecurity = 16,\n\t\t\tFolderShareActivity = 17,\n\t\t\tObligations = 18\n\t\t}\n\n\t\tpublic enum HistoryLinkType\n\t\t{\n\t\t\tNone,\n\t\t\tDocumentVersion,\n\t\t\tSourceDocument,\n\t\t\tTargetDocument,\n\t\t\tHistory,\n\t\t\tExitedWorkflow\n\t\t}\n\n\t\tpublic enum HistoryObjectType\n\t\t{\n\t\t\tFolder = 1,\n\t\t\tDocument = 2,\n\t\t\tReport = 3,\n\t\t\tAccount = 10,\n\t\t\tTest = -1\n\t\t}\n\n\t\tpublic enum HistoryMessageIdentifiers\n\t\t{\n\t\t\tAdded,\n\t\t\tAddedWorkflow,\n\t\t\tAllUsers,\n\t\t\tAppliedADigitalSignature,\n\t\t\tBy,\n\t\t\tCancelledMultiple,\n\t\t\tCancelledSingle,\n\t\t\tCheckoutDocument,\n\t\t\tCommentNoUserMultipleResult,\n\t\t\tCommentNoUserSingleResult,\n\t\t\tCommentUserMultipleResult,\n\t\t\tCommentUserSingleResult,\n\t\t\tDataFieldNotReconciled,\n\t\t\tDataFieldNotReconciled__PLURAL,\n\t\t\tDataFieldReconciled,\n\t\t\tDataFieldReconciled_DataFieldNotReconciled,\n\t\t\tDataFieldReconciled_DataFieldNotReconciled__PLURAL,\n\t\t\tDataFieldReconciled__PLURAL,\n\t\t\tDataFieldReconciled__PLURAL_DataFieldNotReconciled,\n\t\t\tDataFieldReconciled__PLURAL_DataFieldNotReconciled__PLURAL,\n\t\t\tDataFieldReconciliationMismatch,\n\t\t\tDeleted,\n\t\t\tDocExplorerInteractivePreview,\n\t\t\tDocExplorerLwdp,\n\t\t\tDocExplorerNative,\n\t\t\tDocExplorerPreview,\n\t\t\tDocumentCompare,\n\t\t\tDocumentHasBeenReassignedTo,\n\t\t\tDocumentWasRemovedFromEnvelope,\n\t\t\tDraft,\n\t\t\tElectronicSignatureIsComplete,\n\t\t\tEmailMultipleDocument,\n\t\t\tEmailSingleDocument,\n\t\t\tExisting,\n\t\t\tExternalReviewManaulMatchAddAttachment,\n\t\t\tExternalReviewManaulMatchNewDocument,\n\t\t\tExternalReviewManaulMatchReplace,\n\t\t\tField,\n\t\t\tFieldWorkflow,\n\t\t\tFlagManualReviewMultipleAttachments,\n\t\t\tFlagManualReviewOneAttachment,\n\t\t\tFlagManualReview,\n\t\t\tFromTo,\n\t\t\tInboundEmailRemoved,\n\t\t\tInboundFaxRemoved,\n\t\t\tLink,\n\t\t\tMultiple,\n\t\t\tNative,\n\t\t\tNoChange,\n\t\t\tNoCommentNoUserMultipleResult,\n\t\t\tNoCommentNoUserSingleResult,\n\t\t\tNoCommentUserMultipleResult,\n\t\t\tNoCommentUserSingleResult,\n\t\t\tNoDocument, None,\n\t\t\tNoResultNoUser,\n\t\t\tNoResultWithUser,\n\t\t\tNoSenderAccount,\n\t\t\tOther,\n\t\t\tPDF,\n\t\t\tPinpointValueChanged,\n\t\t\tPrevents,\n\t\t\tPreviewAspxFormView,\n\t\t\tPreviewAspxLwdp,\n\t\t\tPreviewAspxNative,\n\t\t\tPreviewAspxPreview,\n\t\t\tPreviewSignatureCancelledBySender,\n\t\t\tPreviousDocumentOwnerHasBeenDeleted,\n\t\t\tPublic,\n\t\t\tRecipient,\n\t\t\tRuleLine,\n\t\t\tRuleXPath,\n\t\t\tRuleStartWorkflow,\n\t\t\tSender,\n\t\t\tSendForExtenralReviewPrepared,\n\t\t\tSendForExternalReviewPrepared,\n\t\t\tShareActionNew,\n\t\t\tSignatureCancelledBySender,\n\t\t\tSignatureOperationCancelledBy,\n\t\t\tSignatureRejected,\n\t\t\tSignatureSendTransactionFailure,\n\t\t\tSignatureSendWithDifferentProvider,\n\t\t\tSignatureTransactionTimedOut,\n\t\t\tSignedByRecipients,\n\t\t\tSingle,\n\t\t\tSpringIngest,\n\t\t\tSxTerm,\n\t\t\tTerminatedStatus,\n\t\t\tTheElectronicSignatureTransactionHasFailed,\n\t\t\tTo,\n\t\t\tUpdateFormDocAspx,\n\t\t\tUpload,\n\t\t\tViaWorkflow,\n\t\t\tWatchersMultipleDocs,\n\t\t\tWatchersSingleDocs,\n\t\t\tWithCCAndEmailMessage,\n\t\t\tWithEmailMessage,\n\t\t\tWithEmailSubject,\n\t\t\tWithEmailSubjectViaWorkflow,\n\t\t\tWorkflow,\n\t\t\tWorkflowActivity,\n\t\t\tWorkflowActivityCompleted,\n\t\t\tWorkflowActivityUserChoiceCompleted\n\t\t}\n\n\t\tpublic enum HistoryCommentIdentifiers\n\t\t{\n\t\t\tNoneOrUserEntry,\n\t\t\tEformPublic,\n\t\t\tEformSubmittedBy,\n\t\t\tShareAction,\n\t\t\tDocumentCompare,\n\t\t\tWorkflow,\n\t\t\tDocumentReminderScheduledUpdated,\n\t\t\tReminderEmailSentTo,\n\t\t\tReminderContactIgnored,\n\t\t\tReminderDeletedContactIgnored,\n\t\t\tReminderGroupIgnored,\n\t\t\tReminderMalformedEmailIgnored,\n\t\t\tReminderNoRecipients,\n\t\t\tSignatureReference,\n\t\t\tSignatureReferenceWithPassword,\n\t\t\tWorkflowAction,\n\t\t\tWorkflowActionWithComment,\n\t\t\tRuleExecution\n\t\t}\n\n\t\tpublic enum HistoricalDocumentsIngestionToIamTaskStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tNotEnabled = 2,\n\t\t\tDmsWritesNotEnabled = 3,\n\t\t\tDMSMigrationWorkerNotEnabled = 4\n\t\t}\n\n\t\t// bit flags\n\t\t[Flags]\n\t\tpublic enum HoldRelevanceType\n\t\t{\n\t\t\tNone = 0x0000,\n\t\t\tPertaining = 0x0001,\n\t\t\tResponsive = 0x0002,\n\t\t\tProducible = 0x0004,\n\t\t\tPrivileged = 0x0010,\n\t\t\tAll = Pertaining | Responsive | Producible | Privileged,\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum HumanActivityTaskType\n\t\t{\n\t\t\tInvalid = 0,\n\t\t\tChooseDocuments = 1,\n\t\t\tChooseUsers = 2,\n\t\t\tApproveDocuments = 3,\n\t\t\tChoice = 4,\n\t\t\tEditDocuments = 5,\n\t\t\tReviewAndSendForExternalReview = 6,\n\t\t\tReviewAndSendForSignature = 7,\n\t\t\tRouting = 8,\n\t\t\tReviewData = 9,\n\t\t\tForm = 10,\n\t\t\tFullPageForm = 11\n\t\t}\n\n\t\t#endregion\n\n\t\t#region I\n\n\t\t//IndexQueue.Priority (null is default, the higher int value, the higher the priority.  Use negative numbers for low priority 'background' processing e.g. -10)\n\n\t\tpublic enum ImplicitDistributionGroupIds\n\t\t{\n\t\t\tAdmin = -1,\n\t\t\tPublisher = -2,\n\t\t\tEnhancedGuest = -4,\n\t\t\tGuest = -99\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Acceptable values for the Document State property.\n\t\t/// </summary>\n\t\tpublic enum InboundFaxStatus\n\t\t{\n\t\t\tAvailable = 0,\n\t\t\tProvisioned = 1,\n\t\t\tDeactivated = -1,\n\t\t\tPending = -2,\n\t\t\tRemovedFromPool = -3\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Operation of an elastic index task\n\t\t/// </summary>\n\t\tpublic enum IndexOperation\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tIndex = 1,\n\t\t\tIndexBulk = 2,\n\t\t\tUpdate = 3,\n\t\t\tUpdateBulk = 4,\n\t\t\tDelete = 5,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Target of document/folder for re-indexing\n\t\t/// </summary>\n\t\tpublic enum IndexTarget\n\t\t{\n\t\t\tAccountDefault = 0,\n\t\t\tAll = 1,\n\t\t\tAzure = 2,\n\t\t\tElasticSearch6 = 3,\n\t\t\tElasticSearch7 = 4,\n\n\t\t}\n\n\t\tpublic enum InputTextDataType\n\t\t{\n\t\t\tString = 0,\n\t\t\tInteger = 1,\n\t\t\tDecimal = 2,\n\t\t\tDate = 3\n\t\t}\n\n\t\tpublic enum IntellegoExtractionStatus\n\t\t{\n\t\t\tFailed = -2,\n\t\t\tNotApplicable = -1,\n\t\t\tNotExtracted = 0,\n\t\t\tExtracted = 1\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Collaborations: Used to differentiate between PinPoint, Check in/out and Combination (both)\n\t\t/// </summary>\n\t\t// TJM: I still think this is a dumb requirement\n\t\tpublic enum InteractionType\n\t\t{\n\t\t\tCombination = 0,\n\t\t\tCheckInOutOnly = 1,\n\t\t\tPinPointOnly = 2\n\t\t}\n\n\t\tpublic enum ImageRotation\n\t\t{\n\t\t\tNone = 0,\n\t\t\tClockwise = 90,\n\t\t\tCounterClockwise = -90,\n\t\t\tUpsideDown = 180,\n\t\t}\n\n\t\tpublic enum InvoiceMergeStatus\n\t\t{\n\t\t\tProcessing = 0,\n\t\t\tSuccess = 1,\n\t\t\tFailed = 2\n\t\t}\n\n\t\tpublic enum APRExtractionStatus\n\t\t{\n\t\t\tFailed = -2,\n\t\t\tNotApplicable = -1,\n\t\t\tNotExtracted = 0,\n\t\t\tExtracted = 1\n\t\t}\n\n\t\t#endregion\n\n\t\t#region J\n\t\tpublic enum JoinType\n\t\t{\n\t\t\t// These are the actual reserved SQL keywords. ToString() gets called on\n\t\t\t// the enum when emitting the sql statement.\n\t\t\tINNER = 0,\n\t\t\tLEFT = 1,\n\t\t\tRIGHT = 2,\n\t\t\tCROSS = 3, //!WATCH OUT! ;)\n\t\t}\n\t\t#endregion\n\t\t#region K\n\n\t\t#endregion\n\t\t#region L\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum LogicalOperator\n\t\t{\n\t\t\tAnd = 0,\n\t\t\tOr = 1\n\t\t}\n\n\t\tpublic enum LoginAccessPoint\n\t\t{\n\t\t\tTools = -3,\n\t\t\tUnitTest = -2,\n\t\t\tUnknown = -1,\n\t\t\tWebUI = 1,\n\t\t\tSSO = 2,\n\t\t\t//FTP = 3,\n\t\t\tSFTP = 4,\n\t\t\t//WebDAV = 5,\n\t\t\tWebSOAP = 6,\n\t\t\tSFAutoLogin = 7,\n\t\t\tRestAPI = 8,\n\t\t\tOpenSearch = 9,\n\t\t\tMergeAPI = 10,\n\t\t\tDocuSign = 11,\n\t\t\tDelegatedLogin = 12,\n\t\t\tSfSignedRequest = 13,\n\t\t\tSpringOAuth = 14,\n\t\t\tAccountSwitch = 15,\n\t\t\tApiAuth = 16,\n\t\t\tDocuSignInternalApi = 17\n\t\t}\n\t\tpublic enum LoginDelegationHours\n\t\t{\n\t\t\t[Description(\"1 hour\")]\n\t\t\t_1 = 1,\n\t\t\t[Description(\"2 hours\")]\n\t\t\t_2 = 2,\n\t\t\t[Description(\"4 hours\")]\n\t\t\t_4 = 4,\n\t\t\t[Description(\"8 hours\")]\n\t\t\t_8 = 8,\n\t\t\t[Description(\"12 hours\")]\n\t\t\t_12 = 12,\n\t\t\t[Description(\"24 hours\")]\n\t\t\t_24 = 24,\n\t\t\t[Description(\"2 days\")]\n\t\t\t_48 = 48,\n\t\t\t[Description(\"3 days\")]\n\t\t\t_72 = 72,\n\t\t\t[Description(\"1 week\")]\n\t\t\t_168 = 168,\n\t\t\t[Description(\"2 weeks\")]\n\t\t\t_336 = 336,\n\t\t\t[Description(\"4 weeks\")]\n\t\t\t_672 = 672\n\t\t}\n\n\t\tpublic enum LoginStatus\n\t\t{\n\t\t\t// Who knows?\n\t\t\tUnknown = 0,\n\n\t\t\t// The user has gone through the signup process and logged into the system\n\t\t\tActive = 1,\n\n\t\t\t// The user has been added to someone's address book, but has never logged into the system\n\t\t\tInactive = 2,\n\n\t\t\t// possible legit account but hasn't been authenticated yet.\n\t\t\tEmailNotAuthenticated = 3,\n\n\t\t\t// user failed to login with proper credentials over the limit, so until clear by an Admin that user is locked out\n\t\t\t//this has been changed so that the Locked status is actually a separate table of auto-expiring LoginLock\n\t\t\t//LockedOut = 4,\n\n\t\t\t//API only user\n\t\t\t//APIUser = 5,\n\n\t\t\t// The login is deleted\n\t\t\tDeleted = 8,\n\t\t\t// This login is for a different Site\n\t\t\tAtOtherSite = 9\n\t\t}\n\n\t\tpublic enum LogLevel\n\t\t{\n\t\t\tNone,\n\t\t\tDebug,\n\t\t\tInfo,\n\t\t\tWarning,\n\t\t\tError,\n\t\t\tFatal\n\t\t}\n\n\t\tpublic enum PreviewBehavior\n\t\t{\n\t\t\t[StringValue(\"\")]\n\t\t\tNotSet = 0,\n\t\t\t[StringValue(\"Preview\")]\n\t\t\tPreview = 1,\n\t\t\t[StringValue(\"Download\")]\n\t\t\tDownloadNative = 2,\n\t\t\t[StringValue(\"Download\")]\n\t\t\tDownloadPdf = 3,\n\t\t\t[StringValue(\"DownloadInline\")]\n\t\t\tDownloadInline = 4\n\t\t}\n\n\t\t#endregion\n\t\t#region M\n\n\t\tpublic enum MenuTagType\n\t\t{\n\t\t\tNone = 0,\n\t\t\tBeta = 1,\n\t\t\tTour = 2\n\t\t}\n\n\t\tpublic enum MergeEngine\n\t\t{\n\t\t\t[Description(\"Xml Merge\")]\n\t\t\tDocxXmlMergeProcessor = 1,\n\t\t\t[Description(\"Open Xml Merge\")]\n\t\t\tDocxOpenXmlMergeProcessor = 2,\n\t\t\t[Description(\"Document Assembler\")]\n\t\t\tDocumentAssemblerMergeProcessor = 3\n\t\t}\n\n\t\tpublic enum MessageType\n\t\t{\n\t\t\tNone = -1,\n\t\t\tExpiration = 0,\n\t\t\tReminder = 1,\n\t\t\tExpirationAndReminder = 2,\n\t\t}\n\n\t\tpublic enum MetadataMappingType\n\t\t{\n\t\t\t//Undefined = -1 ,\n\t\t\t//None = 0 ,\n\t\t\tCSV = 1,\n\t\t\tXML = 2,\n\t\t\t//Tagged = 3\n\t\t}\n\n\t\tpublic enum MvcPreferencePage\n\t\t{\n\t\t\tElectronicSignature = 2,\n\t\t\tDeviceManagement = 3,\n\t\t\tNotificationPreference = 4,\n\t\t\tSFConfiguration = 5,\n\t\t\tAutoNumbers = 6,\n\t\t\tAPIUserSetup = 7,\n\t\t\tSealConfiguration = 8,\n\t\t\tClauseConfiguration = 9\n\t\t}\n\n\t\tpublic enum MigrationEntityType\n\t\t{\n\t\t\tAccount = 1,\n\t\t\tGroup = 2,\n\t\t\tUser = 3\n\t\t}\n\n\t\t#endregion\n\t\t#region N\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum NavigationAndActionsType\n\t\t{\n\t\t\tDocumentActions = 0,\n\t\t\tNavigationActions = 1,\n\t\t\tNavigationHelp = 2,\n\t\t\tNavigation = 3,\n\t\t\tDocumentManagementActions = 4,\n\t\t\tDocumentManagementCustomActions = 5,\n\t\t\tFileItFolderWidget = 6,\n\t\t\tFileItFolderWidgetCustomActions = 7,\n\t\t\tAdvancedPartyUploadCustomActions = 8,\n\t\t\tBrowseDocumentsActions = 9,\n\t\t\tClassicPreviewActions = 10,\n\t\t\tClmFilesActions = 11,\n\t\t\tClmFilesCustomActions = 12\n\t\t}\n\n\t\tpublic enum NewAccountOption\n\t\t{\n\t\t\tNone = 0, // The user cannot create a new account\n\t\t\tPaid = 1, // The user can create a new paid account\n\t\t\tTrial = 2, // The user can create a new trial account\n\t\t\tAll = 3 // The user can create a new trial account or a new paid account\n\t\t}\n\n\t\t/// <summary>\n\t\t/// When to notify a person of new additions to a folder they're watching.\n\t\t/// </summary>\n\t\tpublic enum NotifyFrequencyType\n\t\t{\n\t\t\t[Description(\"Default\")]\n\t\t\tDefault = -1,\n\t\t\t[Description(\"None\")]\n\t\t\tNone = 0,\n\t\t\t[Description(\"Real-time\")]\n\t\t\tRealTime = 1,\n\t\t\t[Description(\"Daily\")]\n\t\t\tDaily = 2\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum NotificationPreference\n\t\t{\n\t\t\t[Description(\"None\")]\n\t\t\tNone = 0x00,\n\t\t\t[Description(\"Notification\")]\n\t\t\tNotification = 0x01,\n\t\t\t[Description(\"Email\")]\n\t\t\tEmail = 0x02,\n\t\t\t[Description(\"Digest\")]\n\t\t\tDigest = 0x04,\n\t\t\t[Description(\"All\")]\n\t\t\tAll = Notification | Email | Digest\n\t\t}\n\n\t\tpublic enum NotificationSubscriptionType\n\t\t{\n\t\t\tDoNotNotify = -1,\n\t\t\tNotify = 0,\n\t\t\tNotifyOnce = 1\n\t\t}\n\n\t\tpublic enum NotificationGroup\n\t\t{\n\t\t\tDocument = 0,\n\t\t\tAdmin = 1\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Used for the NotificationUser table\n\t\t/// </summary>\n\t\tpublic enum NotificationUserDeliveryMethod\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tNotification = 1,\n\t\t\tDigest = 2,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Used for Determining which NPS Survey to display\n\t\t/// </summary>\n\t\tpublic enum NpsSurveyType\n\t\t{\n\t\t\tWootric = 0,\n\t\t\tQualtrics = 1\n\t\t}\n\n\t\t#endregion\n\t\t#region O\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ObjectType\n\t\t{\n\t\t\tInvalid = 0,  // 0 is the default value when the data is null for enums.\n\t\t\tFolder = 1,\n\t\t\tDocument = 2,\n\t\t\tFolderLink = 3,\n\t\t\tSavedSearch = 4, /* CEM - Not currently a node type at all */\n\t\t\tMetadata = 5,\n\t\t\t//Workflow = 6,\n\t\t\t//Setting = 7,\n\t\t\t//Group = 8,\n\t\t\t//User = 9,\n\t\t\tAccount = 10,\n\t\t\t//Contact = 11,\n\t\t\tUserAccount = 12,\n\t\t\t//Security = 13,\n\t\t\t//RecordClass = 14,\n\t\t\t//Record = 15,\n\t\t\tSchedule = 16,\n\t\t\t//Case = 17,\n\t\t\t//CaseTask = 18,\n\t\t\t//CaseComment = 19,\n\t\t\tMetadataGroup = 20,\n\t\t\tExternalReview = 21,\n\t\t\tWorkflowWorkItem = 22,\n\t\t\tReportConfiguration = 23,\n\t\t\tBulkFolder = 31,\n\t\t\tBulkDocument = 32\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum OCRProcessingLevel  // bit field. Used to either specify service capability, or specific processing request\n\t\t{\n\t\t\tNone = 0x00,\n\t\t\tRegularOCR = 0x01, // inlcudes 1D barcode processing\n\t\t\tFormOCR = 0x02,\n\t\t\tOpenOCR = 0x04,\n\t\t\tBarcode2D = 0x08,\n\t\t}\n\n\t\tpublic enum AuthorizationScheme\n\t\t{\n\t\t\t[Description(\"Unknown\")]\n\t\t\tUnknown = 0,\n\t\t\t[Description(\"OAuth\")]\n\t\t\tOAuth = 1,\n\t\t\t[Description(\"Salesforce Impersonation\")]\n\t\t\tSalesforce = 2,\n\t\t\t[Description(\"Bearer token. Same as oauth\")]\n\t\t\tBearer = 3,\n\t\t\t[Description(\"Basic oauth used by Docusign to exchange authcode for accesstoken\")]\n\t\t\tBasic = 4,\n\t\t\t[Description(\"Authorization type used by Docusign Edit desktop applications\")]\n\t\t\tDsEdit = 5\n\t\t}\n\n\t\tpublic enum OAuthKeyType\n\t\t{\n\t\t\t[Description(\"Authorization\")]\n\t\t\tAuthorization = 0,\n\t\t\t[Description(\"Access\")]\n\t\t\tAccess = 1,\n\t\t\t[Description(\"Refresh\")]\n\t\t\tRefresh = 2\n\t\t}\n\n\t\t[Flags]\n\t\tpublic enum OAuthScope\n\t\t{\n\t\t\t// *NOTE* If new scopes are added for external use, add a description to atlas.resx with\n\t\t\t//    title OAuthScope_[name of enum all lowercase]. See OAuthScope_loggedinuser as an example.\n\t\t\t[Description(\"None\")]\n\t\t\tNone = 0x0000,\n\t\t\t[Description(\"Logged in user\")]\n\t\t\tLoggedInUser = 0x0001, // this one allows SOAP access, which gives them all the rights of the currently logged in user.\n\t\t\t[Description(\"Sync\")]\n\t\t\tSync = 0x0002,\n\t\t\t[Description(\"DocumentCreation\")]\n\t\t\tDocumentCreation = 0x0004,\n\t\t\t[Description(\"Access Salesforce Data\")]\n\t\t\tAccessSalesforceData = 0x0008,\n\t\t\t[Description(\"ContentControl\")]\n\t\t\tContentControl = 0x0010,\n\t\t\t[Description(\"Linked Account Administration\")]\n\t\t\tLinkedAccounts = 0x1000,\n\t\t\t[Description(\"Notification\")]\n\t\t\tNotification = 0x2000,\n\t\t\t[Description(\"System\")]\n\t\t\tSystem = 0xFFFF\n\t\t}\n\n\t\tpublic enum OauthAudience\n\t\t{\n\t\t\tGeneralApi = 0,\n\t\t\tOfficeAddIn = 1,\n\t\t\tSignalR = 2   //deprecated\n\t\t}\n\n\t\tpublic enum OcrGetSearchablePdfTaskProcessingStatus\n\t\t{\n\t\t\tFileNotFound = -1,\n\t\t\tFail = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum OpenIn\n\t\t{\n\t\t\tNewWindow,\n\t\t\tWindoid,\n\t\t\tSameWindow,\n\t\t\tNone\n\t\t}\n\n\t\t#endregion\n\t\t#region P\n\t\tpublic enum PartyOperation\n\t\t{\n\t\t\tcreate,\n\t\t\tupdate,\n\t\t\tdelete\n\t\t}\n\n\t\t// Party Source enums match value in resources/Parties.resx\n\t\tpublic enum PartySource\n\t\t{\n\t\t\tDocuSignCLM = 1,\n\t\t\tNetSuiteFinancial = 2,\n\t\t\tSAPAriba = 3,\n\t\t\tWorkdayFinancialManagement = 4,\n\t\t\tSalesforce = 5,\n\t\t\tCoupa = 6,\n\t\t}\n\n\t\tpublic enum PasteStatus\n\t\t{\n\t\t   Success = 0,\n\t\t\tFailure = 1,\n\t\t\tPartialSuccess = 2,\n\t\t\tTooLarge = 3\n\t\t}\n\n\t\tpublic enum PasswordUpgradeReason\n\t\t{\n\t\t\tUpgradeNotRequired,\n\t\t\tAdminRequired,\n\t\t\tPasswordStrengthInvalid,\n\t\t\tExpired\n\t\t}\n\n\t\tpublic enum ProcessSaveAndUpdateData\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tNoTrackedFieldStatuses = 2,\n\t\t\tSaveDataFailed = 3\n\t\t}\n\t\tpublic enum PageLocation\n\t\t{\n\t\t\tTopLeft,\n\t\t\tTopCenter,\n\t\t\tTopRight,\n\t\t\tMidLeft,\n\t\t\tMidCenter,\n\t\t\tMidRight,\n\t\t\tBottomLeft,\n\t\t\tBottomCenter,\n\t\t\tBottomRight\n\t\t}\n\n\t\tpublic enum PasswordStrength\n\t\t{\n\t\t\t// Legacy\n\t\t\tUnknown = 0,\n\t\t\tRegular = 1,\n\n\n\t\t\tStrong = 2,\n\t\t\tStrongPlusOne = 3,\n\t\t\tStrongPlusTwo = 4\n\t\t}\n\n\t\tpublic enum PdfConvertStatus\n\t\t{\n\t\t\tPending = 0,                // PDF does not exist. It's waiting to be converted to PDF.\n\t\t\tFailed = -1,\t\t\t\t// PDF does not exist. Conversion failed\n\t\t\tPasswordProtected = -2,\t// PDF *does* exist, but we can't read it (mangled PDFs also get assigned this status)\n\t\t\tNotApplicable = -3,     // PDF does not exist. Conversion will not attempted at all because we won't create PDF rendition for that document.\n\t\t\tSuccess = 1\t\t\t\t\t// PDF exists.  This is also used for documents that were uploaded as PDF.\n\t\t}\n\n\t\tpublic enum PdfManipulationPriority\n\t\t{\n\t\t\tPassive = -1,\n\t\t\tBackgroundProcessing = 100,\n\t\t\tWeb = 500,\n\t\t\tWebDownload = 1000,\n\t\t}\n\n\t\tpublic enum PreviewButtons\n\t\t{\n\t\t\tsaveNext = 0,\n\t\t\tsaveClose = 1\n\t\t}\n\n\t\t[EnumJavaScriptResource(true)]\n\t\tpublic enum PreviewAvailabilityReasonCode\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tAvailable = 1,\n\t\t\tNativeContent = 2,\n\n\t\t\tPdfConversionFailed = -1,\n\t\t\tInternalType = -2,\n\t\t\tUnsupportedType = -3,\n\t\t\tFileSizeZero = -4,\n\t\t\tFileSizeMax = -5,\n\t\t\tPasswordProtected = -6,\n\t\t\tPageCountZero = -7,\n\t\t\tPageCountUnsupported = -8\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum PreviewViewer\n\t\t{\n\t\t\tlwdp = 0,\n\t\t\tnative = 1,\n\t\t\tpreview = 4,\n\t\t\tinteractivePreview = 5,\n\t\t\tdocReview = 6\n\t\t}\n\n\t\tpublic enum ImageStatus\n\t\t{\n\t\t\tNotAvailable = 0,\n\t\t\tAvailable = 1,\n\t\t\tGenerating = 2\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Privileges that can be assigned to a custom role\n\t\t/// then used to verify if the current user can do a certain action\n\t\t/// </summary>\n\t\t[Flags]\n\t\tpublic enum PrivilegeTypes\n\t\t{\n\t\t\t// int.MinValue will convert into null in sql\n\t\t\tNone = int.MinValue,\n\n\t\t\t/// <summary>\n\t\t\t/// User administration\n\t\t\t/// Should not contain group\n\t\t\t/// membership or Role setting\n\t\t\t/// </summary>\n\t\t\tUserAdmin = 1 << 0,\n\n\t\t\t/// <summary>\n\t\t\t/// This person can edit and\n\t\t\t/// create roles\n\t\t\t/// Also can assign roles to a user\n\t\t\t/// </summary>\n\t\t\tRoleAdmin = 1 << 1,\n\n\t\t\t/// <summary>\n\t\t\t/// Workflow\n\t\t\t/// Smart Rules\n\t\t\t/// Schedules\n\t\t\t/// Forms\n\t\t\t/// Reminder Templates\n\t\t\t/// </summary>\n\t\t\tWorkflowAutomation = 1 << 2,\n\n\t\t\t/// <summary>\n\t\t\t/// Security groups\n\t\t\t/// </summary>\n\t\t\tGroupAdmin = 1 << 3,\n\n\t\t\t/// <summary>\n\t\t\t/// Used for setup setting stuff on an account\n\t\t\t/// Should not include things on the sec pref page\n\t\t\t/// </summary>\n\t\t\tAccountSetup = 1 << 4,\n\n\t\t\t/// <summary>\n\t\t\t/// Basically the things on the sec pref page\n\t\t\t/// </summary>\n\t\t\tSecuritySetup = 1 << 5,\n\n\t\t\t/// <summary>\n\t\t\t/// Allows report creation/editing/deletion\n\t\t\t/// </summary>\n\t\t\tReportAdmin = 1 << 6,\n\n\t\t\t/// <summary>\n\t\t\t/// Allow create, edit, and delete in the Document Generation tool\n\t\t\t/// </summary>\n\t\t\tDocLauncher = 1 << 7,\n\n\t\t\t/// <summary>\n\t\t\t/// Allow administration of the account's branding and custom toolbar actions\n\t\t\t/// </summary>\n\t\t\tUIPreferences = 1 << 8,\n\n\t\t\t/// <summary>\n\t\t\t/// Allow create, edit, and delete of attribute fields on documents. Note: All users that are not in the Guest role will be able to edit attribute values.\n\t\t\t/// </summary>\n\t\t\tAttributesAutoNumbers = 1 << 9, // note that MetadataGroupDelete and MetadataFieldDelete sql stored procedures rely on the value of this enum\n\n\t\t\t/// <summary>\n\t\t\t/// Allow administration of third-party integrations and configurations\n\t\t\t/// </summary>\n\t\t\tIntegrations = 1 << 10,\n\n\t\t\t/// <summary>\n\t\t\t/// Allows management of inbound email addresses and fax numbers\n\t\t\t/// </summary>\n\t\t\tInboundFolderContent = 1 << 11,\n\n\t\t\t/// <summary>\n\t\t\t/// Allow configuration and execution of AI analysis tools to automatically populate attributes\n\t\t\t/// </summary>\n\t\t\tAiAttributeAutofill = 1 << 12,\n\n\t\t\t/// <summary>\n\t\t\t/// Allow configuration and execution of AI analysis tools to automatically populate attributes\n\t\t\t/// </summary>\n\t\t\tObjectMapping = 1 << 13,\n\n\t\t\tAll = -1,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Corresponds to the properties in the PrivilegeCard. Used in RequireAuthenticationAttribute.cs\n\t\t/// to determine access to MVC pages. Add to this enum if you need to use a privilegecard property in\n\t\t/// the RequireAuthenticationAttribute.\n\t\t/// Note: Enum member names need to match property names in RequireAuthenticationAttribute.\n\t\t/// Note: Reflection is used for mapping between the 2 structures.\n\t\t/// </summary>\n\t\t[Flags]\n\t\tpublic enum Privileges : long\n\t\t{\n\t\t\tUndefined = Int64.MinValue,\n\t\t\tHasSuperAdminRights = 1 << 0,\n\t\t\tHasUserAdminRights = 1 << 1,\n\t\t\tHasPublisherRights = 1 << 2,\n\t\t\tHasEnhancedGuestRights = 1 << 3,\n\t\t\tHasGuestRights = 1 << 4,\n\t\t\tCanSetupAttributes = 1 << 5,\n\t\t\tCanSetupUIPreferences = 1 << 6,\n\t\t\tCanParticipateInBPMWorkflow = 1 << 7,\n\t\t\tCanSetupIntegrations = 1 << 8,\n\t\t\tCanManageQueues = 1 << 9,\n\t\t\tCanSetupReminders = 1 << 10,\n\t\t\tCanSetupSalesforceIntegrations = 1 << 11,\n\t\t\tCanSetupSchedules = 1 << 12,\n\t\t\tCanDesignBPMWorkflow = 1 << 13,\n\t\t\tCanStartBPMWorkflow = 1 << 14,\n\t\t\tCanAdministerDocLauncher = 1 << 15,\n\t\t\tCanCheckInOut = 1 << 16,\n\t\t\tCanManageBPMWorkflow = 1 << 17,\n\t\t\tCanAdministerSecurityGroups = 1 << 18,\n\t\t\tCanSetupAccount = 1 << 19,\n\t\t\tCanManageFaxLines = 1 << 20,\n\t\t\tCanAddUser = 1 << 21,\n\t\t\tCanAddContacts = 1 << 22,\n\t\t\tCanSetSecurityPrefs = 1 << 23,\n\t\t\tCanManageForms = 1 << 24,\n\t\t\tCanProvisionInboundEmail = 1 << 25,\n\t\t\tCanDesignReports = 1 << 26,\n\t\t\tCanSetupSmartRules = 1 << 27,\n\t\t\tCanManageConnectedApps = 1 << 28,\n\t\t\tCanManageNotificationPreferences = 1 << 29,\n\t\t\tCanManageParties = 1 << 30,\n\t\t\tCanSetupSmartAgreement = 1L << 31,\n\t\t\tCanManageConnections = 1L << 32,\n\t\t\tCanSendDocuments = 1L << 33,\n\t\t\tCanSetupObjectMapping = 1L << 34,\n\t\t\tCanViewParties = 1L << 35,\n\t\t\tCanAccessContactsPage = 1L << 36,\n\t\t\tCanAddParties = 1L << 37\n\t\t} // Note: Avoid shifting more than 62 because 1L << 63 == Int64.MinValue. When shifting more than 30, use the L (long) suffix on the left side. Otherwise 1 << 31 == Int32.MinValue, 1 << 32 == 1 << 0, , 1 << 33 == 1 << 1, etc...\n\n\t\tpublic enum ProfileNotificationType\n\t\t{\n\t\t\tUnidentified = 0,\n\t\t\tAccountUpdated = 1,\n\t\t\tUserUpdated = 2\n\t\t}\n\n\t\tpublic enum PhysicalStorageOperationType\n\t\t{\n\t\t\tDefault = 0,\n\t\t\tStoreFromFile = 1,\n\t\t\tStoreFromStream = 2,\n\t\t\tDelete = 3,\n\t\t\tCheckExists = 4,\n\t\t\tGetContentLength = 5,\n\t\t\tGetFile = 6,\n\t\t\tGetStream = 7,\n\t\t\tGetStreamRange = 8,\n\t\t\tCreateDocument = 9,\n\t\t\tUpdateDocument = 10\n\t\t}\n\n\t\tpublic enum HybridStorageWritesType\n\t\t{\n\t\t\tAsync = 0,\n\t\t\tSync = 1\n\t\t}\n\n\t\t/// <summary>\n\t\t/// HybridStorageOverride account setting to determine hybrid storage configuration.\n\t\t/// </summary>\n\t\tpublic enum HybridStorageOverride\n\t\t{\n\t\t\tNone = 0, // No override, use feature flags\n\t\t\tDmsWritesDpsReads = 1, // Should only be used for existing accounts that have not migrated historical data to DMS\n\t\t\tDmsWritesAndReads = 2 // Should only be used for new accounts, or accounts where all historical data has been migrated to DMS\n\t\t}\n\n\t\t#region PublicUser Enums\n\n\t\tpublic enum PublicUserContext\n\t\t{\n\t\t\tExternalReview =1\n\t\t}\n\t\tpublic enum PublicUserAction\n\t\t{\n\t\t\tUpload = 1\n\t\t}\n\t\t#endregion\n\n\t\t#region print on demand enums\n\t\tpublic class PrintOnDemand\n\t\t{\n\t\t\tpublic enum OptionType\n\t\t\t{\n\t\t\t\tHandlingFee = 0,\n\t\t\t\tPaper = 1,\n\t\t\t\tTab = 2,\n\t\t\t\tBindingOption = 3,\n\t\t\t\tShipping = 4\n\t\t\t}\n\t\t\tpublic enum TabType\n\t\t\t{\n\t\t\t\tNone = 0,\n\t\t\t\tTabsBetweenDocuments = 1\n\t\t\t}\n\n\t\t\tpublic enum PaperType\n\t\t\t{\n\t\t\t\tBrilliantWhite = 0,\n\t\t\t\tBeige = 1,\n\t\t\t\tLightGray = 2\n\n\t\t\t}\n\n\t\t\tpublic enum BindingOption\n\t\t\t{\n\t\t\t\tNone = 0,\n\t\t\t\tStapled = 1,\n\t\t\t\tPendoflexBinding = 2\n\t\t\t}\n\n\t\t\tpublic enum ShipType\n\t\t\t{\n\t\t\t\tUSMail = 0,\n\t\t\t\tUPSGround = 1,\n\t\t\t\tUPSNextDayAir = 2\n\t\t\t}\n\t\t}\n\n\t\tpublic enum AllowPublicForms\n\t\t{\n\t\t\tNo = 0,\n\t\t\tYes = 1,\n\t\t\tAllowJS =2\n\t\t}\n\n\t\t#endregion\n\t\t#endregion\n\t\t#region Q\n\t\tpublic enum QueueStatus\n\t\t{\n\t\t\tFailure = -1,\n\t\t\tWaiting = 0,\n\t\t\tProcessing = 1,\n\t\t\tSuccess = 2\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Not used from code but is in a lookup table\n\t\t/// </summary>\n\t\tpublic enum QueuePriority\n\t\t{\n\t\t\tDefault = 0,\n\t\t\tBrowseUpload = 10,\n\t\t\tCheckInFile = 10,\n\t\t\tUpdateDocument = 10,\n\t\t\tDraftDocument = 10,\n\t\t\tOfficeUploaderEditInline = 10,\n\t\t\tCollaborationSave = 10,\n\t\t\tSpringCMService = 5,\n\t\t\t//WebDAVServer = 5,\n\t\t\tAtlasUploadService = 5,\n\t\t\tAtlasInboundEmail = 1,\n\t\t\tInboundFax = 1,\n\t\t\tSFTPServer = -10,\n\t\t\tSupport = -100,\n\t\t}\n\n\t\tpublic enum QueryWizard\n\t\t{\n\t\t\tAdvanced,\n\t\t\tDocumentMetadata,\n\t\t\tWorkflowsCompleted,\n\t\t\tWorkflowStepDuration,\n\t\t\tTimesThroughStep,\n\t\t\tExistingReport,\n\n\t\t}\n\t\t#endregion\n\t\t#region R\n\n\t\t/// <summary>\n\t\t/// Enumeration for Delivery Status in the adexs system\n\t\t/// </summary>\n\t\tpublic enum RecipientType\n\t\t{\n\t\t\tContact = 0,\n\t\t\tGroup = 1,\n\t\t\tAdHocEmailAddress = 2,\n\t\t}\n\n\t\tpublic enum ReindexingQueuePriority\n\t\t{\n\t\t\tLow = 0,\n\t\t\tNormal = 1,\n\t\t\tHigh = 2\n\t\t}\n\n\t\tpublic enum ReindexingStatus\n\t\t{\n\t\t\tPending = 0,\n\t\t\tProcessing = 1,\n\t\t\tSuccess = 2,\n\t\t\tFailed = 3\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enumeration for ReplaceTrackedContentStatus.\n\t\t/// </summary>\n\t\tpublic enum ReplaceTrackedContentStatus\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tFailed = 2,\n\t\t\tDocumentNameNotFound = 3,\n\t\t\tFolderNotPresent = 4,\n\t\t\tDocumentNotFound = 5,\n\t\t\tNotSupportedFormat = 6,\n\t\t\tDocumentCheckedOut = 7,\n\t\t\tCorruptDocument = 8\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enumeration for GetTrackedContentStatus.\n\t\t/// </summary>\n\t\tpublic enum GetTrackedContentStatus\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tFailed = 2,\n\t\t\tDocumentNotFound = 3,\n\t\t\tNotSupportedFormat = 4,\n\t\t\tCorruptDocument = 5\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Given role in the recman repository.\n\t\t///\n\t\t/// Note: Code in RecordsSecurityAttribute assumes that higher numbered roles have all\n\t\t/// the powers of lower numbered roles.\n\t\t/// </summary>\n\t\tpublic enum RecordsRoleType\n\t\t{\n\t\t\tNone = 0,\n\t\t\tViewer = 10,\n\t\t\tManager = 20,\n\t\t\tAdministrator = 40,\n\t\t}\n\n\t\tpublic enum RecordClassStatus\n\t\t{\n\t\t\tDeleted = -1,\n\t\t\tNormal = 0,\n\t\t}\n\n\t\tpublic enum RecordOrigination\n\t\t{\n\t\t\t[Description(\"Created Date\")]\n\t\t\tRecordCreatedDate = 0,\n\t\t\t[Description(\"Attribute Date\")]\n\t\t\tMetadataDate = 1,\n\t\t}\n\n\t\tpublic enum ReminderTemplateOffsetType\n\t\t{\n\t\t\tNotSet = int.MinValue,\n\t\t\tNone = 0,\n\t\t\tTemplateApplication = 1,\n\t\t\tMetadataField = 2\n\t\t}\n\n\t\tpublic enum ReminderTemplateOffsetIntervalType\n\t\t{\n\t\t\tNotSet = int.MinValue,\n\t\t\tDays = 1,\n\t\t\tWeeks = 2,\n\t\t\tMonths = 3,\n\t\t\tYears = 4\n\t\t}\n\n\t\tpublic enum ReportExecutionStatus\n\t\t{\n\t\t\tStarted,\n\t\t\tFinished,\n\t\t\tError\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ReportDisplayType\n\t\t{\n\t\t\tReport = 0,\n\t\t\tColumn = 1,\n\t\t\tStacked = 2,\n\t\t\tStackedFull = 3,\n\t\t\tPie = 4\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ReportFilterComparator\n\t\t{\n\t\t\tUnset = 0,\n\t\t\tEqualsAnyOf = 1,\n\t\t\tDoesNotEqualAnyOf = 2,\n\t\t\tContainsAnyOf = 3,\n\t\t\tDoesNotContainAnyOf = 4,\n\t\t\tIsEmpty = 5,\n\t\t\tIsNotEmpty = 6,\n\t\t\tEquals = 7,\n\t\t\tDoesNotEqual = 8,\n\t\t\tGreaterThanOrEqualTo = 9,\n\t\t\tLessThanOrEqualTo = 10,\n\t\t\tBetween = 11\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ReportType : short\n\t\t{\n\t\t\t[Description(\"This is for the old style of custom reporting\")]\n\t\t\tNormal = 0,\t\t\t\t// these are the really old custom custom reports - tied to sprocs usually specific for a customer\n\t\t\tUserDefined = 2,\t\t// these are our Legacy design-able reports\n\t\t\tStandardOffering = 4,   // theses are usually our set of 6 Rdl based reports (e.g. Document Activity) but some that should be type 5 are here too\n\t\t\tAccount = 5,\t\t\t// another form of old custom custom report but tied to rdl\n\n\t\t\tAnalyticsWorkflow = 8,\t\t\t// analytics based workflow reports\n\t\t\tAnalyticsDocument = 9,\t\t\t// analytics document reports\n\t\t\tAnalyticsDocumentActivity = 10, // analytics document activity reports\n\t\t\tAnalyticsUsers = 11,\n\t\t\tAnalyticsAgreementsExpiring = 12,\n\t\t\tAnalyticsObligations = 13,\n\t\t\tAnalyticsAgreementsApproachingRenewal = 14,\n\n\t\t\tDisabled = 255, // can't make this a -1 because it is a tinyint in the db and it ggoes from 0-255\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ReportExportFormat\n\t\t{\n\t\t\tCSV = 0,\n\t\t\tExcel = 1,\n\t\t\tPDF = 2,\n\t\t\tXML = 3,\n\t\t\tMHTML = 4,\n\t\t\tIMAGE = 5,\n\t\t\tWord = 6,\n\t\t}\n\n\t\tpublic enum ReportGroupStyle\n\t\t{\n\t\t\tNone = 0,\n\t\t\tDefault = 1,\n\n\t\t\t//DateTime grouping\n\t\t\tYear = 2,\n\t\t\tMonth = 3,\n\t\t\tDay = 4,\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ReportLoadingState\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tLoading = 1,\n\t\t\tLoaded = 2,\n\t\t\tError = 3,\n\t\t\tTimeout = 4,\n\t\t\tQueueExceeded = 5,\n\t\t\tCanceled = 8,\n\t\t\tAbandonedQuery = 9,\n\t\t\tNetworkError = 10\n\t\t}\n\n\t\t//Ranges as well as groupings for use in an EnumComboBox\n\t\tpublic enum ReportRangeType\n\t\t{\n\t\t\t[Description(\"Day\")]\n\t\t\tDay = 0,\n\t\t\t[Description(\"Yesterday\")]\n\t\t\tYesterday = 1,\n\t\t\t[Description(\"Today\")]\n\t\t\tToday = 2,\n\t\t\t[Description(\"Tomorrow\")]\n\t\t\tTomorrow = 3,\n\t\t\t[Description(\"Last 7 Days\")]\n\t\t\tLast7Days = 4,\n\t\t\t[Description(\"Last 30 Days\")]\n\t\t\tLast30Days = 5,\n\n\t\t\t[Description(\"Week\")]\n\t\t\tWeek = 10,\n\t\t\t[Description(\"Last Week\")]\n\t\t\tLastWeek = 11,\n\t\t\t[Description(\"This Week\")]\n\t\t\tThisWeek = 12,\n\t\t\t[Description(\"Next Week\")]\n\t\t\tNextWeek = 13,\n\n\t\t\t[Description(\"Month\")]\n\t\t\tMonth = 20,\n\t\t\t[Description(\"Last Month\")]\n\t\t\tLastMonth = 21,\n\t\t\t[Description(\"This Month\")]\n\t\t\tThisMonth = 22,\n\t\t\t[Description(\"Next Month\")]\n\t\t\tNextMonth = 23,\n\n\t\t\t[Description(\"Quarter\")]\n\t\t\tQuarter = 30,\n\t\t\t[Description(\"Last Quarter\")]\n\t\t\tLastQuarter = 31,\n\t\t\t[Description(\"This Quarter\")]\n\t\t\tThisQuarter = 32,\n\t\t\t[Description(\"Next Quarter\")]\n\t\t\tNextQuarter = 33,\n\n\t\t\t[Description(\"Year\")]\n\t\t\tYear = 40,\n\t\t\t[Description(\"Last Year\")]\n\t\t\tLastYear = 41,\n\t\t\t[Description(\"This Year\")]\n\t\t\tThisYear = 42,\n\t\t\t[Description(\"Next Year\")]\n\t\t\tNextYear = 43,\n\t\t}\n\n\t\tpublic enum ReportQueryType\n\t\t{\n\t\t\tNormal,\n\t\t\tAggregate,\n\t\t\tTotalCounts\n\t\t}\n\n\n\t\tpublic enum ReportValueAggregate\n\t\t{\n\t\t\tNone,\n\t\t\tSum,\n\t\t\tAverage,\n\t\t\tCount,\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum ReportSubType\n\t\t{\n\t\t\tTabular = 0,\n\t\t\tTemplate = 1,\n\t\t\tChart = 2,\n\t\t}\n\n\t\tpublic enum ReserveLoginStatus\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tGranted = 1,\n\t\t\tTaken = 2\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enumeration for Reset Password Request Status, this is used by both\n\t\t/// a user initiated reset password or the inital user verification to set password.\n\t\t/// </summary>\n\t\tpublic enum ResetPasswordRequestStatus\n\t\t{\n\t\t\tUnChanged = 0,\n\t\t\tChanged = 1,\n\t\t\tPendingVerification = 2,\n\t\t\tVerified = 3,\n\t\t\tApiSecretRequested = 4,\n\t\t\tApiSecretGranted = 5,\n\t\t\tResetAllowed = 6\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Only one unit of date can be input for a retention schedule\n\t\t/// </summary>\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum RetentionUnit\n\t\t{\n\t\t\tDays = 1,\n\t\t\tMonths = 0,\n\t\t\tYears = 2,\n\t\t\tForever = -1,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enumerates the modes of auto-refresh\n\t\t/// </summary>\n\t\tpublic enum RefreshMode\n\t\t{\n\t\t\tDashboard = 0,\n\t\t\tInbox = 1,\n\t\t\tFolder = 2,\n\t\t}\n\t\t/// <summary>\n\t\t/// Enumerates refresh intervals\n\t\t/// Not set will not refresh at all\n\t\t///\n\t\t/// Values are in seconds\n\t\t/// </summary>\n\t\tpublic enum RefreshInterval\n\t\t{\n\t\t\t[Description(\"No Refresh\")]\n\t\t\tNotSet = 0,\n\t\t\t[Description(\"1 minute\")]\n\t\t\tInterval1 = 60000,\n\t\t\t[Description(\"5 minutes\")]\n\t\t\tInterval2 = 300000,\n\t\t\t[Description(\"10 minutes\")]\n\t\t\tInterval3 = 600000,\n\t\t\t[Description(\"30 minutes\")]\n\t\t\tInterval4 = 1800000,\n\t\t}\n\t\t/// <summary>\n\t\t/// The action type for resending an email.\n\t\t/// </summary>\n\t\tpublic enum ResendEmailType\n\t\t{\n\t\t\tApproval = 0,\n\t\t\tExternalReview = 1\n\t\t}\n\n\t\tpublic enum RestTokenType\n\t\t{\n\t\t\tSpringCM_User = 1,\n\t\t\tDocuSign_User = 2,\n\t\t\tDocuSign_Application = 3,\n\t\t\tDocuSign_Resource = 4\n\t\t}\n\n\t\t/// <summary>\n\t\t/// PartySync Email Results Type\n\t\t/// </summary>\n\t\tpublic enum ResultsEmail\n\t\t{\n\t\t\tOnlySuccess,\n\t\t\tOnlyErrors,\n\t\t\tMixedResults,\n\t\t\tNoUpdates\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Acceptable values for the Document State property.\n\t\t/// </summary>\n\t\tpublic enum ReTrialInvitationStatus\n\t\t{\n\t\t\tPending = 0,\n\t\t\tAccepted = 1,\n\t\t\tDeclined = 2\n\t\t}\n\n\t\tpublic enum RevisionContextEnum\n\t\t{\n\t\t\tNone = 0,\n\t\t\tSelectOld = 1,\n\t\t\tSelectNew = 2\n\t\t}\n\n\t\tpublic enum RevisionStatus\n\t\t{\n\t\t\tDefault = 0,\n\t\t\tDeleted = -1 // Indicates the that this revision has been deleted; we don't need to keep the FileData around\n\t\t}\n\n\t\tpublic enum RequestSource\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tSCM = 1,\n\t\t\tSF = 2,\n\t\t\tAPI = 3,\n\t\t\tSFBILLING = 4\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum RoleType\n\t\t{\n\t\t\tSigner = 0,\n\t\t\tElectronicSeal = 1,\n\t\t\tInPersonSigner = 2\n\t\t}\n\n\t\tpublic enum RulesEngineConfigType\n\t\t{\n\t\t\tCustom = 0,\n\t\t\tSystemDefined = 1,\n\t\t}\n\n\t\t#endregion\n\t\t#region S\n\n\t\tpublic enum SAMLNameIdentifierType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tUsername = 1,\n\t\t\tDSUserId = 2,\n\t\t\tEmail = 3\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Product Areas which can be given distinct language settings.\n\t\t/// </summary>\n\t\tpublic enum SettingAuthTier\n\t\t{\n\t\t\t/// <summary>\n\t\t\t/// This setting is the base default for a tiered setting whether at the Default, AccountType, Account, Persona, or User level.\n\t\t\t/// </summary>\n\t\t\tDefault,\n\t\t\t/// <summary>\n\t\t\t/// This setting is for authenticated users whether at the Default, AccountType, Account, Persona or User level.\n\t\t\t/// </summary>\n\t\t\tInternal,\n\t\t\t/// <summary>\n\t\t\t/// This setting is for non-authenticated contexts with an Account context, like Public Share or External Review.\n\t\t\t/// </summary>\n\t\t\tExternal,\n\t\t\t/// <summary>\n\t\t\t/// This setting is for non-authenticated contexts without an account context like Login.\n\t\t\t/// </summary>\n\t\t\tPublic\n\t\t}\n\n\t\tpublic enum SecurityCalcStatus\n\t\t{\n\t\t\tFailure = -1,\n\t\t\tSuccess = 1,\n\t\t\tWaiting = 2\n\t\t}\n\n\t\tpublic enum SignatureAlgorithm\n\t\t{\n\t\t\tnone,\n\t\t\tHS256,\n\t\t\tRSA256\n\t\t}\n\n\t\tpublic enum SourceProductName\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tEsign = 1,\n\t\t\tAdmin = 2,\n\t\t\tCLM = 3,\n\t\t\tGen = 4,\n\t\t\tNegotiate = 5\n\t\t}\n\n\t\tpublic enum SourceIndexType\n\t\t{\n\t\t\tReIndex = 0,\n\t\t\tDocumentChange = 1,\n\t\t\tMetadataChange = 2\n\t\t}\n\n\t\tpublic enum ValidateDocumentReminderStatus\n\t\t{\n\t\t\tInvalidSenderEmail = -13,\n\t\t\tInvalidTemplate = -12,\n\t\t\tInvalidDate = -11,\n\t\t\tDocumentIsTrashed = -10,\n\t\t\tInvalidAdHocEmailRecipient = -9,\n\t\t\tNotAuthorized = -8,\n\t\t\tDuplicateReminder = -7,\n\t\t\tReachedMaxReminders = -6,\n\t\t\tDateInPast = -5,\n\t\t\tMissingRecipient = -4,\n\t\t\tMissingSender = -3,\n\t\t\tMissingName = -2,\n\t\t\tInvalidDocument = -1,\n\t\t\tSuccess = 0,\n\t\t}\n\n\t\t//In anticipation of other types of selections for queries\n\t\tpublic enum CustomReportSelectionType\n\t\t{\n\t\t\tNone,\n\t\t\tMetadata,\n\t\t}\n\n\t\tpublic enum SearchContentFileTypes\n\t\t{\n\t\t\tAll = 0,\n\t\t\tText = 1,\n\t\t\tAudio = 2,\n\t\t\tVideo = 3,\n\t\t\tImage = 4,\n\t\t\tOther = 5\n\t\t}\n\n\t\tpublic enum SearchVersion\n\t\t{\n\t\t\t[Description(\"CLM Search\")]\n\t\t\tCLMSearch = 0,\n\n\t\t\t[Description(\"Modern Search\")]\n\t\t\tModernSearch = 1,\n\t\t}\n\n\t\tpublic enum SFSecurity\n\t\t{\n\t\t\tProfile = 0,\n\t\t\tRole = 1\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum SecurityAccessRuleValidationStatus\n\t\t{\n\t\t\tValid = 0,\n\t\t\tWarning = 1,\n\t\t\tError = 2\n\t\t}\n\n\t\tpublic enum SecurityAccessRuleValidationTrigger\n\t\t{\n\t\t\tNone = 0, // This should signal a full account validation\n\t\t\tGroupDeleted = 1,\n\t\t\tAttributeDeleted = 2,\n\t\t\tPartyDeleted = 3,\n\t\t\tSecurityMetadataDelete = 4,\n\t\t\tMetadataGroupDefinitionDeleted = 5,\n\t\t\tMetadataGroupDefinitionChanged = 6\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum SecurityTypes\n\t\t{\n\t\t\tUnset = 0,\n\t\t\tInheritFromParentFolder = 1,\n\t\t\tNoAccess = 2,\n\t\t\tView = 3,\n\t\t\tViewCreate = 4,\n\t\t\tViewEdit = 5,\n\t\t\tViewEditDelete = 6,\n\t\t\tViewEditDeleteSetAccess = 7,\n\t\t\tCustom = 8\n\t\t}\n\n\t\tpublic enum SecurityItemTable\n\t\t{\n\t\t\tUser = 1,\n\t\t\tFolder = 2,\n\t\t\tFolderRemoveSee = 3,\n\t\t\tDocument = 4\n\t\t}\n\n\t\tpublic enum SecurityLevel\n\t\t{\n\t\t\tNotSet = int.MinValue,\n\t\t\tDeny = 0,\n\t\t\tGrant = 1\n\t\t}\n\t\tpublic enum SecurityModel\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tHierarchical = 1,\n\t\t\tStatic = 2\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum SecurityPrincipalType\n\t\t{\n\t\t\tRole = 0,\n\t\t\tSecurityGroup = 1,\n\t\t\tUser = 2,\n\t\t}\n\n\t\tpublic enum SecurityEvalParallelizationMode\n\t\t{\n\t\t\tParallelForEach,\n\t\t\tThreadPool,\n\t\t\tAsyncTaskList,\n\t\t\tSerial\n\t\t}\n\n\t\tpublic enum SendEmailDocumentAs\n\t\t{\n\t\t\tLink = 1,\n\t\t\tAttachment = 2\n\t\t}\n\n\t\tpublic enum SealDigitalAppType\n\t\t{\n\t\t\tscorecardanalyzer = 1,\n\t\t\tcustom = 2\n\t\t}\n\n\t\tpublic enum ScorecardDatabagDocumentStatus\n\t\t{\n\t\t\tProcessed\n\t\t}\n\n\t\tpublic enum SealLabelExtractionStatus\n\t\t{\n\t\t\tFailed = -2,\n\t\t\tNotApplicable = -1,\n\t\t\tNotExtracted = 0,\n\t\t\tExtracted = 1\n\t\t}\n\n\t\tpublic enum SealScorecardStatus\n\t\t{\n\t\t\tFailed = -2,\n\t\t\tNotApplicable = -1,\n\t\t\tNotExtracted = 0,\n\t\t\tExtracted = 1\n\t\t}\n\n\t\tpublic enum AnalyzerDocumentStatus\n\t\t{\n\t\t\tFailed = -2,\n\t\t\tNotApplicable = -1,\n\t\t\tNotSaved = 0,\n\t\t\tSaved = 1\n\t\t}\n\n\t\tpublic enum ScorecardRiskLevel\n\t\t{\n\t\t\tNA,\n\t\t\tLow,\n\t\t\tMedium,\n\t\t\tHigh\n\t\t}\n\n\t\tpublic enum StagedMetadataStatus\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tVerified = 1,\n\t\t\tUnverified = 2,\n\t\t\tIgnored = 3\n\t\t}\n\n\t\tpublic enum AIExtractionStatus\n\t\t{\n\t\t\t[Description(\"Failed\")]\n\t\t\tFailed = -1,\n\n\t\t\t[Description(\"Unprocessed\")]\n\t\t\tUnProcessed = 0,\n\n\t\t\t[Description(\"Processing\")]\n\t\t\tProcessing = 1,\n\n\t\t\t[Description(\"Unreviewed\")]\n\t\t\tUnReviewed = 2,\n\n\t\t\t[Description(\"Reviewed\")]\n\t\t\tReviewed = 3\n\t\t}\n\n\t\tpublic enum NavigatorAIExtractionStatus\n\t\t{\n\t\t\t[Description(\"None\")]\n\t\t\tNone = -1,\n\n\t\t\t[Description(\"NotStarted\")]\n\t\t\tNotStarted = 0,\n\n\t\t\t[Description(\"InProgress\")]\n\t\t\tInProgress = 1,\n\n\t\t\t[Description(\"Done\")]\n\t\t\tDone = 2,\n\n\t\t\t[Description(\"Skipped\")]\n\t\t\tSkipped = 3,\n\n\t\t\t[Description(\"Failed\")]\n\t\t\tFailed = 7\n\t\t}\n\n\t\tpublic enum AgreementSummaryStatusReasonCode\n\t\t{\n\t\t\t/* Failure Status Updates */\n\t\t\t[Description(\"Callback With Non Retryable Error\")]\n\t\t\tCallbackWithNonRetryableError = -25,\n\n\t\t\t[Description(\"Exceeded Retry Threshold\")]\n\t\t\tExceededRetryThreshold = -24,\n\n\t\t\t[Description(\"Exceeded Processing Threshold\")]\n\t\t\tExceededProcessingThreshold = -23,\n\n\t\t\t[Description(\"Summary Retrieval Error\")]\n\t\t\tRetrievalError = -22,\n\n\t\t\t[Description(\"Summary Initiation Task Failure\")]\n\t\t\tTaskFailure = -21,\n\n\t\t\t[Description(\"Task Queuing Error\")]\n\t\t\tTaskQueuingError = -20,\n\n\t\t\t/* Not Applicable Status Updates */\n\t\t\t[Description(\"File Size Exceeded\")]\n\t\t\tFileSizeExceeded = -12,\n\n\t\t\t[Description(\"PDF Not Available\")]\n\t\t\tPDFUnavailable = -11,\n\n\t\t\t[Description(\"Unsupported Extension\")]\n\t\t\tUnsupported = -10,\n\n\t\t\t/* Unexpected Status Updates  */\n\t\t\t[Description(\"Unexpected Response on Summary Initiation\")]\n\t\t\tUnexpectedResponseOnInitiation = -2,\n\n\t\t\t[Description(\"Unexpected Response on Summary Retrieval\")]\n\t\t\tUnexpectedResponseOnRetrieval = -1,\n\n\t\t\t[Description(\"Unspecified\")]\n\t\t\tUnspecified = 0,\n\n\t\t\t/* Expected Status Updates */\n\t\t\t[Description(\"Retry\")]\n\t\t\tRetry = 1,\n\n\t\t\t[Description(\"Queued For Processing\")]\n\t\t\tQueued = 2,\n\n\t\t\t[Description(\"Callback Complete\")]\n\t\t\tCallback = 3,\n\n\t\t\t[Description(\"Summary Saved\")]\n\t\t\tSummarySaved = 4\n\t\t}\n\n\t\tpublic enum StagedMetadataReviewProcessResultStatus\n\t\t{\n\t\t\tPartyNotFound = -10,\n\t\t\tFailedToUpdateAgreementInAOM = -9,\n\t\t\tDocumentNotFound = -8,\n\t\t\tNoItemsProvided = -7,\n\t\t\tFailedToUpdateStagedMetadata = -6,\n\t\t\tFailedToUpdateMetadata = -5,\n\t\t\tFailedToNormalizeMetadataSelectedValue = -4,\n\t\t\tMetadataFieldNotFound = -3,\n\t\t\tStagedMetadataNotFound = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t}\n\n\t\tpublic enum AIStagedMetadataUpdateType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tMetadataUpdated = 1,\n\t\t\tDocumentRenamed = 2,\n\t\t\tDocumentCheckedIn = 3,\n\t\t\tDocumentEliminated = 4,\n\t\t\tDocumentDeleted = 5,\n\t\t}\n\n\t\tpublic enum SharedStorageUseCase\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tMergeProcess = 1,\n\t\t\tDocCompare = 2,\n\t\t\tExternalReview = 3,\n\t\t\tSfMergeProcess = 4,\n\t\t\tDocPreview = 5\n\t\t}\n\n\t\tpublic enum DataReviewValidationStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t}\n\n\t\tpublic enum DataReviewValidationErrorType\n\t\t{\n\t\t\tIsRequired = -10,\n\t\t\tMaxChars = -9,\n\t\t\tOutsideNumberRange = -8,\n\t\t\tMaxNumber = -7,\n\t\t\tDateMinValue = -6,\n\t\t\tDateMaxValue = -5,\n\t\t\tUnknown = 0,\n\t\t}\n\n\t\tpublic enum WorkerPoolNotifyRecipients\n\t\t{\n\t\t\tAllMembers = 0,\n\t\t\tQueueOwnersOnly = 1,\n\t\t\tNoOne = 2\n\t\t}\n\n\t\t// There are potentially more levels that will be added as needed\n\t\t// These values should be synced with related stored procedures; the sprocs\n\t\t// use the literal values 'Application', 'Default', etc.\n\t\tpublic enum SettingLevel\n\t\t{\n\t\t\tApplication = 0, // No Heirarchy\n\t\t\tDefault = 10,\n\t\t\tAccountType = 15, // ATL-22122 - Do DB work to allow settings to be set on Account Type\n\t\t\tAccount = 20,\n\t\t\tUserAccount = 30,\n\t\t\tPersona = 40\n\t\t}\n\n\t\tpublic enum SortDirection\n\t\t{\n\t\t\tAscending,\n\t\t\tDescending,\n\t\t}\n\n\t\tpublic enum SqlErrorCodes\n\t\t{\n\t\t\tNoLockScanBroken = 601, // See http://support.microsoft.com/kb/815008\n\t\t\tDeadlock = 1205, // See http://www.windowsitpro.com/SQLServer/Articles/ArticleID/8412/pg/2/2.html\n\t\t\tUserDefined = 50000\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum StorageUnit\n\t\t{\n\t\t\tByte = 0,\n\t\t\tKilobyte = 1,\n\t\t\tMegabyte = 2,\n\t\t\tGigabyte = 3\n\t\t}\n\n\t\tpublic enum StartAIBulkAnalysisTransactionsTaskStatus\n\t\t{\n\t\t\tLockedBatch = -6,\n\t\t\tFailedToStartAllSubFolders = -5,\n\t\t\tBatchNotFound = -4,\n\t\t\tNoDocumentFound = -3,\n\t\t\tFailedInsertingAllTransactions = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tBatchInCancelledStatus = 2\n\t\t}\n\n\t\tpublic enum SyncProcessResult\n\t\t{\n\t\t\tError = 0,\n\t\t\tCreated = 1,\n\t\t\tUpdated = 2,\n\t\t\tDeleted = 3,\n\t\t\tNoChange = 4,\n\t\t}\n\n\t\tpublic enum SyncRuleType\n\t\t{\n\t\t\tAttribute = 0,\n\t\t\tFolder = 1\n\t\t}\n\n\t\tpublic enum DeviceApplicationStatus\n\t\t{\n\t\t\t[Description(\"Unknown\")]\n\t\t\tUnknown = -1,\n\t\t\t[Description(\"Active\")]\n\t\t\tActive = 0,\n\t\t\t[Description(\"Revoke Requested\")]\n\t\t\tRevokeRequested = 1,\n\t\t\t[Description(\"Revoke Sent\")]\n\t\t\tRevokeSent = 2,\n\t\t\t[Description(\"Revoked\")]\n\t\t\tRevoked = 3,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Special system folders.  All system folder types\n\t\t/// should be negative numbers.  The Folder stored procs understand\n\t\t/// these as shortcuts, and can lookup the real folder for it.\n\t\t/// The idea here is a special identifier that be used to indicate\n\t\t/// the current user's inbox, without knowing the current user's inbox's\n\t\t/// folderId.\n\t\t/// </summary>\n\t\tpublic enum SystemFolderType\n\t\t{\n\t\t\tNormal = 0, // Not a system folder\n\t\t\tInbox = -1,\n\t\t\tTrash = -2,\n\t\t\tExpired = -3,\n\t\t\tRoot = -4,\n\t\t\tSF = -5,\n\t\t\tFinalizedWorkflows = -6,\n\t\t\tUsers = -7,\n\t\t\t// Case = -8, Retired type. No longer in use.\n\t\t\tEOS = -9, // external objects storage\n\t\t\tAllAccess = -10,\t// replacement for User Home/Inbox folders - single shared location\n\t\t\tStaticSecurity = -11  //Root folder having Static Security\n\t\t}\n\n\t\tpublic enum AllowPasswordLogin\n\t\t{\n\t\t\tNo = -1,\n\t\t\tDefault = 0,\n\t\t\tYes = 1\n\t\t}\n\n\t\tpublic enum SharedStorageOperationType\n\t\t{\n\t\t\tDefault = 0,\n\t\t\tSaveFileFromStream = 1,\n\t\t\tSaveFileFromStreamTtl = 2,\n\t\t\tDeleteFile = 3,\n\t\t\tFileExists = 4,\n\t\t\tGetChunk = 5,\n\t\t\tGetContentLength = 6,\n\t\t\tGetFileStream = 7,\n\t\t\tGetPartialStream =8\n\t\t}\n\n\t\tpublic enum SearchablePdfStatus\n\t\t{\n\t\t\tFailed = -2,\n\t\t\tNotApplicable = -1,\n\t\t\tNotSaved = 0,\n\t\t\tSaved = 1\n\t\t}\n\n\t\t#endregion\n\t\t#region T\n\t\tpublic enum Tabs\n\t\t{\n\t\t\t[Description(\"Default\"), RoleRequired(UserRole.Guest)]\n\t\t\tNone = 0,\n\t\t\t[Description(\"Dashboard\"), RoleRequired(UserRole.Guest)]\n\t\t\tDashboard = 1,\n\t\t\t[Description(\"My Workflows\"), RoleRequired(UserRole.Enhanced_Guest)]\n\t\t\tWorkflow = 2,\n\t\t\t[Description(\"Address Book\"), RoleRequired(UserRole.NotSet)]\n\t\t\tAddressBook = 4, //Obsolete\n\t\t\t[Description(\"Documents\"), RoleRequired(UserRole.Guest)]\n\t\t\tMyDocuments = 5,\n\t\t\t[Description(\"Reports\"), RoleRequired(UserRole.Enhanced_Guest)]\n\t\t\tReports = 6,\n\t\t\t[Description(\"Preferences\"), RoleRequired(UserRole.Guest)]\n\t\t\tMyAccount = 7,\n\t\t\t[Description(\"Meetings\"), RoleRequired(UserRole.NotSet)]\n\t\t\tMeetings = 8, //Obsolete\n\t\t\t[Description(\"Forms\"), RoleRequired(UserRole.Guest)]\n\t\t\tForms = 9,\n\t\t\t[Description(\"Search\"), RoleRequired(UserRole.Guest)]\n\t\t\tSearch = 10,\n\t\t\t//[Description(\"Records\"), RoleRequired(UserRole.Publishing)]\n\t\t\t//Records = 11,\n\t\t\t[Description(\"Dashboard\"), RoleRequired(UserRole.Guest)]\n\t\t\tNewDashboard = 12,\n\t\t\t[Description(\"Tasks\"), RoleRequired(UserRole.Enhanced_Guest)]\n\t\t\tTasks = 13,\n\t\t\t[Description(\"Admin\"), RoleRequired(UserRole.Admin)]\n\t\t\tAdmin = 14,\n\t\t\t[Description(\"Documents\"), RoleRequired(UserRole.Guest)]\n\t\t\tFiles = 15,\n\t\t\t[Description(\"Contacts\"), RoleRequired(UserRole.Enhanced_Guest)]\n\t\t\tContacts = 16,\n\t\t\t[Description(\"Parties\"), RoleRequired(UserRole.Publishing)]\n\t\t\tParties = 17,\n\t\t\t[Description(\"Agreements\"), RoleRequired(UserRole.Guest)]\n\t\t\tAgreements = 18,\n\t\t\t[Description(\"Sitemap\"), RoleRequired(UserRole.Guest)]\n\t\t\tSitemap = 19\n\t\t}\n\n\t\tpublic enum TabVisibility\n\t\t{\n\t\t\tShow = 0,\n\t\t\tMenuOnly = 1,\n\t\t\tHide = 2\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum TaskCompletionResult\n\t\t{\n\t\t\tCompleted,\n\t\t\tNoAccessError,\n\t\t\tAlreadyCompletedError,\n\t\t\tValidationError,\n\t\t\tOtherError\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum TaskManagementGridViews\n\t\t{\n\t\t\tMY_TASKS = 0,\n\t\t\tALL_TASKS = 1,\n\t\t\tTASK_GROUP_TASKS = 2,\n\t\t\tINDIVIDUAL_TASK_GROUP_TASKS = 3,\n\t\t\tMANAGED_USER_TASKS = 4,\n\t\t\tINDIVIDUAL_MANAGED_USER_TASKS = 5,\n\t\t\tORPHANED_TASKS = 6\n\t\t}\n\n\t\tpublic enum TaskInitiator\n\t\t{\n\t\t\tUI = 0,\n\t\t\tWorkflow = 1,\n\t\t\tApi = 2\n\t\t}\n\n\t\tpublic enum CounterType\n\t\t{\n\t\t\tUnkown = 0,\n\t\t\tApiRequests = 1,\n\t\t\tApiByEndpointRequests = 2\n\t\t}\n\n\t\tpublic enum TwoFactorAuthentication\n\t\t{\n\t\t\tDisabled = 1,\n\t\t\tGoogle = 2\n\t\t}\n\n\t\tpublic enum TlsProvider\n\t\t{\n\t\t\tLoadBalancer = 1,\n\t\t\tIIS = 2,\n\t\t\tSelfHost = 3\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum TrackedChangesStatus\n\t\t{\n\t\t\tNotApplicable = -1,\n\t\t\tUnknown = 0,\n\t\t\tNoRevisions = 1,\n\t\t\tRevisionsExist = 2,\n\t\t\tPasswordProtected = 3\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum TrackedContentStatus\n\t\t{\n\t\t\tFailed = -2,\n\t\t\tNotApplicable = -1,\n\t\t\tNotExtracted = 0,\n\t\t\tExtracted = 1\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum TranslationUpdateStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tDownloaded = 0,\n\t\t\tUploaded = 1,\n\t\t\tProcessingUpload = 2,\n\t\t\tImported = 3,\n\t\t\tPublishing = 4,\n\t\t\tPublished = 5\n\t\t}\n\n\t\tpublic enum TranslationUpdateLogAction\n\t\t{\n\t\t\tNoAction = 0,\n\t\t\tAdd = 1,\n\t\t\tEdit = 2,\n\t\t\tDelete = 3\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum TranslationExportFileType\n\t\t{\n\t\t\tXLF = 0,\n\t\t\tCSV = 1\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Int value matters for export/import. Database uses string.\n\t\t/// </summary>\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum TranslationNamespace\n\t\t{\n\t\t\tAll = -1,\n\t\t\tNone = 0,\n\t\t\tAttributes = 1,\n\t\t\tDocumentGeneration = 2\n\t\t}\n\n\t\t[EnumJavaScriptResource(true)]\n\t\t[JsonConverter(typeof(StringEnumConverter))]\n\t\tpublic enum TimeUnit\n\t\t{\n\t\t\tDays = 1,\n\t\t\tWeeks = 2,\n\t\t\tMonths = 3,\n\t\t\tYears = 4\n\t\t}\n\n\t\t#endregion\n\t\t#region U\n\n\t\tpublic enum UpdateBatchStatus\n\t\t{\n\t\t\tFailed = -2,\n\t\t\tBatchNotFound = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tEmptyBatchName = 2\n\t\t}\n\n\t\t/// <summary>\n\t\t/// DO NOT USE Enums.UserRole.ToString()  Use Enums.GetName instead.\n\t\t/// This allows us to play with the Enums.UserRole names without having to\n\t\t/// redo large portions of code all the time.\n\t\t///\n\t\t/// NOTE: EntitySelectionAttribute (and maybe others?) relies on the fact that roles with more privs have a\n\t\t///\t      lower number.\n\t\t///\n\t\t/// NOTE: SalesforceUserSync uses TryGetValueFromDescription() below to get enum from description attribute value\n\t\t/// </summary>\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum UserRole\n\t\t{\n\t\t\tNotSet = int.MinValue,\n\t\t\tDeleted = -1,\n\t\t\tPrimary = 0, // Super Admin\n\t\t\tAdmin = 1, // User Admin\n\t\t\tPublishing = 2, // Full Subscriber\n\t\t\tEnhanced_Guest = 4, // Limited Subscriber\n\t\t\tGuest = 99, // Guest\n\t\t}\n\n\t\tpublic enum UserRoleNameType\n\t\t{\n\t\t\tClassic = 0,\n\t\t\tCLM = 1,\n\t\t\tMixedMode = 2\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Status of Uploads\n\t\t/// </summary>\n\t\tpublic enum UploadStatus\n\t\t{\n\t\t\tFailure = 0,\n\t\t\tSuccess = 1,\n\t\t\tInProgress = 2\n\t\t}\n\n\t\tpublic enum UriType\n\t\t{\n\t\t\tSearch,\n\t\t\tRegular,\n\t\t\tBaseCollection\n\t\t}\n\n\t\tpublic enum RequestOriginListType\n\t\t{\n\t\t\tBlacklist = 1,\n\t\t\tWhitelist = 2\n\t\t}\n\n\t\tpublic enum RequestOriginRestrictionTarget\n\t\t{\n\t\t\tClickjackProtection = 1\n\t\t}\n\n\t\tpublic enum UserConsentType\n\t\t{\n\t\t\tIdeasPortal\n\t\t}\n\n\t\tpublic enum UxIconset\n\t\t{\n\t\t\tNone = 0,\n\t\t\tUX,\n\t\t\tAtlas,\n\t\t\tFiletypes,\n\t\t\tPrism,\n\t\t\tNorthstar\n\t\t}\n\n\t\tpublic enum UpsertRuleModelAndMappingResultStatus\n\t\t{\n\t\t\tMappingUidNotSpecified = -4,\n\t\t\tRuleModelUidNotSpecified = -3,\n\t\t\tRulesConfigInUse = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum UpsertGroupMappingResultStatus\n\t\t{\n\t\t\tRulesConfigNotFound = -3,\n\t\t\tRulesConfigInUse = -2,\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum UpsertRulesConfigErrorType\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tRulesConfigWithNameAlreadyExists = 1,\n\t\t\tEmptyRulesConfigName = 2,\n\t\t\tRulesConfigInUse = 3,\n\t\t\tRulesConfigNotFound = 4\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum UserGroupMigrationStatus\n\t\t{\n\t\t\tFailure = -1,\n\t\t\tNotSet = 0,\n\t\t\tInProgress = 2,\n\t\t\tDsMappingComplete = 3,\n\t\t\tComplete = 4,\n\t\t\tRollback = 5\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum UserGroupMigrationUserType\n\t\t{\n\t\t\tSfdc = 1, // SFDC Users\n\t\t\tClm = 2   //CLM only users\n\t\t}\n\n\t\tpublic enum UnifiedRepositoryIngestionReason\n\t\t{\n\t\t\tUnknown = 0,\n\t\t\tAttributeUpdated = 1,\n\t\t\tDocumentSigned = 2\n\t\t}\n\n\t\tpublic enum UnifiedRepositoryIngestionStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tInProgress = 2,\n\t\t\tNotEnabled = 3,\n\t\t\tDocumentNotIngestedInDms = 4,\n\t\t\tInValidDocumentVersionFound = 5,\n\t\t\tDmsWritesNotEnabled = 6,\n\t\t\tDocumentExtensionNotSupportedForIAMIngestion = 8,\n\t\t\tDocumentCopyProcessFailed = 9,\n\t\t\tUnlock = 10,\n\t\t\tFailedAfterUnlockMaxAttemptsReached = 11,\n\t\t\tInProgressHistoricalIngestionIsNotEnabled = 12,\n\t\t\tCompletionAttributeNotDefined = 13,\n\t\t\tDocumentNotFound = 14,\n\t\t\tFileDataNotFound = 15\n\t\t}\n\n\t\tpublic enum UnifiedRepositoryAttributeSyncStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t}\n\n\t\tpublic enum UnifiedRepositoryHistorySyncStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tHistorySyncDisabled = 2\n\t\t}\n\n\t\tpublic enum UnifiedRepositoryDmsMetadataCreationStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t}\n\n\t\tpublic enum UnifiedRepositoryDeletionStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tDeleted = 1,\n\t\t}\n\n\t\tpublic enum UnifiedRepositoryDocumentMoveProcessingStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccessDeletedFromUr = 1,\n\t\t\tSuccessQueuedForIngestion = 2,\n\t\t\tNotEnabled = 3,\n\t\t\tNotSupported = 4,\n\t\t\tNotCompleted = 5,\n\t\t\tAlreadyDeletedInUr = 6,\n\t\t\tNotPreviouslyCompleted = 7,\n\t\t\tNotUrDeleted = 8,\n\t\t\tNotFound = 9,\n\t\t\tUnableToTakeReservation = 10,\n\t\t}\n\n\t\tpublic enum DMSRuntimeSyncProcessingStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tNotEnabled = 2,\n\t\t\tNotFound = 3,\n\t\t\tNotApplicable = 4,\n\t\t\tUnableToTakeReservation = 5,\n\t\t}\n\n\t\tpublic enum UnifiedRepositoryFolderMoveProcessingStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tNotEnabled = 2,\n\t\t\tNoFolder = 3,\n\t\t\tUnableToTakeReservation = 4,\n\t\t}\n\n\t\t#endregion\n\t\t#region V\n\t\t/// <summary>\n\t\t/// These are virtual folders in the tree hierarchy.  They do not belong in the SystemFolderType enumeration\n\t\t/// though, because the sprocs don't know about them.  However, these values should probably not conflict with\n\t\t/// the values in SystemFolderType, so we start at -1000 and go lower.\n\t\t/// </summary>\n\t\tpublic enum VirtualFolderType\n\t\t{\n\t\t\tNormal = 0,\n\t\t\tRecentlyAccessedDocuments = -1000,\n\t\t\tLastSearchResults = -1001,\n\t\t\tError = -1002,\n\t\t\tRecordsRoot = -1003,\n\t\t}\n\n\t\tpublic enum ValidationTypes\n\t\t{\n\t\t\tEmail,\n\t\t\tPhoneNumber,\n\t\t\tURL,\n\t\t\tRegex\n\t\t}\n\t\t#endregion\n\n\t\t#region W\n\n\t\tpublic enum SealProcessingStatus\n\t\t{\n\t\t\tDocumentFailed = -5,\n\t\t\tJobFailed = -4,\n\t\t\tFileNotSupported = -3,\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1,\n\t\t\tStarted = 2\n\t\t}\n\n\t\tpublic enum SealScorecardProcessingStatus\n\t\t{\n\t\t\tExtractionsNotFound = -6,\n\t\t\tInvalidTaskDetails = -5,\n\t\t\tFileNotSupported = -4,\n\t\t\tDigitalAppNotFound = -3,\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1,\n\t\t\tStarted = 2,\n\t\t}\n\n\t\tpublic enum SealGetDatabagProcessingStatus\n\t\t{\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1,\n\t\t\tNoSealBaseUrl = 2,\n\t\t\tNativeFileSizeGreaterThanMax = 3,\n\t\t}\n\n\t\tpublic enum ClauseSmartContractProcessingStatus\n\t\t{\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1,\n\t\t\tUserNotFound = 2,\n\t\t\tDocumentNotFound = 3,\n\t\t\tContractAlreadySigned = 4,\n\t\t\tClauseOrganizationNotFound = 5,\n\t\t\tTemplateParameterNotFound = 6,\n\t\t\tUnableToParseTemplateParameterValue = 7\n\t\t}\n\n\t\tpublic enum TrackedContentExtractionProcessingStatus\n\t\t{\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1,\n\t\t\tNativeFileSizeGreaterThanMax = 2,\n\t\t}\n\n\t\tpublic enum SfEmailProcessingStatus\n\t\t{\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1\n\t\t}\n\n\t\tpublic enum CommentsReconcileProcessingStatus\n\t\t{\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1,\n\t\t\tDocumentNotFound = 2,\n\t\t\tCommentSelectionsNotFound = 3,\n\t\t\tWaitingForPreviousReconcileTask = 4,\n\t\t}\n\n\t\tpublic enum GlyphReconciliationStatus\n\t\t{\n\t\t\tUnknown = -2,\n\t\t\tFailed = -1,\n\t\t\tPending = 0,\n\t\t\tSuccess = 1,\n\t\t\tNotApplicable = 2,\n\t\t\tDocumentNotFound = 3,\n\t\t\tInvalidSelectionType = 4\n\t\t}\n\n\t\tpublic enum GlyphExtractionTaskStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnknown = 0,\n\t\t\tSuccess = 1,\n\t\t\tWaitingForPdfCreation = 2,\n\t\t\tWaitingForTransientPdf = 3,\n\t\t\tWaitingForReservation = 4\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum NpsSurveySetting\n\t\t{\n\t\t\tDisable = 0,\n\t\t\tEnable = 1,\n\t\t\tDebug = 2\n\t\t}\n\n\t\tpublic enum WorkflowEngine\n\t\t{\n\t\t\tNone = 0,\n\t\t\tLegacyWasScarry = 1,\t\t// Boo!\n\t\t\tWINS = 2,\t\t\t// Yay!\n\t\t\tDefault = None\n\t\t}\n\n\t\tpublic enum WorkflowParentStatus\n\t\t{\n\t\t\tNone = 0,\n\t\t\tFailed = 1,\n\t\t\tAborted = 2,\n\t\t\tSuspended = 3\n\t\t}\n\n\t\tpublic enum WorkflowParseStatus\n\t\t{\n\t\t\tFailed = -1,\n\t\t\tUnparsed = 0,\n\t\t\tLiteral,\n\t\t\tExpression\n\t\t}\n\n\t\tpublic enum WorkflowRevisionStatus\n\t\t{\n\t\t\tDeleted = -1,\n\t\t\tUnpublished = 0,\n\t\t\tPublished = 1,\n\t\t\tSuspended = 2,\n\t\t}\n\n\t\tpublic enum WorkflowDefinitionType\n\t\t{\n\t\t\tUser = 0,\n\t\t\tPredefined = 1\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum DateRangeType\n\t\t{\n\t\t\tToday = 0,\n\t\t\tLastWeek = 1,\n\t\t\tThisWeek = 2,\n\t\t\tLastMonth = 3,\n\t\t\tThisMonth = 4,\n\t\t\tLastYear = 5,\n\t\t\tThisYear = 6,\n\t\t\tRolling = 7,\n\t\t\tCustom = 8,\n\t\t\tAllTime = 9,\n\t\t\tBeforeToday = 10,\n\t\t\tYearToDate = 11 // ThisYear except future\n\t\t}\n\n\t\t[EnumJavaScriptResource(false)]\n\t\tpublic enum WorkflowStatus\n\t\t{\n\t\t\tAborted = 0,\n\t\t\tExecuting = 1,\n\t\t\tCompleted = 2,\n\t\t\tFailed = 3,\n\t\t\tPaused = 4\n\t\t}\n\n\t\t// Used for approval workflows\n\t\tpublic enum WorkFlowStepActionType\n\t\t{\n\t\t\tEdit = 1,\n\t\t\tApprove = 2,\n\t\t\tUpdateVariable = 3,\n\t\t\tFinalize = 10\n\t\t}\n\n\t\tpublic enum WorkflowVariableType\n\t\t{\n\t\t\tUnknown = -1,\n\t\t\tString = 0,\n\t\t\tNumber = 1,\n\t\t\tDate = 2,\n\t\t\tList = 3,\n\t\t\tUser = 4,\n\t\t\tXml = 5,\n\t\t\tGuid = 6,\n\t\t}\n\n\t\tpublic enum WorkflowComment\n\t\t{\n\t\t\t[Description(\"Yes\")]\n\t\t\tYes = 0,\n\t\t\t[Description(\"No\")]\n\t\t\tNo = 1,\n\t\t\t[Description(\"Required\")]\n\t\t\tRequired = 2,\n\n\t\t\t//Existing workflows have true/false values\n\t\t\tTrue = Yes,\n\t\t\tFalse = No,\n\t\t}\n\n\t\tpublic enum WopiActionType\n\t\t{\n\t\t\tview,\n\t\t\tedit,\n\t\t\teditnew,\n\t\t\tconvert,\n\t\t\tgetinfo,\n\t\t\tinteractivepreview,\n\t\t\tmobileView,\n\t\t\tembedview,\n\t\t\tembededit,\n\t\t\timagepreview,\n\t\t\tformsubmit,\n\t\t\tformedit,\n\t\t\trest,\n\t\t\tpresent,\n\t\t\tpresentservice,\n\t\t\tattend,\n\t\t\tattendservice,\n\t\t\tsyndicate,\n\t\t\tlegacywebservice,\n\t\t\trtc,\n\t\t\tpreloadedit,\n\t\t\tpreloadview,\n\t\t\tcollab\n\t\t}\n\n\t\tpublic enum WopiRequirement\n\t\t{\n\t\t\tupdate,\n\t\t\tlocks,\n\t\t\tcobalt,\n\t\t\tcontainers\n\t\t}\n\n\t\tpublic enum WopiExtension\n\t\t{\n\t\t\tnone,\n\t\t\tods,\n\t\t\txls,\n\t\t\txlsb,\n\t\t\txlsm,\n\t\t\txlsx,\n\t\t\tone,\n\t\t\tonetoc2,\n\t\t\todp,\n\t\t\tpot,\n\t\t\tpotm,\n\t\t\tpotx,\n\t\t\tpps,\n\t\t\tppsm,\n\t\t\tppsx,\n\t\t\tppt,\n\t\t\tpptm,\n\t\t\tpptx,\n\t\t\tdoc,\n\t\t\tdocm,\n\t\t\tdocx,\n\t\t\tdot,\n\t\t\tdotm,\n\t\t\tdotx,\n\t\t\todt,\n\t\t\tpdf,\n\t\t\tonepkg,\n\t\t\twopitest,\n\t\t\tcsv\n\t\t}\n\n\t\tpublic enum WopiPlaceholderType\n\t\t{\n\t\t\tUNSUPPORTED,\n\t\t\tBUSINESS_USER,\n\t\t\tDC_LLCC,\n\t\t\tDISABLE_ASYNC,\n\t\t\tDISABLE_BROADCAST,\n\t\t\tEMBEDDED,\n\t\t\tFULLSCREEN,\n\t\t\tPERFSTATS,\n\t\t\tRECORDING,\n\t\t\tTHEME_ID,\n\t\t\tUI_LLCC\n\t\t}\n\n\t\tpublic enum WopiApp\n\t\t{\n\t\t\tExcel,\n\t\t\tOneNote,\n\t\t\tPowerPoint,\n\t\t\tVisio,\n\t\t\tWopiTest,\n\t\t\tWord,\n\t\t\tWordPdf\n\t\t}\n\n\t\tpublic enum RequestType\n\t\t{\n\t\t\tNone,\n\n\t\t\tCheckFileInfo,\n\t\t\tPutRelativeFile,\n\n\t\t\tLock,\n\t\t\tUnlock,\n\t\t\tRefreshLock,\n\t\t\tUnlockAndRelock,\n\t\t\tGetLock, //not yet used but will be added according to WOPI documentation\n\n\t\t\tExecuteCobaltRequest,\n\n\t\t\tDeleteFile,\n\t\t\tReadSecureStore,\n\t\t\tGetRestrictedLink,\n\t\t\tRevokeRestrictedLink,\n\n\t\t\tCheckFolderInfo,\n\n\t\t\tGetFile,\n\t\t\tPutFile,\n\t\t\tRenameFile,\n\t\t\tPutUserInfo,\n\t\t\tEnumerateAncestors,\n\t\t}\n\n\t\t#endregion\n\n\n\t\t#region WINS\n\t\t// workflow engine\n\n\t\t///<summary>\n\t\t/// This list is used for the status of both\n\t\t/// a workflow instance and a workflow step within such\n\t\t///</summary>\n\t\tpublic enum WorkflowStepStatus\n\t\t{\n\t\t\t[StringValue(\"Execution Pending\")]\n\t\t\tPending = 0,\t// -- 0: Pending start / unstarted\n\t\t\t[StringValue(\"Executing\")]\n\t\t\tExecuting = 1,\t// -- 1: Executing / in progress\n\t\t\t[StringValue(\"Waiting\")]\n\t\t\tWaiting = 2,\t// -- 2: Waiting\n\t\t\t[StringValue(\"Completed\")]\n\t\t\tCompleted = 3,\t// -- 3: Completed successfully\n\t\t\t[StringValue(\"Paused\")]\n\t\t\tPaused = 4,\t\t// -- 4: Paused\n\t\t\t[StringValue(\"Failed\")]\n\t\t\tFailed = -1,\t// -- -1: Failed with errors\n\t\t\t[StringValue(\"Aborted\")]\n\t\t\tAborted = -2,\t// -- -2: Aborted / killed\n\t\t}\n\n\t\tpublic enum WorkflowStepActivityStatus\n\t\t{\n\t\t\tWaitingAssigned = 0,\t\t// -- 0: Waiting, assigned (AssignedUserAccountUid must be non-NULL)\n\t\t\tWaitingUnassigned = 1,\t\t// -- 1: Waiting, unassigned (AssignedUserAccountUid must be NULL, SecurityGroupId must be non-NULL)\n\t\t\tOwnership = 2,\t\t\t\t// -- 2: Ownership / work started (we do not currently use this, but may in the future)\n\t\t\tCompletedByUser = 3,\t\t// -- 3: Completed by user\n\t\t\tCompletedByStep = 4,\t\t// -- 4: Completed by step (eg, if three people were assigned to a step, you get three activity records;\n\t\t\t//\t\t\tif the step completes after only one is done, the other two would receive this status)\n\t\t\tIncomplete = 5, // -- 5: Work not completed due to rate limiting\n\t\t\tInvalid = 6, // -- 6: Item invalid, should not be processed\n\t\t}\n\n\t\tpublic enum WorkflowAbortNotificationType\n\t\t{\n\t\t\tNone,\n\t\t\tFiftyPercent,\n\t\t\tTwentyFivePercent,\n\t\t\tTenPercent,\n\t\t\tOneMonth,\n\t\t\tOneWeek,\n\t\t\tOneDay\n\t\t}\n\n\t\tpublic enum WorkflowThrottledStatus\n\t\t{\n\t\t\tNotThrottled = 0,\n\t\t\tThrottledDueToExpressionRateLimit = 1,\n\t\t\tThrottledDueToSmallBenRateLimit = 2,\n\t\t}\n\n\t\t#endregion WINS\n\n\t\t#region XY\n\n\t\tpublic enum XMLDataSource\n\t\t{\n\t\t\tDocument = 0,\n\t\t\tDocumentContent = 1,\n\t\t\tFolder = 2,\n\t\t\tString = 3,\n\t\t\tSharedStorage = 4\n\t\t}\n\n\t\tpublic enum YesNoDefault\n\t\t{\n\t\t\tYes = 1,\n\t\t\tNo = 0,\n\t\t\tDefault = -1\n\t\t}\n\n\t\tpublic enum DefaultDocumentsView\n\t\t{\n\t\t\tGrid = 0,\n\t\t\tTiles = 1\n\t\t}\n\n\t\t#endregion\n\n\t\t#region helper functions\n\n\t\tpublic const string ENUM_RESOURCE_FORMAT = \"enum_{0}_{1}\"; // 0 is the name of the enum 1 is a member: enum_YesNoDefault_Yes\n\t\t/// <summary>\n\t\t/// Returns the string defined in the given resource manager as \"enum_EnumName_FieldName\". For example \"enum_UserRole_Primary\".\n\t\t/// Falls back to GetName(Enum).\n\t\t/// </summary>\n\t\tpublic static string GetLocalizedName(Enum e, ResourceManager rm)\n\t\t{\n\t\t\tstring enumResourceKeyName = string.Format(ENUM_RESOURCE_FORMAT, e.GetType().Name, e);\n\t\t\tstring loc = null;\n\t\t\tif (null != rm)\n\t\t\t{\n\t\t\t\tloc = rm.GetString(enumResourceKeyName);\n\t\t\t}\n\t\t\tif (string.IsNullOrEmpty(loc))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// Other projects (reporting) can't really reference these resources, so the attempt will throw. We silently ignore it\n\t\t\t\t\t// and let it fall through and pick up the string from the description attribute of the enum.\n\t\t\t\t\tloc = Resources.CoreTypes.ResourceManager.GetString(enumResourceKeyName);\n\t\t\t\t}\n\t\t\t\tcatch\n\t\t\t\t{\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif (!string.IsNullOrEmpty(loc))\n\t\t\t\treturn loc;\n\n\t\t\t// Just adding a track of the enums not found, we should check the logs for '[I18N|Error]' instances\n\t\t\t// Default File: wherever/san/logs/atlas/{MachineName}/app.txt\n\t\t\t_log.WarnNoPII(\"[I18N|Error] EnumLocalizedName not found: \" + enumResourceKeyName);\n\t\t\treturn GetName(e);\n\t\t}\n\n\t\t//////public static SortedList<string, int> GetLocalizedNames(Type enumType, ResourceManager rm)\n\t\t//////{\n\t\t//////    SortedList<string, int> nv = new SortedList<string, int>();\n\t\t//////    MemberInfo[] members = enumType.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static);\n\t\t//////    for(int ndx = 0; ndx < members.Length; ndx++)\n\t\t//////    {\n\t\t//////        Enum e = (Enum) Enum.Parse(enumType, members[ndx].Name);\n\t\t//////        nv.Add(GetLocalizedName(e, rm), Convert.ToInt32(e));\n\t\t//////    }\n\t\t//////    return nv;\n\t\t//////}\n\n\t\t/// <summary>\n\t\t/// Returns a sorted list all the constants defined in an enum. The key is the name, on which it is sorted\n\t\t/// and the value is the int for the constant.\n\t\t/// Can filter the return list on the enum value based on the predicate.\n\t\t/// Good for drop down list on the UI\n\t\t/// </summary>\n\t\tpublic static SortedList<string, int> GetLocalizedNames(Type enumType, ResourceManager rm, Func<int, bool> predicate = null)\n\t\t{\n\t\t\tSortedList<string, int> nv = new SortedList<string, int>();\n\t\t\tMemberInfo[] members = enumType.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static);\n\t\t\tfor (int ndx = 0; ndx < members.Length; ndx++)\n\t\t\t{\n\t\t\t\tEnum e = (Enum)Enum.Parse(enumType, members[ndx].Name);\n\t\t\t\tint intval = Convert.ToInt32(e);\n\t\t\t\tif (null != predicate && !predicate.Invoke(intval))\n\t\t\t\t\tcontinue;\n\t\t\t\tnv.Add(GetLocalizedName(e, rm), intval);\n\t\t\t}\n\t\t\treturn nv;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Use reflection to find if the Description attribute was made for this enum value.\n\t\t/// If one exists, return that value.  This is what allows us to rename Enums.UserRole\n\t\t/// members willynilly.\n\t\t/// If none exists, then we return the simple ToString.\n\t\t/// </summary>\n\t\tpublic static string GetName(Enum e)\n\t\t{\n\t\t\t// Use reflection to find the appropriate Description attribute.\n\t\t\t// If no description attribute exists, just return role.ToString().\n\t\t\t// Concept taken from here: http://blogs.msdn.com/abhinaba/archive/2005/10/20/483000.aspx\n\t\t\tMemberInfo[] memInfo = e.GetType().GetMember(e.ToString());\n\t\t\tif (memInfo != null && memInfo.Length > 0)\n\t\t\t{\n\t\t\t\tobject[] attrs = memInfo[0].GetCustomAttributes(typeof(DescriptionAttribute), false);\n\t\t\t\tif (attrs != null && attrs.Length > 0) return ((DescriptionAttribute)attrs[0]).Description;\n\t\t\t}\n\n\t\t\treturn e.ToString();\n\t\t}\n\n\t\tpublic static Dictionary<UserRoleNameType, List<string>> GetAllRoleStrings()\n\t\t{\n\t\t\tvar dictionary = new Dictionary<UserRoleNameType, List<string>>();\n\t\t\tdictionary.Add(UserRoleNameType.Classic, ClassicUserRoleStrings().Values.ToList());\n\t\t\tdictionary.Add(UserRoleNameType.CLM, ClmUserRoleStrings().Values.ToList());\n\t\t\treturn dictionary;\n\t\t}\n\n\t\tpublic static string GetUserRoleString(UserRole userRole, UserRoleNameType nameType, CultureInfo cultureInfo = null)\n\t\t{\n\t\t\tDictionary<UserRole, string> dictionary = new Dictionary<UserRole, string>();\n\t\t\tswitch (nameType)\n\t\t\t{\n\t\t\t\tcase UserRoleNameType.Classic:\n\t\t\t\t\tdictionary = ClassicUserRoleStrings(cultureInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase UserRoleNameType.CLM:\n\t\t\t\t\tdictionary = ClmUserRoleStrings(cultureInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase UserRoleNameType.MixedMode:\n\t\t\t\t\tdictionary = ClmMixedModeUserRoleStrings(cultureInfo);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dictionary.ContainsKey(userRole))\n\t\t\t{\n\t\t\t\treturn dictionary[userRole];\n\t\t\t}\n\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\tpublic static string GetUserRoleStringPlural(UserRole userRole, UserRoleNameType nameType)\n\t\t{\n\t\t\tDictionary<UserRole, string> dictionary = new Dictionary<UserRole, string>();\n\t\t\tswitch (nameType)\n\t\t\t{\n\t\t\t\tcase UserRoleNameType.Classic:\n\t\t\t\t\tdictionary = ClassicUserRoleStringsPlural();\n\t\t\t\t\tbreak;\n\t\t\t\tcase UserRoleNameType.CLM:\n\t\t\t\t\tdictionary = ClmUserRoleStringsPlural();\n\t\t\t\t\tbreak;\n\t\t\t\tcase UserRoleNameType.MixedMode:\n\t\t\t\t\tdictionary = ClmMixedModeUserRoleStringsPlural();\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dictionary.ContainsKey(userRole))\n\t\t\t{\n\t\t\t\treturn dictionary[userRole];\n\t\t\t}\n\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\tprivate static Dictionary<UserRole, string> ClassicUserRoleStrings(CultureInfo cultureInfo = null)\n\t\t{\n\t\t\treturn new Dictionary<UserRole, string>\n\t\t\t{\n\t\t\t\t{UserRole.Primary, Resources.CoreTypes.ResourceManager.GetString(\"ClassicPrimery\", cultureInfo ?? CultureInfo.CurrentUICulture) },\n\t\t\t\t{UserRole.Admin, Resources.CoreTypes.ResourceManager.GetString(\"ClassicAdmin\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Publishing, Resources.CoreTypes.ResourceManager.GetString(\"ClassicPublishing\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Enhanced_Guest, Resources.CoreTypes.ResourceManager.GetString(\"ClassicEnhancedGuest\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Guest, Resources.CoreTypes.ResourceManager.GetString(\"ClassicGuest\", cultureInfo ?? CultureInfo.CurrentUICulture)}\n\t\t\t};\n\t\t}\n\n\t\tprivate static Dictionary<UserRole, string> ClmUserRoleStrings(CultureInfo cultureInfo = null)\n\t\t{\n\t\t\treturn new Dictionary<UserRole, string>\n\t\t\t{\n\t\t\t\t{UserRole.Primary, Resources.CoreTypes.ResourceManager.GetString(\"CLMPrimery\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Publishing, Resources.CoreTypes.ResourceManager.GetString(\"CLMPublishing\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Guest, Resources.CoreTypes.ResourceManager.GetString(\"CLMGuest\", cultureInfo ?? CultureInfo.CurrentUICulture)}\n\t\t\t};\n\t\t}\n\n\t\tprivate static Dictionary<UserRole, string> ClmMixedModeUserRoleStrings(CultureInfo cultureInfo = null)\n\t\t{\n\t\t\treturn new Dictionary<UserRole, string>\n\t\t\t{\n\t\t\t\t{UserRole.Primary, Resources.CoreTypes.ResourceManager.GetString(\"CLMPrimery\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Admin, Resources.CoreTypes.ResourceManager.GetString(\"ClassicAdmin\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Publishing, Resources.CoreTypes.ResourceManager.GetString(\"CLMPublishing\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Enhanced_Guest, Resources.CoreTypes.ResourceManager.GetString(\"ClassicEnhancedGuest\", cultureInfo ?? CultureInfo.CurrentUICulture)},\n\t\t\t\t{UserRole.Guest, Resources.CoreTypes.ResourceManager.GetString(\"CLMGuest\", cultureInfo ?? CultureInfo.CurrentUICulture)}\n\t\t\t};\n\t\t}\n\n\t\tprivate static Dictionary<UserRole, string> ClassicUserRoleStringsPlural()\n\t\t{\n\t\t\treturn new Dictionary<UserRole, string>\n\t\t\t{\n\t\t\t\t{UserRole.Primary, Resources.CoreTypes.ClassicPrimeryPlural},\n\t\t\t\t{UserRole.Admin, Resources.CoreTypes.ClassicAdminPlural},\n\t\t\t\t{UserRole.Publishing, Resources.CoreTypes.ClassicPublishingPlural},\n\t\t\t\t{UserRole.Enhanced_Guest, Resources.CoreTypes.ClassicEnhancedGuestPlural},\n\t\t\t\t{UserRole.Guest, Resources.CoreTypes.ClassicGuestPlural}\n\t\t\t};\n\t\t}\n\n\t\tprivate static Dictionary<UserRole, string> ClmUserRoleStringsPlural()\n\t\t{\n\t\t\treturn new Dictionary<UserRole, string>\n\t\t\t{\n\t\t\t\t{UserRole.Primary, Resources.CoreTypes.CLMPrimeryPlural},\n\t\t\t\t{UserRole.Publishing, Resources.CoreTypes.CLMPublishingPlural},\n\t\t\t\t{UserRole.Guest, Resources.CoreTypes.CLMGuestPlural}\n\t\t\t};\n\t\t}\n\n\t\tprivate static Dictionary<UserRole, string> ClmMixedModeUserRoleStringsPlural()\n\t\t{\n\t\t\treturn new Dictionary<UserRole, string>\n\t\t\t{\n\t\t\t\t{UserRole.Primary, Resources.CoreTypes.CLMPrimeryPlural},\n\t\t\t\t{UserRole.Admin, Resources.CoreTypes.ClassicAdminPlural},\n\t\t\t\t{UserRole.Publishing, Resources.CoreTypes.CLMPublishingPlural},\n\t\t\t\t{UserRole.Enhanced_Guest, Resources.CoreTypes.ClassicEnhancedGuestPlural},\n\t\t\t\t{UserRole.Guest, Resources.CoreTypes.CLMGuestPlural}\n\t\t\t};\n\t\t}\n\n\t\tpublic static ActionType[] DocumentActionTypes = {\n\t\t\tActionType.AddWatchedDocuments,\n#pragma warning disable CS0618 // Type or member is obsolete\n\t\t\tActionType.AdvancedMarkup,\n#pragma warning restore CS0618 // Type or member is obsolete\n#pragma warning disable CS0618 // Type or member is obsolete\n\t\t\tActionType.AdvancedMarkupCreated,\n#pragma warning restore CS0618 // Type or member is obsolete\n#pragma warning disable CS0618 // Type or member is obsolete\n\t\t\tActionType.AdvancedMarkupUpdated,\n#pragma warning restore CS0618 // Type or member is obsolete\n\t\t\tActionType.ApprovalCanceledByUser,\n\t\t\tActionType.ApprovalCheckout,\n\t\t\tActionType.ApprovalCheckoutCanceled,\n\t\t\tActionType.ApprovalWorkflowInitiated,\n\t\t\tActionType.BPMWorkflowProcess,\n\t\t\tActionType.ChatterWorker,\n\t\t\tActionType.CheckinReassigned,\n\t\t\tActionType.CollaborationCheckout,\n\t\t\tActionType.CompletedHumanActivity,\n\t\t\tActionType.DocumentAccessJustification,\n\t\t\tActionType.DocumentActionPublish,\n\t\t\tActionType.DocumentAdded,\n\t\t\tActionType.DocumentAddedAsCopy,\n\t\t\tActionType.DocumentCheckIn,\n\t\t\tActionType.DocumentCopied,\n\t\t\tActionType.DocumentDeleted,\n\t\t\tActionType.DocumentEditInBrowserAutosave,\n\t\t\tActionType.DocumentEditInBrowserLock,\n\t\t\tActionType.DocumentEditInBrowserUnlock,\n\t\t\tActionType.DocumentExportToSalesforce,\n\t\t\tActionType.DocumentImportFromSalesforce,\n\t\t\tActionType.DocumentMoved,\n\t\t\tActionType.DocumentOpenWithGoogleDocs,\n\t\t\tActionType.DocumentReminderAdHocEmailIgnored,\n\t\t\tActionType.DocumentReminderContactIgnored,\n\t\t\tActionType.DocumentReminderDeleted,\n\t\t\tActionType.DocumentReminderDeletedContactIgnored,\n\t\t\tActionType.DocumentReminderGroupIgnored,\n\t\t\tActionType.DocumentReminderNoRecipients,\n\t\t\tActionType.DocumentReminderProcessed,\n\t\t\tActionType.DocumentReminderScheduled,\n\t\t\tActionType.DocumentReminderUpdated,\n\t\t\tActionType.DocumentSaveFromGoogleDocs,\n\t\t\tActionType.DocumentSent,\n\t\t\tActionType.DocumentShareDeleted,\n\t\t\tActionType.DocumentSupersede,\n\t\t\tActionType.DocumentTypeChanged,\n\t\t\tActionType.DocumentUndoCheckout,\n\t\t\tActionType.DocumentUndoOpenWithGoogleDocs,\n\t\t\tActionType.DocumentViaEchoSignAction,\n\t\t\tActionType.DownloadNative,\n\t\t\tActionType.DownloadPDF,\n\t\t\tActionType.DuplicateHandlingRename,\n\t\t\tActionType.EditUrl,\n\t\t\tActionType.ElectronicSignatureReminderAction,\n\t\t\tActionType.ExpirationNoticeSent,\n\t\t\tActionType.ExpirationSet,\n\t\t\tActionType.ExternalReviewCancelled,\n\t\t\tActionType.ExternalReviewCancelledAborted,\n\t\t\tActionType.ExternalReviewCancelledInvalidRecipient,\n\t\t\tActionType.ExternalReviewCancelledRejectedByWorflow,\n\t\t\tActionType.ExternalReviewCheckout,\n\t\t\tActionType.ExternalReviewCompletedCheckoutCancelled,\n\t\t\tActionType.ExternalReviewCompletedDocumentAndComments,\n\t\t\tActionType.ExternalReviewCompletedDocumentCheckin,\n\t\t\tActionType.ExternalReviewCompletedNoNewDocumentCheckin,\n\t\t\tActionType.ExternalReviewCompletedInternally,\n\t\t\tActionType.ExternalReviewErrored,\n\t\t\tActionType.ExternalReviewExpirationNew,\n\t\t\tActionType.ExternalReviewInitiated,\n\t\t\tActionType.ExternalReviewNativeDownload,\n\t\t\tActionType.ExternalReviewPreview,\n\t\t\tActionType.ExternalReviewReminderBounced,\n\t\t\tActionType.ExternalReviewResend,\n\t\t\tActionType.ExternalReviewWatcherRemoved,\n\t\t\tActionType.IntoWorkflow,\n\t\t\tActionType.KeywordsChanged,\n\t\t\tActionType.LWDPView,\n\t\t\tActionType.LegalHoldPlaced,\n\t\t\tActionType.LegalHoldReleased,\n\t\t\tActionType.LegalHoldUpdated,\n\t\t\tActionType.MetadataChanged,\n\t\t\tActionType.NativeView,\n\t\t\tActionType.NodeCopyAction,\n\t\t\tActionType.NodeRenameAction,\n\t\t\tActionType.ObligationAdded,\n\t\t\tActionType.ObligationDeleted,\n\t\t\tActionType.ObligationUpdated,\n\t\t\tActionType.OutboundFaxFailed,\n\t\t\tActionType.OutboundFaxSent,\n\t\t\tActionType.OutboundFaxSubmitted,\n\t\t\tActionType.OutofWorkflow,\n\t\t\tActionType.PDFView,\n\t\t\tActionType.PinPointMode,\n\t\t\tActionType.ReminderNoticeSent,\n\t\t\tActionType.ReminderSet,\n\t\t\tActionType.RemoveWatchedDocuments,\n\t\t\tActionType.SendEmailAction,\n\t\t\tActionType.SentSpringLink,\n\t\t\tActionType.ShareAction,\n\t\t\tActionType.ShareDownloadNativeAction,\n\t\t\tActionType.ShareDownloadPDFAction,\n\t\t\tActionType.SharePreviewAction,\n\t\t\tActionType.SharedFolderCheckout,\n\t\t\tActionType.SignatureCancelled,\n\t\t\tActionType.SignatureCheckout,\n\t\t\tActionType.SignatureClientCallback,\n\t\t\tActionType.SignatureFailed,\n\t\t\tActionType.SignatureRecipientApproved,\n\t\t\tActionType.SignatureRecipientBounced,\n\t\t\tActionType.SignatureRecipientDelegated,\n\t\t\tActionType.SignatureRecipientRejected,\n\t\t\tActionType.SignatureRecipientSealed,\n\t\t\tActionType.SignatureRecipientSent,\n\t\t\tActionType.SignatureRecipientSigned,\n\t\t\tActionType.SignatureRecipientViewed,\n\t\t\tActionType.SignatureRejected,\n\t\t\tActionType.SignatureSentForSigning,\n\t\t\tActionType.SignatureSigned,\n\t\t\tActionType.SignatureTimedOut,\n\t\t\tActionType.TitleChanged,\n\t\t\tActionType.TrashWorker,\n\t\t\tActionType.Unknown,\n\t\t\tActionType.WorkflowApproved,\n\t\t\tActionType.WorkflowCheckout,\n\t\t\tActionType.WorkflowEdited,\n\t\t\tActionType.WorkflowFinalized,\n\t\t\tActionType.WorkflowRejected,\n\t\t\tActionType.ExternalReviewEmailAttachmentDownload\n\t\t};\n\n\t\t/// <summary>\n\t\t/// Use reflection to find if the Description attribute was made for this enum value.\n\t\t/// If one exists, return that value.  This is what allows us to rename Enums.UserRole\n\t\t/// members willynilly.\n\t\t/// If none exists, then we return the simple ToString.\n\t\t/// Created by DK but basically made the above function return all of the members.\n\t\t/// </summary>\n\t\tpublic static string[] GetNames(Type enumType)\n\t\t{\n\t\t\t// Use reflection to find the appropriate Description attribute.\n\t\t\t// If no description attribute exists, just return role.ToString().\n\t\t\t// Concept taken from here: http://blogs.msdn.com/abhinaba/archive/2005/10/20/483000.aspx\n\n\t\t\t// Get static members declared on this class only; we don't want ToString(), CompareTo(), etc.\n\t\t\tMemberInfo[] members = enumType.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.Static);\n\t\t\tList<string> arl = new List<string>();\n\t\t\tif (members != null && members.Length > 0)\n\t\t\t{\n\t\t\t\tforeach (MemberInfo memInfo in members)\n\t\t\t\t{\n\t\t\t\t\tobject[] attrs = memInfo.GetCustomAttributes(typeof(DescriptionAttribute), false);\n\t\t\t\t\tif (attrs != null && attrs.Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tarl.Add(((DescriptionAttribute)attrs[0]).Description);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tarl.Add(memInfo.Name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn arl.ToArray();\n\t\t}\n\n\n\t\tpublic static Dictionary<long, string> GetUserRoleNameValues(UserRoleNameType nameType)\n\t\t{\n\t\t\tDictionary<long, string> values = new Dictionary<long, string>();\n\t\t\tDictionary<UserRole, string> dictionary = new Dictionary<UserRole, string>();\n\t\t\tswitch (nameType)\n\t\t\t{\n\t\t\t\tcase UserRoleNameType.Classic:\n\t\t\t\t\tdictionary = ClassicUserRoleStrings();\n\t\t\t\t\tbreak;\n\t\t\t\tcase UserRoleNameType.CLM:\n\t\t\t\t\tdictionary = ClmUserRoleStrings();\n\t\t\t\t\tbreak;\n\t\t\t\tcase UserRoleNameType.MixedMode:\n\t\t\t\t\tdictionary = ClmMixedModeUserRoleStrings();\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tforeach (KeyValuePair<UserRole, string> valuePair in dictionary)\n\t\t\t{\n\t\t\t\tvalues.Add((long) valuePair.Key, valuePair.Value);\n\t\t\t}\n\n\t\t\treturn values;\n\t\t}\n\n\n\t\t/// <summary>\n\t\t/// Use reflection to find the role required for this enum.\n\t\t/// If none exists, then we return not set... which will have to be handled\n\t\t/// in uses of this function.\n\t\t/// </summary>\n\t\tpublic static UserRole GetRoleRequired(Enum e)\n\t\t{\n\t\t\t//get the reflected member and then get the custom attribute of the member\n\t\t\tMemberInfo[] memInfo = e.GetType().GetMember(e.ToString());\n\t\t\tif (memInfo != null && memInfo.Length > 0)\n\t\t\t{\n\t\t\t\tobject[] attrs = memInfo[0].GetCustomAttributes(typeof(RoleRequired), false);\n\t\t\t\tif (attrs != null && attrs.Length > 0) return ((RoleRequired)attrs[0]).Required;\n\t\t\t}\n\n\t\t\t//RoleRequired attribute was not set\n\t\t\treturn UserRole.NotSet;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// This makes things easier to lookup all of the values an enum has.\n\t\t///\n\t\t/// IMPORTANT the key is the value not the name of the enum.\n\t\t/// </summary>\n\t\t/// <param name=\"e\"></param>\n\t\t/// <returns></returns>\n\t\tpublic static NameValueCollection GetNVC(Enum e)\n\t\t{\n\t\t\t// create at the beginning so that it always send a NVC even if it is empty\n\t\t\tNameValueCollection nvc = new NameValueCollection();\n\n\t\t\t//Load all of the enum names Uses enum w/out the s\n\t\t\tstring[] names = Enum.GetNames(e.GetType());\n\n\t\t\t// put the roles in a namevaluecollection for easy access later\n\t\t\tforeach (string name in names)\n\t\t\t{\n\t\t\t\t//parse back from the name to the actual enum\n\t\t\t\tEnum next = (Enum)Enum.Parse(e.GetType(), name, true);\n\t\t\t\tif (next != null)\n\t\t\t\t\tnvc.Add(Convert.ToInt32(next).ToString(), GetName(next));\n\t\t\t}\n\n\t\t\treturn nvc;\n\t\t}\n\n\t\tprivate static readonly ConcurrentDictionary<Type, IReadOnlyDictionary<int, string>> EnumDictionaryCache = new ConcurrentDictionary<Type, IReadOnlyDictionary<int, string>>();\n\t\tpublic static IReadOnlyDictionary<int, string> ToDictionary<T>()\n\t\t{\n\t\t\tvar type = typeof(T);\n\t\t\tif (!type.IsEnum)\n\t\t\t\tthrow new ArgumentException(\"Type must be an enum\");\n\n\t\t\treturn EnumDictionaryCache.GetOrAdd(type, _ => Enum.GetValues(type)\n\t\t\t\t.Cast<T>()\n\t\t\t\t.ToDictionary(@enum => (int) (object) @enum, @enum =>\n\t\t\t\t\ttype.GetMember(@enum.ToString())[0].GetCustomAttributes(typeof(DescriptionAttribute), false)\n\t\t\t\t\t\t.OfType<DescriptionAttribute>()\n\t\t\t\t\t\t.FirstOrDefault()?.Description ?? @enum.ToString()));\n\t\t}\n\n\t\tpublic static bool TryGetValueFromDescription<T>(string description, out T value, StringComparison stringCompare = StringComparison.OrdinalIgnoreCase)\n\t\t{\n\t\t\tvar type = typeof(T);\n\t\t\tif (!type.IsEnum)\n\t\t\t\tthrow new ArgumentException();\n\n\t\t\tvalue = default(T);\n\t\t\tif (description == null)\n\t\t\t\treturn false;\n\n\t\t\tforeach (var field in type.GetFields())\n\t\t\t{\n\t\t\t\tvar attribute = Attribute.GetCustomAttribute(field,\n\t\t\t\t\ttypeof(DescriptionAttribute)) as DescriptionAttribute;\n\t\t\t\tif (attribute != null && attribute.Description.Equals(description, stringCompare))\n\t\t\t\t{\n\t\t\t\t\tvalue = (T) field.GetValue(null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (field.Name == description)\n\t\t\t\t{\n\t\t\t\t\tvalue = (T) field.GetValue(null);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic static bool TryGetUserRoleFromStringValue(string roleString, UserRoleNameType nameType, out UserRole role, CultureInfo cultureInfo = null)\n\t\t{\n\n\t\t\tDictionary<UserRole, string> dictionary = new Dictionary<UserRole, string>();\n\t\t\trole = UserRole.NotSet;\n\t\t\tswitch (nameType)\n\t\t\t{\n\t\t\t\tcase UserRoleNameType.Classic:\n\t\t\t\t\tdictionary = ClassicUserRoleStrings(cultureInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase UserRoleNameType.CLM:\n\t\t\t\t\tdictionary = ClmUserRoleStrings(cultureInfo);\n\t\t\t\t\tbreak;\n\t\t\t\tcase UserRoleNameType.MixedMode:\n\t\t\t\t\tdictionary = ClmMixedModeUserRoleStrings(cultureInfo);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (dictionary.Any(x => x.Value.Equals(roleString, StringComparison.InvariantCultureIgnoreCase)))\n\t\t\t{\n\t\t\t\trole = dictionary\n\t\t\t\t\t.FirstOrDefault(x => x.Value.Equals(roleString, StringComparison.InvariantCultureIgnoreCase)).Key;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\n\t\tpublic static bool TryParse<T>(string value, out T result)\n\t\t{\n\t\t\tbool ok = false;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tresult = (T)Enum.Parse(typeof(T), value, true);\n\t\t\t\tif (typeof(T).GetCustomAttributes(typeof(FlagsAttribute), false).Any())\n\t\t\t\t\tok = true; // no checking if invalid flags are set\n\t\t\t\telse\n\t\t\t\t\tok = Enum.IsDefined(typeof(T), result);\n\t\t\t}\n\t\t\tcatch\n\t\t\t{\n\t\t\t\tresult = default(T);\n\t\t\t}\n\n\t\t\treturn ok;\n\t\t}\n\n\t\tpublic static string GetStringValue(Enum linkBehavior)\n\t\t{\n\t\t\tstring output;\n\t\t\tType type = linkBehavior.GetType();\n\t\t\tFieldInfo fi = type.GetField(linkBehavior.ToString());\n\t\t\tStringValue[] attrs = fi.GetCustomAttributes(typeof(StringValue), false) as StringValue[];\n\t\t\tif (attrs.Length > 0)\n\t\t\t{\n\t\t\t\toutput = attrs[0].Value;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toutput = linkBehavior.ToString();\n\t\t\t}\n\t\t\treturn output;\n\t\t}\n\n\t\tpublic static Dictionary<string, int> ToStringIntDictionary<T>()\n\t\t{\n\t\t\tvar values = Enum.GetValues(typeof(T)).Cast<int>();\n\t\t\treturn values.ToDictionary(value => Enum.GetName(typeof(T), value));\n\t\t}\n\n\t\t#endregion\n\n\t\t#region attributes\n\t\t/// <summary>\n\t\t/// New attribute for enums to set roles\n\t\t/// on Enums.\n\t\t/// DK - Started off as a landing page need to turn off specific pages\n\t\t/// in the dropdown box.\n\t\t/// </summary>\n\t\tprivate class RoleRequired : Attribute\n\t\t{\n\t\t\tprivate readonly UserRole _required;\n\n\t\t\tpublic RoleRequired(UserRole ur)\n\t\t\t{\n\t\t\t\t_required = ur;\n\t\t\t}\n\n\t\t\t//no reason to allow setting\n\t\t\tpublic UserRole Required\n\t\t\t{\n\t\t\t\tget { return _required; }\n\t\t\t}\n\t\t}\n\n\t\tpublic class StringValue : System.Attribute\n\t\t{\n\t\t\tprivate string _value;\n\n\t\t\tpublic StringValue(string value)\n\t\t\t{\n\t\t\t\t_value = value;\n\t\t\t}\n\n\t\t\tpublic string Value\n\t\t\t{\n\t\t\t\tget { return _value; }\n\t\t\t}\n\n\t\t}\n\t\t#endregion\n\n\t\t/// <summary>\n\t\t/// Enums for different account types\n\t\t/// </summary>\n\t\tpublic enum AttributeEdition\n\t\t{\n\t\t\tEssentials = 1,\n\t\t\tCore = 2,\n\t\t\tMax = 3,\n\t\t\tPlus = 4\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enums for Docusign-Request-Priority header\n\t\t/// </summary>\n\t\tpublic enum DocuSignRequestPriority\n\t\t{\n\t\t\tNone = -1,\n\t\t\tHighPriority = 0,\n\t\t\tLowPriority = 1\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Tracks the status of removing legacy Security rows for an account from the Atlas database.\n\t\t/// Used during JIT/SER migration.\n\t\t/// </summary>\n\t\tpublic enum SecurityPurgeTrackerStatus\n\t\t{\n\t\t\tNotStarted = 0,\n\t\t\tInProgress = 1,\n\t\t\tPaused = 2,\n\t\t\tDone = 3,\n\t\t\tError = 4,\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Enums for SecuritySeeReference types\n\t\t/// </summary>\n\t\tpublic enum EntityType\n\t\t{\n\t\t\tRole = 1,\n\t\t\tGroup = 2,\n\t\t\tUser = 3\n\t\t}\n\t}\n}\n",
            "relevance_score": 100
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
            "content": "\ufeffusing System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\nusing ADEXS.Atlas.Workflow.Activities.Activities.Helpers;\nusing ADEXS.Atlas.Workflow.Activities.Governance;\nusing ADEXS.Atlas.Workflow.Activities.Interfaces;\nusing ADEXS.Atlas.Workflow.Activities.Model;\nusing ADEXS.Atlas.Workflow.Readers.DefinitionConverter;\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Caching;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Model.Workflow;\nusing ADEXS.Core.Domain.Persistence.Model;\nusing ADEXS.Core.Domain.Persistence.Model.Workflow;\nusing ADEXS.Core.Domain.Repository.User;\nusing ADEXS.Core.Domain.Repository.Workflow;\nusing ADEXS.Core.Domain.Repository.Workflow.Client;\nusing ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Conversions;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Util.Text;\nusing ADEXS.WINS.Interfaces;\nusing SCMAppenders;\nusing Version = ADEXS.Core.Domain.Model.Workflow.Version;\nusing ADEXS.Core.Domain.Repository.Workflow.Types;\nusing ADEXS.Core.Workflow.Infrastructure.Exceptions;\nusing ADEXS.Core.Workflow.Model;\nusing ADEXS.Core.Workflow.Repository.Interfaces;\nusing ADEXS.Core.Workflow.Infrastructure.Telemetry;\nusing CLM.MessageDefines.Constants;\nusing Monitoring = DocuSign.Monitoring;\nusing Polly;\nusing IExpressionServiceClient = ADEXS.Core.Workflow.Expressions.Interfaces.IExpressionServiceClient;\nusing CoreDomainWorkflowRepository = ADEXS.Core.Domain.Repository.Workflow.Interfaces;\nusing Definition = ADEXS.Core.Domain.Model.Workflow.Definition;\nusing Revision = ADEXS.Core.Domain.Model.Workflow.Revision;\nusing Design = DocuSign.CLM.Workflow.Core.Persistence.Model.Design;\nusing IGovernor = ADEXS.WINS.Engine.Throttling.IGovernor;\nusing ADEXS.MqWorkers.DispatchedWorker.Telemetry;\nusing ADEXS.Core.Domain.FeatureFlags.Remoting;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Domain.Repository.ProvisioningRepository;\nusing ADEXS.Core.Domain.ExpressionService;\nusing ADEXS.Core.Domain.Providers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Workflow.Infrastructure.FeatureFlags;\nusing ADEXS.Core.Workflow.Config;\nusing DocuSign.OneConfig.Extensions;\nusing ADEXS.WINS.Exceptions;\nusing ADEXS.WINS.Helpers;\n\nusing CallbackEventBehavior = DocuSign.CLM.Workflow.Core.Contracts.Model.WorkflowEnums.CallbackEventBehavior;\n\nusing Platform.Common;\n\nnamespace ADEXS.WINS.Engine\n{\n\tpublic class WINSManager : AbstractRemotable, IWorkflowClient\n\t{\n\t\tpublic const int LockMaxRetry = 20;\n\t\tpublic const int LockMsWaitBetweenRetry = 1000;\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(WINSManager));\n\n\t\tprivate readonly IGovernor _governor;\n\n\t\tprivate readonly IWorkflowSettingRepository _workflowSettingRepository;\n\n\t\tprivate readonly IInstanceVariableGovernance _instanceVariableGovernance;\n\n\t\tprivate IWorkflowConfig _workflowConfig;\n\n\t\tprivate IGovernor Governor => _governor;\n\n\t\tprivate IWorkflowSettingRepository WorkflowSettingRepository => _workflowSettingRepository;\n\n\t\tprivate IInstanceVariableGovernance InstanceVariableGovernance => _instanceVariableGovernance;\n\n\t\tprivate IWorkflowConfig WorkflowConfig(int accountId) => _workflowConfig = (_workflowConfig ?? ServiceLocator.GetInstance<IConfigProvider>().GetConfig<IWorkflowConfig>(accountId));\n\n\t\tprivate readonly IWatchedSingletonConfig<ISiteConfig> _siteConfig;\n\n\t\tprivate readonly ICacheRepository _cacheRepository;\n\n\t\tpublic WINSManager()\n\t\t\t: this(\n\t\t\t\tServiceLocator.GetInstance<IGovernor>(),\n\t\t\t\tServiceLocator.GetInstance<IWorkflowSettingRepository>(),\n\t\t\t\tServiceLocator.GetInstance<IInstanceVariableGovernance>(),\n\t\t\t\tServiceLocator.GetInstance<IWatchedSingletonConfig<ISiteConfig>>(),\n\t\t\t\tServiceLocator.GetInstance<ICacheRepository>())\n\t\t{\n\t\t}\n\n\t\tpublic WINSManager(\n\t\t\tIGovernor governor,\n\t\t\tIWorkflowSettingRepository workflowSettingRepository,\n\t\t\tIInstanceVariableGovernance instanceVariableGovernance,\n\t\t\tIWatchedSingletonConfig<ISiteConfig> siteConfig,\n\t\t\tICacheRepository cacheRepository)\n\t\t{\n\t\t\t_governor = governor;\n\t\t\t_workflowSettingRepository = workflowSettingRepository;\n\t\t\t_instanceVariableGovernance = instanceVariableGovernance;\n\t\t\t_siteConfig = siteConfig;\n\t\t\t_cacheRepository = cacheRepository;\n\t\t}\n\n\t\tpublic override string RemoteServiceURL =>\n\t\t\tApplicationSettings.WorkflowIsBulk\n\t\t\t\t? ApplicationSettings.WinsSlowServiceURL\n\t\t\t\t: ApplicationSettings.WinsServiceURL;\n\n\t\t#region Code shared with ADEXS.Core.Domain.Repository.Workflow.Client.RemoteWINSClient\n\n\t\tpublic Definition CreateNewWorkflowDefinition(UserAccount user, string workflowName)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tvar result = WINSClientLibrary.CreateNewWorkflowDefinition(user, workflowName);\n\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorWithPII($\"Error creating new workflow definition for workflowName {{0}}\", e, workflowName);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void KillWorkflow(UserAccount user, Guid instanceUid, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid);\n\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid);\n\t\t\t\t\t\t\tcontrol.Abort(user, comment);\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error killing instance\"), e);\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic IWorkItem LoadWorkItem(UserAccount user, Guid workItemUid)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.LoadWorkItem(user, workItemUid);\n\t\t\t\t\tif (result != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, result.InstanceUid);\n\t\t\t\t\t}\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error loading workItemUid {0}\", workItemUid), e);\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\tthrow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void PauseWorkflow(UserAccount user, Guid instanceUid, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSaveInstanceStateChangedForGrpcEngineV1(instanceUid);\n\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid);\n\t\t\t\t\t\t\tcontrol.Pause(user, comment);\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error pausing instance\"), e);\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void ResumeFailedWorkflow(UserAccount user, Guid instanceUid, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tif (WorkflowManager.Instance.IsInstanceRevisionExecutionSuspended(user.AccountId, instanceUid, out Guid revisionUid))\n\t\t\t\t{\n\t\t\t\t\tstring message = $\"Cannot resume failed instance {instanceUid} because its revision {revisionUid} is suspended\";\n\t\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\t\tthrow new ApplicationException(message);\n\t\t\t\t}\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid);\n\t\t\t\t\t\t\tcontrol.ResumeFromError(user, comment);\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error resuming failed instance\"), e);\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void ResumeWorkflow(UserAccount user, Guid instanceUid, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tif (WorkflowManager.Instance.IsInstanceRevisionExecutionSuspended(user.AccountId, instanceUid, out Guid revisionUid))\n\t\t\t\t{\n\t\t\t\t\tstring message =\n\t\t\t\t\t\t$\"Cannot resume instance {instanceUid} because its revision {revisionUid} is suspended\";\n\t\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\t\tthrow new ApplicationException(message);\n\t\t\t\t}\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId, instanceUid))\n\t\t\t\t{\n\t\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tIWINSControlInstance control = WorkflowManager.Instance.GetControlInstance(user.AccountId, instanceUid);\n\t\t\t\t\t\t\tcontrol.Resume(user, comment);\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error resuming instance\"), e);\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void SubmitWorkItem(UserAccount user, Guid workItemUid, string output, string comments, IList<string> activityMessages, IDictionary<string, object> updatedVariables)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII(string.Format(\"SubmitWorkItem: WorkItemUid {0}, output {1}\", workItemUid, PII.Encode(output)));\n\t\t\t\t\t\tWorkItem workItem = WorkItemPersistence.WorkflowInstance(user.AccountId).LoadByUid(user.AccountId, user.Uid, workItemUid);\n\t\t\t\t\t\tif (workItem == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new ApplicationException(string.Format(\"Invalid workItemUid '{0}' for accountId '{1}'\", workItemUid, user.AccountId));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, workItem.InstanceUid);\n\n\t\t\t\t\t\tvar instance = ServiceLocator.GetInstance<IInstanceRepository>().LoadByUId(user.AccountId, user.Uid, workItem.InstanceUid);\n\n\t\t\t\t\t\tif (instance.EngineVersion == Core.Workflow.Constants.EngineVersionV2 && WorkflowConfig(user.AccountId).EnableWorkflowEngineV2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.InfoNoPII(\"Submitting work item (v2) via API\");\n\t\t\t\t\t\t\tvar workflowEngineV2Service = ServiceLocator.GetInstance<IWorkflowEngineV2Service>();\n\t\t\t\t\t\t\tworkflowEngineV2Service.SubmitWorkItem(user.AccountId, user.Uid, workItemUid, output, comments, updatedVariables);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (workItem.Status != Enums.WorkflowStepActivityStatus.WaitingAssigned && workItem.Status != Enums.WorkflowStepActivityStatus.WaitingUnassigned) throw new WorkItemAlreadyCompletedException(string.Format($\"WorkItemUid '{workItemUid}' is already completed for instance {instance.Uid}\"));\n\t\t\t\t\t\t\tif (WorkflowManager.Instance.IsInstanceRevisionExecutionSuspended(user.AccountId, workItem.InstanceUid, out Guid revisionUid))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstring message =\n\t\t\t\t\t\t\t\t\t$\"Cannot submit WorkItem {workItemUid} for instance {workItem.InstanceUid} because its revision {revisionUid} is suspended\";\n\t\t\t\t\t\t\t\t_log.InfoNoPII(message);\n\t\t\t\t\t\t\t\tthrow new ApplicationException(message);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tWorkItemResponse response = new WorkItemResponse(user, output, comments, activityMessages, updatedVariables);\n\t\t\t\t\t\t\tEvent e = Event.CreateCallbackEvent(workItem.AccountId, workItem.InstanceUid, workItem.ActivityUid, workItem.Uid.ToString(), response);\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (WorkflowManager.Instance.IsAcceptingWork)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tWorkflowManager.Instance.ExecuteEvent(e);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t_log.WarnNoPII($\"Workflow manager is no longer accepting work, will attempt to queue {workItemUid}\");\n\t\t\t\t\t\t\t\t\tWorkflowManager.Instance.QueueEvent(e);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (InstanceAlreadyCompletedException)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (InstanceLockedException ilex)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII($\"SubmitWorkItem: Instance locked for WorkItemUid {workItemUid}, output {PII.Encode(output)}, will attempt to queue event - {ilex.Message}\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.QueueEvent(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII(string.Format(\"SubmitWorkItem: Internal error while executing event for WorkItemUid {0}, output {1}, will attempt to queue event\", workItemUid, PII.Encode(output)), ex);\n\t\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{ex.Message} {ex.StackTrace}\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.QueueEvent(e);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (WorkItemAlreadyCompletedException wacex)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"SubmitWorkItem: WorkItem {workItemUid} already completed, output {PII.Encode(output)}, no action taken - {wacex.Message}\");\n\t\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidState, \"The specified workitem is already completed\");\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InstanceAlreadyCompletedException iacex)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII($\"SubmitWorkItem: Instance for WorkItem {workItemUid} already completed, output {PII.Encode(output)}, no action taken - {iacex.Message}\");\n\t\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidState, \"The specified workflow is already completed\");\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PublicException pe)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII($\"Error submitting workItemUid {workItemUid} - PublicException ({pe.Reason}) was thrown\", pe.InnerException);\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error submitting workItemUid {0} with output {1}\", workItemUid, PII.Encode(output)), e);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\t// Web.Resources.BPM.NoSuchStep\n\t\t\t\t\t\tthrow new PublicException(PublicException.FailReason.InvalidState, \"The specified workflow step is either already completed, or is no longer assigned to you.\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Design LoadDesign(UserAccount user, Version version)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IVersionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, version.Uid);\n\n\t\t\t\tif (design.IsOld && AccountPersistence.AuthenticationInstance.LoadById(user.AccountId).Settings.UseNewWorkflowDesigner)\n\t\t\t\t{\n\t\t\t\t\tif (AccountPersistence.AuthenticationInstance.LoadById(user.AccountId).Settings.ConvertToNewWorkflowDesign)\n\t\t\t\t\t{\n\t\t\t\t\t\tdesign = new Legacy2Designer(new DefinitionReaderLegacy(design)).Convert(user, version);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ApplicationException(string.Format(\"ConvertToNewWorkflowDesign account setting is off. Cannot convert workflow with version {0}\", version.Uid));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn design;\n\t\t\t}\n\t\t}\n\n\t\tpublic Design LoadDesign(UserAccount user, Revision revision)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar design = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IRevisionRepository>().LoadDesignerDefinitionByUid(user.AccountId, user.Uid, revision.Uid);\n\n\t\t\t\tif (design.IsOld && AccountPersistence.AuthenticationInstance.LoadById(user.AccountId).Settings.UseNewWorkflowDesigner)\n\t\t\t\t{\n\t\t\t\t\tif (AccountPersistence.AuthenticationInstance.LoadById(user.AccountId).Settings.ConvertToNewWorkflowDesign)\n\t\t\t\t\t{\n\t\t\t\t\t\tdesign = new Legacy2Designer(new DefinitionReaderLegacy(design)).Convert(user, revision);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ApplicationException(string.Format(\"ConverToNewWorkflowDesign account setting is off. Cannot convert workflow with revision {0}\", revision.Uid));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn design;\n\t\t\t}\n\t\t}\n\n\t\tpublic Design ConvertLegacyDefinition(UserAccount user, Design oldDesign)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = new Legacy2Designer(new DefinitionReaderLegacy(oldDesign)).Convert(user);\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpublic string CompileExpressionBuilderExpression(UserAccount user, string code, string additionalCode, string returnType)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tstring jwtToken = null;\n\n\t\t\t\tif (Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.CloudExpressionAPIBehavior == FeatureFlagConstants.ApiCallBehaviorLive\n\t\t\t\t\t|| Core.Workflow.Infrastructure.FeatureFlags.WorkflowFeatureFlags.CloudExpressionAPIBehavior == FeatureFlagConstants.ApiCallBehaviorShadow\n\t\t\t\t\t|| !IsOnPrem())\n\t\t\t\t{\n\t\t\t\t\tjwtToken = ServiceLocator.GetInstance<IDSAccountsServerRepository>()\n\t\t\t\t\t\t.GetJwtGrantAccessToken(DSAccountsServerRepository.WorkflowScopes, secretName: ExpressionServiceClient.CLMWorkflowExpressionTokenRSAInfoSecretName);\n\t\t\t\t}\n\n\t\t\t\tvar workflowEvaluateExpressionResult = ServiceLocator.GetInstance<IExpressionServiceClient>()\n\t\t\t\t\t.WorkflowCompileExpression(user.AccountId, code, additionalCode, returnType,\n\t\t\t\t\t\tWorkflowSettingRepository.GetEnableWorkflowExpressionErrorWithSource(user.AccountId), jwtToken\n\t\t\t\t\t\t);\n\n\t\t\t\treturn workflowEvaluateExpressionResult.ErrorMessage;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool UpdateVariables(UserAccount userAccount, Guid activityUid, List<VariableUpdate> variableUpdates, Guid sourceInstanceUid, Guid sourceActivityUid)\n\t\t{\n\t\t\treturn UpdateVariablesWithResult(userAccount, activityUid, variableUpdates, sourceInstanceUid, sourceActivityUid) == WorkflowEnums.UpdateParentVariableResult.Updated;\n\t\t}\n\n\t\tpublic WorkflowEnums.UpdateParentVariableResult UpdateVariablesWithResult(UserAccount userAccount, Guid activityUid, List<VariableUpdate> variableUpdates, Guid sourceInstanceUid, Guid sourceActivityUid)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(userAccount.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(userAccount.AccountId, sourceInstanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid);\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(userAccount.AccountId, sourceInstanceUid)))\n\t\t\t\t{\n\t\t\t\t\tInstanceActivity parentActivity = InstanceActivityPersistence.WorkflowInstance(userAccount.AccountId).LoadByUId(userAccount.AccountId, userAccount.Uid, activityUid);\n\t\t\t\t\tif (parentActivity == null) throw new ApplicationException(string.Format(\"Cannot load parentActivityUid {0}: No matching record\", activityUid));\n\n\t\t\t\t\tWorkflowInstance parentWorkflowInstance = null;\n\t\t\t\t\tvar workflowManager = WorkflowManager.Instance;\n\t\t\t\t\tvar wasInMemory = false;\n\t\t\t\t\tWorkflowEnums.UpdateParentVariableResult result;\n\n\t\t\t\t\tvar instance = ServiceLocator.GetInstance<IWorkflowRepository>().LoadInstanceById(userAccount.AccountId, userAccount.Uid, sourceInstanceUid);\n\t\t\t\t\tClientWorkflowContext ctx = new ClientWorkflowContext(userAccount.Uid, instance, sourceActivityUid);\n\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.DebugNoPII($\"Attempting to get a lock on instance {parentActivity.InstanceUid}\");\n\n\t\t\t\t\t\tif (!WorkflowManager.Instance.IsAcceptingWork)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII(\n\t\t\t\t\t\t\t\t$\"Workflow manager is no longer accepting work. Cannot update parent instance uid {parentActivity.InstanceUid}\");\n\t\t\t\t\t\t\treturn WorkflowEnums.UpdateParentVariableResult.Error;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparentWorkflowInstance = GetLockedParentWorkflowInstance(ctx, parentActivity.InstanceUid,\n\t\t\t\t\t\t\tworkflowManager, out wasInMemory);\n\t\t\t\t\t\tif (parentWorkflowInstance == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.ErrorNoPII(\n\t\t\t\t\t\t\t\t$\"Giving up on trying to get a lock on parent instance {parentActivity.InstanceUid} after {LockMaxRetry} tries\");\n\t\t\t\t\t\t\treturn WorkflowEnums.UpdateParentVariableResult.Error;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_log.DebugNoPII($\"Got a lock on parent instance {parentWorkflowInstance.Uid}\");\n\n\t\t\t\t\t\t// We need parentWorkflowInstance to have it's variable properties populated, this below call will do that (as a side-effect) via _CreateContext, the result is irrelevant\n\t\t\t\t\t\tparentWorkflowInstance.CheckActivityForCompletion(parentActivity);\n\n\t\t\t\t\t\tresult =\n\t\t\t\t\t\t\tUpdateVariables(ctx, parentWorkflowInstance, parentActivity, variableUpdates)\n\t\t\t\t\t\t\t\t? WorkflowEnums.UpdateParentVariableResult.Updated\n\t\t\t\t\t\t\t\t: WorkflowEnums.UpdateParentVariableResult.NotUpdated;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InstanceLockedException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.WarnNoPII(ex.Message, ex);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{ex.Message} {ex.StackTrace}\");\n\t\t\t\t\t\tresult = WorkflowEnums.UpdateParentVariableResult.ParentInstanceLocked;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII(ex.Message, ex);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{ex.Message} {ex.StackTrace}\");\n\t\t\t\t\t\tresult = WorkflowEnums.UpdateParentVariableResult.Error;\n\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t{\n\t\t\t\t\t\tctx.LogDebugNoPII($\"Unlocked parent instance {parentWorkflowInstance?.Uid}\");\n\t\t\t\t\t\tReleaseLock(parentWorkflowInstance, workflowManager, wasInMemory);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// The reason for the destinationContext parameter is when we're updating variables in\n\t\t/// a different workflow than the current one; eg, the UpdateParentVariableAction\n\t\t/// makes use of this.\n\t\t/// </summary>\n\t\tpublic static bool UpdateVariables(ClientWorkflowContext sourceContext, WorkflowInstance parentWorkflowInstance, InstanceActivity parentActivity, List<VariableUpdate> updates)\n\t\t{\n\t\t\tClientWorkflowContext updateContext = new ClientWorkflowContext(sourceContext.UserAccountUid, parentWorkflowInstance.Model);\n\n\t\t\tvar variableNameValues = UpdateVariablesHelper.BuildVariablesToUpdate(sourceContext, updateContext, updates);\n\n\t\t\t// Update variables\n\t\t\tint updateCount = 0;\n\t\t\tparentWorkflowInstance.SetVariables(\n\t\t\t\tparentActivity,\n\t\t\t\tvariableNameValues,\n\t\t\t\tout List<InstanceVariable> oldVariables,\n\t\t\t\tout bool areVariablesOverTotalSizeLimit,\n\t\t\t\tout int totalVariablesSizeBytes,\n\t\t\t\tout int totalVariablesSizeLimitBytes,\n\t\t\t\tout Dictionary<string, int> oversizedVariables,\n\t\t\t\tout int variableValueSizeLimitBytes);\n\n\t\t\tif (areVariablesOverTotalSizeLimit)\n\t\t\t{\n\t\t\t\tsourceContext.LogActivityErrorNoPII(\n\t\t\t\t\tstring.Format(\n\t\t\t\t\t\tAtlas.Workflow.Activities.Resources.WINSResources.TheWorkflowsTotalVariableSizeIs0BytesAndIsOverTheLimitOf1Bytes,\n\t\t\t\t\t\ttotalVariablesSizeBytes,\n\t\t\t\t\t\ttotalVariablesSizeLimitBytes));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Log oversized variables\n\t\t\t\tforeach (var variable in oversizedVariables)\n\t\t\t\t{\n\t\t\t\t\tsourceContext.LogActivityErrorWithPII(\n\t\t\t\t\t\tstring.Format(\n\t\t\t\t\t\t\tAtlas.Workflow.Activities.Resources.WINSResources.Variable0Is0BytesInSizeAndIsOverTheVariableSizeLimitOf1BytesTheVariableCannotBeSet,\n\t\t\t\t\t\t\tvariable.Value,\n\t\t\t\t\t\t\tvariableValueSizeLimitBytes),\n\t\t\t\t\t\tpii: variable.Key);\n\t\t\t\t}\n\n\t\t\t\t// Log updates\n\t\t\t\tupdateCount = UpdateVariablesHelper.LogUpdates(sourceContext, updateContext, variableNameValues, oldVariables);\n\t\t\t}\n\n\t\t\treturn updateCount > 0;\n\t\t}\n\n\t\tprivate WorkflowInstance GetLockedParentWorkflowInstance(ClientWorkflowContext sourceContext, Guid parentInstanceUid, WorkflowManager workflowManager, out bool wasInMemory)\n\t\t{\n\t\t\tvar policy = Policy\n\t\t\t\t.Handle<InstanceLockedException>()\n\t\t\t\t.OrResult<(WorkflowInstance WorkflowInstance, bool WasInMemory)>(r => r.WorkflowInstance == null)\n\t\t\t\t.WaitAndRetry(LockMaxRetry, (_) => TimeSpan.FromMilliseconds(LockMsWaitBetweenRetry),\n\t\t\t\t\t(result, timeSpan, retryCount, context) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tvar logMessage = $\"{nameof(LoadAndLockExisting)} failed trying to lock instance {parentInstanceUid} on retry {retryCount} out of {LockMaxRetry}\";\n\t\t\t\t\t\tif (result.Exception != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"{logMessage}, with exception.\", result.Exception);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (result.Result.WorkflowInstance == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"{logMessage}, with null instance.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.WarnNoPII($\"{logMessage}.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\tWorkflowInstance workflowInstance;\n\t\t\t(workflowInstance, wasInMemory) = policy.Execute(() => LoadAndLockExisting(sourceContext.AccountId, parentInstanceUid, workflowManager));\n\t\t\treturn workflowInstance;\n\t\t}\n\n\t\tprivate (WorkflowInstance workflowInstance, bool wasInMemory) LoadAndLockExisting(int accountId, Guid parentInstanceUid, WorkflowManager workflowManager)\n\t\t{\n\t\t\tvar workflowInstance =\n\t\t\t\tworkflowManager.LoadAndLockExisting(accountId, parentInstanceUid, out bool wasInMemory);\n\t\t\treturn (workflowInstance, wasInMemory);\n\t\t}\n\n\t\tprivate static void ReleaseLock(WorkflowInstance workflowInstance, WorkflowManager workflowManager, bool wasInMemory)\n\t\t{\n\t\t\tif (workflowInstance != null)\n\t\t\t{\n\t\t\t\tif (wasInMemory)\n\t\t\t\t{\n\t\t\t\t\tworkflowManager.RemoveLock(workflowInstance);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tworkflowManager.RemoveInstance(workflowInstance, DateTime.UtcNow.AddMinutes(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void SystemCallback(int accountId, Guid instanceUid, Guid activityUid, string callbackName, object callbackData = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowActivityUid, activityUid);\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(accountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.InfoNoPII(string.Format(\"System callback with callbackName {0}\", callbackName));\n\t\t\t\t\t\tInstance instance = InstancePersistence.WorkflowInstance(accountId).LoadByUId(accountId, Constants.WorkflowUser, instanceUid);\n\t\t\t\t\t\tif (instance == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new ArgumentException(string.Format(\"Invalid instanceUid '{0}' for accountId '{1}'\", instanceUid, accountId));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (instance.IsCompleted && instance.Status != Enums.WorkflowStepStatus.Failed)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_log.InfoNoPII($\"Ignoring callback '{callbackName}' for instance '{instanceUid}' in '{instance.Status}' status\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (activityUid == Guid.Empty) _GuessLegacyActivityUid(instance, ref activityUid, ref callbackName);\n\t\t\t\t\t\tif (activityUid == Guid.Empty && WorkflowSettingRepository.GetDisableCreatingEventsWithEmptyActivityUids())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// if the activityUid is still empty, do not create an event for it\n\t\t\t\t\t\t\tstring emptyActivityErrorMsg = $\"ActivityUid cannot be empty when creating an event (event '{callbackName}', instance '{instanceUid}' for account '{accountId}')\";\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ErrorMessage, $\"UserError: {emptyActivityErrorMsg}\");\n\t\t\t\t\t\t\t_log.WarnNoPII(emptyActivityErrorMsg);\n\t\t\t\t\t\t\tthrow new ArgumentException(emptyActivityErrorMsg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tEvent e = Event.CreateCallbackEvent(accountId, instanceUid, activityUid, callbackName, callbackData);\n\n\t\t\t\t\t\tbool reachedMaxInstancesInMemory = false;\n\t\t\t\t\t\tbool alreadyMaxedOutForAccount = false;\n\t\t\t\t\t\tbool isInPenaltyBox = false;\n\n\t\t\t\t\t\tif ((isInPenaltyBox = Governor.IsInPenaltyBox(accountId)) ||\n\t\t\t\t\t\t\t\t(reachedMaxInstancesInMemory = WorkflowManager.Instance.IsFull) ||\n\t\t\t\t\t\t\t\t(alreadyMaxedOutForAccount = WorkflowManager.Instance.AlreadyMaxedOutForAccount(accountId)))\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tWorkflowManager.Instance.CreateEvent(e);\n\n\t\t\t\t\t\t\tif (isInPenaltyBox)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"Account is currently in penalty box. Creating Event '{callbackName}'\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.LogInstanceDeferredGovernanceLimitReached(instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (reachedMaxInstancesInMemory)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"Instances is full for account. Creating Event '{callbackName}'\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.LogInstanceDeferredMaxInstancesInMemory(instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (alreadyMaxedOutForAccount)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"Instances already maxed out for account. Creating Event '{callbackName}'\");\n\t\t\t\t\t\t\t\tWorkflowManager.Instance.LogInstanceDeferredMaxedOutForAccount(instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tWorkflowManager.Instance.QueueEvent(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\t_log.ErrorNoPII(string.Format(\"Error processing system callback with callbackName {0}\", callbackName), e);\n\t\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic string ExportWorkflowDefinition(UserAccount user, string workflowName, int versionNumber = int.MinValue, int revisionNumber = int.MinValue)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tvar result = WINSClientLibrary.ExportWorkflowDefinition(user, workflowName, versionNumber, revisionNumber);\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpublic Revision ImportWorkflowDefinition(UserAccount user, string workflowName, string definitionData, bool overwriteExistingWorkflow, string comment = \"\", string templateId = \"\", int templateVersion = int.MinValue)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\n\t\t\t\t\tif (string.IsNullOrEmpty(comment)) comment = \"ImportWorkflowDefinition\";\n\t\t\t\t\tVersionPersistence versionPersistence = VersionPersistence.WorkflowInstance(user.AccountId);\n\t\t\t\t\tRevisionPersistence revisionPersistence = RevisionPersistence.WorkflowInstance(user.AccountId);\n\t\t\t\t\tDefinition definition = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IDefinitionRepository>().LoadByName(user.AccountId, user.Uid, workflowName);\n\t\t\t\t\tVersion version;\n\t\t\t\t\tif (definition == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tdefinition = CreateNewWorkflowDefinition(user, workflowName);\n\t\t\t\t\t\tif (definition.LatestVersionUid == Guid.Empty) throw new ApplicationException(string.Format(\"DefinitionUid {0} returned a null LatestVersionUid\", definition.Uid));\n\t\t\t\t\t\tversion = versionPersistence.LoadByUid(user.AccountId, user.Uid, definition.LatestVersionUid);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tversion = versionPersistence.LoadByUid(user.AccountId, user.Uid, definition.LatestVersionUid);\n\t\t\t\t\t\t// It is possible that we already have this definition xml; if so, we don't need to reversion.\n\t\t\t\t\t\tDesign checkDesign = versionPersistence.LoadDesignerDefinitionByUid(user.AccountId, user.Uid, version.Uid);\n\n\t\t\t\t\t\tif (overwriteExistingWorkflow || checkDesign.Definition != definitionData)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(checkDesign.Definition))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tversion = VersionWorkflow(user, version.Uid, comment: comment);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbool isJson = definitionData.isValidJson();\n\t\t\t\t\tif (isJson)\n\t\t\t\t\t{\n\t\t\t\t\t\tversionPersistence.SaveDesignerDefinition(user, version.Uid, definitionData, comment);\n\n\t\t\t\t\t\tif (!string.IsNullOrWhiteSpace(templateId))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tversion.TemplateId = templateId;\n\t\t\t\t\t\t\tversion.TemplateVersion = templateVersion;\n\t\t\t\t\t\t\tversionPersistence.Save(version, definitionData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tversionPersistence.SaveLegacyXml(user, version.Uid, definitionData, comment);\n\t\t\t\t\t}\n\n\t\t\t\t\t// It is possible that we already have this definition xml published; if so, we don't need to publish again.\n\t\t\t\t\tif (version.IsPublished())\n\t\t\t\t\t{\n\t\t\t\t\t\tRevision revision = revisionPersistence.LoadLatestByVersionUid(user.AccountId, user.Uid, version.Uid);\n\t\t\t\t\t\tDesign checkDesign = revisionPersistence.LoadDesignerDefinitionByUid(user.AccountId, user.Uid, revision.Uid);\n\t\t\t\t\t\tif ((isJson && checkDesign.DesignerDefinition == definitionData) || checkDesign.LegacyXml == definitionData)\n\t\t\t\t\t\t\treturn revision;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar publishedRevision = _PublishWorkflow(user, version.Uid, comment: comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn publishedRevision;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Revision PublishWorkflow(UserAccount user, string workflowName, int versionNumber, int revisionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\t\tVersion version = VersionPersistence.WorkflowInstance(user.AccountId).LoadByNameAndVersion(user.AccountId, user.Uid, workflowName, versionNumber);\n\t\t\t\t\tvar publishedRevision = _PublishWorkflow(user, version.Uid, revisionNumber, comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn publishedRevision;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Revision PublishWorkflow(UserAccount user, Guid versionUid, int revisionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\t\tvar publishedRevision = _PublishWorkflow(user, versionUid, revisionNumber, comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn publishedRevision;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Version VersionWorkflow(UserAccount user, string workflowName, int sourceVersionNumber, int sourceRevisionNumber = int.MinValue, int newVersionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, workflowName, sourceVersionNumber, sourceRevisionNumber, newVersionNumber, comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Version VersionWorkflow(UserAccount user, Guid sourceVersionUid, int sourceRevisionNumber = int.MinValue, int newVersionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\t{\n\t\t\t\tCheckEnableMigrationSuspendWorkflowFeature(user.AccountId);\n\t\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t\t{\n\t\t\t\t\tvar result = WINSClientLibrary.VersionWorkflow(user, sourceVersionUid, sourceRevisionNumber, newVersionNumber, comment);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic bool IsActivityExecutionLimitReached(int accountId, Guid instanceUid, Guid revisionUid, DateTime revisionCreatedDate, int activityExecutionCount)\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(accountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(accountId, instanceUid))\n\t\t\t{\n\t\t\t\tbool isActivityExecutionLimitReached = Governor.IsActivityExecutionLimitReached(accountId, instanceUid, revisionUid, revisionCreatedDate, activityExecutionCount, out _);\n\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\treturn isActivityExecutionLimitReached;\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\n\t\t#region Remoted methods called by clients\n\n\t\tpublic Guid StartRoutingApprovalWorkflow(UserAccount user, Guid revisionUid, string routingApprovalName, string sourceType, string sourceId, string xmlParam = null)\n\t\t{\n\t\t\tRequires.NotNull(user, nameof(user));\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tStartParameters startParameters = new StartParameters(user, xmlParam, sourceType, sourceId);\n\t\t\t\t\t// This is for routing/approval workflows.  Each one has a different revision, but they all come in with the same\n\t\t\t\t\t// definition, which is named \"RoutingApproval\".  This lets us override that name and provide the one we really want.\n\t\t\t\t\tstartParameters.RoutingApprovalInstanceName = routingApprovalName;\n\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, revisionUid, startParameters);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid SendStartWorkflow(UserAccount user, string workflowName, string sourceType, string sourceId, string xmlParam = null)\n\t\t{\n\t\t\tRequires.NotNull(user, nameof(user));\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, default(Guid))))\n\t\t\t\t{\n\t\t\t\t\tGuid result = WorkflowRepository.SendStartWorkflow(user, workflowName, sourceType, sourceId, xmlParam);\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, result);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid StartWorkflow(UserAccount user, string workflowName, string sourceType, string sourceId, string xmlParam = null, Guid instanceUid = default(Guid))\n\t\t{\n\t\t\treturn StartWorkflowFromSource(user, workflowName, sourceType, sourceId, xmlParam, instanceUid);\n\t\t}\n\n\t\tpublic Guid StartWorkflowFromSource(UserAccount user, string workflowName, string sourceType, string sourceId, string xmlParam, Guid instanceUid)\n\t\t{\n\t\t\tRequires.NotNull(user, nameof(user));\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, user.Uid, workflowName, xmlParam, sourceType, sourceId, instanceUid);\n\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PublicException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ex.Reason == PublicException.FailReason.NonexistentObject)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tMonitoring.ServiceContext.Log(Framework.Common.ExceptionDataPoint.ApiExceptionMessage, $\"Request failed to start workflow instance '{instanceUid}' for account '{user.AccountId}'. Reason: No such workflow found.\");\n\t\t\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic Guid StartWorkflowWithParameters(UserAccount user, Guid revisionUid, StartParameters startParameters, Guid instanceUid = default(Guid))\n\t\t{\n\t\t\tusing (CreateFeatureFlagsRemoteCallWrapper(user.AccountId))\n\t\t\tusing (var logger = BuildRequestEventLoggerAndClearMonitoringContext(user.AccountId))\n\t\t\t{\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(user.AccountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\tGuid result = _StartWorkflow(user.AccountId, revisionUid, startParameters, instanceUid);\n\t\t\t\t\tif (logger != null) logger.Success = true;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\n\t\tprivate Revision _PublishWorkflow(UserAccount user, Guid versionUid, int revisionNumber = int.MinValue, string comment = null)\n\t\t{\n\t\t\t// The point of this is to make sure that we can understand the definition and translate it.  If we can't, we want to flag\n\t\t\t// that now, rather than when they try to run the workflow.\n\n\t\t\tvar version = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IVersionRepository>().LoadByUid(user.AccountId, user.Uid, versionUid);\n\t\t\tServiceLocator.GetInstance<IDefinitionReaderFactory>().GetDefinitionReaderFromVersion(version).BuildWorkflowMap(version);\n\n\t\t\tRevisionPersistence revisionPersistence = RevisionPersistence.WorkflowInstance(user.AccountId);\n\t\t\tGuid publishedRevisionUid = revisionPersistence.Publish(user, versionUid, revisionNumber: revisionNumber, comment: comment);\n\n\t\t\tRevision revision = revisionPersistence.LoadByUid(user.AccountId, user.Uid, publishedRevisionUid);\n\n\t\t\tCoreDomainWorkflowRepository.IRevisionRepository revisionRepository = ServiceLocator.GetInstance<CoreDomainWorkflowRepository.IRevisionRepository>();\n\n\t\t\tnew DefinitionEventEmitter\n\t\t\t{\n\t\t\t\tEventName = DefinitionEventEmitter.DefinitionEventType.RevisionPublished,\n\t\t\t\tAccountId = user.AccountId,\n\t\t\t\tUserAccountUid = user.Uid,\n\t\t\t\tDefinitionUid = revision.DefinitionUid,\n\t\t\t\tVersionUid = revision.VersionUid,\n\t\t\t\tRevisionUid = revision.Uid,\n\t\t\t\tIsFirstRevision = revisionRepository.LoadByDefinitionUid(user.AccountId, user.Uid, revision.DefinitionUid).Count <= 1,\n\t\t\t\tTemplateId = version.TemplateId,\n\t\t\t\tTemplateVersion = version.TemplateId == null ? 0 : version.TemplateVersion\n\t\t\t}.Emit();\n\n\t\t\treturn revision;\n\t\t}\n\n\t\tprivate Guid _StartWorkflow(int accountId, Guid revisionUid, StartParameters startParameters, Guid instanceUid = default(Guid))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (Governor.IsStartInstanceLimitReached(accountId))\n\t\t\t\t{\n\t\t\t\t\t_log.WarnNoPII($\"Start instance limit reached - Preventing the starting of a workflow for revisionUid {revisionUid} from source type '{startParameters.SourceType}' and source id '{startParameters.SourceId}'\");\n\t\t\t\t\tGovernor.EmitInstanceStartCountExceededTelemetry(accountId);\n\n\t\t\t\t\tthrow new PublicException(PublicException.FailReason.TemporarilyUnavailable, Resources.WINSResources.TooManyWorkflowStarted);\n\t\t\t\t}\n\n\t\t\t\t_log.InfoNoPII($\"Starting workflow for revisionUid {revisionUid} from source type '{startParameters.SourceType}' and source id '{startParameters.SourceId}'\");\n\n\t\t\t\tvar paramsXml = InstanceVariable.CreateFromValueString(accountId, instanceUid, \"ParametersXml\", Enums.WorkflowVariableType.Xml, startParameters.ParametersXml);\n\t\t\t\tThrowIfVariablesOverSizeLimit(accountId, paramsXml, DateTime.UtcNow);\n\n\t\t\t\tinstanceUid = WorkflowManager.Instance.CreateNewInstance(accountId, revisionUid, startParameters, instanceUid);\n\n\t\t\t\tnew ManagerWorkload(\"InstanceCreated\", accountId, instanceUid)\n\t\t\t\t{\n\t\t\t\t\tRevisionUid = revisionUid.ToString(),\n\t\t\t\t\tSourceId = startParameters.SourceId,\n\t\t\t\t\tSourceType = startParameters.SourceType,\n\t\t\t\t\tScopeUid = startParameters.ScopeUid,\n\t\t\t\t\tInitiatingUser = startParameters.Submitter.Uid,\n\t\t\t\t\tInitiatingInstanceUid = startParameters.ParentInstanceUid,\n\t\t\t\t}.Log();\n\n\t\t\t\tusing (ScmNDC.Push(BuildNDCTags(accountId, instanceUid)))\n\t\t\t\t{\n\t\t\t\t\t_log.InfoNoPII(string.Format(\"Created instance for revisionUid {0}\", revisionUid));\n\t\t\t\t\tif (startParameters.AlertParent)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring msg = \"\";\n\t\t\t\t\t\tServiceLocator.GetInstance<IWorkflowCallbackHelper>().RegisterWorkflowCallback(\n\t\t\t\t\t\t\taccountId,\n\t\t\t\t\t\t\tstartParameters.Submitter,\n\t\t\t\t\t\t\tstartParameters.ParentInstanceUid,\n\t\t\t\t\t\t\tstartParameters.ParentActivityUid,\n\t\t\t\t\t\t\tstring.Empty,\n\t\t\t\t\t\t\tScmEnums.EventType.WorkflowStatusChanged,\n\t\t\t\t\t\t\tstartParameters.CallbackName,\n\t\t\t\t\t\t\tinstanceUid,\n\t\t\t\t\t\t\tstartParameters.CallbackEventDestPath,\n\t\t\t\t\t\t\tref msg,\n\t\t\t\t\t\t\tCallbackEventBehavior.Blocking);\n\t\t\t\t\t}\n\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, instanceUid);\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowRevisionUid, revisionUid);\n\n\t\t\t\t\treturn instanceUid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t_log.ErrorNoPII(string.Format(\"Error starting workflow for revisionUid {0}\", revisionUid), e);\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{e.Message} {e.StackTrace}\");\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tprivate Guid _StartWorkflow(int accountId, Guid userAccountUid, string workflowName, string xmlParameters, string sourceType, string sourceId, Guid instanceUid = default(Guid))\n\t\t{\n\t\t\t_log.InfoWithPII($\"Request to start ({{0}}) with instanceUid {instanceUid} from source type '{sourceType}' and source id '{sourceId}'\", workflowName);\n\n\t\t\tUserAccount user = ServiceLocator.GetInstance<IUserAccountRepository>().LoadByUid(accountId, userAccountUid);\n\n\t\t\tDefinition definition = WorkflowRepository.LoadDefinition(accountId, userAccountUid, workflowName);\n\t\t\tif (definition == null)\n\t\t\t{\n\t\t\t\t_log.WarnWithPII($\"User {userAccountUid} trying to start workflow of invalid name ({{0}})\", workflowName);\n\t\t\t\tthrow new PublicException(PublicException.FailReason.NonexistentObject, string.Format(\"Invalid workflow name: {0}\", workflowName));\n\t\t\t}\n\n\t\t\tif (definition.LatestRevisionUid == Guid.Empty)\n\t\t\t{\n\t\t\t\t_log.WarnWithPII($\"Workflow ({{0}}) has no published versions\", workflowName);\n\t\t\t\tthrow new PublicException(PublicException.FailReason.NonexistentObject, string.Format(\"Workflow {0} is not published\", workflowName));\n\t\t\t}\n\n\t\t\tStartParameters startParameters = new StartParameters(user, xmlParameters, sourceType, sourceId);\n\n\t\t\treturn _StartWorkflow(accountId, definition.LatestRevisionUid, startParameters, instanceUid);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// In the previous incarnation of WINS, ActivityUid was not part of the callbackName -- MWF required\n\t\t/// all bookmark names to be unique amongst instance, not amongst activity, so it wasn't necessary.\n\t\t/// If we're receiving an old MWF-callback (eg, for a workflow that was running at the time), we might need to\n\t\t/// parse this out.\n\t\t/// Or at least try.\n\t\t/// </summary>\n\t\tprivate void _GuessLegacyActivityUid(Instance instance, ref Guid activityUid, ref string callbackName)\n\t\t{\n\t\t\tif (string.IsNullOrEmpty(callbackName)) return;\n\t\t\tif (Event.ControlNames.IsControlName(callbackName)) return;\n\t\t\t// Attempt #1: In many cases this used the format {ActivityUid}@{Name}; if so, we should strip the ActivityUid out and return it.\n\t\t\tstring callbackNameText = callbackName;\n\t\t\tint pos = callbackName.IndexOf(\"@\");\n\t\t\tif (pos >= 0)\n\t\t\t{\n\t\t\t\tstring activityUidText = callbackName.Substring(0, pos);\n\t\t\t\tcallbackNameText = callbackName.Substring(pos + 1);\n\t\t\t\tif (Conversions.TryParseGuid(activityUidText) != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\tactivityUid = Conversions.TryParseGuid(activityUidText);\n\t\t\t\t\tcallbackName = callbackNameText;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInstanceActivityBookmarks bookmarks = InstanceActivityBookmarkPersistence.WorkflowInstance(instance.AccountId).LoadByInstance(instance.AccountId, instance.Uid);\n\t\t\t// Attempt #2: Do we have a single callback match for the name?  If so, use that.\n\t\t\tIEnumerable<InstanceActivityBookmark> matches = bookmarks.Where(n => n.CallbackName == callbackNameText);\n\t\t\tif (matches.Count() == 1)\n\t\t\t{\n\t\t\t\tactivityUid = matches.First().ActivityUid;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Otherwise, not much we can do.  It's possible it's not meant for an activity (eg, an \"Abort\" command event), so we definitely\n\t\t\t// don't want to throw an error.\n\t\t}\n\n\t\t[DocuSign.Monitoring.EventSource(\"RemotedCallsException\", \"CLM.WINSManager\")]\n\t\t[DocuSign.Monitoring.Counter(\"RemotedCallsException\", \"CLM.WINSManager\", InstanceProperty = \"Description\")]\n\t\tprivate static DocuSign.Monitoring.ExceptionEventSource _remotedCallErrorEvent = new DocuSign.Monitoring.ExceptionEventSource();\n#pragma warning disable CA1822 // Member 'BuildRequestEventLoggerAndClearMonitoringContext' does not access instance data and can be marked as static. Reason: used in .net 4.8\n\t\tprivate TaskServiceRequestEventLogger BuildRequestEventLoggerAndClearMonitoringContext(int accountId, Guid intanceUid = default, [CallerMemberName] string action = null)\n#pragma warning restore CA1822 // Member 'BuildRequestEventLoggerAndClearMonitoringContext' does not access instance data and can be marked as static. Reason: used in .net 4.8\n\t\t{\n\t\t\tTaskServiceRequestEventLogger logger = null;\n\t\t\ttry\n\t\t\t{\n#if NETFRAMEWORK\n\t\t\t\t// note: checking this setting will be logged under unknown Application if we're in a remote call and we're not hitting the cache\n\t\t\t\tif (WorkflowSettingRepository.GetClearKazmonContextInsideRemoteProxyCalls())\n\t\t\t\t{\n\t\t\t\t\t// these public methods are not only called externally but also by each other so we may call this twice in the context of the same request\n\t\t\t\t\t// knowing when to reset the context because it was a remote call vs a call from another public method is not trivial hence checking whether the current ServiceContext is a transparent proxy or a real object\n\t\t\t\t\tif (System.Runtime.Remoting.RemotingServices.IsTransparentProxy(DocuSign.Monitoring.ServiceContext.Current))\n\t\t\t\t\t{\n\t\t\t\t\t\t_remotedCallErrorEvent.Emit(\"Monitoring Context is a remote object and cannot be accessed; resetting\", \"TransparentProxyReset\");\n\t\t\t\t\t\tlogger = new TaskServiceRequestEventLogger(Guid.Empty, action);\n\t\t\t\t\t}\n\t\t\t\t\t// when making multiple remote proxy calls from the same request the second remote call and above have the context cleared from the first request (happening via AsyncRequestEventLogger.Dispose)\n\t\t\t\t\telse if (DocuSign.Monitoring.MonitoringContext.TraceToken == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger = new TaskServiceRequestEventLogger(Guid.Empty, action);\n\t\t\t\t\t}\n\t\t\t\t}\n#else\n\t\t\t\tif (DocuSign.Monitoring.MonitoringContext.TraceToken == null)\n\t\t\t\t{\n\t\t\t\t\tlogger = new TaskServiceRequestEventLogger(Guid.Empty, action);\n\t\t\t\t}\n#endif\n\n\t\t\t\t// Log Something within the remoting call.\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiLogger, $\"InRemoteCall: {Core.Domain.FeatureFlags.WorkflowFeatureFlags.TestSettingForLoggingInRemotingCall}\");\n\t\t\t\t// Log AccountId for remoting call\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.AccountId, accountId);\n\n\t\t\t\tif (intanceUid != Guid.Empty)\n\t\t\t\t{\n\t\t\t\t\t// Log WorkflowInstanceUid for remoting call\n\t\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.WorkflowInstanceUid, intanceUid);\n\t\t\t\t}\n\t\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types - we want to catch all exception here, this is just logging logic\n\t\t\tcatch (Exception ex)\n#pragma warning restore CA1031\n\t\t\t{\n\t\t\t\t_remotedCallErrorEvent.Emit(ex, \"Exception\");\n\t\t\t\t// Log Exception and Stack Trace for remoting call\n\t\t\t\tMonitoring.ServiceContext.Log(Monitoring.DataPoint.ApiException, $\"{ex.Message} {ex.StackTrace}\");\n\t\t\t}\n\t\t\treturn logger;\n\t\t}\n\n\n\t\tpublic void ThrowIfVariablesOverSizeLimit(int accountId, InstanceVariable variable, DateTime instanceCreatedDate)\n\t\t{\n\t\t\tif (InstanceVariableGovernance.IsVariableValueOverSizeLimit(accountId, variable, instanceCreatedDate, activityConfiguration: null,\n\t\t\t\tout int variableValueSizeBytes, out int variableValueSizeLimitBytes))\n\t\t\t{\n\t\t\t\tthrow new PublicException(\n\t\t\t\t\tPublicException.FailReason.InvalidArgument,\n\t\t\t\t\tstring.Format(\n\t\t\t\t\t\tstring.Format(\n\t\t\t\t\t\t\tResources.WINSResources.Variable0Is0BytesInSizeAndIsOverTheVariableSizeLimitOf1BytesTheVariableCannotBeSet,\n\t\t\t\t\t\t\tvariableValueSizeBytes,\n\t\t\t\t\t\t\tvariableValueSizeLimitBytes),\n\t\t\t\t\t\tvariable.Name));\n\t\t\t}\n\n\t\t\tif (InstanceVariableGovernance.AreVariablesOverTotalSizeLimit(accountId, new InstanceVariables { variable }, instanceCreatedDate, activityConfiguration: null,\n\t\t\t\tout int totalVariablesSizeBytes, out int totalVariablesSizeLimitBytes))\n\t\t\t{\n\t\t\t\tthrow new PublicException(\n\t\t\t\t\tPublicException.FailReason.InvalidArgument,\n\t\t\t\t\tstring.Format(\n\t\t\t\t\t\tstring.Format(\n\t\t\t\t\t\t\tResources.WINSResources.TheWorkflowsTotalVariableSizeIs0BytesAndIsOverTheLimitOf1BytesTheVariable0CannotBeSet,\n\t\t\t\t\t\t\ttotalVariablesSizeBytes,\n\t\t\t\t\t\t\ttotalVariablesSizeLimitBytes),\n\t\t\t\t\t\tvariable.Name));\n\t\t\t}\n\t\t}\n\n\t\tprivate string[] BuildNDCTags(int accountId, Guid instanceUid) => instanceUid != default(Guid) ? new[] { $\"A:{accountId}\", $\"W:{instanceUid}\" } : new[] { $\"A:{accountId}\" };\n\n\t\tpublic void CheckEnableMigrationSuspendWorkflowFeature(int accountId)\n\t\t{\n\t\t\tif (WorkflowSettingRepository.GetEnableSuspendWorkflowFeature(accountId))\n\t\t\t{\n\t\t\t\tthrow new PublicException(PublicException.FailReason.TemporarilyUnavailable, Resources.WINSResources.WorkflowAndTaskFeatureTemporarilyUnavailableTryAgainLater);\n\t\t\t}\n\t\t}\n\n\t\tprivate static IDisposable CreateFeatureFlagsRemoteCallWrapper(int accountId)\n\t\t{\n#if NETFRAMEWORK\n\t\t\treturn FeatureFlagsRemoteCallWrapperFactory.CreateInstance(accountId);\n#else\n\t\t\treturn null;\n#endif\n\t\t}\n\n\t\tprivate bool IsOnPrem()\n\t\t{\n\t\t\tvar environmentType = _siteConfig?.Value?.EnvironmentType;\n\t\t\treturn environmentType == Core.Util.Config.EnvironmentType.OnPrem;\n\t\t}\n\n\t\tprivate void SaveInstanceStateChangedForGrpcEngineV1(Guid instanceUid)\n\t\t{\n\t\t\tvar workflowV1ClientInvariantConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IWorkflowV1ClientInvariantConfig>>();\n\n\t\t\tif (!IsOnPrem() && workflowV1ClientInvariantConfig?.Value?.IsGrpcClientEnabled == true)\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Saving instance state change for instanceUid: {instanceUid}\");\n\t\t\t\tInstanceStateChangedHelper.SaveInstanceStateChanged(instanceUid, _cacheRepository, WorkflowSettingRepository);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_log.InfoNoPII($\"Skipping save of instance state change for instanceUid: {instanceUid}\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
            "relevance_score": 95
          },
          {
            "path": "/Users/shuaib.tabit/Documents/Atlas/src/ActIntegration/Client/ActIntegrationClient.cs",
            "content": "\ufeffusing ADEXS.ActIntegration.Client;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Repository.ExternalDataMapRepository;\nusing ADEXS.Core.Domain.Repository.ProvisioningRepository;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing GraphQL;\nusing GraphQL.Client.Abstractions;\nusing GraphQL.Client.Http;\nusing GraphQL.Client.Serializer.Newtonsoft;\nusing System;\nusing System.Linq;\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.Text;\nusing System.Threading.Tasks;\nusing DocuSign.Url.Extensions;\nusing DocuSign.CLM.Monitoring.SmartMon;\nusing System.IO;\n\nusing ADEXS.Core.Domain.DataPlacement;\nusing Consul;\n\nnamespace ADEXS.ActIntegration\n{\n\tpublic class ActIntegrationClient : IActIntegrationClient\n\t{\n\t\tprivate static string SiteName => ApplicationSettings.Site;\n\t\tprivate const string GraphQLPath = \"graphql\";\n\n\t\tprivate readonly IDSAccountsServerRepository _accountsServerRepository;\n\t\tprivate readonly IExternalDataMapRepository _externalDataMapRepository;\n\t\tprivate readonly IActIntegrationFeatureFlags _featureFlags;\n\t\tprivate readonly IDataPlacementRepository _dataPlacementRepository;\n\n\t\tprivate static readonly IDiscreetLogger _logger = DiscreetLogger.GetLogger(typeof(ActIntegrationClient));\n\n\t\tprivate enum GraphQLRequestType\n\t\t{\n\t\t\tIntrospection,\n\t\t\tExecuteQueryAction,\n\t\t\tExecuteMutationAction,\n\t\t\tStatus\n\t\t}\n\n\t\tpublic ActIntegrationClient(\n\t\t\tIDSAccountsServerRepository accountsServerRepository,\n\t\t\tIExternalDataMapRepository externalDataMapRepository,\n\t\t\tIActIntegrationFeatureFlags featureFlags,\n\t\t\tIDataPlacementRepository dataPlacementRepository)\n\t\t{\n\t\t\t_accountsServerRepository = accountsServerRepository;\n\t\t\t_externalDataMapRepository = externalDataMapRepository;\n\t\t\t_featureFlags = featureFlags;\n\t\t\t_dataPlacementRepository = dataPlacementRepository;\n\t\t}\n\n\n\t\tpublic async Task<HttpResponseMessage> MakeHttpRequestV2Async(UserAccount userAccount, Guid dsUserId, Guid dsAccountId, HttpMethod method, string relativePath, string correlationToken = null, string content = null,\n\t\t\tstring sourceCtx = null, int timeOutInSeconds = 0, ISmartMon smartMon = null, bool useApplicationToken = true)\n\t\t{\n\t\t\tif (userAccount == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(userAccount));\n\t\t\t}\n\n\t\t\tvar logBase = new ActIntegrationLog(\"MakeHttpRequestV2\").WithContextValue(\"URL\", $\"{method} {relativePath}\");\n\n\t\t\tvar timeout = timeOutInSeconds > 0 ? TimeSpan.FromSeconds(timeOutInSeconds) : TimeSpan.Zero;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsmartMon?.AddData(\"DsUserId\", dsUserId);\n\t\t\t\tsmartMon?.AddData(\"DsAccountId\", dsAccountId);\n\t\t\t\tsmartMon?.LogSplitTime(\"ExternalDataMapLoaded\");\n\n\t\t\t\tvar accountInfo = BuildActAccountInfo(userAccount.AccountId, dsAccountId, userAccount.Uid, dsUserId, userAccount.EmailAddress, useApplicationToken);\n\n\t\t\t\tvar logBaseWithAccountInfo = new ActIntegrationLog(logBase).WithActAccountInfo(accountInfo);\n\t\t\t\t_logger.InfoNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, \"Making HTTP request\"));\n\n\t\t\t\tstring[] scopes = { Constants.DocuSignAuthenticationScopes.ActRead, Constants.DocuSignAuthenticationScopes.ActExecute };\n\t\t\t\tstring actToken = GetAuthToken(scopes, accountInfo, constrained: false);\n\n\t\t\t\tsmartMon?.LogSplitTime(\"AcquiredToken\");\n\t\t\t\tusing (var client = GetHttpClient())\n\t\t\t\t{\n\t\t\t\t\tAddDefaultRequestHeaders(accountInfo, actToken, client, correlationToken, sourceCtx: sourceCtx);\n\t\t\t\t\tclient.DefaultRequestHeaders.Add(\"x-ds-userid\", accountInfo.UserId.ToString());\n\n\t\t\t\t\tvar baseUrl = _featureFlags.UseShardXplatUrl\n\t\t\t\t\t\t? ApplicationSettings.DocusignActApplicationShardedBaseUrl\n\t\t\t\t\t\t: ApplicationSettings.DocusignActApplicationBaseUrl;\n\t\t\t\t\tif (baseUrl.Contains(\"{0}\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar shardId = _dataPlacementRepository.GetShardIdByAccount(userAccount.Account);\n\t\t\t\t\t\t_logger.InfoNoPII($\"Shard retrieved for account: {userAccount.AccountId} shardId: {shardId}\");\n\n\t\t\t\t\t\tif (shardId != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseUrl = string.Format(baseUrl, shardId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar message = $\"Unable to get ACT Shard URL for Account: {userAccount.AccountId}\";\n\t\t\t\t\t\t\t_logger.ErrorNoPII(message);\n\t\t\t\t\t\t\tthrow new ActIntegrationException(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar path = new Uri(baseUrl + relativePath);\n\t\t\t\t\tsmartMon?.AddData(\"Path\", path.ToString());\n\t\t\t\t\t_logger.InfoNoPII($\"ActIntegration Client MakeHttpRequestV2 Method: {method?.ToString() ?? \"GET\"} BaseUri: {baseUrl} Path: {relativePath} FullUri: {path} \");\n\n\t\t\t\t\t// Get content if available\n\t\t\t\t\tusing var payload = new StringContent(content ?? string.Empty, Encoding.UTF8, \"application/json\");\n\n\t\t\t\t\tif (timeout != TimeSpan.Zero)\n\t\t\t\t\t{\n\t\t\t\t\t\tclient.Timeout = timeout;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Make the call\n\t\t\t\t\tHttpResponseMessage response;\n\t\t\t\t\tswitch (method)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Post:\n\t\t\t\t\t\t\t_logger.InfoNoPII(\"making http post call\");\n\t\t\t\t\t\t\tresponse = await client.PostAsync(path, payload).ConfigureAwait(false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Put:\n\t\t\t\t\t\t\t_logger.InfoNoPII(\"making http put call\");\n\t\t\t\t\t\t\tresponse = await client.PutAsync(path, payload).ConfigureAwait(false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Delete:\n\t\t\t\t\t\t\t_logger.InfoNoPII(\"making http delete call\");\n\t\t\t\t\t\t\tresponse = await client.DeleteAsync(path).ConfigureAwait(false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t_logger.InfoNoPII(\"making http get call\");\n\t\t\t\t\t\t\tresponse = await client.GetAsync(path).ConfigureAwait(false);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsmartMon?.LogSplitTime(\"HttpRequestCompleted\");\n\t\t\t\t\tsmartMon?.AddData(\"ResponseCode\", response.StatusCode.ToString());\n\t\t\t\t\tif (!response.IsSuccessStatusCode)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring message = $\"Error {response.StatusCode} {method} {path}\";\n\t\t\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, message));\n\t\t\t\t\t\tstring errorContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);\n\t\t\t\t\t\tsmartMon?.AddData(\"ActError\", errorContent);\n\t\t\t\t\t\tthrow new ActIntegrationHttpException(message, (int)response.StatusCode, errorContent);\n\t\t\t\t\t}\n\n\t\t\t\t\t_logger.InfoNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, \"HTTP request successful\"));\n\t\t\t\t\tstring responseContent = await response.Content.ReadAsStringAsync().ConfigureAwait(false);\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AggregateException ex) when (ex.InnerException.GetType() == typeof(TaskCanceledException))\n\t\t\t{\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, \"Failed calling ACT Apps (Timeout)\"), ex.InnerException);\n\t\t\t\tsmartMon?.AddData(\"RequestTimeout\", 1);\n\t\t\t\tthrow new ActIntegrationRequestTimeoutException(\"ACT request timed out\", timeout);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tsmartMon?.AddData(\"UnknownException\", 1);\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, \"Failed calling ACT Apps\"), ex);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic HttpResponseMessage MakeHttpRequestV2(UserAccount userAccount, Guid dsUserId, Guid dsAccountId, HttpMethod method, string relativePath, string correlationToken = null, string content = null,\n\t\t\tstring sourceCtx = null, int timeOutInSeconds = 0, ISmartMon smartMon = null, bool useApplicationToken = true)\n\t\t{\n\t\t\tif (userAccount == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(userAccount));\n\t\t\t}\n\n\t\t\tvar logBase = new ActIntegrationLog(\"MakeHttpRequest\").WithContextValue(\"URL\", $\"{method} {relativePath}\");\n\n\t\t\tvar timeout = timeOutInSeconds > 0 ? TimeSpan.FromSeconds(timeOutInSeconds) : TimeSpan.Zero;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsmartMon?.AddData(\"DsUserId\", dsUserId);\n\t\t\t\tsmartMon?.AddData(\"DsAccountId\", dsAccountId);\n\t\t\t\tsmartMon?.LogSplitTime(\"ExternalDataMapLoaded\");\n\n\t\t\t\tvar accountInfo = BuildActAccountInfo(userAccount.AccountId, dsAccountId, userAccount.Uid, dsUserId, userAccount.EmailAddress, useApplicationToken);\n\n\t\t\t\tvar logBaseWithAccountInfo = new ActIntegrationLog(logBase).WithActAccountInfo(accountInfo);\n\t\t\t\t_logger.InfoNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, \"Making HTTP request\"));\n\n\t\t\t\tstring[] scopes = { Constants.DocuSignAuthenticationScopes.ActRead, Constants.DocuSignAuthenticationScopes.ActExecute };\n\t\t\t\tstring actToken = GetAuthToken(scopes, accountInfo, constrained: false);\n\t\t\t\tsmartMon?.LogSplitTime(\"AcquiredToken\");\n\t\t\t\tusing (var client = GetHttpClient())\n\t\t\t\t{\n\t\t\t\t\tAddDefaultRequestHeaders(accountInfo, actToken, client, correlationToken, sourceCtx: sourceCtx);\n\t\t\t\t\tclient.DefaultRequestHeaders.Add(\"x-ds-userid\", accountInfo.UserId.ToString());\n\n\t\t\t\t\tvar baseUrl = _featureFlags.UseShardXplatUrl\n\t\t\t\t\t\t? ApplicationSettings.DocusignActApplicationShardedBaseUrl\n\t\t\t\t\t\t: ApplicationSettings.DocusignActApplicationBaseUrl;\n\t\t\t\t\tif (baseUrl.Contains(\"{0}\"))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar shardId = _dataPlacementRepository.GetShardIdByAccount(userAccount.Account);\n\t\t\t\t\t\t_logger.InfoNoPII($\"Shard retrieved for account: {userAccount.AccountId} shardId: {shardId}\");\n\n\t\t\t\t\t\tif (shardId != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbaseUrl = string.Format(baseUrl, shardId);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar message = $\"Unable to get ACT Shard URL for Account: {userAccount.AccountId}\";\n\t\t\t\t\t\t\t_logger.ErrorNoPII(message);\n\t\t\t\t\t\t\tthrow new ActIntegrationException(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar path = new Uri(baseUrl + relativePath);\n\t\t\t\t\tsmartMon?.AddData(\"Path\", path.ToString());\n\t\t\t\t\t_logger.InfoNoPII($\"ActIntegration Client MakeHttpRequestV2 Method: {method?.ToString() ?? \"GET\"} BaseUri: {baseUrl} Path: {relativePath} FullUri: {path} \");\n\n\t\t\t\t\t// Get content if available\n\t\t\t\t\tusing var payload = new StringContent(content ?? string.Empty, Encoding.UTF8, \"application/json\");\n\n\t\t\t\t\tif (timeout != TimeSpan.Zero)\n\t\t\t\t\t{\n\t\t\t\t\t\tclient.Timeout = timeout;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Make the call\n\t\t\t\t\tHttpResponseMessage response;\n\t\t\t\t\tswitch (method)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Post:\n\t\t\t\t\t\t\t_logger.InfoNoPII(\"making http post call\");\n\t\t\t\t\t\t\tresponse = client.PostAsync(path, payload).Result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Put:\n\t\t\t\t\t\t\t_logger.InfoNoPII(\"making http put call\");\n\t\t\t\t\t\t\tresponse = client.PutAsync(path, payload).Result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Delete:\n\t\t\t\t\t\t\t_logger.InfoNoPII(\"making http delete call\");\n\t\t\t\t\t\t\tresponse = client.DeleteAsync(path).Result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t_logger.InfoNoPII(\"making http get call\");\n\t\t\t\t\t\t\tresponse = client.GetAsync(path).Result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsmartMon?.LogSplitTime(\"HttpRequestCompleted\");\n\t\t\t\t\tsmartMon?.AddData(\"ResponseCode\", response.StatusCode.ToString());\n\t\t\t\t\tif (!response.IsSuccessStatusCode)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring message = $\"Error {response.StatusCode} {method} {path}\";\n\t\t\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, message));\n\t\t\t\t\t\tstring errorContent = response.Content.ReadAsStringAsync().Result;\n\t\t\t\t\t\tsmartMon?.AddData(\"ActError\", errorContent);\n\t\t\t\t\t\tthrow new ActIntegrationHttpException(message, (int)response.StatusCode, errorContent);\n\t\t\t\t\t}\n\n\t\t\t\t\t_logger.InfoNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, \"HTTP request successful\"));\n\t\t\t\t\tstring responseContent = response.Content.ReadAsStringAsync().Result;\n\t\t\t\t\treturn response;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AggregateException ex) when (ex.InnerException.GetType() == typeof(TaskCanceledException))\n\t\t\t{\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, \"MakeHttpRequestV2: Failed calling ACT Apps (Timeout)\"), ex.InnerException);\n\t\t\t\tsmartMon?.AddData(\"RequestTimeout\", 1);\n\t\t\t\tthrow new ActIntegrationRequestTimeoutException(\"ACT request timed out\", timeout);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tsmartMon?.AddData(\"UnknownException\", 1);\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, \"MakeHttpRequestV2: Failed calling ACT Apps\"), ex);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic string MakeHttpRequest(UserAccount userAccount, HttpMethod method, string relativePath, string correlationToken = null, string content = null,\n\t\t\tstring sourceCtx = null, int timeOutInSeconds = 0, ISmartMon smartMon = null)\n\t\t{\n\t\t\tvar logBase = new ActIntegrationLog(\"MakeHttpRequest\").WithContextValue(\"URL\", $\"{method} {relativePath}\");\n\n\t\t\tvar timeout = timeOutInSeconds > 0 ? TimeSpan.FromSeconds(timeOutInSeconds) : TimeSpan.Zero;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_externalDataMapRepository.LoadDsAccountAndDsUserFromUser(userAccount, out var dsUserId, out var dsAccountId);\n\t\t\t\tsmartMon?.AddData(\"DsUserId\", dsUserId);\n\t\t\t\tsmartMon?.AddData(\"DsAccountId\", dsAccountId);\n\t\t\t\tsmartMon?.LogSplitTime(\"ExternalDataMapLoaded\");\n\n\t\t\t\tvar accountInfo = BuildActAccountInfo(userAccount.AccountId, dsAccountId, userAccount.Uid, dsUserId, userAccount.EmailAddress, _featureFlags.EnableAppTokenForChatNotificationApi);\n\n\t\t\t\tvar logBaseWithAccountInfo = new ActIntegrationLog(logBase).WithActAccountInfo(accountInfo);\n\t\t\t\t_logger.InfoNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, \"Making HTTP request\"));\n\n\t\t\t\tstring[] scopes = GetTokenScopesForHttpMethod(method, accountInfo);\n\t\t\t\tstring actToken = GetAuthToken(scopes, accountInfo);\n\n\t\t\t\tsmartMon?.LogSplitTime(\"AcquiredToken\");\n\t\t\t\tusing (var client = GetHttpClient())\n\t\t\t\t{\n\t\t\t\t\tAddDefaultRequestHeaders(accountInfo, actToken, client, correlationToken, sourceCtx: sourceCtx);\n\n\t\t\t\t\tvar path = new Uri(GetActIntegrationAppsBaseUrl(), relativePath);\n\t\t\t\t\tsmartMon?.AddData(\"Path\", path.ToString());\n\n\t\t\t\t\t// Get content if available\n\t\t\t\t\tStringContent payload = null;\n\t\t\t\t\tif (!string.IsNullOrWhiteSpace(content))\n\t\t\t\t\t{\n\t\t\t\t\t\tpayload = new StringContent(content, Encoding.UTF8, \"application/json\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (timeout != TimeSpan.Zero)\n\t\t\t\t\t{\n\t\t\t\t\t\tclient.Timeout = timeout;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Make the call\n\t\t\t\t\tHttpResponseMessage response;\n\t\t\t\t\tswitch (method)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Post:\n\t\t\t\t\t\t\tresponse = client.PostAsync(path, payload).Result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Put:\n\t\t\t\t\t\t\tresponse = client.PutAsync(path, payload).Result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase HttpMethod m when m == HttpMethod.Delete:\n\t\t\t\t\t\t\tresponse = client.DeleteAsync(path).Result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tresponse = client.GetAsync(path).Result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tsmartMon?.LogSplitTime(\"HttpRequestCompleted\");\n\t\t\t\t\tsmartMon?.AddData(\"ResponseCode\", response.StatusCode.ToString());\n\t\t\t\t\tif (!response.IsSuccessStatusCode)\n\t\t\t\t\t{\n\t\t\t\t\t\tstring message = $\"Error {response.StatusCode} {method} {path}\";\n\t\t\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, message));\n\t\t\t\t\t\tstring errorContent = response.Content.ReadAsStringAsync().Result;\n\t\t\t\t\t\tsmartMon?.AddData(\"ActError\", errorContent);\n\t\t\t\t\t\tthrow new ActIntegrationHttpException(message, (int)response.StatusCode, errorContent);\n\t\t\t\t\t}\n\n\t\t\t\t\t_logger.InfoNoPII(ActIntegrationLog.Build(logBaseWithAccountInfo, \"HTTP request successful\"));\n\t\t\t\t\tstring responseContent = response.Content.ReadAsStringAsync().Result;\n\t\t\t\t\treturn responseContent;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AggregateException ex) when (ex.InnerException.GetType() == typeof(TaskCanceledException))\n\t\t\t{\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, \"Failed calling ACT Apps (Timeout)\"), ex.InnerException);\n\t\t\t\tsmartMon?.AddData(\"RequestTimeout\", 1);\n\t\t\t\tthrow new ActIntegrationRequestTimeoutException(\"ACT request timed out\", timeout);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tsmartMon?.AddData(\"UnknownException\", 1);\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, \"Failed calling ACT Apps\"), ex);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tpublic async Task<TResponse> MakeIntrospectionQueryAsync<TResponse>(UserAccount userAccount, GraphQLRequest request, ActIntegrationDetails details)\n\t\t{\n\t\t\treturn await MakeForegroundActIntegrationGraphQLRequestAsync<TResponse>(userAccount, request, GraphQLRequestType.Introspection, details);\n\t\t}\n\n\t\tpublic TResponse MakeIntrospectionQuery<TResponse>(UserAccount userAccount, GraphQLRequest request, ActIntegrationDetails details)\n\t\t{\n\t\t\treturn MakeForegroundActIntegrationGraphQLRequest<TResponse>(userAccount, request, GraphQLRequestType.Introspection, details);\n\t\t}\n\n\t\tpublic TResponse ExecuteQueryAction<TResponse>(Account account, GraphQLRequest request, ActIntegrationDetails details, string appId, string sourceCtx = null)\n\t\t{\n\t\t\treturn MakeBackgroundActIntegrationGraphQLRequest<TResponse>(account, request, GraphQLRequestType.ExecuteQueryAction, details, appId, sourceCtx);\n\t\t}\n\n\t\tpublic TResponse ExecuteMutationAction<TResponse>(Account account, GraphQLRequest request, ActIntegrationDetails details, string appId, string sourceCtx = null)\n\t\t{\n\t\t\treturn MakeBackgroundActIntegrationGraphQLRequest<TResponse>(account, request, GraphQLRequestType.ExecuteMutationAction, details, appId, sourceCtx);\n\t\t}\n\n\t\tpublic TResponse MakeStatusQuery<TResponse>(Account account, GraphQLRequest request, ActIntegrationDetails details, string appId, string sourceCtx = null)\n\t\t{\n\t\t\treturn MakeBackgroundActIntegrationGraphQLRequest<TResponse>(account, request, GraphQLRequestType.Status, details, appId, sourceCtx);\n\t\t}\n\n\t\tpublic TResponse MakeStatusQuery<TResponse>(UserAccount userAccount, GraphQLRequest request, ActIntegrationDetails details, string appId, string sourceCtx = null)\n\t\t{\n\t\t\treturn MakeBackgroundActIntegrationGraphQLRequest<TResponse>(userAccount, request, GraphQLRequestType.Status, details, appId, sourceCtx);\n\t\t}\n\n\t\tpublic T ExecuteQueryAction<T>(UserAccount userAccount, GraphQLRequest request, ActIntegrationDetails details, string appId, string sourceCtx = null)\n\t\t{\n\t\t\treturn MakeUserContextActIntegrationGraphQlRequest<T>(userAccount, request, GraphQLRequestType.ExecuteQueryAction, details, appId, sourceCtx);\n\t\t}\n\n\t\tpublic T ExecuteMutationAction<T>(UserAccount userAccount, GraphQLRequest request, ActIntegrationDetails details, string appId, string sourceCtx = null)\n\t\t{\n\t\t\treturn MakeUserContextActIntegrationGraphQlRequest<T>(userAccount, request, GraphQLRequestType.ExecuteMutationAction, details, appId, sourceCtx);\n\t\t}\n\n\t\tprivate T MakeUserContextActIntegrationGraphQlRequest<T>(UserAccount userAccount, GraphQLRequest request, GraphQLRequestType requestType, ActIntegrationDetails details,\n\t\t\tstring appId, string sourceCtx = null)\n\t\t{\n\t\t\t_externalDataMapRepository.LoadDsAccountAndDsUserFromUser(userAccount, out Guid dsUserId, out Guid dsAccountId);\n\t\t\tActAccountInfo accountInfo = BuildActAccountInfo(userAccount.AccountId, dsAccountId, userAccount.Uid, dsUserId, userAccount.EmailAddress, _featureFlags.EnableAppTokenForChatNotificationApi);\n\n\t\t\treturn MakeActIntegrationGraphQLRequest<T>(accountInfo, request, requestType, details, appId, sourceCtx);\n\t\t}\n\n\t\t// For unit testing to help mock HttpClient instead of wrapping it.\n\t\tpublic HttpMessageHandler HttpMessageHandler { get; set; }\n\n\t\tprivate HttpClient GetHttpClient()\n\t\t{\n\t\t\treturn HttpMessageHandler == null ? new HttpClient(new ActIntegrationHttpRetryHandler()) : new HttpClient(HttpMessageHandler);\n\t\t}\n\n\t\t// For unit testing\n\t\tpublic IGraphQLClient GraphQLClient { get; set; }\n\n\t\tprivate IGraphQLClient GetGraphQLClient(ActAccountInfo accountInfo, string actToken, string correlationToken, string appId = null, string sourceCtx = null)\n\t\t{\n\t\t\tif (GraphQLClient != null) return GraphQLClient;\n\n\t\t\tUri endPoint = new Uri(GetActIntegrationAppsBaseUrl(), GraphQLPath);\n\t\t\tHttpClient httpClient = new HttpClient(new ActIntegrationHttpRetryHandler());\n\t\t\tGraphQLHttpClient ret = new GraphQLHttpClient(new GraphQLHttpClientOptions { EndPoint = endPoint }, new NewtonsoftJsonSerializer(), httpClient);\n\t\t\tAddDefaultRequestHeaders(accountInfo, actToken, ret.HttpClient, correlationToken, appId, sourceCtx);\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate static string[] GetTokenScopesForGraphQLRequestType(GraphQLRequestType requestType, ActAccountInfo accountInfo)\n\t\t{\n\t\t\tif (!accountInfo.UseApplicationToken)\n\t\t\t{\n\t\t\t\treturn DSAccountsServerRepository.DSSignatureScopes;\n\t\t\t}\n\n\t\t\tswitch (requestType)\n\t\t\t{\n\t\t\t\tcase GraphQLRequestType.ExecuteQueryAction:\n\t\t\t\tcase GraphQLRequestType.ExecuteMutationAction:\n\t\t\t\tcase GraphQLRequestType.Status:\n\t\t\t\t\treturn DSAccountsServerRepository.DSActExecuteTokenScope;\n\t\t\t\tcase GraphQLRequestType.Introspection:\n\t\t\t\t\treturn DSAccountsServerRepository.DSActReadTokenScope;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new ArgumentException($\"Invalid GraphQL request type {requestType}\");\n\t\t\t}\n\t\t}\n\n\t\tprivate static string[] GetTokenScopesForHttpMethod(HttpMethod method, ActAccountInfo accountInfo)\n\t\t{\n\t\t\tif (accountInfo.UseApplicationToken)\n\t\t\t{\n\t\t\t\treturn method == HttpMethod.Get\n\t\t\t\t\t? DSAccountsServerRepository.DSActReadTokenScope\n\t\t\t\t\t: DSAccountsServerRepository.DSActWriteTokenScope;\n\t\t\t}\n\n\t\t\treturn DSAccountsServerRepository.DSSignatureScopes;\n\t\t}\n\t\tprivate void AddDefaultRequestHeaders(ActAccountInfo accountInfo, string actToken, HttpClient client, string correlationToken = null, string appId = null, string sourceCtx = null)\n\t\t{\n\t\t\tclient.DefaultRequestHeaders.Accept.Clear();\n\t\t\tclient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(Enums.AuthorizationScheme.Bearer.ToString(), actToken);\n\n\t\t\t// Default headers for both CM / DS Accounts\n\t\t\tclient.DefaultRequestHeaders.Add(Constants.DocuSignCustomHeaders.ClmAccountId, accountInfo.AccountId.ToString());\n\t\t\tclient.DefaultRequestHeaders.Add(Constants.DocuSignCustomHeaders.ClmSiteName, SiteName);\n\t\t\tclient.DefaultRequestHeaders.Add(Constants.DocuSignCustomHeaders.ClmUserId, accountInfo.UserId.ToString());\n\t\t\tclient.DefaultRequestHeaders.Add(Constants.DocuSignCustomHeaders.ClmAccountType, accountInfo.Type.ToString());\n\n\t\t\t// DS specific account headers\n\t\t\tif (accountInfo.Type == ActAccountInfoType.DocuSign)\n\t\t\t{\n\t\t\t\tvar userInfo = _accountsServerRepository.GetUserInfo(accountInfo.DsUserGuid);\n\t\t\t\tif (userInfo != null)\n\t\t\t\t{\n\t\t\t\t\tclient.DefaultRequestHeaders.Add(Constants.ActCustomHeaders.DocuSignAccountIdGuid, accountInfo.DsAccountGuid.ToString());\n\t\t\t\t\tclient.DefaultRequestHeaders.Add(Constants.ActCustomHeaders.DocuSignUserId, accountInfo.DsUserGuid.ToString());\n\n\t\t\t\t\tvar currentAccount = userInfo.Accounts?.FirstOrDefault(x => x.AccountId == accountInfo.AccountGuid);\n\t\t\t\t\tif (currentAccount != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tclient.DefaultRequestHeaders.Add(Constants.ActCustomHeaders.DocuSignAccountIdNumber, currentAccount.FriendlyAccountId);\n\t\t\t\t\t\tclient.DefaultRequestHeaders.Add(Constants.ActCustomHeaders.DocuSignSiteName, new Uri(currentAccount.BaseUri).RetrieveSite());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Legacy headers (Sending DS account id with a different header name. Not to be confused with CLM account guid.\n\t\t\tclient.DefaultRequestHeaders.Add(Constants.DocuSignCustomHeaders.ClmAccountGuid, accountInfo.AccountGuid.ToString());\n\n\t\t\t// Other headers\n\t\t\tif (sourceCtx != null)\n\t\t\t{\n\t\t\t\tclient.DefaultRequestHeaders.Add(Constants.DocuSignCustomHeaders.SourceContext, sourceCtx);\n\t\t\t}\n\n\t\t\tif (!string.IsNullOrEmpty(appId))\n\t\t\t{\n\t\t\t\tclient.DefaultRequestHeaders.Add(Constants.DocuSignCustomHeaders.AppId, appId);\n\t\t\t}\n\n\t\t\tif (!string.IsNullOrEmpty(correlationToken))\n\t\t\t{\n\t\t\t\tclient.DefaultRequestHeaders.Add(Constants.DocuSignCustomHeaders.CorrelationToken, correlationToken);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Makes a GraphQL Request in a background process, which has no user context\n\t\t/// </summary>\n\t\tprivate TResponse MakeBackgroundActIntegrationGraphQLRequest<TResponse>(Account account, GraphQLRequest request, GraphQLRequestType requestType,\n\t\t\tActIntegrationDetails details, string appId, string sourceCtx = null)\n\t\t{\n\t\t\tGuid dsAccountId = _externalDataMapRepository.LoadDsAccountIdFromAccountId(account.Id);\n\t\t\tActAccountInfo accountInfo = BuildActAccountInfo(account.Id, dsAccountId, Guid.Empty, Guid.Empty, account.Email, _featureFlags.EnableAppTokenForChatNotificationApi);\n\n\t\t\treturn MakeActIntegrationGraphQLRequest<TResponse>(accountInfo, request, requestType, details, appId, sourceCtx);\n\t\t}\n\n\t\tprivate TResponse MakeBackgroundActIntegrationGraphQLRequest<TResponse>(UserAccount userAccount, GraphQLRequest request, GraphQLRequestType requestType,\n\t\t\tActIntegrationDetails details, string appId, string sourceCtx = null)\n\t\t{\n\t\t\t_externalDataMapRepository.LoadDsAccountAndDsUserFromUser(userAccount, out Guid dsUserId, out Guid dsAccountId);\n\t\t\tActAccountInfo accountInfo = BuildActAccountInfo(userAccount.AccountId, dsAccountId, userAccount.Uid, dsUserId, userAccount.EmailAddress, _featureFlags.EnableAppTokenForChatNotificationApi);\n\n\t\t\treturn MakeActIntegrationGraphQLRequest<TResponse>(accountInfo, request, requestType, details, appId, sourceCtx);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Makes a GraphQL Request in a foreground process, which has user context\n\t\t/// </summary>\n\t\tprivate TResponse MakeForegroundActIntegrationGraphQLRequest<TResponse>(UserAccount userAccount, GraphQLRequest request, GraphQLRequestType requestType,\n\t\t\tActIntegrationDetails details)\n\t\t{\n\t\t\t_externalDataMapRepository.LoadDsAccountAndDsUserFromUser(userAccount, out Guid dsUserId, out Guid dsAccountId);\n\t\t\tActAccountInfo accountInfo = BuildActAccountInfo(userAccount.AccountId, dsAccountId, userAccount.Uid, dsUserId, userAccount.EmailAddress, _featureFlags.EnableAppTokenForChatNotificationApi);\n\n\t\t\treturn MakeActIntegrationGraphQLRequest<TResponse>(accountInfo, request, requestType, details);\n\t\t}\n\n\t\tpublic static ActAccountInfo BuildActAccountInfo(int clmAccountId, Guid dsAccountId, Guid clmUserId, Guid dsUserId, string emailAddress, bool forceUseAppToken)\n\t\t{\n\t\t\t// if dsAccountId is empty, it's a CLM.cm account\n\t\t\tvar isDsAccount = dsAccountId != Guid.Empty;\n\t\t\tvar accountInfo = new ActAccountInfo\n\t\t\t{\n\t\t\t\tAccountId = clmAccountId,\n\t\t\t\tType = isDsAccount ? ActAccountInfoType.DocuSign : ActAccountInfoType.Clm,\n\t\t\t\tAccountGuid = isDsAccount ? dsAccountId : Guid.Empty,\n\t\t\t\tUserId = isDsAccount ? dsUserId : clmUserId,\n\t\t\t\tClmUserId = clmUserId,\n\t\t\t\tEmail = emailAddress,\n\t\t\t\tUseAppTokenOverride = forceUseAppToken,\n\t\t\t\tDsAccountGuid = dsAccountId,\n\t\t\t\tDsUserGuid = dsUserId,\n\t\t\t};\n\n\t\t\t_logger.InfoNoPII($\"BuildActAccountInfo ${accountInfo}\");\n\t\t\treturn accountInfo;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Makes a GraphQL Request in a foreground process, which has user context\n\t\t/// </summary>\n\t\tprivate async Task<TResponse> MakeForegroundActIntegrationGraphQLRequestAsync<TResponse>(UserAccount userAccount, GraphQLRequest request, GraphQLRequestType requestType,\n\t\t\tActIntegrationDetails details)\n\t\t{\n\t\t\t_externalDataMapRepository.LoadDsAccountAndDsUserFromUser(userAccount, out Guid dsUserId, out Guid dsAccountId);\n\t\t\tActAccountInfo accountInfo = BuildActAccountInfo(userAccount.AccountId, dsAccountId, userAccount.Uid, dsUserId, userAccount.EmailAddress, _featureFlags.EnableAppTokenForChatNotificationApi);\n\n\t\t\treturn await MakeActIntegrationGraphQLRequestAsync<TResponse>(accountInfo, request, requestType, details);\n\t\t}\n\n\t\tprivate TResponse MakeActIntegrationGraphQLRequest<TResponse>(ActAccountInfo accountInfo, GraphQLRequest request, GraphQLRequestType requestType,\n\t\t\tActIntegrationDetails details, string appId = null, string sourceCtx = null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn MakeActIntegrationGraphQLRequestAsync<TResponse>(accountInfo, request, requestType, details, appId, sourceCtx).Result;\n\t\t\t}\n\t\t\tcatch (AggregateException e)\n\t\t\t{\n\t\t\t\t// Even if only one exception is thrown (as it happens in this case) the Task will still wrap the exception in an AggregateException\n\t\t\t\tvar innerException = e.InnerExceptions[0];\n\t\t\t\tvar logBase = new ActIntegrationLog(\"MakeActIntegrationGraphQLRequest\", sourceCtx).WithContextValue(\"RequestType\", $\"{requestType:G}\")\n\t\t\t\t\t.WithActAccountInfo(accountInfo);\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, \"ActIntegration GraphQL Request failed\"), innerException);\n\n\t\t\t\tthrow innerException;\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task<TResponse> MakeActIntegrationGraphQLRequestAsync<TResponse>(ActAccountInfo accountInfo, GraphQLRequest request, GraphQLRequestType requestType,\n\t\t\tActIntegrationDetails details, string appId = null, string sourceCtx = null)\n\t\t{\n\t\t\tvar logBase = new ActIntegrationLog(\"MakeActIntegrationGraphQLRequestAsync\", sourceCtx).WithContextValue(\"RequestType\", $\"{requestType:G}\")\n\t\t\t\t.WithActAccountInfo(accountInfo);\n\t\t\tvar graphQLRequestEventSource = new ActIntegrationGraphQLEventSource\n\t\t\t{\n\t\t\t\tAccountInfo = accountInfo.ToString(),\n\t\t\t\tAccountId = accountInfo.AccountId,\n\t\t\t\tAccountGuid = accountInfo.AccountGuid,\n\t\t\t\tUserId = accountInfo.UserId,\n\t\t\t\tRequestType = requestType.ToString(),\n\t\t\t\tSourceContext = sourceCtx\n\t\t\t}.AddDetails(details);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tstring[] scopes = GetTokenScopesForGraphQLRequestType(requestType, accountInfo);\n\t\t\t\tstring actToken = GetAuthToken(scopes, accountInfo, sourceCtx);\n\n\t\t\t\tgraphQLRequestEventSource.StartDate = DateTime.UtcNow;\n\n\t\t\t\tusing (IGraphQLClient client = GetGraphQLClient(accountInfo, actToken, details.CorrelationToken, appId, sourceCtx))\n\t\t\t\t{\n\t\t\t\t\tGraphQLResponse<TResponse> response;\n\t\t\t\t\tswitch (requestType)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase GraphQLRequestType.Introspection:\n\t\t\t\t\t\tcase GraphQLRequestType.ExecuteQueryAction:\n\t\t\t\t\t\tcase GraphQLRequestType.Status:\n\t\t\t\t\t\t\tresponse = await client.SendQueryAsync<TResponse>(request);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase GraphQLRequestType.ExecuteMutationAction:\n\t\t\t\t\t\t\tresponse = await client.SendMutationAsync<TResponse>(request);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new ArgumentException($\"Invalid GraphQL request type {requestType}\");\n\t\t\t\t\t}\n\n\t\t\t\t\tgraphQLRequestEventSource.EndDate = DateTime.UtcNow;\n\t\t\t\t\tgraphQLRequestEventSource.Duration = (long)(graphQLRequestEventSource.EndDate - graphQLRequestEventSource.StartDate).TotalMilliseconds;\n\n\t\t\t\t\tif (response.Errors?.Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, $\"GraphQL error:\\n{GraphQLErrorListToString(response.Errors)}\"));\n\t\t\t\t\t\tgraphQLRequestEventSource.Success = \"False\";\n\t\t\t\t\t\tgraphQLRequestEventSource.ErrorMessage = response.Errors.ToString();\n\t\t\t\t\t\tgraphQLRequestEventSource.Emit();\n\t\t\t\t\t\tthrow new ActIntegrationGraphQLException(\"ACT request error\", response.Errors);\n\t\t\t\t\t}\n\n\t\t\t\t\t_logger.InfoNoPII(ActIntegrationLog.Build(logBase, \"GraphQL request was successful\"));\n\t\t\t\t\tgraphQLRequestEventSource.Success = \"True\";\n\t\t\t\t\tgraphQLRequestEventSource.Emit();\n\n\t\t\t\t\treturn response.Data;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, $\"An exception occurred when making GraphQL request\"), ex);\n\t\t\t\tgraphQLRequestEventSource.EndDate = DateTime.UtcNow;\n\t\t\t\tgraphQLRequestEventSource.Duration = (long)(graphQLRequestEventSource.EndDate - graphQLRequestEventSource.StartDate).TotalMilliseconds;\n\t\t\t\tgraphQLRequestEventSource.Success = \"False\";\n\t\t\t\tgraphQLRequestEventSource.ErrorMessage = $\"An exception occurred when making GraphQL request {ex}\";\n\t\t\t\tgraphQLRequestEventSource.Emit();\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t\tprivate static Uri GetActIntegrationAppsBaseUrl()\n\t\t{\n\t\t\treturn new Uri(ApplicationSettings.DocuSignActAppsBaseUrl);\n\t\t}\n\n\t\tpublic string GetAuthToken(string[] scopes, ActAccountInfo accountInfo, string sourceCtx = null, bool constrained = true)\n\t\t{\n\t\t\tif (accountInfo == null) throw new ArgumentNullException(nameof(accountInfo));\n\t\t\tvar logBase = new ActIntegrationLog(\"GetAuthToken\", sourceCtx).WithActAccountInfo(accountInfo);\n\n\t\t\tif (accountInfo.UseApplicationToken)\n\t\t\t{\n\t\t\t\tif (accountInfo.UseAppTokenOverride)\n\t\t\t\t{\n\t\t\t\t\tscopes = DSAccountsServerRepository.DSActFirstPartyTokenScope;\n\t\t\t\t}\n\n\t\t\t\tvar clmAppToken = _accountsServerRepository.GetJwtGrantAccessToken(scopes);\n\t\t\t\tif (string.IsNullOrWhiteSpace(clmAppToken))\n\t\t\t\t{\n\t\t\t\t\tvar message = \"App Token for CLM failed\";\n\t\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, message));\n\t\t\t\t\tthrow new ActIntegrationException(message);\n\t\t\t\t}\n\n\t\t\t\treturn clmAppToken;\n\t\t\t}\n\n\t\t\tstring dsUserId = accountInfo.UserId.ToString();\n\t\t\t// Use Constrained delegation\n\t\t\t// First, get the user token for CLM\n\t\t\tstring clmUserToken = _accountsServerRepository.GetJwtGrantAccessToken(scopes, dsUserId);\n\n\t\t\tif (string.IsNullOrWhiteSpace(clmUserToken))\n\t\t\t{\n\t\t\t\tstring message = $\"User Token for CLM failed\";\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, message));\n\t\t\t\tthrow new ActIntegrationException(message);\n\t\t\t}\n\n\t\t\tif (!constrained) return clmUserToken;\n\n\t\t\t// Exchange the CLM user token for an ACT user token\n\t\t\tstring actUserToken = _accountsServerRepository.GetJwtConstrainedDelegationAccessToken(ApplicationSettings.DocusignActClientApplicationId, clmUserToken,\n\t\t\t\tDSAccountsServerRepository.SpringApiScopes, dsUserId);\n\n\t\t\tif (string.IsNullOrWhiteSpace(actUserToken))\n\t\t\t{\n\t\t\t\tstring message = $\"User Token for ACT failed\";\n\t\t\t\t_logger.ErrorNoPII(ActIntegrationLog.Build(logBase, message));\n\t\t\t\tthrow new ActIntegrationException(message);\n\t\t\t}\n\n\t\t\treturn actUserToken;\n\t\t}\n\n\t\tprivate static string GraphQLErrorListToString(GraphQLError[] errorList)\n\t\t{\n\t\t\tvar errorMessage = new StringBuilder();\n\t\t\tforeach (var error in errorList)\n\t\t\t{\n\t\t\t\tstring path = error.Path is null ? \"\" : $\" (path: {string.Join(\">\", error.Path.Select(p => p.ToString()).ToArray())})\";\n\t\t\t\terrorMessage.AppendLine($\"{error.Message}{path}\");\n\t\t\t}\n\n\t\t\treturn errorMessage.ToString();\n\t\t}\n\t}\n}\n",
            "relevance_score": 90
          }
        ],
        "reasoning_chain": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "1. Analysis",
              "reasoning": "1. Analysis  \n   \u2022 Goal: Whenever a CLM **incoming web-HTTP request span** is created we must add two new span attributes:  \n     \u2013 HTTP_REFERER  \u2190 Request.Headers[\"Referer\"]  ",
              "conclusion": "     \u2013 HTTP_REFERER  \u2190 Request.Headers[\"Referer\"]  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 2,
              "description": "2. Planning",
              "reasoning": "2. Planning  \n   \u2022 Look for code that:  \n     \u2013 Runs as ASP.NET middleware / HttpModule / DelegatingHandler.  ",
              "conclusion": "     \u2013 Runs as ASP.NET middleware / HttpModule / DelegatingHandler.  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 3,
              "description": "3. Implementation (candidate files & why)",
              "reasoning": "3. Implementation (candidate files & why)\n\n   1. src/Core.Domain/Utilities/ActivityEnricher.cs  ",
              "conclusion": "   1. src/Core.Domain/Utilities/ActivityEnricher.cs  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 4,
              "description": "4. Validation",
              "reasoning": "4. Validation  \n   \u2022 Unit / integration test: send a request with \u201cReferer\u201d header and a response that issues a 302 with \u201cLocation\u201d; verify via OpenTelemetry exporter that the span contains the two new attributes.  \n   \u2022 Manual: run service locally with OTLP console exporter and observe output.",
              "conclusion": "   \u2022 Manual: run service locally with OTLP console exporter and observe output.",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            }
          ],
          "final_conclusion": "Confidence: 0.61",
          "overall_confidence": 0.8,
          "alternative_approaches": [
            "(Optional / lower priority but still relevant if central instrumentation is here)",
            "Alternative approaches considered"
          ]
        }
      },
      "error": null,
      "execution_time": 11.528162002563477,
      "cache_hit": false
    },
    "patch_generation": {
      "stage_name": "patch_generation",
      "status": "StageStatus.COMPLETED",
      "result": {
        "diff": "Error generating patch: Error code: 400 - {'error': {'message': \"This model's maximum context length is 200000 tokens. However, your messages resulted in 226543 tokens. Please reduce the length of the messages.\", 'type': 'invalid_request_error', 'param': 'messages', 'code': 'context_length_exceeded'}}\n\nFallback explanation based on reasoning.",
        "explanation": "# Patch generation failed - manual implementation required",
        "selection_reasoning": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "1. Analysis",
              "reasoning": "1. Analysis  \n   \u2022 Goal: Whenever a CLM **incoming web-HTTP request span** is created we must add two new span attributes:  \n     \u2013 HTTP_REFERER  \u2190 Request.Headers[\"Referer\"]  ",
              "conclusion": "     \u2013 HTTP_REFERER  \u2190 Request.Headers[\"Referer\"]  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 2,
              "description": "2. Planning",
              "reasoning": "2. Planning  \n   \u2022 Look for code that:  \n     \u2013 Runs as ASP.NET middleware / HttpModule / DelegatingHandler.  ",
              "conclusion": "     \u2013 Runs as ASP.NET middleware / HttpModule / DelegatingHandler.  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 3,
              "description": "3. Implementation (candidate files & why)",
              "reasoning": "3. Implementation (candidate files & why)\n\n   1. src/Core.Domain/Utilities/ActivityEnricher.cs  ",
              "conclusion": "   1. src/Core.Domain/Utilities/ActivityEnricher.cs  ",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            },
            {
              "step_number": 4,
              "description": "4. Validation",
              "reasoning": "4. Validation  \n   \u2022 Unit / integration test: send a request with \u201cReferer\u201d header and a response that issues a 302 with \u201cLocation\u201d; verify via OpenTelemetry exporter that the span contains the two new attributes.  \n   \u2022 Manual: run service locally with OTLP console exporter and observe output.",
              "conclusion": "   \u2022 Manual: run service locally with OTLP console exporter and observe output.",
              "confidence": 0.8,
              "evidence": [
                "LLM analysis"
              ]
            }
          ],
          "final_conclusion": "Confidence: 0.61",
          "overall_confidence": 0.8,
          "alternative_approaches": [
            "(Optional / lower priority but still relevant if central instrumentation is here)",
            "Alternative approaches considered"
          ]
        },
        "patch_reasoning": {
          "strategy": "ReasoningStrategy.CHAIN_OF_THOUGHT",
          "steps": [
            {
              "step_number": 1,
              "description": "Fallback analysis",
              "reasoning": "Error in LLM reasoning: Error code: 400 - {'error': {'message': \"This model's maximum context length is 200000 tokens. However, your messages resulted in 226286 tokens. Please reduce the length of the messages.\", 'type': 'invalid_request_error', 'param': 'messages', 'code': 'context_length_exceeded'}}",
              "conclusion": "Using fallback approach",
              "confidence": 0.5,
              "evidence": [
                "Error occurred"
              ]
            }
          ],
          "final_conclusion": "Fallback conclusion due to reasoning error",
          "overall_confidence": 0.5,
          "alternative_approaches": [
            "Manual implementation"
          ]
        },
        "selected_files": [
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfoProcessor.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/DetectTypeProcessor.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/MessageWorkerService/DispatchedWorker.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WorkflowInstance.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Service/V1/WinsService.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Session/RedisSessionStateProviderWrapper.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorWindows.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/MimeLookup/MimeDetectorCrossPlatform.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/VideoInfo/VideoInfo.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Extensions/Telemetry/ActivityExtensions.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/AtlasDataManipulationService/Startup.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/ICoreInstrumentationLifetimeService.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/CoreInstrumentationLifetimeService.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web/DocExplorer/Controllers/PanelControllers/AttributesController.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Controls/FormExtensions.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowScopeEvents/WorkflowScopeEventsController.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowActivities/WorkflowActivitiesController.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Infrastructure/Telemetry/WorkflowDefinition/WorkflowDefinitionController.Trace.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Constants.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/Core.Types/Enums.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/WINS/Engine/WINSManager.cs",
          "/Users/shuaib.tabit/Documents/Atlas/src/ActIntegration/Client/ActIntegrationClient.cs"
        ]
      },
      "error": null,
      "execution_time": 5.347928047180176,
      "cache_hit": false
    },
    "validation": {
      "stage_name": "validation",
      "status": "StageStatus.COMPLETED",
      "result": {
        "overall_score": 0.6416666666666667,
        "test_results": [
          {
            "test_name": "Intent Required Fields",
            "test_type": "TestType.UNIT",
            "passed": false,
            "score": 0.5,
            "details": {
              "missing_fields": [
                "search_keywords"
              ]
            },
            "errors": [
              "Missing required field: search_keywords"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Telemetry Operation Validity",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "type": "span",
              "action": "ADD_ATTRIBUTES"
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Semantic Description Quality",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "description_length": 110,
              "quality_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Patch Format Validity",
            "test_type": "TestType.UNIT",
            "passed": false,
            "score": 0.0,
            "details": {
              "patch_length": 344
            },
            "errors": [
              "Invalid unified diff format"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Code Style Compliance",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 1.0,
            "details": {
              "style_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.003
          },
          {
            "test_name": "Change Scope Appropriateness",
            "test_type": "TestType.UNIT",
            "passed": true,
            "score": 0.7,
            "details": {
              "scope_score": 0.7
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Code Compilation",
            "test_type": "TestType.INTEGRATION",
            "passed": false,
            "score": 0.0,
            "details": {
              "files_count": 30
            },
            "errors": [
              "Mismatched parentheses in BaseApiHandler.cs",
              "Mismatched parentheses in AttributesController.cs",
              "Mismatched parentheses in Enums.cs",
              "Mismatched parentheses in ActIntegrationClient.cs"
            ],
            "warnings": [],
            "execution_time": 2.0
          },
          {
            "test_name": "OpenTelemetry Attribute Naming",
            "test_type": "TestType.COMPLIANCE",
            "passed": false,
            "score": 0.5,
            "details": {
              "attributes_count": 2
            },
            "errors": [
              "Non-compliant attribute names found"
            ],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Instrumentation Pattern Compliance",
            "test_type": "TestType.COMPLIANCE",
            "passed": true,
            "score": 1.0,
            "details": {
              "pattern_score": 1.0
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.002
          },
          {
            "test_name": "Resource Usage Analysis",
            "test_type": "TestType.PERFORMANCE",
            "passed": true,
            "score": 1.0,
            "details": {
              "score": 1.0,
              "errors": [],
              "warnings": []
            },
            "errors": [],
            "warnings": [],
            "execution_time": 0.003
          },
          {
            "test_name": "No Hardcoded Secrets",
            "test_type": "TestType.COMPLIANCE",
            "passed": true,
            "score": 1.0,
            "details": {},
            "errors": [],
            "warnings": [],
            "execution_time": 0.001
          },
          {
            "test_name": "Input Validation",
            "test_type": "TestType.COMPLIANCE",
            "passed": false,
            "score": 0.0,
            "details": {
              "validation_score": 0.0
            },
            "errors": [
              "Insufficient input validation"
            ],
            "warnings": [
              "Input validation could be improved"
            ],
            "execution_time": 0.002
          }
        ],
        "recommendations": [
          "Address failing tests before deployment",
          "Improve implementation for low-scoring areas",
          "Validate telemetry data collection in staging environment"
        ],
        "risk_assessment": "HIGH",
        "compliance_status": {
          "opentelemetry": false,
          "security": true,
          "style": true
        }
      },
      "error": null,
      "execution_time": 0.02125072479248047,
      "cache_hit": false
    },
    "report_generation": {
      "stage_name": "report_generation",
      "status": "StageStatus.COMPLETED",
      "result": {
        "report_type": "comprehensive",
        "report_length": 3960
      },
      "error": null,
      "execution_time": 0.0002720355987548828,
      "cache_hit": false
    }
  }
}