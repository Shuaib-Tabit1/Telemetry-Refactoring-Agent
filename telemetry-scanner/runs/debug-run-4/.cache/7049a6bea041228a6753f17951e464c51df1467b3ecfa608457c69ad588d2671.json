[
  [
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.GateKeeper/Middlewares/LogAsyncRequestHttpMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.API.GateKeeper.Telemetry;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.API.GateKeeper.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.API.GateKeeper\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Profile/ProfileModule.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Runtime.Serialization.Formatters.Binary;\nusing System.Threading;\nusing System.Web;\nusing System.Web.SessionState;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.RequestHeaders;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Config.Context;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.MVC;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\nusing log4net;\n\nnamespace ADEXS.Web.Common.Profile\n{\n\tpublic class ProfileModule : IHttpModule\n\t{\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(\"ADEXS.Web.Common\");\n\n\n\t\tprivate PerformanceLog _performanceLog;\n\t\tprivate IDisposable _logContext;\n\n\t\t[EventSource(\"Session Size\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Size\", \"CLM.SessionState\", DisplayUnit = CounterUnit.kilobytes,\n\t\t\tRanges = new double[10] { 1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 20000 },\n\t\t\tMeasureProperty = \"Count\", InstanceProperty = \"Description\", ShowVolume = true)]\n\t\tprivate static readonly CountEventSource _sessionSizeEventSource = new CountEventSource();\n\n\t\t[EventSource(\"Session Serialization Timing\", \"CLM.SessionState\")]\n\t\t[Counter(\"Session Serialization Timing\", \"CLM.SessionState\", DisplayUnit = CounterUnit.milliseconds,\n\t\t\tRanges = new double[10] { 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t\tMeasureProperty = \"Duration\", SuccessProperty = \"Success\", InstanceProperty = \"Description\")]\n\t\tprivate static readonly TimingEventSource _sessionSerializationTimingEventSource = new TimingEventSource();\n\n\t\t[EventSource(\"Large Session\", \"CLM.SessionState\")]\n\t\t[Counter(\"Large Session\", \"CLM.SessionState\")]\n\t\tprivate static readonly PropertyBagEventSource _largeSessionEventSource = new PropertyBagEventSource();\n\n\t\t/// <summary>\n\t\t/// You will need to configure this module in the web.config file of your\n\t\t/// web and register it with IIS before being able to use it. For more information\n\t\t/// see the following link: http://go.microsoft.com/?linkid=8101007\n\t\t/// </summary>\n\t\t#region IHttpModule Members\n\n\t\tpublic void Dispose()\n\t\t{\n\t\t\t//clean-up code here.\n\t\t}\n\n\t\tpublic void Init(HttpApplication context)\n\t\t{\n\t\t\t// Below is an example of how you can handle LogRequest event and provide\n\t\t\t// custom logging implementation for it\n\t\t\tcontext.BeginRequest += OnBeginRequest;\n\t\t\tcontext.PreRequestHandlerExecute += OnPreRequestHandlerExecute;\n\t\t\tcontext.PostRequestHandlerExecute += OnPostRequestHandlerExecute;\n\t\t\tcontext.EndRequest += OnEndRequest;\n\t\t\tcontext.Error += OnError;\n\t\t}\n\n\t\t/* IIS request life cycle BeginRequest ->  AuthenticateRequest -> AuthorizeRequest -> ResolveRequestCache -> AcquireRequestState ->\n\t\t * PreRequestHandlerExecute -> ProcessRequest -> PostRequestHandlerExecute -> ReleaseRequestState -> UpdateRequestCache -> EndRequest */\n\n\t\tprivate void OnBeginRequest(object sender, EventArgs e)\n\t\t{\n\t\t\tif (_performanceLog == null)\n\t\t\t\t_performanceLog = new PerformanceLog();\n\n\t\t\t_performanceLog.Start(HttpContext.Current.Request);\n\t\t}\n\n\t\tprivate void OnPostRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(HttpContext.Current);\n\t\t\tLogSessionSize(HttpContext.Current?.Session);\n\t\t\t_performanceLog.SetSession(HttpContext.Current?.Session);\n\t\t}\n\n\t\tprivate void OnPreRequestHandlerExecute(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tHttpContext context = HttpContext.Current;\n\t\t\t\tAtlasContext.Reset();\n\n\t\t\t\t// MonitoringContext is initialized in the ScmLogRequestHttpModule module on\n\t\t\t\t// BeginRequest. This runs before this event handler. By this time the\n\t\t\t\t// CorrelationToken is set. Including getting it from the X-DocuSign-CorrelationToken header if available.\n\t\t\t\tGuid corrId = MonitoringContext.CorrelationToken ?? Guid.Empty;\n\t\t\t\tif (Guid.Empty == corrId)\n\t\t\t\t{\n\t\t\t\t\t// Only in extremely unlikely scenario\n\t\t\t\t\tGuid.TryParse(AtlasContext.Current.TransactionId, out corrId);\n\t\t\t\t\tMonitoringContext.CorrelationToken = corrId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAtlasContext.Current.TransactionId = corrId.ToString();\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t// Now we'll have TransactionId, CorrelationId, and CorrelationToken all set to the same value. Three is a crowd?...\n\t\t\t\t_logContext = LogContext.Set(AtlasContext.Current.TransactionId);\n\n\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t{\n\t\t\t\t\t_log.DebugNoPII($\"ServiceLocator:\\n{ServiceLocator.Container.WhatDoIHave(typeof(ILogContextStore))}\");\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Reset();\n\t\t\t\tif (context != null)\n\t\t\t\t{\n\t\t\t\t\tif (context.Request != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tAtlasContext.Current.ClientIpAddress = IPAddressUtil.FetchIpAddress(context.Request);\n\t\t\t\t\t\tAtlasContext.Current.ClientUserAgent = context.Request.UserAgent;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Similar code exists for web services, which don't use session.\n\t\t\t\t\t// That code is in SetContextIds\n\t\t\t\t\tHttpSessionState session = context.Session;\n\t\t\t\t\tif (session != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tUserAccount user = CommonData.CurrentUser;\n\t\t\t\t\t\tif (user != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAtlasContext.Current.AccountId = user.AccountId;\n\t\t\t\t\t\t\tAtlasContext.Current.UserAccountUid = user.Uid;\n\t\t\t\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = user.AccountId == int.MinValue ? \"null\" : user.AccountId.ToString();\n\n\t\t\t\t\t\t\tvar userContextSetter = AtlasWebDependencyResolver.ScopedInstance?.GetService<IUserContextSetter>();\n\t\t\t\t\t\t\tif (userContextSetter != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.InfoNoPII($\"The user's AccountId: {user.AccountId} for user id: {user.Uid} in OnPreRequestHandlerExecute.\");\n\t\t\t\t\t\t\t\t// ensure that DI consumers have access the user/account context\n\t\t\t\t\t\t\t\tuserContextSetter.AccountId = user.AccountId;\n\t\t\t\t\t\t\t\tuserContextSetter.UserId = user.Uid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_log.WarnNoPII(\"No UserContextSetter is available - account context propagation will not work.\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar docusignAccountId = CommonData.DocuSignAccountId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignAccountId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignAccountId = docusignAccountId;\n\n\t\t\t\t\t\t\tvar docusignUserId = CommonData.DocuSignUserId;\n\t\t\t\t\t\t\tif (!string.IsNullOrEmpty(docusignUserId))\n\t\t\t\t\t\t\t\tAtlasContext.Current.DocuSignUserId = docusignUserId;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnPreRequestHandlerExecute in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Measuring session size ATL-56207\n\t\t/// </summary>\n\t\tprivate static void LogSessionSize(HttpSessionState session)\n\t\t{\n\t\t\tif (session == null || !Configuration.GetBooleanAppSetting(\"EnableSessionSizeLogging\", false))\n\t\t\t\treturn;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlong totalSessionBytes = 0;\n\t\t\t\tstring largestItemKey = string.Empty;\n\t\t\t\tlong largestItemSizeBytes = 0;\n\t\t\t\tint itemCount = 0;\n\n\t\t\t\tusing (OperationTimer sessionSerializationTimer = _sessionSerializationTimingEventSource.CreateTimer())\n\t\t\t\t{\n\t\t\t\t\tBinaryFormatter formatter = new BinaryFormatter();\n\t\t\t\t\tforeach (var sessionKey in session)\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (Stream s = new MemoryStream())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstring key = (string)sessionKey;\n\t\t\t\t\t\t\tvar item = session[key];\n\t\t\t\t\t\t\tif (item != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\titemCount++;\n\n\t\t\t\t\t\t\t\tformatter.Serialize(s, item);\n\n\t\t\t\t\t\t\t\tif (s.Length > largestItemSizeBytes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlargestItemKey = key;\n\t\t\t\t\t\t\t\t\tlargestItemSizeBytes = s.Length;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttotalSessionBytes += s.Length;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsessionSerializationTimer.SetResult(true);\n\t\t\t\t}\n\n\t\t\t\t_sessionSizeEventSource.Emit(totalSessionBytes);\n\n\t\t\t\tif (totalSessionBytes > Configuration.GetInt64AppSetting(\"LargeSessionSizeLoggingThreshold\", 1000000)) // default to 1MB\n\t\t\t\t{\n\t\t\t\t\tstring aid = AtlasContext.Current?.AccountId.ToString();\n\t\t\t\t\tstring userId = AtlasContext.Current?.UserAccountUid.ToString();\n\n\t\t\t\t\tusing (var propertyBag = _largeSessionEventSource.CreateEventPropertyBag())\n\t\t\t\t\t{\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"AccountId\", aid);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"UserAccountUid\", userId);\n\n\t\t\t\t\t\tif (_log.IsDebugEnabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionId\", session.SessionID);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionSizeInBytes\", totalSessionBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemKey\", largestItemKey);\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemSizeInBytes\", largestItemSizeBytes.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"TotalSessionItemCount\", itemCount.ToString());\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"ThreadId\", Thread.CurrentThread.ManagedThreadId.ToString());\n\t\t\t\t\t}\n\n\t\t\t\t\t_log.InfoNoPII($\"Detected Large SessionState. AccountId {aid} UserAccountUid {userId} SessionId {session.SessionID} SessionSizeInBytes {totalSessionBytes} TotalItemCount {itemCount} Largest Item Key {largestItemKey} ({largestItemSizeBytes})\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Exception occurred while attempting to measure session.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnError(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t//get latest exception (top level exception is probably an HTTPUnhandledException which contains underlying exceptions via .InnerException)\n\n\t\t\t\tException baseException = null;\n\t\t\t\tvar lastError = HttpContext.Current.Server.GetLastError();\n\t\t\t\tif (lastError == null)\n\t\t\t\t{\n\t\t\t\t\tvar allError = HttpContext.Current.AllErrors;\n\t\t\t\t\tif (allError != null && allError.Length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tbaseException = allError[allError.Length - 1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbaseException = lastError.GetBaseException();\n\t\t\t\t}\n\n\t\t\t\tif (_performanceLog != null) _performanceLog.Stop(baseException);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnError in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnEndRequest(object sender, EventArgs e)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (_performanceLog != null)\n\t\t\t\t{\n\t\t\t\t\t_performanceLog.Stop();\n\t\t\t\t\t_performanceLog.Dispose();\n\t\t\t\t\t_performanceLog = null;\n\t\t\t\t}\n\n\t\t\t\t_logContext?.Dispose();\n\t\t\t\t_logContext = null;\n\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] = \"null\";\n\n\t\t\t\t// we are no longer looking for outstanding DB transactions here.\n\t\t\t\t// because the module does not have to run in the same thread as the request handler\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Trouble OnEndRequest in ProfileModule.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tAtlasContext.Current.CacheClient.FlushCache();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\t_log.WarnNoPII(\"Could not clear the user settings on the thread for the request.\", ex);\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t}\n\n\t\t#endregion\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/Helpers/BaseApiHandler.cs",
      "content": "\ufeffusing System;\nusing System.Collections.Specialized;\nusing System.Diagnostics;\nusing System.Text;\nusing System.Threading;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Model;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Web.Common.Helpers;\n\nusing DocuSign.DynamicSettings;\nusing DocuSign.Monitoring;\n\nnamespace ADEXS.Web.Common;\n/// <summary>\n/// Temporary Base class to redirect the ASHX API call to new Controller API as part of the effort of web migration to .net6\n/// This will eventually cleaned up once we move to .net6\n/// </summary>\npublic abstract class BaseApiHandler : IHttpHandler\n{\n\t[EventSource(\"Exception\", \"CLM.FeatureFlags.PopulateFeatureFlagContext\")]\n\t[Counter(\"Exception\", \"CLM.FeatureFlags.PopulateFeatureFlagContext\", InstanceProperty = \"Description\")]\n\tprivate static ExceptionEventSource _featureFlagContextExceptionEventSource = new ExceptionEventSource();\n\n\tprivate static readonly IDiscreetLogger Logger = DiscreetLogger.GetLogger(typeof(BaseApiHandler));\n\n\t// reletive path for new controller api. ex) \"A/TileView/GetTiles\"\n\t// where full url is https://localhost/atlas/A/TileView/GetTiles\n\tprotected abstract string Path { get; }\n\n\tpublic virtual bool IsReusable { get; set; }\n\n\tpublic virtual void ProcessRequest(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tPopulateFeatureFlagContext(AtlasContext.Current.UserAccount, context);\n\t\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to Populate Feature Flag Context: {LogData()}\", ex);\n\t\t}\n\n\t\tif (ShouldRedirectHelper())\n\t\t{\n\t\t\tRedirect(context);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tHandleRequest(context);\n\t\t}\n\t}\n\n\tprotected abstract bool ShouldRedirect();\n\tprotected abstract void HandleRequest(HttpContext context);\n\n\tprivate string LogData()\n\t{\n\t\treturn $\"aid:{AtlasContext.Current.AccountId} uid:{AtlasContext.Current.UserAccountUid} relativeUrl: {Path}\";\n\t}\n\tprivate void Redirect(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t\t}\n\n\t\t\t// Get the original path info\n\t\t\tvar pathInfo = !string.IsNullOrEmpty(context.Request.PathInfo) ? context.Request.PathInfo : \"\";\n\n\t\t\t// Get the original query string\n\t\t\tvar queryString = context.Request.QueryString;\n\n\t\t\t// URL-encode pathInfo and queryString before building the new URL\n\t\t\tvar encodedPathInfo = HttpUtility.UrlPathEncode(pathInfo);\n\t\t\tvar encodedQueryString = ToUrlEncodedQueryString(queryString);\n\n\t\t\tvar baseUrl = AtlasUrlHelper.WebApplicationBasePath();\n\t\t\tvar newUrl = $\"{baseUrl}/{Path}{encodedPathInfo}{encodedQueryString}\";\n\n\t\t\t// Set the status code to 307 Temporary Redirect\n\t\t\tcontext.Response.StatusCode = Microsoft.AspNetCore.Http.StatusCodes.Status307TemporaryRedirect;\n\n\t\t\t// Set the Location header with the new Controller URL\n\t\t\tcontext.Response.AddHeader(\"Location\", newUrl);\n\n\t\t}\n\t\tcatch (ThreadAbortException)\n\t\t{\n\t\t\t// Do nothing intentionally.\n\t\t\t// The above Redirect call is *meant* to abort the thread with an exception and we do _not_ want it caught by the below catch block.\n\t\t\t// See this article for why we are catching it here and why we do nothing in this block.\n\t\t\t// https://learn.microsoft.com/en-us/dotnet/standard/threading/destroying-threads#handling-threadabortexception\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to Redirect: {LogData()}\", ex);\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprivate bool ShouldRedirectHelper()\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn ShouldRedirect();\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tLogger.ErrorNoPII($\"Failed to evaluate ShouldRedirect: {LogData()}\", ex);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate static void PopulateFeatureFlagContext(UserAccount currentUser, HttpContext context)\n\t{\n\t\tif (context == null)\n\t\t{\n\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t}\n\n\t\tif (currentUser == null || !ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId > 0)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = AtlasContext.Current.AccountId;\n\t\t\t}\n\t\t\telse if (context.Request.QueryString[Constants.QueryStringParameters.AccountIdAbbreviated] != null)\n\t\t\t{\n\t\t\t\tif (int.TryParse(context.Request.QueryString[Constants.QueryStringParameters.AccountIdAbbreviated], out var accountId))\n\t\t\t\t{\n\t\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = accountId;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountId] = currentUser.AccountId;\n\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.UserId] = currentUser.Uid;\n\t\t\tif (currentUser.Account != null)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.AccountType] = currentUser.Account.AccountType;\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.PlanName] = NpsUtilities.GetPlanIdName(currentUser.Account);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\t_featureFlagContextExceptionEventSource.Emit(ex);\n\t\t}\n\t}\n\n\tprivate static string ToUrlEncodedQueryString(NameValueCollection collection)\n\t{\n\t\tif (collection == null || collection.Count == 0)\n\t\t{\n\t\t\treturn string.Empty;\n\t\t}\n\n\t\tvar builder = new StringBuilder();\n\t\tvar first = true;\n\t\tfor (var i = 0; i < collection.Count; i++)\n\t\t{\n\t\t\tvar key = collection.GetKey(i);\n\t\t\tvar value = collection.Get(i);\n\t\t\tbuilder.Append(first ? '?' : '&');\n\t\t\tfirst = false;\n\t\t\tbuilder.Append(HttpUtility.UrlEncode(key));\n\t\t\tbuilder.Append('=');\n\t\t\tbuilder.Append(HttpUtility.UrlEncode(value));\n\t\t}\n\n\t\treturn builder.ToString();\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Contains method call: SetTag (1 times)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Middlewares/LogAsyncRequestHttpMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing ADEXS.Web.Telemetry;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\nusing ADEXS.Core.Domain.Utilities;\n\nnamespace ADEXS.Web.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.WebNet\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences); Telemetry infrastructure: Import: DocuSign.CLM.Monitoring.HttpModules, Import: DocuSign.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions; Matches 2 keywords: middleware, OpenTelemetry",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag",
        "Pattern: Monitoring",
        "Import: DocuSign.Monitoring",
        "Pattern: Instrumentation",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
        "Pattern: Activity.Current",
        "Import: DocuSign.CLM.Monitoring.HttpModules",
        "OpenTelemetry",
        "middleware",
        "Pattern: OpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.Allocation/Middlewares/LogAsyncRequestHttpMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.API.Allocation.Telemetry;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Monitoring;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.API.Allocation.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic class LogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\t[EventSource(\"LogRequestHttpMiddleware\", \"CLM.API.Allocation\")]\n\tprivate static readonly PropertyBagEventSource PropBagEvent = new();\n\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic LogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tpublic LogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tprotected override PropertyBagEventSource LogRequestHttpModulePropBagEvent => PropBagEvent;\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ProfileMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nusing log4net;\n\nusing Microsoft.AspNetCore.Http;\n\nusing Microsoft.AspNetCore.Http.Features;\n\nnamespace ADEXS.Web.Common.AspNetCore.Middlewares;\n\npublic sealed class ProfileMiddleware : IDisposable\n{\n\tprivate static readonly IDiscreetLogger Log = DiscreetLogger.GetLogger(typeof(ProfileMiddleware));\n\tprivate readonly RequestDelegate _next;\n\tprivate IDisposable? _logContext;\n\n\t[EventSource(\"Session Size\", \"CLM.SessionState\")]\n\t[Counter(\n\t\t\"Session Size\",\n\t\t\"CLM.SessionState\",\n\t\tDisplayUnit = CounterUnit.kilobytes,\n\t\tRanges = new double[10] { 1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 20000 },\n\t\tMeasureProperty = \"Count\",\n\t\tInstanceProperty = \"Description\",\n\t\tShowVolume = true)]\n\tprivate static readonly CountEventSource SessionSizeEventSource = new CountEventSource();\n\n\t[EventSource(\"Session Serialization Timing\", \"CLM.SessionState\")]\n\t[Counter(\n\t\t\"Session Serialization Timing\",\n\t\t\"CLM.SessionState\",\n\t\tDisplayUnit = CounterUnit.milliseconds,\n\t\tRanges = new double[10] { 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\tMeasureProperty = \"Duration\",\n\t\tSuccessProperty = \"Success\",\n\t\tInstanceProperty = \"Description\")]\n\tprivate static readonly TimingEventSource SessionSerializationTimingEventSource = new TimingEventSource();\n\n\t[EventSource(\"Large Session\", \"CLM.SessionState\")]\n\t[Counter(\"Large Session\", \"CLM.SessionState\")]\n\tprivate static readonly PropertyBagEventSource LargeSessionEventSource = new PropertyBagEventSource();\n\n\t// Avoid using HttpContext.Session directly because it will throw an exception if the session is not available.\n\tprivate static bool HasSession(HttpContext context) =>\n\t\tcontext?.Features?.Get<ISessionFeature>() != null && context?.Session != null;\n\n\tpublic ProfileMiddleware(RequestDelegate next)\n\t{\n\t\t_next = next;\n\t}\n\n\tpublic async Task InvokeAsync(HttpContext context)\n\t{\n\t\tif (context != null)\n\t\t{\n\t\t\t// Do something with context near the beginning of request processing.\n\t\t\tOnPreRequestHandlerExecute(context);\n\n\t\t\tawait _next.Invoke(context);\n\n\t\t\t// Clean up.\n\t\t\tOnPostRequestHandlerExecute(context);\n\t\t\tOnEndRequest();\n\t\t}\n\t}\n\n\tpublic void Dispose()\n\t{\n\t\t_logContext?.Dispose();\n\t}\n\n\tprivate void OnPreRequestHandlerExecute(HttpContext context)\n\t{\n\t\ttry\n\t\t{\n\t\t\tLog.DebugNoPII(\"OnPreRequestHandlerExecute called.\");\n\t\t\tAtlasContext.Reset();\n\n\t\t\t// MonitoringContext is initialized in the AbstractLogRequestHttpMiddleware on\n\t\t\t// BeginRequest. This runs before this event handler. By this time the\n\t\t\t// CorrelationToken is set. Including getting it from the X-DocuSign-CorrelationToken header if available.\n\t\t\tvar corrId = MonitoringContext.CorrelationToken ?? Guid.Empty;\n\t\t\tif (corrId == Guid.Empty)\n\t\t\t{\n\t\t\t\t// Only in extremely unlikely scenario\n\t\t\t\tif (Guid.TryParse(AtlasContext.Current.TransactionId, out corrId))\n\t\t\t\t{\n\t\t\t\t\tLog.WarnNoPII(\n\t\t\t\t\t\t\"MonitoringContext.CorrelationToken was not set, but AtlasContext.Current.TransactionId was set. Using it to set MonitoringContext.CorrelationToken.\");\n\t\t\t\t\tMonitoringContext.CorrelationToken = corrId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog.WarnNoPII(\n\t\t\t\t\t\t\"MonitoringContext.CorrelationToken was not set, and AtlasContext.Current.TransactionId was not a valid Guid. Using Guid.Empty.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"MonitoringContext.CorrelationToken set to: {corrId}\");\n\t\t\t\tAtlasContext.Current.TransactionId = corrId.ToString();\n\t\t\t}\n\n\t\t\t// Overwrite TransactionId to use Activity.Current.Id\n\t\t\tif (!string.IsNullOrWhiteSpace(Activity.Current?.Id))\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Activity.Current.Id is set to: {Activity.Current.Id}. Overwriting AtlasContext.Current.TransactionId.\");\n\t\t\t\tAtlasContext.Current.TransactionId = Activity.Current.Id;\n\t\t\t}\n\n\t\t\tLog.DebugNoPII($\"AtlasContext.Current.TransactionId set to: {AtlasContext.Current.TransactionId}\");\n\t\t\t_logContext?.Dispose();\n\t\t\t_logContext = LogContext.Set(AtlasContext.Current.TransactionId);\n\n\t\t\tif (Log.IsDebugEnabled)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"ServiceLocator:\\n{ServiceLocator.Container.WhatDoIHave(typeof(ILogContextStore))}\");\n\t\t\t}\n\n\t\t\tif (context.Connection != null)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Connection RemoteIpAddress: {context.Connection.RemoteIpAddress?.ToString()}\");\n\t\t\t\tAtlasContext.Current.ClientIpAddress = context.Connection.RemoteIpAddress?.ToString();\n\t\t\t}\n\n\t\t\tif (context.Request != null)\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Request Path: {context.Request.Path}\");\n\t\t\t\tAtlasContext.Current.ClientUserAgent = context.Request.Headers?.UserAgent.ToString();\n\t\t\t}\n\n\t\t\t// Similar code exists for web services, which don't use session.\n\t\t\t// That code is in SetContextIds\n\t\t\tif (HasSession(context))\n\t\t\t{\n\t\t\t\tLog.DebugNoPII($\"Session Id: {context.Session.Id}\");\n\t\t\t\tvar user = CommonData.CurrentUser;\n\t\t\t\tif (user != null)\n\t\t\t\t{\n\t\t\t\t\tLog.DebugNoPII($\"User AccountId: {user.AccountId}, User Uid: {user.Uid}\");\n\t\t\t\t\tAtlasContext.Current.AccountId = user.AccountId;\n\t\t\t\t\tAtlasContext.Current.UserAccountUid = user.Uid;\n\t\t\t\t\tLogicalThreadContext.Properties[\"accountid\"] =\n\t\t\t\t\t\tuser.AccountId == int.MinValue ? \"null\" : user.AccountId.ToString();\n\n\t\t\t\t\tvar docusignAccountId = CommonData.DocuSignAccountId;\n\t\t\t\t\tif (!string.IsNullOrEmpty(docusignAccountId))\n\t\t\t\t\t{\n\t\t\t\t\t\tLog.DebugNoPII($\"DocuSign AccountId: {docusignAccountId}\");\n\t\t\t\t\t\tAtlasContext.Current.DocuSignAccountId = docusignAccountId;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar docusignUserId = CommonData.DocuSignUserId;\n\t\t\t\t\tif (!string.IsNullOrEmpty(docusignUserId))\n\t\t\t\t\t{\n\t\t\t\t\t\tLog.DebugNoPII($\"DocuSign UserId: {docusignUserId}\");\n\t\t\t\t\t\tAtlasContext.Current.DocuSignUserId = docusignUserId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLog.DebugNoPII(\"No user found in session.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLog.DebugNoPII(\"No session found.\");\n\t\t\t}\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Error setting AtlasContext.Current properties.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n\n\tprivate static void OnPostRequestHandlerExecute(HttpContext context)\n\t{\n\t\tActivity.Current?.SetTagsWithCommonFields(context);\n\t\tif (HasSession(context))\n\t\t{\n\t\t\tLogSessionSize(context.Session);\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// Measuring session size ATL-56207\n\t/// </summary>\n\tprivate static void LogSessionSize(ISession session)\n\t{\n\t\tif (!Configuration.GetBooleanAppSetting(\"EnableSessionSizeLogging\", false))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tlong totalSessionBytes = 0;\n\t\t\tvar largestItemKey = string.Empty;\n\t\t\tlong largestItemSizeBytes = 0;\n\t\t\tvar itemCount = 0;\n\n\t\t\tusing (var sessionSerializationTimer = SessionSerializationTimingEventSource.CreateTimer())\n\t\t\t{\n\t\t\t\tforeach (var sessionKey in session.Keys)\n\t\t\t\t{\n\t\t\t\t\tif (session.TryGetValue(sessionKey, out var bytes))\n\t\t\t\t\t{\n\t\t\t\t\t\titemCount++;\n\t\t\t\t\t\tif (bytes.Length > largestItemSizeBytes)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlargestItemKey = sessionKey;\n\t\t\t\t\t\t\tlargestItemSizeBytes = bytes.Length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttotalSessionBytes += bytes.Length;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsessionSerializationTimer.SetResult(true);\n\t\t\t}\n\n\t\t\tSessionSizeEventSource.Emit(totalSessionBytes);\n\n\t\t\t// default to 1MB\n\t\t\tif (totalSessionBytes > Configuration.GetInt64AppSetting(\"LargeSessionSizeLoggingThreshold\", 1000000))\n\t\t\t{\n\t\t\t\tvar aid = AtlasContext.Current?.AccountId.ToString();\n\t\t\t\tvar userId = AtlasContext.Current?.UserAccountUid.ToString();\n\n\t\t\t\tusing (var propertyBag = LargeSessionEventSource.CreateEventPropertyBag())\n\t\t\t\t{\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"AccountId\", aid);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"UserAccountUid\", userId);\n\n\t\t\t\t\tif (Log.IsDebugEnabled)\n\t\t\t\t\t{\n\t\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionId\", session.Id);\n\t\t\t\t\t}\n\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"SessionSizeInBytes\", totalSessionBytes.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemKey\", largestItemKey);\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"LargestSessionItemSizeInBytes\", largestItemSizeBytes.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"TotalSessionItemCount\", itemCount.ToString());\n\t\t\t\t\tpropertyBag.AddOrUpdate(\"ThreadId\", Environment.CurrentManagedThreadId.ToString());\n\t\t\t\t}\n\n\t\t\t\tLog.InfoNoPII(\n\t\t\t\t\t$\"Detected Large SessionState. AccountId {aid} UserAccountUid {userId} SessionId {session.Id} SessionSizeInBytes {totalSessionBytes} TotalItemCount {itemCount} Largest Item Key {largestItemKey} ({largestItemSizeBytes})\");\n\t\t\t}\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Exception occurred while attempting to measure session.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n\n\tprivate void OnEndRequest()\n\t{\n\t\ttry\n\t\t{\n\t\t\t_logContext?.Dispose();\n\t\t\t_logContext = null;\n\t\t\tLogicalThreadContext.Properties[\"accountid\"] = \"null\";\n\n\t\t\t// we are no longer looking for outstanding DB transactions here.\n\t\t\t// because the module does not have to run in the same thread as the request handler\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Trouble OnEndRequest in ProfileModule.\", ex);\n\t\t\tex.Report();\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tAtlasContext.Current.CacheClient.FlushCache();\n\t\t}\n#pragma warning disable CA1031 // Do not catch general exception types\n\t\tcatch (Exception ex)\n#pragma warning restore CA1031 // Do not catch general exception types\n\t\t{\n\t\t\tLog.WarnNoPII(\"Could not clear the user settings on the thread for the request.\", ex);\n\t\t\tex.Report();\n\t\t}\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common.AspNetCore/Web.Common.AspNetCore/Middlewares/ScmLogAsyncRequestHttpMiddleware.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Telemetry;\n\nusing DocuSign.CLM.Monitoring.HttpModules;\nusing DocuSign.Platform;\n\nusing Microsoft.AspNetCore.Http;\n\nnamespace ADEXS.Web.Common.AspNetCore.Middlewares;\n\n/// <summary>\n/// Middleware that logs requests to KazMon. Code ensures monitoring context runs in both IIS HttpContext and async CallContext.\n/// </summary>\npublic abstract class ScmLogAsyncRequestHttpMiddleware : AbstractLogRequestHttpMiddleware\n{\n\tprivate readonly IServiceInstrumentation _serviceInstrumentation;\n\n\tstatic ScmLogAsyncRequestHttpMiddleware()\n\t{\n\t\t// Indicate that we're running in both IIS HttpContext and async CallContext.\n\t\t// This ensures that logging works properly.\n\t\tSystemUtil.RunningInAsyncAndIisContexts = true;\n\t\tSystemUtil.RunningInDotNetCore = true;\n\t}\n\n\tprotected ScmLogAsyncRequestHttpMiddleware(RequestDelegate next, IServiceInstrumentation serviceInstrumentation)\n\t\t: base(next)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t}\n\n\tpublic override async Task Invoke(HttpContext context)\n\t{\n\t\tvar activity = Activity.Current;\n\n\t\ttry\n\t\t{\n\t\t\tcontext.AddKazMonServerVariables();\n\t\t\tactivity?.SetTagsWithCommonFields(context);\n\t\t\tawait base.Invoke(context);\n\t\t\tactivity?.SetStatus(context?.Response.StatusCode < 400 ? ActivityStatusCode.Ok : ActivityStatusCode.Error);\n\t\t}\n\t\tcatch (Exception ex) when (ex.TraceAndIgnore(activity, ActivityStatusCode.Error))\n\t\t{\n\t\t\tthrow;\n\t\t}\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/MVC/Filters/MvcAuditedRequestAttribute.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\n#if NETFRAMEWORK\nusing System.Web;\nusing System.Web.Mvc;\nusing System.Web.Routing;\nusing ADEXS.Web.CommonUI.Helpers;\n#else\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.AspNetCore.Http;\n#endif\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.FeatureFlags;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Extensions;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.DynamicSettings;\nusing DocuSign.Monitoring;\nusing ADEXS.Core.Domain.Utilities;\n\nnamespace ADEXS.Web.CommonUI.MVC.Filters\n{\n\tpublic abstract class MvcAuditedRequestAttribute : ActionFilterAttribute, IActionFilter, IExceptionFilter\n\t{\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Duration\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Duration\", \"CLM.API\",\n\t\t/// InstanceProperty = \"Description\",\n\t\t/// DisplayUnit = CounterUnit.milliseconds,\n\t\t/// Ranges = new double[10] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t/// MeasureProperty = \"Duration\",\n\t\t/// SuccessProperty = \"Success\")]\n\t\t/// static readonly TimingEventSource apiEventSource = new TimingEventSource();\n\t\t/// </summary>\n\t\tprotected abstract TimingEventSource ApiEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Attempts\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Attempts\", \"CLM.API\", InstanceProperty = \"Description\")]\n\t\t/// static readonly SimpleEventSource attemptEventSource = new SimpleEventSource();\n\t\t/// </summary>\n\t\tprotected abstract SimpleEventSource AttemptEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the timing Stopwatch instance will be stored.\n\t\t/// Example: \"ClmApi.Stopwatch\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_StopWatch { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the the name of the counter instance will be stored.\n\t\t/// Example: \"ClmApi.InstanceName\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_CounterInstance { get; }\n\n\t\tprivate static string NO_CONTROLLER_STRING = \"_no-controller_\";\n\t\tprivate static string NO_ACTION_NAME = \"_no-action_\";\n\t\tprivate static string NO_HTTP_VERB = \"_no-verb_\";\n\n\t\tpublic override void OnActionExecuting(ActionExecutingContext filterContext)\n\t\t{\n#if NETFRAMEWORK\n\t\t\tstring controllerName = filterContext.ActionDescriptor.ControllerDescriptor.ControllerName;\n\t\t\tServiceContext.Log(DataPoint.ApiController, controllerName);\n\t\t\tstring actionName = filterContext.ActionDescriptor.ActionName;\n\t\t\tServiceContext.Log(DataPoint.Action, actionName);\n#else\n\t\t\tvar controllerName = filterContext.ActionDescriptor.RouteValues[\"controller\"] ?? NO_CONTROLLER_STRING;\n\t\t\tServiceContext.Log(DataPoint.ApiController, controllerName);\n\t\t\tvar actionName = filterContext.ActionDescriptor.RouteValues[\"action\"] ?? NO_ACTION_NAME;\n\t\t\tServiceContext.Log(DataPoint.Action, actionName);\n#endif\n\n\t\t\tif (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.ControllerName] = controllerName;\n\t\t\t\tDynamicSettingsContext.Items[DynamicSettingsContextItems.ActionName] = actionName;\n\t\t\t}\n\n\t\t\tvar httpContext = filterContext.HttpContext;\n#if NETFRAMEWORK\n\t\t\tstring counterInstanceName = FormatInstanceName(controllerName, actionName, httpContext.Request.HttpMethod);\n#else\n\t\t\tvar counterInstanceName = FormatInstanceName(controllerName, actionName, httpContext.Request.Method);\n#endif\n\t\t\tAttemptEventSource.Emit(counterInstanceName);\n\n#if NETFRAMEWORK\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext?.ApplicationInstance?.Context);\n#else\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n#endif\n\n\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\thttpContext.Items[PropName_StopWatch] = sw;\n\t\t\thttpContext.Items[PropName_CounterInstance] = counterInstanceName;\n\n\t\t\tif (ApplicationSettings.EnableFeatureFlags && ApplicationSettings.TestFeatureFlagEvaluation)\n\t\t\t{\n\t\t\t\tint intSetting = AtlasFeatureFlags.DummyIntSetting;\n\t\t\t\tstring stringSetting = AtlasFeatureFlags.DummyStringSetting;\n\t\t\t\tServiceContext.Log(\n\t\t\t\t\tDataPoint.ApiRequestLogging,\n\t\t\t\t\t$\"intSetting: {intSetting} | stringSetting: {stringSetting}\");\n\t\t\t}\n\t\t}\n\n\t\tpublic override void OnActionExecuted(ActionExecutedContext filterContext)\n\t\t{\n\t\t\tSetCommonDataPoints();\n\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(filterContext.HttpContext);\n\t\t\tFinalizeLogging(sw, instanceName, false);\n\t\t}\n\n\t\tpublic virtual void OnException(ExceptionContext filterContext)\n\t\t{\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(filterContext.HttpContext);\n\t\t\tbool isServerError = IsServerError(filterContext.Exception);\n\t\t\tif (filterContext.Exception != null)\n\t\t\t{\n\t\t\t\tfilterContext.Exception.Trace().Report();\n\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, filterContext.Exception.Message);\n\t\t\t}\n\n\t\t\tFinalizeLogging(sw, instanceName, isServerError);\n\t\t}\n\n#if NETFRAMEWORK\n\t\tprivate (Stopwatch sw, string instanceName) GetStopWatchAndInstanceName(HttpContextBase context)\n\t\t{\n\t\t\tStopwatch sw = context.Items[PropName_StopWatch] as Stopwatch;\n\t\t\tif (null == sw)\n\t\t\t{\n\t\t\t\tsw = Stopwatch.StartNew();\n\t\t\t}\n\n\t\t\tstring instanceName = context.Items[PropName_CounterInstance] as string;\n\t\t\tif (null == instanceName)\n\t\t\t{\n\t\t\t\tinstanceName = FormatInstanceName(context);\n\t\t\t}\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n#else\n\t\tprivate (Stopwatch sw, string instanceName) GetStopWatchAndInstanceName(HttpContext context)\n\t\t{\n\t\t\tvar sw = context.Items[PropName_StopWatch] as Stopwatch ?? Stopwatch.StartNew();\n\n\t\t\tvar instanceName = context.Items[PropName_CounterInstance] as string ?? FormatInstanceName(context);\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n#endif\n\n#if NETFRAMEWORK\n\t\tprotected virtual string FormatInstanceName(HttpContextBase httpContext)\n\t\t{\n\t\t\tstring controllerName = NO_CONTROLLER_STRING;\n\t\t\tstring actionName = NO_ACTION_NAME;\n\t\t\tstring httpMethod = NO_HTTP_VERB;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tRouteData rd = httpContext.Request.RequestContext.RouteData;\n\t\t\t\tactionName = rd.GetRequiredString(\"action\");\n\t\t\t\tcontrollerName = rd.GetRequiredString(\"controller\");\n\t\t\t\thttpMethod = httpContext.Request.HttpMethod;\n\t\t\t}\n\t\t\tcatch(Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t\treturn FormatInstanceName(controllerName, actionName, httpMethod);\n\t\t}\n#else\n\t\tprotected virtual string FormatInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tobject? actionNameObj = null;\n\t\t\tobject? controllerNameObj = null;\n\t\t\tvar httpMethod = NO_HTTP_VERB;\n\t\t\ttry\n\t\t\t{\n\t\t\t\thttpContext.Request.RouteValues.TryGetValue(\"action\", out actionNameObj);\n\t\t\t\thttpContext.Request.RouteValues.TryGetValue(\"controller\", out controllerNameObj);\n\t\t\t\thttpMethod = httpContext.Request.Method;\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\n\t\t\tvar controllerName = controllerNameObj as string ?? NO_CONTROLLER_STRING;\n\t\t\tvar actionName = actionNameObj as string ?? NO_ACTION_NAME;\n\t\t\treturn FormatInstanceName(controllerName, actionName, httpMethod);\n\t\t}\n#endif\n\n\t\tprotected virtual string FormatInstanceName(string controllerName, string actionName, string httpMethod)\n\t\t{\n\t\t\treturn $\"{controllerName}.{actionName}.{httpMethod}\";\n\t\t}\n\n\t\tprivate void FinalizeLogging(Stopwatch sw, string instanceName, bool isError)\n\t\t{\n\t\t\tTimeSpan apiRunTime = TimeSpan.MinValue;\n\t\t\tif (sw != null)\n\t\t\t{\n\t\t\t\tapiRunTime = sw.Elapsed;\n\t\t\t}\n\n\t\t\tApiEventSource.Emit(apiRunTime, !isError, instanceName);\n\t\t}\n\n\t\tprotected virtual bool IsServerError(Exception exception)\n\t\t{\n\t\t\tbool isError = !(exception is AdexsDisplayException);\n\n\t\t\treturn isError;\n\t\t}\n\n\n\t\tpublic static void SetCommonDataPoints()\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId != int.MinValue)\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, AtlasContext.Current.AccountId);\n\t\t\tif (AtlasContext.Current.UserAccountUid != Guid.Empty)\n\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\tif (AtlasContext.Current.UserAccount != null)\n\t\t\t\tServiceContext.Log(DataPoint.AccountType, Enum.GetName(typeof(Enums.AccountType), AtlasContext.Current.UserAccount.Account.AccountType));\n\t\t}\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (2 occurrences); Contains method call: SetTag (2 times)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.CommonUI/Helpers/HttpRequestAuditHelper.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Exceptions;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.Types;\nusing ADEXS.Core.Util.Extensions;\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Monitoring;\n\nnamespace ADEXS.Web.CommonUI.Helpers\n{\n\tpublic abstract class HttpRequestAuditHelper\n\t{\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Duration\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Duration\", \"CLM.API\",\n\t\t///\tInstanceProperty = \"Description\",\n\t\t///\tDisplayUnit = CounterUnit.milliseconds,\n\t\t///\tRanges = new double[10] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 },\n\t\t///\tMeasureProperty = \"Duration\",\n\t\t///\tSuccessProperty = \"Success\")]\n\t\t/// static readonly TimingEventSource apiEventSource = new TimingEventSource();\n\t\t/// </summary>\n\t\tprotected abstract TimingEventSource ApiEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Should always return the same *statically* allocated instance. Example:\n\t\t/// [EventSource(\"Request Attempts\", \"CLM.API\")]\n\t\t/// [Counter(\"Request Attempts\", \"CLM.API\", InstanceProperty = \"Description\")]\n\t\t/// static readonly SimpleEventSource attemptEventSource = new SimpleEventSource();\n\t\t/// </summary>\n\t\tprotected abstract SimpleEventSource AttemptEventSource { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the timing Stopwatch instance will be stored.\n\t\t/// Example: \"ClmApi.Stopwatch\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_StopWatch { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which the the name of the counter instance will be stored.\n\t\t/// Example: \"ClmApi.InstanceName\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_CounterInstance { get; }\n\n\t\t/// <summary>\n\t\t/// Name of the property under which any error will be stored.\n\t\t/// Example: \"ClmApi.Error\"\n\t\t/// </summary>\n\t\tprotected abstract string PropName_Error { get; }\n\n\t\t/// <summary>\n\t\t/// Implementations are intended to be used as singletons.\n\t\t/// </summary>\n\t\tprotected HttpRequestAuditHelper()\n\t\t{\n\t\t}\n\n\t\tpublic static void SetCommonDataPoints()\n\t\t{\n\t\t\tif (AtlasContext.Current.AccountId != int.MinValue)\n\t\t\t\tServiceContext.Log(DataPoint.AccountId, AtlasContext.Current.AccountId);\n\t\t\tif (AtlasContext.Current.UserAccountUid != Guid.Empty)\n\t\t\t\tServiceContext.Log(DataPoint.UserId, AtlasContext.Current.UserAccountUid);\n\t\t\tif (AtlasContext.Current.UserAccount != null)\n\t\t\t\tServiceContext.Log(DataPoint.AccountType, Enum.GetName(typeof(Enums.AccountType), AtlasContext.Current.UserAccount.Account.AccountType));\n\t\t}\n\n\t\tpublic virtual void BeginRequest(HttpContext httpContext)\n\t\t{\n\t\t\tActivity.Current?.SetTagsWithCommonFields(httpContext);\n\n\t\t\tif (httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tstring counterInstanceName = FormatInstanceName(httpContext);\n\t\t\tAttemptEventSource.Emit(counterInstanceName);\n\n\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\thttpContext.Items[PropName_StopWatch] = sw;\n\t\t\thttpContext.Items[PropName_CounterInstance] = counterInstanceName;\n\t\t}\n\n\t\tpublic virtual void EndRequest(HttpContext httpContext)\n\t\t{\n\t\t\tif(httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSetCommonDataPoints();\n\t\t\t(Stopwatch sw, string instanceName) = GetStopWatchAndInstanceName(httpContext);\n\n\t\t\tbool isError = false;\n\t\t\tException exError = httpContext.Items[PropName_Error] as Exception;\n\t\t\tif (null != exError && !(exError is AdexsDisplayException))\n\t\t\t{\n\t\t\t\tisError = true;\n\t\t\t}\n\n\t\t\tFinalizeLogging(sw, instanceName, isError);\n\t\t}\n\n\t\tpublic virtual void SetError(HttpContext httpContext, Exception ex)\n\t\t{\n\t\t\tif(httpContext.Handler is MvcHandler)\n\t\t\t{\n\t\t\t\t// Handled via MvcAuditedRequestAttribute\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(null != ex)\n\t\t\t{\n\t\t\t\tex.Trace().Report();\n\t\t\t\tServiceContext.Log(DataPoint.ApiErrorMessage, ex.Message);\n\t\t\t\thttpContext.Items[PropName_Error] = ex;\n\t\t\t}\n\t\t}\n\n\t\tprivate (Stopwatch, string) GetStopWatchAndInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tStopwatch sw = httpContext.Items[PropName_StopWatch] as Stopwatch;\n\t\t\tif (null == sw)\n\t\t\t{\n\t\t\t\tsw = Stopwatch.StartNew();\n\t\t\t}\n\n\t\t\tstring instanceName = httpContext.Items[PropName_CounterInstance] as string;\n\t\t\tif (null == instanceName)\n\t\t\t{\n\t\t\t\tinstanceName = FormatInstanceName(httpContext);\n\t\t\t}\n\n\t\t\treturn (sw, instanceName);\n\t\t}\n\n\t\tprotected virtual string FormatInstanceName(HttpContext httpContext)\n\t\t{\n\t\t\tvar pageName = \"_no-page_\";\n\t\t\tvar httpMethod = \"_no-verb_\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\thttpMethod = httpContext.Request.HttpMethod;\n\t\t\t\tpageName = httpContext.Request.Url.Segments.Last();\n\t\t\t}\n\t\t\tcatch(Exception ex)\n\t\t\t{\n\t\t\t\tex.Report();\n\t\t\t}\n\t\t\t\n\t\t\treturn FormatInstanceName(pageName, httpMethod);\n\t\t}\n\n\t\tprotected virtual string FormatInstanceName(string pageName, string httpMethod)\n\t\t{\n\t\t\treturn $\"{pageName}.{httpMethod}\";\n\t\t}\n\n\t\tprivate void FinalizeLogging(Stopwatch sw, string instanceName, bool isError)\n\t\t{\n\t\t\tTimeSpan apiRunTime = TimeSpan.MinValue;\n\t\t\tif (sw != null)\n\t\t\t{\n\t\t\t\tapiRunTime = sw.Elapsed;\n\t\t\t}\n\n\t\t\tApiEventSource.Emit(apiRunTime, !isError, instanceName);\n\t\t}\n\t}\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (1 occurrences)",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.Domain/Utilities/ActivityEnricher.cs",
      "content": "\ufeffusing System.Diagnostics;\nusing System.Linq;\n\n\n#if NETFRAMEWORK\nusing System.Web;\n#else\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Http.Features;\n#endif\n\nusing DocuSign.Monitoring;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nnamespace ADEXS.Core.Domain.Utilities;\npublic static class ActivityEnricher\n{\n\tpublic static void SetTagsWithCommonFields(this Activity activity, HttpContext context)\n\t{\n\t\tif (activity == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tSetAccountIdTag(activity);\n\t\tSetUserIdTag(activity);\n\t\tSetSessionIdTag(activity, context);\n\t}\n\n\tprivate static void SetAccountIdTag(Activity activity)\n\t{\n\t\tif (AtlasContext.Current != null && AtlasContext.Current.AccountId != 0 && AtlasContext.Current.AccountId != int.MinValue)\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, AtlasContext.Current.AccountId);\n\t\t\treturn;\n\t\t}\n\n\t\tvar dataPointCollection = ServiceContext.Current?.DataPointCollection?.GetDataPointValues(DataPoint.AccountId);\n\t\tif (dataPointCollection != null)\n\t\t{\n\t\t\tvar account = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(account))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignAccountId, account);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void SetUserIdTag(Activity activity)\n\t{\n\t\tif (AtlasContext.Current != null && !System.Guid.Empty.Equals(AtlasContext.Current.UserAccountUid))\n\t\t{\n\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, AtlasContext.Current.UserAccountUid);\n\t\t\treturn;\n\t\t}\n\n\t\tvar dataPointCollection = ServiceContext.Current?.DataPointCollection?.GetDataPointValues(DataPoint.UserId);\n\t\tif (dataPointCollection != null)\n\t\t{\n\t\t\tvar userId = dataPointCollection.FirstOrDefault();\n\t\t\tif (!string.IsNullOrEmpty(userId))\n\t\t\t{\n\t\t\t\tactivity.SetTag(TraceSemanticConventions.AttributeDocuSignUserId, userId);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\n#if NETFRAMEWORK\n\tprivate static void SetSessionIdTag(Activity activity, HttpContext context)\n\t{\n\t\tif (!string.IsNullOrEmpty(context?.Session?.SessionID))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, context?.Session?.SessionID);\n\t\t}\n\t}\n#else\n\tprivate static void SetSessionIdTag(Activity activity, HttpContext context)\n\t{\n\t\tvar session = context == null ? null : GetSession(context);\n\t\tif (!string.IsNullOrEmpty(session?.Id))\n\t\t{\n\t\t\tactivity.SetTag(OtelSemanticConventions.SessionId, session?.Id);\n\t\t}\n\t}\n\n\tprivate static ISession GetSession(HttpContext context)\n\t{\n\t\tvar sessionFeature = context?.Features?.Get<ISessionFeature>();\n\t\treturn sessionFeature == null ? null : context.Session;\n\t}\n#endif\n\n}\n",
      "search_score": 100,
      "search_reasoning": "Direct match for 'SetTag' (7 occurrences); Direct match for 'Activity.SetTag' (6 occurrences); Contains method call: SetTag (7 times); Matches 2 keywords: Activity.SetTag, OpenTelemetry",
      "search_strategy": "keyword",
      "matching_patterns": [
        "SetTag",
        "Activity.SetTag",
        "OpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web.Common/ScmHttpApplication.cs",
      "content": "\ufeff// BUGBUG: ATL-71924 Move code dependent on System.Web out of Core.Domain\n#if NETFRAMEWORK\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading.Tasks;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.Utilities;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.ServiceFramework.Helpers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.FeatureFlags;\nusing ADEXS.Web.Common.Session;\n\nusing DocuSign.CLM.Monitoring;\nusing DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions;\n\nusing log4net;\nusing log4net.Config;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing ApplicationInfo = ADEXS.Core.Domain.Utilities.ApplicationInfo;\n\nnamespace ADEXS.Web.Common;\n\n/// <summary>\n/// Base class for all SCM web applications.\n/// </summary>\npublic abstract class ScmHttpApplication : HttpApplication\n{\n\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\t/// <summary>\n\t/// Don't use the standard Application_Start(). .Net picks one via reflection\n\t/// and runs it. Ends up being this one here, not the one in the derived class.\n\t/// </summary>\n\tprotected void ApplicationStart()\n\t{\n\t\t// log4net initialization\n\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n\t\tXmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\tConfigurationHelper.InitializeConfiguration();\n\n\t\tif (ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\n\t\t// Use MSF specific env variable, fallback to app settings.\n\t\tvar appName = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? AppConfig.AppName(ApplicationInfo.Name);\n\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? SiteConfig.Environment(\"Unknown\");\n\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\n\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\tapplicationName: appName,\n\t\t\tappVersion: typeof(ScmHttpApplication).Assembly.GetName().Version.ToString(),\n\t\t\tenvironmentName: environment,\n\t\t\tsiteName: site,\n\t\t\tpartitionName: partition,\n\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\tshouldEnableLogFileListener: () => Configuration.GetBooleanAppSetting(\"KazmonEnableLogFileListener\", false));\n\n\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t{\n\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\tassembly: typeof(ScmHttpApplication).Assembly,\n\t\t\t\t\tconfigureTracer: tracerProviderBuilder =>\n\t\t\t\t\t{\n\t\t\t\t\t\t_ = tracerProviderBuilder\n\t\t\t\t\t\t\n\t\t\t\t\t\t.AddAspNetInstrumentation(options =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t})\n\t\t\t\t\t.AddSource(typeof(RedisSessionStateProviderWrapper).FullName);\n\t\t\t\t\t},\n\t\t\t\t\tconfigureMeter: o => o.AddAspNetInstrumentation(options => options.Enrich = (HttpContext context, ref TagList tags) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!tags.Any(t => t.Key == \"http.route\") &&\n\t\t\t\t\t\t\tcontext.Request != null &&\n\t\t\t\t\t\t\t(context.Request.Url.AbsolutePath.EndsWith(\"aspx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"asmx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"ashx\", StringComparison.OrdinalIgnoreCase)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttags.Add(\"url.path\", context.Request.Url.AbsolutePath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}))).GetAwaiter().GetResult();\n\t\t\t}\n\t\t}\n\n\t\tif (!ConfigWrapper.UseOneConfig)\n\t\t{\n\t\t\tBootstrap();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This one stays the standard Application_End(), as no derive class overrides it.\n\t/// </summary>\n\tprotected virtual void Application_End()\n\t{\n\t\ttry\n\t\t{\n\t\t\tLogManager.Shutdown();\n\t\t}\n\t\tcatch { }\n\n\t\tUninitializeFeatureFlags();\n\n\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t{\n\t\t\t// Run synchronously\n\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t}\n\n\t\tKazmonMonitoring.ShutdownKazmon();\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to initialize feature flags.\n\t/// </summary>\n\tprotected virtual void InitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t}\n\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application shutdown to uninitialize feature flags.\n\t/// </summary>\n\tprotected virtual void UninitializeFeatureFlags()\n\t{\n\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t{\n\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t}\n\t}\n\n\t/// <summary>\n\t/// This method is called once during application startup to bootstrap the dependency injection container.\n\t/// </summary>\n\tprotected virtual void Bootstrap()\n\t{\n\t}\n}\n\n#endif\n",
      "search_score": 100,
      "search_reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions, Import: OpenTelemetry.Metrics",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: DocuSign.CLM.Monitoring",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions",
        "Import: OpenTelemetry.Metrics",
        "Import: OpenTelemetry.Trace",
        "Pattern: OpenTelemetry",
        "Pattern: Instrumentation",
        "Pattern: Monitoring",
        "Pattern: Metrics",
        "Pattern: UseOpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/internal/AtlasCustomerSupport/Global.asax.cs",
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Web;\n\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.ServiceFramework;\nusing ADEXS.Core.ServiceFramework.Helpers;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.Extensions;\nusing ADEXS.Core.Util.FeatureFlags;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow;\nusing ADEXS.ElasticCore;\nusing ADEXS.FeatureFlags;\nusing ADEXS.MQ;\nusing DocuSign.CLM.Monitoring;\nusing log4net.Config;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing Constants = ADEXS.Core.Types.Constants;\n\nnamespace AtlasCustomerSupport\n{\n\t/// <summary>\n\t/// Summary description for Global.\n\t/// </summary>\n\tpublic class Global : System.Web.HttpApplication\n\t{\n\n\t\tprivate static readonly IDiscreetLogger _log = DiscreetLogger.GetLogger(typeof(Global));\n\n\t\tprivate ICoreInstrumentationLifetimeService _coreInstrumentationLifetimeService;\n\n\n\t\t/// <summary>\n\t\t/// Required designer variable.\n\t\t/// </summary>\n\t\tprivate System.ComponentModel.IContainer components = null;\n\n\t\tpublic Global()\n\t\t{\n\t\t\tInitializeComponent();\n\t\t}\n\n\t\tprotected void Application_Start(Object sender, EventArgs e)\n\t\t{\n\t\t\t// Initialize log4net.  This should eventually be replaced by\n\t\t\t// code in AssemblyInfo.cs once the new log4net version is out.\n\t\t\t// (Added for log4net 1.2.0 Beta 8).\n\t\t\t// TODO: we are using log4net 2.0.8, so this is not needed, we should migrate this code to use AssemblyInfo.cs.\n\t\t\tFileInfo logConfigFileInfo = new FileInfo(AppDomain.CurrentDomain.SetupInformation.ConfigurationFile);\n\t\t\tXmlConfigurator.ConfigureAndWatch(logConfigFileInfo);\n\n\t\t\tConfigurationHelper.InitializeConfiguration();\n\n\t\t\tBootstrapper.Bootstrap(() => new List<IServiceRegistry> {\n\t\t\t\tnew MessageQueueRegistry(),\n\t\t\t\tnew WebCoreDomainRegistry(),\n\t\t\t\tnew CoreWorkflowRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew ElasticCoreRegistry(),\n\t\t\t\tnew FeatureFlagRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew AppFeatureFlagsRegistry<PSOToolFeatureFlagsConfiguration>(),\n\t\t\t\tnew OneConfigServiceRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew ServiceConfigServiceRegistry(WebCoreDomainRegistry.OneConfigPath, \"PsoToolConfig.ini\"),\n\t\t\t\tnew AtlasCustomerSupportRegistry(WebCoreDomainRegistry.OneConfigPath),\n\t\t\t\tnew CoreServiceFrameworkRegistry(),\n\t\t\t});\n\n\t\t\t// Use MSF specific env variable, fallback to app settings.\n\t\t\tvar appName = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\") ?? AppConfig.AppName(\"PSOTool\");\n\t\t\tvar site = SiteConfig.Site(ApplicationSettings.Site);\n\t\t\tvar environment = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_ENVIRONMENT\") ?? SiteConfig.Environment(\"Unknown\");\n\t\t\tvar partition = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_PARTITION\");\n\n\t\t\tKazmonMonitoring.InitializeKazmon(\n\t\t\t\tapplicationName: appName,\n\t\t\t\tappVersion: typeof(Global).Assembly.GetName().Version.ToString(),\n\t\t\t\tenvironmentName: environment,\n\t\t\t\tsiteName: site,\n\t\t\t\tpartitionName: partition,\n\t\t\t\tshouldEnableKazmon: () => ApplicationSettings.KazmonEnableMonitoring,\n\t\t\t\tshouldEnableSmartMon: () => ApplicationSettings.SmartMonEnable,\n\t\t\t\tshouldEnableLogFileListener: () => Configuration.GetBooleanAppSetting(\"KazmonEnableLogFileListener\", false));\n\n\t\t\tif (Configuration.GetBooleanAppSetting(\"UseOpenTelemetryNetFramework\", true))\n\t\t\t{\n\t\t\t\t_coreInstrumentationLifetimeService = ServiceLocator.Container.TryGetInstance<ICoreInstrumentationLifetimeService>();\n\n\t\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t\t{\n\t\t\t\t\t// Run synchronously\n\t\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StartAsync(\n\t\t\t\t\t\tassembly: typeof(Global).Assembly,\n\t\t\t\t\t\tconfigureTracer: o => o.AddAspNetInstrumentation(),\n\t\t\t\t\t\tconfigureMeter: o => o.AddAspNetInstrumentation(options => options.Enrich = (HttpContext context, ref TagList tags) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!tags.Any(t => t.Key == \"http.route\") &&\n\t\t\t\t\t\t\t\tcontext.Request != null &&\n\t\t\t\t\t\t\t\t(context.Request.Url.AbsolutePath.EndsWith(\"aspx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"asmx\", StringComparison.OrdinalIgnoreCase) ||\n\t\t\t\t\t\t\t\t context.Request.Url.AbsolutePath.EndsWith(\"ashx\", StringComparison.OrdinalIgnoreCase)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttags.Add(\"url.path\", context.Request.Url.AbsolutePath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}))).GetAwaiter().GetResult();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ApplicationSettings.EnableFeatureFlags)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.Init(ApplicationSettings.Site);\n\t\t\t}\n\t\t\telse if (ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.InitializeContextOnly();\n\t\t\t}\n\t\t}\n\n\t\tprotected void Session_Start(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_BeginRequest(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_EndRequest(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_AuthenticateRequest(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_Error(Object sender, EventArgs e)\n\t\t{\n\t\t\tException exception = Server.GetLastError();\n\t\t\tif (exception == null)\n\t\t\t{\n\t\t\t\tException[] allError = HttpContext.Current?.AllErrors;\n\t\t\t\tif (allError != null && allError.Length > 0)\n\t\t\t\t\texception = allError[allError.Length - 1];\n\t\t\t}\n\t\t\tvar guid = Activity.Current?.Id ?? Guid.NewGuid().ToString();\n\t\t\tvar message = $\"An unhandled exception occured. ReferenceId: {guid}\";\n\t\t\t_log.ErrorNoPII(message, exception);\n\t\t\tResponse.Redirect($\"Error.aspx?{Constants.QueryStringParameters.MessageRef}={guid}\");\n\n\t\t\texception?.Trace().Report();\n\t\t}\n\n\t\tprotected void Session_End(Object sender, EventArgs e)\n\t\t{\n\n\t\t}\n\n\t\tprotected void Application_End(Object sender, EventArgs e)\n\t\t{\n\t\t\tif (ApplicationSettings.EnableFeatureFlags || ApplicationSettings.EnableFeatureFlagsContext)\n\t\t\t{\n\t\t\t\tFeatureFlagsBootstrap.UnInitialize();\n\t\t\t}\n\n\t\t\tif (_coreInstrumentationLifetimeService != null)\n\t\t\t{\n\t\t\t\t// Run synchronously\n\t\t\t\tTask.Run(() => _coreInstrumentationLifetimeService.StopAsync()).GetAwaiter().GetResult();\n\t\t\t}\n\n\t\t\tKazmonMonitoring.ShutdownKazmon();\n\t\t}\n\n\t\t#region Web Form Designer generated code\n\t\t/// <summary>\n\t\t/// Required method for Designer support - do not modify\n\t\t/// the contents of this method with the code editor.\n\t\t/// </summary>\n\t\tprivate void InitializeComponent()\n\t\t{\n\t\t\tthis.components = new System.ComponentModel.Container();\n\t\t}\n\t\t#endregion\n\t}\n}\n\n",
      "search_score": 100,
      "search_reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.Monitoring, Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: DocuSign.CLM.Monitoring",
        "Import: OpenTelemetry.Metrics",
        "Import: OpenTelemetry.Trace",
        "Pattern: Activity.Current",
        "Pattern: OpenTelemetry",
        "Pattern: Instrumentation",
        "Pattern: Monitoring",
        "Pattern: Metrics",
        "Pattern: UseOpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Program.cs",
      "content": "using System.Collections.Generic;\n\nusing ADEXS.Atlas.Workflow.Activities;\nusing ADEXS.Atlas.Workflow.Readers;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.DocuSignUrl;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Core;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow;\nusing ADEXS.ElectronicSignature;\nusing ADEXS.Etl;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.MQ;\nusing ADEXS.OrchestrationIntegration;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.SForce.Core;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\n\nusing DocuSign.CLM.API.WorkflowActivities;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Filters;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Filters.SwaggerDoc;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.IoC;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters;\n\nusing DocuSign.CLM.SmallBenClient;\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\n\nusing Microsoft.AspNetCore.Authentication.JwtBearer;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.IdentityModel.Logging;\nusing Microsoft.IdentityModel.Tokens;\nusing Microsoft.OpenApi.Models;\n\nusing OpenTelemetry.Metrics;\n\nvar builder = ScmWebApplication.CreateScmWebService(args);\n\nbuilder.ConfigureDefaultScmWebService(\n\targs,\n\t() => new List<IServiceRegistry>\n\t{\n\t\tnew CoreServiceRegistry(),\n\t\tnew CoreWorkflowRegistry(),\n\t\tnew AtlasWorkflowReadersRegistry(),\n\t\tnew MessageQueueRegistry(),\n\t\tnew SmallBenClientRegistry(),\n\t\tnew CoreDomainRegistry(),\n\t\tnew EtlRegistry(),\n\t\tnew ESignatureRegistry(),\n\t\tnew SalesForceRegistry(),\n\t\tnew MergeEngineServiceRegistry(),\n\t\tnew AtlasWorkflowActivitiesRegistry(),\n\t\tnew OrchestrationIntegrationRegistry()\n\t},\n\tWorkflowActivitiesConstants.ServiceName,\n\tconfigureMeter: options =>\n\t{\n\t\toptions.AddView(instrumentName: \"workflowactivities.api.duration\",\n\t\t\tnew ExplicitBucketHistogramConfiguration\n\t\t\t{\n\t\t\t\tBoundaries = new double[] { 10, 25, 50, 100, 200, 500, 1000, 2000, 5000, 10000 }\n\t\t\t});\n\t},\n\tappConfigFileName: \"WorkflowActivitiesApiConfig.ini\");\n\nbuilder.Services.AddWebCoreBasedConfigProviders();\n\n// We only enable JwtAuth when on-prem due to MSF -> onprem communication\nif (ApplicationSettings.EnvironmentType == EnvironmentType.OnPrem)\n{\n\tbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\n\t.AddJwtBearer(options =>\n\t{\n\t\toptions.RequireHttpsMetadata = builder.Configuration.GetValue<bool>(\"Jwt_PublicKeyRequireHttps\", true);\n\t\toptions.Authority = new DocuSignAccountsServerUrl().AuthorityUrl();\n#pragma warning disable CA5404 // Do not disable token validation checks\n\t\toptions.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false };\n#pragma warning restore CA5404 // Do not disable token validation checks\n\t});\n\tbuilder.Services.AddAuthorization(options =>\n\t{\n\t\toptions.AddPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopePolicyName, policy =>\n\t\t\tpolicy.RequireClaim(\n\t\t\t\tADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopeClaimKey,\n\t\t\t\tADEXS.Core.Types.Constants.DocuSignAuthenticationScopes.ClmActivitiesExecute));\n\t\toptions.DefaultPolicy = options.GetPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.ScopePolicyName);\n\t});\n}\nelse\n{\n\tbuilder.Services.AddAuthentication();\n\tbuilder.Services.AddAuthorization(options =>\n\t{\n\t\toptions.AddPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.AllowAllPolicyName, policy =>\n\t\t\tpolicy.Requirements.Add(new AllowAnonymousRequirement()));\n\t\toptions.DefaultPolicy = options.GetPolicy(ADEXS.Core.Types.Constants.WorkflowActivitiesApi.AllowAllPolicyName);\n\t});\n\tbuilder.Services.AddSingleton<IAuthorizationHandler, AllowAnonymousHandler>();\n}\n\nbuilder.Services.AddWorkflowActivitiesServices();\n\nbuilder.Services.AddMvc(options =>\n{\n\toptions.Filters.Add(new GlobalActionFilter());\n\toptions.Filters.Add(new AuditedRequestAttribute());\n\toptions.Filters.Add(new WorkflowActivitiesExceptionFilterAttribute());\n});\n\n// Do not remove -- this is required for proper deserialization of InstanceVariables\nbuilder.Services.AddControllers().AddNewtonsoftJson();\nbuilder.Services.AddEndpointsApiExplorer();\n\nbuilder.Services.AddSwaggerGen(options =>\n{\n\toptions.CustomOperationIds(c => $\"{c.ActionDescriptor.RouteValues[\"action\"]}\");\n\toptions.SupportNonNullableReferenceTypes();\n\toptions.UseAllOfForInheritance();\n\toptions.SwaggerDoc(WorkflowActivitiesConstants.ServiceVersion, new OpenApiInfo\n\t{\n\t\tTitle = WorkflowActivitiesConstants.ServiceName,\n\t\tVersion = WorkflowActivitiesConstants.ServiceVersion\n\t});\n\toptions.DocumentFilter<PathFormatDocumentFilter>();\n\toptions.SchemaFilter<EnumNameSchemaFilter>();\n});\n\nbuilder.Services.AddSwaggerGenNewtonsoftSupport();\n\nbuilder.Services.AddSingleton<IMetricsEmitter, WorkflowActivitiesMetricsEmitter>();\n\nbuilder.Services.AddHttpClient();\n\nbuilder.Services.AddComponentsInstrumentation();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n\tIdentityModelEventSource.ShowPII = true;\n}\n\napp.UseCommonScmServices();\n\napp.UseMiddleware<LogRequestHttpMiddleware>();\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.UseSwagger();\napp.UseSwaggerUI();\n\napp.UseStaticFiles();\napp.UseStaticFiles($\"/{WorkflowActivitiesConstants.ServiceUrlPrefixNoTrailingSlash}\");\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{WorkflowActivitiesConstants.ServiceUrlPrefix}version\");\napp.MapVersionEndpoint($\"{WorkflowActivitiesConstants.ServiceVersion}/version\");\napp.MapControllers();\n\napp.RunScmWebService();\n",
      "search_score": 100,
      "search_reasoning": "Telemetry infrastructure: Import: DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics, Import: OpenTelemetry.Metrics; Matches 2 keywords: middleware, OpenTelemetry",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry.Metrics.MetricsEmitters",
        "Import: OpenTelemetry.Metrics",
        "Pattern: Instrumentation",
        "OpenTelemetry",
        "Config file: program.cs",
        "middleware",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics",
        "Pattern: OpenTelemetry",
        "Pattern: Metrics"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Core.ServiceFramework/CoreInstrumentationLifetimeService.cs",
      "content": "\ufeff#nullable enable\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.Loggers;\nusing ADEXS.ServiceFramework.OpenTelemetry.Extensions;\n\nusing DocuSign.OneConfig.Extensions;\n\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\n\nusing OpenTelemetry.Metrics;\nusing OpenTelemetry.Trace;\n\nusing StructureMap;\n\nnamespace ADEXS.Core.ServiceFramework;\n\npublic class CoreInstrumentationLifetimeService : ICoreInstrumentationLifetimeService\n{\n\tprivate static readonly IDiscreetLogger Log = DiscreetLogger.GetLogger(typeof(CoreInstrumentationLifetimeService));\n\n\tprivate readonly IContainer _container;\n\n\tprivate IHostedService? _openTelemetryService;\n\n\tpublic CoreInstrumentationLifetimeService(IContainer container)\n\t{\n\t\tif (container == null)\n\t\t{\n\t\t\tthrow new ArgumentNullException(nameof(container));\n\t\t}\n\n\t\t_container = container;\n\t}\n\n\tpublic async Task StartAsync(\n\t\tAssembly? assembly = null,\n\t\tAction<TracerProviderBuilder>? configureTracer = null,\n\t\tAction<MeterProviderBuilder>? configureMeter = null,\n\t\tCancellationToken cancellationToken = default)\n\t{\n\t\tvar appConfig = _container.TryGetInstance<IWatchedSingletonConfig<IAppConfig>>()?.Value;\n\n\t\tif (appConfig == null)\n\t\t{\n\t\t\tLog.ErrorNoPII($\"Unable to resolve {nameof(IAppConfig)}, OpenTelemetry won't be configured.\");\n\t\t\treturn;\n\t\t}\n\n\t\tvar configuration = _container.TryGetInstance<IConfiguration>();\n\t\tif (configuration == null)\n\t\t{\n\t\t\tLog.ErrorNoPII($\"Unable to resolve {nameof(IConfiguration)}, OpenTelemetry won't be configured.\");\n\t\t\treturn;\n\t\t}\n\n\t\tvar serviceName = appConfig.TelemetryAppName;\n\n\t\tif (string.IsNullOrWhiteSpace(serviceName))\n\t\t{\n\t\t\tLog.ErrorNoPII($\"{nameof(IAppConfig)}.{nameof(appConfig.TelemetryAppName)} is not defined, OpenTelemetry won't be configured.\");\n\t\t\treturn;\n\t\t}\n\n\t\tvar cloudNameOverride = Environment.GetEnvironmentVariable(\"MONITORING_SYSTEM_APPLICATION\");\n\n\t\tif (!string.IsNullOrWhiteSpace(cloudNameOverride))\n\t\t{\n\t\t\tserviceName = cloudNameOverride;\n\t\t}\n\n\t\tLog.InfoNoPII($\"Starting OpenTelemetry for {serviceName}.\");\n\n\t\tvar services = new ServiceCollection();\n\n\t\tvar serviceVersion = assembly?.GetName().Version?.ToString();\n\n\t\t// Add logging\n\t\tservices.AddLogging();\n\t\tservices.AddScmCoreInstrumentation(\n\t\t\tconfiguration,\n\t\t\tserviceName!,\n\t\t\tserviceVersion: serviceVersion,\n\t\t\tconfigureTracer: configureTracer,\n\t\t\tconfigureMeter: configureMeter);\n\n\t\t// Ensure original configuration is not overriten.\n\t\tforeach (var serviceDescriptor in services.Where(s => s.ServiceType == typeof(IConfiguration)).ToList())\n\t\t{\n\t\t\tservices.Remove(serviceDescriptor);\n\t\t}\n\n\t\tvar existingHostedServices = _container.GetInstance<IEnumerable<IHostedService>>();\n\n\t\tvar registry = new Registry();\n\t\tregistry.Populate(services);\n\n\t\t_container.Configure(c => c.AddRegistry(registry));\n\n\t\tvar updatedHostedServices = _container.GetInstance<IEnumerable<IHostedService>>();\n\t\t_openTelemetryService = updatedHostedServices.Except(existingHostedServices)\n\t\t\t.Where(s => s.GetType().FullName?.StartsWith(\"OpenTelemetry.\", StringComparison.OrdinalIgnoreCase) == true)\n\t\t\t.Single();\n\n\t\tvar loggerFactory = _container.GetInstance<ILoggerFactory>();\n\t\tMicrosoftLoggingAdapterAppender.Attach(loggerFactory);\n\n\t\tawait _openTelemetryService.StartAsync(cancellationToken);\n\n\t\tMicrosoftLoggingAdapterAppender.ClearLoggerCache();\n\n\t\tLog.InfoNoPII($\"OpenTelemetry started for for {serviceName}.\");\n\t}\n\n\tpublic async Task StopAsync(CancellationToken cancellationToken = default)\n\t{\n\t\tLog.InfoNoPII($\"Stopping OpenTelemetry.\");\n\n\t\tMicrosoftLoggingAdapterAppender.Dettach();\n\n\t\tif (_openTelemetryService == null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tawait _openTelemetryService.StopAsync(cancellationToken);\n\n\t\tLog.InfoNoPII($\"OpenTelemetry Stopped.\");\n\t}\n}\n#nullable restore\n",
      "search_score": 100,
      "search_reasoning": "Telemetry infrastructure: Import: ADEXS.ServiceFramework.OpenTelemetry.Extensions, Import: OpenTelemetry.Metrics, Import: OpenTelemetry.Trace",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: ADEXS.ServiceFramework.OpenTelemetry.Extensions",
        "Import: OpenTelemetry.Metrics",
        "Import: OpenTelemetry.Trace",
        "Pattern: OpenTelemetry",
        "Pattern: Instrumentation",
        "Pattern: Metrics",
        "Pattern: TracerProvider",
        "Pattern: MeterProvider",
        "Config file: coreinstrumentationlifetimeservice.cs"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/API.WorkflowActivities/Controllers/WorkflowActivitiesController.cs",
      "content": "\ufeffusing System;\nusing System.Diagnostics;\nusing System.Net;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nusing ADEXS.Atlas.Workflow.Readers.Readers;\nusing ADEXS.Core.Workflow;\n\nusing CLM.MessageDefines.Event;\n\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Exceptions;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Telemetry;\nusing DocuSign.CLM.API.WorkflowActivities.Infrastructure.Utility;\nusing DocuSign.CLM.API.WorkflowActivities.Models;\nusing DocuSign.Monitoring;\n\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\n\nusing ActivityContext = DocuSign.CLM.API.WorkflowActivities.Models.ActivityContext;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace DocuSign.CLM.API.WorkflowActivities.Controllers;\n\n[ApiController]\n[Authorize]\n[Route($\"{Constants.OnPremApiRoutePrefix}/[controller]\")] // OnPrem routing\n[Route($\"{WorkflowActivitiesConstants.ServiceUrlPrefix}[controller]\")] // Cloud routing\npublic partial class WorkflowActivitiesController : Controller\n{\n\tprivate readonly ILogger _logger;\n\tprivate readonly IWorkflowDesignToWorkflowMapMapper _workflowDesignToWorkflowMapMapper;\n\n\tpublic WorkflowActivitiesController(\n\t\tIServiceInstrumentation serviceInstrumentation,\n\t\tIWorkflowDesignToWorkflowMapMapper workflowDesignToWorkflowMapMapper,\n\t\tILoggerFactory loggerFactory)\n\t{\n\t\t_serviceInstrumentation = serviceInstrumentation;\n\t\t_workflowDesignToWorkflowMapMapper = workflowDesignToWorkflowMapMapper;\n\t\t_logger = loggerFactory.CreateLogger(GetType());\n\t}\n\n\t[HttpPost(\"execute\")]\n\t[ProducesResponseType(typeof(ActivityOutput), (int)HttpStatusCode.OK)]\n\tpublic async Task<IActionResult> ExecuteActivityAsync([FromBody] ActivityContext activityContext)\n\t{\n\t\tValidationUtils.ValidateActivityExecuteContext(activityContext, _logger, out var accountId, out var userAccountUid);\n\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityContext.ActivityJsonDefinition);\n\t\t\t\tvar output = winsActivity.Execute(activityContext.WorkflowActivityContext);\n\n\t\t\t\tvar activityOutput = new ActivityOutput\n\t\t\t\t{\n\t\t\t\t\tWorkflowActivityContext = activityContext.WorkflowActivityContext\n\t\t\t\t};\n\t\t\t\tactivityOutput.InstanceActivityOutput.AddRange(output);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Ok(activityOutput));\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to execute the activity due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t[HttpPut(\"callback\")]\n\t[ProducesResponseType(typeof(ActivityOutput), (int)HttpStatusCode.OK)]\n\tpublic async Task<IActionResult> ExecuteCallbackAsync([FromBody] ActivityCallbackContext activityCallbackContext)\n\t{\n\t\tValidationUtils.ValidateActivityCallbackContext(activityCallbackContext, _logger, out var accountId, out var userAccountUid);\n\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityCallbackContext.ActivityJsonDefinition);\n\t\t\t\tvar output = winsActivity.ExecuteCallback(activityCallbackContext.WorkflowActivityContext, activityCallbackContext.Name, activityCallbackContext.Payload);\n\n\t\t\t\tvar activityOutput = new ActivityOutput\n\t\t\t\t{\n\t\t\t\t\tWorkflowActivityContext = activityCallbackContext.WorkflowActivityContext\n\t\t\t\t};\n\t\t\t\tactivityOutput.InstanceActivityOutput.AddRange(output);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Ok(activityOutput));\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to execute the activity callback due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\t[HttpPut(\"humanCallback\")]\n\t[ProducesResponseType(typeof(HumanActivityOutput), (int)HttpStatusCode.OK)]\n\tpublic async Task<IActionResult> ExecuteHumanCallbackAsync(\n\t\t[FromBody] ActivityCallbackContext activityCallbackContext)\n\t{\n\t\tValidationUtils.ValidateActivityCallbackContext(activityCallbackContext, _logger, out var accountId,\n\t\t\tout var userAccountUid);\n\t\tValidationUtils.ValidateJson(activityCallbackContext.Payload, _logger);\n\t\tHumanAssignmentPayload humanAssignmentPayload;\n\t\ttry\n\t\t{\n\t\t\thumanAssignmentPayload =\n\t\t\t\tJsonSerializer.Deserialize<HumanAssignmentPayload>(activityCallbackContext.Payload);\n\t\t\tValidationUtils.ValidateHumanAssignmentPayload(humanAssignmentPayload);\n\t\t}\n\t\tcatch (Exception ex)\n\t\t{\n\t\t\tvar msg =\n\t\t\t\t$\"Failed to execute the human activity callback due to JSON deserialization error: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t_logger.LogError(ex, msg);\n\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\tthrow new WorkflowActivitiesApiException(HttpStatusCode.BadRequest, msg);\n\t\t}\n\n\t\tusing (_logger.BeginScope(\"AccountId: {AccountId}, UserAccountUid: {UserAccountUid}\", accountId, userAccountUid))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity =\n\t\t\t\t\t_workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId,\n\t\t\t\t\t\tactivityCallbackContext.ActivityJsonDefinition);\n\t\t\t\tvar assignmentCompleteEvent = new AssignmentCompleteEvent()\n\t\t\t\t{\n\t\t\t\t\tAccountId = accountId,\n\t\t\t\t\tAssignmentId = humanAssignmentPayload.AssignmentUid,\n\t\t\t\t\tStatus = humanAssignmentPayload.AssignmentStatus\n\t\t\t\t};\n\t\t\t\tvar output = winsActivity.ExecuteHumanCallbackViaApi(\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext,\n\t\t\t\t\tassignmentCompleteEvent,\n\t\t\t\t\tout var completeWorkItemResponse);\n\n\t\t\t\tvar activityOutput = new HumanActivityOutput\n\t\t\t\t{\n\t\t\t\t\tWorkflowActivityContext = activityCallbackContext.WorkflowActivityContext,\n\t\t\t\t\tWaitForNextStep = completeWorkItemResponse.WaitForNextStep,\n\t\t\t\t};\n\t\t\t\tactivityOutput.InstanceActivityOutput.AddRange(output);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Ok(activityOutput));\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg =\n\t\t\t\t\t$\"Failed to execute the human activity callback due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\t[HttpPatch(\"complete\")]\n\t[ProducesResponseType(typeof(ActivityCompleteResponse), (int)HttpStatusCode.OK)]\n\tpublic async Task<IActionResult> CheckActivityForCompletionAsync([FromBody] ActivityContext activityContext)\n\t{\n\t\tValidationUtils.ValidateActivityExecuteContext(activityContext, _logger, out var accountId, out var userAccountUid);\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityContext.ActivityJsonDefinition);\n\t\t\t\tvar output = activityContext.WorkflowActivityContext.InstanceActivity.Output;\n\t\t\t\tvar activityCompleteResponse = new ActivityCompleteResponse { ActivityOutput = null };\n\t\t\t\tif (winsActivity.CanBeMarkedAsCompleted(activityContext.WorkflowActivityContext, ref output))\n\t\t\t\t{\n\t\t\t\t\tactivityContext.WorkflowActivityContext.InstanceActivity.Output = output;\n\t\t\t\t\tvar instanceActivityOutputs = winsActivity.OnActivityCompleted(activityContext.WorkflowActivityContext);\n\t\t\t\t\tvar activityOutput = new ActivityOutput\n\t\t\t\t\t{\n\t\t\t\t\t\tWorkflowActivityContext = activityContext.WorkflowActivityContext\n\t\t\t\t\t};\n\t\t\t\t\tactivityOutput.InstanceActivityOutput.AddRange(instanceActivityOutputs);\n\n\t\t\t\t\tactivityCompleteResponse.ActivityOutput = activityOutput;\n\t\t\t\t}\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Ok(activityCompleteResponse));\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to check the activity for completion due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\t[HttpPatch(\"finish\")]\n\t[ProducesResponseType((int)HttpStatusCode.Accepted)]\n\tpublic async Task<IActionResult> FinishActivityAsync([FromBody] ActivityContext activityContext)\n\t{\n\t\tValidationUtils.ValidateActivityExecuteContext(activityContext, _logger, out var accountId, out var userAccountUid);\n\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityContext.ActivityJsonDefinition);\n\t\t\t\twinsActivity.ActivityFinished(activityContext.WorkflowActivityContext);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(Accepted());\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to finish activity due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n\n\t[HttpDelete(\"abort\")]\n\t[ProducesResponseType((int)HttpStatusCode.NoContent)]\n\tpublic async Task<IActionResult> AbortActivityAsync([FromBody] ActivityContext activityContext)\n\t{\n\t\tValidationUtils.ValidateActivityExecuteContext(activityContext, _logger, out var accountId, out var userAccountUid);\n\n\t\tusing (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid);\n\t\t\t\tvar winsActivity = _workflowDesignToWorkflowMapMapper.MapSingleActivity(accountId, activityContext.ActivityJsonDefinition);\n\t\t\t\twinsActivity.OnActivityAborted(activityContext.WorkflowActivityContext);\n\n\t\t\t\tactivity?.SetStatus(ActivityStatusCode.Ok);\n\t\t\t\treturn await Task.FromResult(NoContent());\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tvar msg = $\"Failed to abort activity due to exception: {ex.GetType().Name}: {ex.Message}\";\n\t\t\t\t_logger.LogError(ex, msg);\n\t\t\t\tServiceContext.Log(DataPoint.ErrorMessage, msg);\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\t}\n}\n",
      "search_score": 95,
      "search_reasoning": "Telemetry infrastructure: Import: DocuSign.Monitoring, Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid), Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: DocuSign.Monitoring",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope(\"AccountId: {AccountId}, UserAccountUid: {UserAccountUid}\", accountId, userAccountUid))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.InstanceUid,\n\t\t\t\t\tactivityCallbackContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Import: (_logger.BeginScope($\"[AccountId: {accountId}, UserAccountUid: {userAccountUid}]\"))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing var activity = StartActivity(accountId, userAccountUid, activityContext.WorkflowActivityContext.InstanceActivity.InstanceUid, activityContext.WorkflowActivityContext.InstanceActivity.Uid)",
        "Pattern: Instrumentation",
        "Pattern: Monitoring",
        "Pattern: StartActivity"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DetectTypeService/Program.cs",
      "content": "using System.IO;\nusing System.Reflection;\n\nusing ADEXS.Core.ServiceFramework.Extensions;\nusing ADEXS.DetectTypeService;\nusing ADEXS.DetectTypeService.Config;\nusing ADEXS.DetectTypeService.MetadataUpdater;\nusing ADEXS.DetectTypeService.MimeLookup;\nusing ADEXS.DetectTypeService.Telemetry.Metrics.MetricsEmitters;\nusing ADEXS.DetectTypeService.VideoInfo;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\nusing DocuSign.OneConfig.Extensions.DotNet;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\n\nconst string serviceName = \"clm-detect-type-service\";\n\nvar builder = ScmWebApplication.CreateScmService(args);\n\nbuilder.ConfigureDefaultScmService(\n\targs,\n\tDetectTypeServiceComponent.GetComponentServiceRegistries,\n\tserviceName,\n\tappConfigFileName: \"DetectTypeServiceConfig.ini\");\n\nbuilder.Services.AddHealthChecks()\n\t.AddCoreFrameworkChecks(builder.Configuration);\n\nbuilder.Services.AddServicedComponent<DetectTypeServiceComponent>();\n\nbuilder.Services.AddScoped<IVideoInfo, VideoInfo>();\nbuilder.Services.AddScoped<MimeDetectorWindows, MimeDetectorWindows>();\nbuilder.Services.AddScoped<MimeDetectorCrossPlatform, MimeDetectorCrossPlatform>();\nbuilder.Services.AddScoped<IMimeDetectorFactory>(\n\tc => new MimeDetectorFactory(\n\t\tc.GetRequiredService<MimeDetectorWindows>(),\n\t\tc.GetRequiredService<MimeDetectorCrossPlatform>(),\n\t\tc.GetRequiredService<IMimeDetectiveConfig>()));\nbuilder.Services.AddScoped(c => c.GetRequiredService<IMimeDetectorFactory>().Create());\nbuilder.Services.AddScoped<IMetadataUpdater, MetadataUpdater>();\n\nbuilder.Services.AddScoped<VideoInfoProcessor, VideoInfoProcessor>();\nbuilder.Services.AddScoped<DetectTypeProcessor, DetectTypeProcessor>();\n\nbuilder.Services.AddComponentsInstrumentation();\nbuilder.Services.AddSingleton<IMetricsEmitter, DetectTypeMetricsEmitter>();\nbuilder.Services.AddSingleton<IMetricsEmitter, VideoInfoMetricsEmitter>();\nbuilder.Services.AddSingleton<IMetricsEmitter, MimeDetectorMetricsEmitter>();\nbuilder.Services.AddSingleton<IMetricsEmitter, MediaInfoMetricsEmitter>();\n\nvar executableDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? string.Empty;\nvar detectTypeServiceConfigPath = Path.Combine(executableDirectory, \"Config\", \"Files\", \"DetectTypeServiceConfig.ini\");\nvar mimeDetectiveConfigPath = Path.Combine(executableDirectory, \"Config\", \"Files\", \"MimeDetectiveConfig.ini\");\nbuilder.Services.AddScopedConfigType<IMimeDetectiveConfig>(mimeDetectiveConfigPath);\nbuilder.Services.AddScopedConfigType<IDetectTypeServiceFeaturesConfig>(detectTypeServiceConfigPath);\n\nvar app = builder.Build();\n\napp.UseCommonScmServices();\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{serviceName}/v1/version\");\napp.MapVersionEndpoint($\"{serviceName}/v2/version\");\napp.MapGet(\"/\", () => $\"No WebAPI defined for {serviceName}\");\n\napp.RunScmService();\n",
      "search_score": 90,
      "search_reasoning": "Telemetry infrastructure: Import: ADEXS.DetectTypeService.Telemetry.Metrics.MetricsEmitters, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics, Pattern: OpenTelemetry",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: ADEXS.DetectTypeService.Telemetry.Metrics.MetricsEmitters",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics",
        "Pattern: OpenTelemetry",
        "Pattern: Instrumentation",
        "Pattern: Metrics",
        "Config file: program.cs"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/AdvancedInsightsService/Program.cs",
      "content": "\ufeff#if NET\n#nullable enable\nusing ADEXS.AdvancedInsightsService;\nusing ADEXS.AdvancedInsightsService.Extensions;\nusing ADEXS.AdvancedInsightsService.Telemetry.MetricsEmitters;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.ServiceFramework.Extensions;\n\nusing DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\n\nconst string serviceName = \"clm-advanced-insights-service\";\n\nvar builder = ScmWebApplication.CreateScmService(args);\n\nbuilder.ConfigureDefaultScmService(args, AdvancedInsightsServiceComponent.GetComponentServiceRegistries, serviceName, appConfigFileName: \"AdvancedInsightsService.ini\");\n\nbuilder.Services.AddHealthChecks()\n\t.AddAdvancedInsightsHealthChecks(builder.Configuration);\n\nbuilder.Services.AddServicedComponent<AdvancedInsightsServiceComponent>();\nbuilder.Services.AddSingleton<IMetricsEmitter, AdvancedInsightsMetricsEmitter>();\nbuilder.Services.AddComponentsInstrumentation();\n\nvar app = builder.Build();\n\napp.UseCommonScmServices();\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{serviceName}/v1/version\");\napp.MapGet(\"/\", () => $\"No WebAPI defined for {serviceName}\");\n\napp.RunScmService();\n\n#nullable restore\n#endif\n",
      "search_score": 90,
      "search_reasoning": "Telemetry infrastructure: Import: ADEXS.AdvancedInsightsService.Telemetry.MetricsEmitters, Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics, Pattern: OpenTelemetry",
      "search_strategy": "pattern",
      "matching_patterns": [
        "Import: ADEXS.AdvancedInsightsService.Telemetry.MetricsEmitters",
        "Import: DocuSign.Msf.AspNet.OpenTelemetry.ServiceMetrics",
        "Pattern: OpenTelemetry",
        "Pattern: Instrumentation",
        "Pattern: Metrics",
        "Config file: program.cs"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/SForce.Services/Program.cs",
      "content": "\ufeff#if NET\n#nullable enable\n\nusing System.IO;\nusing System.Reflection;\n\nusing ADEXS.AtlasDataManipulationService.Extensions;\nusing ADEXS.Core.ServiceFramework.Extensions;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.ServiceFramework.OpenTelemetry.Extensions;\nusing ADEXS.SForce.Services;\n\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\nusing DocuSign.OneConfig.Extensions;\nusing DocuSign.OneConfig.Extensions.DotNet;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\n\nconst string serviceName = \"clm-sforce-service\";\n\nvar builder = ScmWebApplication.CreateScmService(args);\n\nbuilder.ConfigureDefaultScmService(args, SForceServiceComponent.GetComponentServiceRegistries, serviceName, appConfigFileName: \"SForce.Services.ini\");\n\nbuilder.Services.AddHealthChecks()\n\t.AddSfServiceHealthChecks(builder.Configuration);\n\nbuilder.Services.AddComponentsInstrumentation();\n\nbuilder.Services.AddServicedComponent<SForceServiceComponent>();\n\nvar app = builder.Build();\n\napp.UseCommonScmServices();\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{serviceName}/v1/version\");\napp.MapGet(\"/\", () => $\"No WebAPI defined for {serviceName}\");\n\napp.RunScmService();\n\n#nullable restore\n#endif\n",
      "search_score": 65,
      "search_reasoning": "Matches 1 keywords: OpenTelemetry",
      "search_strategy": "keyword",
      "matching_patterns": [
        "OpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/ESignatureService/Program.cs",
      "content": "\ufeff#if NET\n#nullable enable\n\nusing System.IO;\nusing System.Reflection;\n\nusing ADEXS.Core.ServiceFramework.Extensions;\nusing ADEXS.ESignatureService;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.ServiceFramework.OpenTelemetry.Extensions;\n\nusing DocuSign.OneConfig.Extensions;\nusing DocuSign.OneConfig.Extensions.DotNet;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\n\nconst string serviceName = \"clm-esignature\";\n\nvar builder = ScmWebApplication.CreateScmService(args);\n\nbuilder.ConfigureDefaultScmService(args, ESignatureComponent.GetComponentServiceRegistries, serviceName, appConfigFileName: \"ESignatureService.ini\");\n\nbuilder.Services.AddHealthChecks()\n\t.AddCoreFrameworkChecks(builder.Configuration);\n\nbuilder.Services.AddComponentsInstrumentation();\n\nbuilder.Services.AddServicedComponent<ESignatureComponent>();\n\nvar app = builder.Build();\n\napp.UseCommonScmServices();\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{serviceName}/v1/version\");\napp.MapGet(\"/\", () => $\"No WebAPI defined for {serviceName}\");\n\napp.RunScmService();\n\n#nullable restore\n#endif\n",
      "search_score": 65,
      "search_reasoning": "Matches 1 keywords: OpenTelemetry",
      "search_strategy": "keyword",
      "matching_patterns": [
        "OpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/DocumentCompareService/Program.cs",
      "content": "\ufeff#if NET\n#nullable enable\n\nusing System.IO;\nusing System.Reflection;\n\nusing ADEXS.Core.ServiceFramework.Extensions;\nusing ADEXS.DocumentCompareService;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.ServiceFramework.OpenTelemetry.Extensions;\n\nusing DocuSign.OneConfig.Extensions;\nusing DocuSign.OneConfig.Extensions.DotNet;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\nusing ADEXS.DocumentCompareService.Extensions;\n\nconst string serviceName = \"clm-document-compare\";\n\nvar builder = ScmWebApplication.CreateScmService(args);\n\nbuilder.ConfigureDefaultScmService(args, DocumentCompareServiceComponent.GetComponentServiceRegistries, serviceName, appConfigFileName: \"DocumentCompareService.ini\");\n\nbuilder.Services.AddHealthChecks()\n\t.AddDocumentCompareServiceHealthChecks(builder.Configuration);\n\nbuilder.Services.AddComponentsInstrumentation();\n\nbuilder.Services.AddServicedComponent<DocumentCompareServiceComponent>();\n\nvar app = builder.Build();\n\napp.UseCommonScmServices();\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{serviceName}/v1/version\");\napp.MapGet(\"/\", () => $\"No WebAPI defined for {serviceName}\");\n\napp.RunScmService();\n\n#nullable restore\n#endif\n",
      "search_score": 65,
      "search_reasoning": "Matches 1 keywords: OpenTelemetry",
      "search_strategy": "keyword",
      "matching_patterns": [
        "OpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/ProfileLogger/Program.cs",
      "content": "\ufeff#if NET\n#nullable enable\n\nusing System.IO;\nusing System.Reflection;\n\nusing ADEXS.Core.ServiceFramework.Extensions;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.ProfileLogger;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.ServiceFramework.OpenTelemetry.Extensions;\n\nusing DocuSign.OneConfig.Extensions;\nusing DocuSign.OneConfig.Extensions.DotNet;\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.Extensions.DependencyInjection;\n\nconst string serviceName = \"clm-profile-logger\";\n\nvar builder = ScmWebApplication.CreateScmService(args);\n\nbuilder.ConfigureDefaultScmService(args, ProfileLoggerComponent.GetComponentServiceRegistries, serviceName, appConfigFileName: \"ProfileLogger.ini\");\n\nbuilder.Services.AddHealthChecks()\n\t.AddCoreFrameworkChecks(builder.Configuration);\n\nbuilder.Services.AddComponentsInstrumentation();\n\nbuilder.Services.AddServicedComponent<ProfileLoggerComponent>();\n\nvar app = builder.Build();\n\napp.UseCommonScmServices();\n\napp.MapServiceHealthChecks();\napp.MapVersionEndpoint($\"{serviceName}/v1/version\");\napp.MapGet(\"/\", () => $\"No WebAPI defined for {serviceName}\");\n\napp.RunScmService();\n\n#nullable restore\n#endif\n",
      "search_score": 65,
      "search_reasoning": "Matches 1 keywords: OpenTelemetry",
      "search_strategy": "keyword",
      "matching_patterns": [
        "OpenTelemetry"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/Web/OWINStartup.cs",
      "content": "\ufeffusing System;\nusing System.Web;\nusing System.Web.Hosting;\n\nusing ADEXS.Web.Config;\nusing ADEXS.Web.RequestFiltering;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Web.Common.Helpers;\n\nusing DocuSign.OneConfig.Extensions;\n\nusing Microsoft.Owin;\nusing Microsoft.Owin.Extensions;\nusing Microsoft.Owin.Infrastructure;\n\nusing Owin;\n\nusing SameSiteMode = System.Web.SameSiteMode;\nusing ADEXS.Core.Util.Loggers;\n\n[assembly: OwinStartup(typeof(ADEXS.Web.OWINStartup))]\nnamespace ADEXS.Web\n{\n\tpublic class OWINStartup\n\t{\n\t\tprivate static readonly IDiscreetLogger Log = DiscreetLogger.GetLogger(typeof(OWINStartup));\n\n\t\tpublic void Configuration(IAppBuilder app)\n\t\t{\n\t\t\tapp.UseStageMarker(PipelineStage.MapHandler);\n\n\t\t\tLog.InfoNoPII($\"Configuring OWINS...\\n\" +\n\t\t\t\t\t$\"ApplicationPhysicialPath: {HostingEnvironment.ApplicationPhysicalPath}\\n\" +\n\t\t\t\t\t$\"AppDomain.CurrentDomain.FriendlyName: {AppDomain.CurrentDomain.FriendlyName}\\n\" +\n\t\t\t\t\t$\"ApplicationVirtualPath: {HostingEnvironment.ApplicationVirtualPath}\\n\" +\n\t\t\t\t\t$\"ApplicationID: {HostingEnvironment.ApplicationID}\\n\" +\n\t\t\t\t\t$\"Site Name: {HostingEnvironment.SiteName}\\n\" +\n\t\t\t\t\t$\"DotVVMEnabled: {ApplicationSettings.DotVVMEnablePages}\\n\" +\n\t\t\t\t\t$\"IsWebProject(): {IsWebProject()}\");\n\t\t\tif (ApplicationSettings.DotVVMEnablePages && IsWebProject())\n\t\t\t{\n\t\t\t\tLog.InfoNoPII(\"Configuring and Enabling DotVVM Middleware... \\n\" +\n\t\t\t\t\t$\"ApplicationPhysicialPath: {HostingEnvironment.ApplicationPhysicalPath}\");\n\t\t\t\tvar dotVVMStartupConfig = ServiceLocator.GetInstance<IWatchedSingletonConfig<IDotVVMStartupConfig>>();\n\t\t\t\tvar isDebug = dotVVMStartupConfig.Value.IsDebug;\n\n\t\t\t\tapp.Use<DotVVM.Middleware.PostbackCompressionMiddleware>();\n\t\t\t\tapp.Use<DotVVM.Middleware.PostbackUpdateControlFilterMiddleware>();\n\t\t\t\tapp.UseDotVVM<DotvvmStartup>(HostingEnvironment.ApplicationPhysicalPath, debug: isDebug, useErrorPages: isDebug);\n\n\t\t\t}\n\n\t\t\tif (ApplicationSettings.ServProtEnableRequestFiltering)\n\t\t\t{\n\t\t\t\tapp.Use<IncomingRequestFilteringOwinMiddleware>();\n\t\t\t}\n\t\t}\n\n\t\t// Only load DotVVM for Web project\n\t\tprivate bool IsWebProject()\n\t\t{\n\t\t\treturn\n\t\t\t\t// On-Prem Web Project\n\t\t\t\tHostingEnvironment.ApplicationPhysicalPath.Contains(\"\\\\Web\\\\\") ||\n\t\t\t\tHostingEnvironment.ApplicationPhysicalPath.EndsWith(\"\\\\Web\") ||\n\t\t\t\t// MSF Web Project\n\t\t\t\tHostingEnvironment.ApplicationVirtualPath.EndsWith(\"/clm\");\n\t\t}\n\t}\n\n\tpublic class DotVVMCookieManager : ICookieManager\n\t{\n\t\tpublic string GetRequestCookie(IOwinContext context, string key)\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t\t}\n\n\t\t\tvar webContext = context.Get<HttpContextBase>(typeof(HttpContextBase).FullName);\n\t\t\tvar cookie = webContext.Request.Cookies[key];\n\t\t\treturn cookie == null ? null : cookie.Value;\n\t\t}\n\n\t\tpublic void AppendResponseCookie(IOwinContext context, string key, string value, CookieOptions options)\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t\t}\n\t\t\tif (options == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(options));\n\t\t\t}\n\t\t\tif (key == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(key));\n\t\t\t}\n\n\t\t\tvar webContext = context.Get<HttpContextBase>(typeof(HttpContextBase).FullName);\n\n\t\t\tbool domainHasValue = !string.IsNullOrEmpty(options.Domain);\n\t\t\tbool pathHasValue = !string.IsNullOrEmpty(options.Path);\n\t\t\tbool sameSiteHasValue = options.SameSite != null;\n\t\t\tbool expiresHasValue = options.Expires.HasValue;\n\n\t\t\tvar cookie = new HttpCookie(key, value);\n\t\t\tif (domainHasValue)\n\t\t\t{\n\t\t\t\tcookie.Domain = options.Domain;\n\t\t\t}\n\t\t\tif (pathHasValue)\n\t\t\t{\n\t\t\t\tcookie.Path = options.Path;\n\t\t\t}\n\t\t\tif (expiresHasValue)\n\t\t\t{\n\t\t\t\tcookie.Expires = options.Expires.Value;\n\t\t\t}\n\t\t\tif (options.Secure)\n\t\t\t{\n\t\t\t\tcookie.Secure = true;\n\t\t\t}\n\t\t\tif (options.HttpOnly)\n\t\t\t{\n\t\t\t\tcookie.HttpOnly = true;\n\t\t\t}\n\t\t\tif (key.Contains(DotvvmStartup.DotVVMSessionIdCookieName))\n\t\t\t{\n\t\t\t\tcookie.SameSite = SameSiteMode.None;\n\t\t\t}\n\t\t\telse if (sameSiteHasValue)\n\t\t\t{\n\t\t\t\tcookie.SameSite = (SameSiteMode)options.SameSite;\n\t\t\t}\n\n\t\t\tif (cookie.SameSite == SameSiteMode.None)\n\t\t\t{\n\t\t\t\tcookie.Path = $\"{cookie.Path}; {CookieHelper.SameSiteNonePartitionedValue}\";\n\t\t\t}\n\n\t\t\twebContext.Response.AppendCookie(cookie);\n\t\t}\n\n\t\tpublic void DeleteCookie(IOwinContext context, string key, CookieOptions options)\n\t\t{\n\t\t\tif (context == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(context));\n\t\t\t}\n\t\t\tif (options == null)\n\t\t\t{\n\t\t\t\tthrow new ArgumentNullException(nameof(options));\n\t\t\t}\n\n\t\t\tAppendResponseCookie(\n\t\t\t\tcontext,\n\t\t\t\tkey,\n\t\t\t\tstring.Empty,\n\t\t\t\tnew CookieOptions\n\t\t\t\t{\n\t\t\t\t\tPath = options.Path,\n\t\t\t\t\tDomain = options.Domain,\n\t\t\t\t\tExpires = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc),\n\t\t\t\t});\n\t\t}\n\t}\n}\n",
      "search_score": 55,
      "search_reasoning": "Matches 1 keywords: middleware",
      "search_strategy": "keyword",
      "matching_patterns": [
        "middleware"
      ],
      "is_main_file": true
    },
    {
      "path": "/Users/shuaib.tabit/Documents/Atlas/src/WebNet/Program.cs",
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Reflection;\n\nusing ADEXS.ActIntegration;\nusing ADEXS.Core.Domain;\nusing ADEXS.Core.Domain.AtlasUrl;\nusing ADEXS.Core.Domain.Persistence.Lookup;\nusing ADEXS.Core.Domain.ServiceProtection;\nusing ADEXS.Core.Util.Config;\nusing ADEXS.Core.Util.FeatureFlags;\nusing ADEXS.Core.Util.ServiceLocator;\nusing ADEXS.Core.Workflow;\nusing ADEXS.DocumentReviewMenuActions;\nusing ADEXS.ElasticCore;\nusing ADEXS.ElectronicSignature;\nusing ADEXS.HealthCheck.AspNetCore.Extensions;\nusing ADEXS.MQ;\nusing ADEXS.ServiceFramework.Extensions;\nusing ADEXS.Web;\nusing ADEXS.Web.AtlasUrl;\nusing ADEXS.Web.Common.AspNetCore;\nusing ADEXS.Web.Common.AspNetCore.Extensions;\nusing ADEXS.Web.Common.AspNetCore.Helpers;\nusing ADEXS.Web.CommonUI.AspNetCore;\nusing ADEXS.Web.CommonUI.AspNetCore.Extensions;\nusing ADEXS.Web.Config;\nusing ADEXS.Web.Controller;\nusing ADEXS.Web.Extensions;\nusing ADEXS.Web.HostedServices;\nusing ADEXS.Web.FeatureFlags;\nusing ADEXS.Web.Filters;\nusing ADEXS.Web.Forwarder;\nusing ADEXS.Web.Routing;\nusing ADEXS.Web.WebNetConstants;\n\nusing DocuSign.Msf.AspNet.VersionEndpoint.Extensions;\nusing DocuSign.OneConfig.Extensions.DotNet;\n\nusing HealthChecks.UI.Client;\n\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Builder.Extensions;\nusing Microsoft.AspNetCore.Diagnostics.HealthChecks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.HttpOverrides;\nusing Microsoft.AspNetCore.Mvc.Infrastructure;\nusing Microsoft.AspNetCore.Mvc.Routing;\nusing Microsoft.AspNetCore.Rewrite;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.FileProviders;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.IdentityModel.Logging;\n\nusing Newtonsoft.Json;\n\nusing Yarp.ReverseProxy.Forwarder;\n\nvar builder = ScmWebApplication.CreateScmWebService(args);\n\nbuilder.ConfigureDefaultScmWebService(\n\targs,\n\t() => new List<IServiceRegistry>\n\t{\n\t\tnew CoreDomainRegistry(),\n\t\tnew ElasticCoreRegistry(),\n\t\tnew MessageQueueRegistry(),\n\t\tnew WebCommonRegistry(),\n\t\tnew MenuActionsRegistry(),\n\t\tnew ESignatureRegistry(),\n\t\t//new SharedTemplatesRegistry(),\n\t\tnew ActIntegrationRegistry(),\n\t\tnew CoreWorkflowRegistry(),\n\t\t//new WorkflowClientRegistry(),\n\t\t//new UserTaskListRegistry(),\n\t\t//new InteractivePreviewCoreRegistry(),\n\t\tnew ServiceProtectionRegistry(),\n\t\t//new SearchRegistry()\n\t},\n\tServiceConstants.ServiceName);\n\nbuilder.Services.AddOptions<WebNetOptions>();\nbuilder.Services.Configure<WebNetOptions>(builder.Configuration.GetSection(WebNetOptions.Section));\n\nbuilder.Services.AddReverseProxy()\n\t\t\t.LoadFromConfig(builder.Configuration.GetSection(\"ReverseProxy\"))\n\t\t\t.AddConfigFilter<AddressOverrideConfigFilter>();\n\nbuilder.Services.AddSingleton<IForwarderHttpClientFactory, ConfigurableForwarderHttpClientFactory>();;\n\nbuilder.Services.AddMvc(options =>\n{\n\toptions.Filters.Add<ExceptionFilter>();\n\toptions.Filters.Add<AuditedRequestAttribute>();\n})\n.AddRazorOptions(options =>\n{\n\toptions.ViewLocationFormats.Add(\"/Views/Partials/{0}.cshtml\");\n});\n\n// NOTE: Using AddNewtonsoftJson to allow dynamic body in controller actions.\nbuilder.Services.AddControllers()\n\t.AddNewtonsoftJson(options =>\n\t{\n\t\toptions.SerializerSettings.NullValueHandling = NullValueHandling.Ignore;\n\n\t\t// Move to PascalCase\n\t\toptions.SerializerSettings.ContractResolver = null;\n\t});\n\nbuilder.Services.AddAntiforgery();\n\nbuilder.Services.AddComponentsInstrumentation();\n\nbuilder.Services.AddHttpContextAccessor();\nbuilder.Services.AddSingleton<IActionContextAccessor, ActionContextAccessor>();\nbuilder.Services.AddRouting();\nbuilder.Services.AddSingleton<IUrlHelperFactory, UrlHelperFactory>();\nbuilder.Services.AddConditionalEndpoints<ConditionalEndpointSelector>();\n\nbuilder.Services.AddWebCommonUi();\n\n// Enables IMemoryCache to replace HttpContext.Cache\nbuilder.Services.AddMemoryCache();\n\nbuilder.Services.AddResponseCaching();\n\nbuilder.Services.AddLegacyMachineKeyDataProtector();\n\n// NOTE: do not enable sessions in higher environments until we figure out how to use legacy sessions\nif (builder.Environment.IsDevelopment() || builder.Environment.IsStaging())\n{\n\t// Temporary solution to enable Http Session.\n\tbuilder.Services.AddStackExchangeRedisCache(options =>\n\t{\n\t\toptions.ConnectionMultiplexerFactory = () => ADEXS.Caching.RedisCache.GetOrCreateRedisConnectionImplAsync(null, System.Threading.CancellationToken.None).AsTask();\n\t\toptions.InstanceName = \"AuthAppSession\";\n\t});\n\tbuilder.Services.AddSession(options =>\n\t{\n\t\toptions.IdleTimeout = TimeSpan.FromMinutes(30);\n\t});\n}\n\nWebHostEnvironmentHelper.WebHostEnvironment = builder.Environment;\n\n// WebRegistry\nbuilder.Services.AddScoped<IUrlProvider, WebUrlProvider>();\n\nvar executableDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? string.Empty;\nbuilder.Services.AddSingletonConfigType<IReverseProxyConfig>(Path.Combine(executableDirectory, \"Config\", \"Files\", \"ReverseProxyConfig.ini\"));\nbuilder.Services.AddScopedConfigType<IDotVVMFeatureFlagsConfig>(Path.Combine(executableDirectory, \"Config\", \"Files\", \"DotVVMFeatureFlagsConfig.ini\"));\nbuilder.Services.AddScopedConfigType<IMiscellaneousUXFeatureFlagsConfig>(Path.Combine(executableDirectory, \"Config\", \"Files\", \"MiscellaneousUXFeatureFlagsConfig.ini\"));\nbuilder.Services.AddScopedConfigType<ISearchFeatureFlagsConfig>(Path.Combine(executableDirectory, \"Config\", \"Files\", \"SearchFeatureFlagsConfig.ini\"));\nbuilder.Services.AddScopedConfigType<IConditionalEndpointSelectorConfig>(Path.Combine(executableDirectory, \"Config\", \"Files\", \"ConditionalEndpointSelectorConfig.ini\"));\n\n// Add DotVVM services\nbuilder.Services.AddDotVVM<DotvvmStartup>();\n\nbuilder.Services.AddSingleton<IHostedService, ActionManagerLifetimeHostedService>();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment())\n{\n\tIdentityModelEventSource.ShowPII = true;\n}\n\napp.UseMiddleware<UsePathBaseMiddleware>(new PathString($\"/{ServiceConstants.ServiceUrlPrefixNoTrailingSlash}\"));\napp.UseMiddleware<UsePathBaseMiddleware>(new PathString($\"/{ServiceConstants.AlternativeCloudServiceUrlPrefixNoTrailingSlash}\"));\napp.UseMiddleware<UsePathBaseMiddleware>(new PathString($\"/{ServiceConstants.AlternativeServiceUrlPrefixNoTrailingSlash}\"));\napp.UseMiddleware<UsePathBaseMiddleware>(new PathString($\"/{ServiceConstants.AlternativeOnPremServiceUrlPrefixNoTrailingSlash}\"));\n\napp.UseStaticFiles();\n\napp.MapServiceHealthChecks();\napp.MapHealthChecks($\"{ServiceConstants.AlternativeServiceUrlPrefix}health\", new HealthCheckOptions\n{\n\tResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse,\n\tPredicate = _ => true\n});\n\n// TODO: Remove this when the we able to do redirect from WebNet.\nif (app.Environment.IsDevelopment())\n{\n\tvar rewriteOptions = new RewriteOptions()\n\t\t.AddRedirect(\n\t\t\t\"^Documents/BrowseDocuments\\\\.aspx$\",\n\t\t\t\"/d/Documents/BrowseDocuments\",\n\t\t\tStatusCodes.Status302Found);\n\tapp.UseRewriter(rewriteOptions);\n}\n\napp.UseCommonScmServices();\n\napp.UseResponseCaching();\n\n// NOTE: do not enable sessions in higher environments until we figure out how to use legacy sessions\nif (app.Environment.IsDevelopment() || app.Environment.IsStaging())\n{\n\tapp.UseSession();\n}\n\napp.UseScmAsyncHttpRequestLogging();\n\napp.UseProfileMiddleware();\n\nHttpContextHelper.Configure(app.Services.GetRequiredService<IHttpContextAccessor>());\n\napp.Use(async (context, next) =>\n{\n\t// Log the incoming X-Forwarded-For & X-Original-For headers (if any)\n\tvar xForwardedFor = context.Request.Headers[ForwardedHeadersDefaults.XForwardedForHeaderName].ToString();\n\tvar xOriginalFor = context.Request.Headers[ForwardedHeadersDefaults.XOriginalForHeaderName].ToString();\n\tvar remoteIp = context.Connection.RemoteIpAddress;\n\tvar logger = context.RequestServices.GetRequiredService<ILoggerFactory>().CreateLogger(\"ADEXS.Web.XForwardedLogger\");\n\n\tlogger.LogInformation(\"Remote IP: {RemoteIp}, X-Forwarded-For: {XForwardedFor}, X-Original-For: {XOriginalFor}\", remoteIp, xForwardedFor, xOriginalFor);\n\n\tawait next();\n});\n\n// Add DotVVM middleware\napp.UseDotVVM<DotvvmStartup>(app.Environment.ContentRootPath);\n\napp.UseAuthentication();\napp.UseAuthorization();\n\napp.MapVersionEndpoint(\"version\");\n\napp.MapControllers().WithConditionalRoute();\napp.MapControllerRoute(\"PortalAuthenticationError\", \"Portal/PortalAuthenticationError/{action}\", new { controller = \"PortalAuthenticationError\", action = \"Index\" });\napp.MapControllerRoute(\"SSOEndpoint\", \"A/SSO/SSOEndpoint\", new { controller = \"SSOEndpoint\", action = \"SSOEndpoint\" });\napp.MapControllerRoute(\"SSOEndpointAshx\", \"SSO/SSOEndpoint.ashx\", new { controller = \"SSOEndpoint\", action = \"SSOEndpoint\" });\napp.MapControllerRoute(\"ThemeCss\", \"ThemeCss/{action}\", new { controller = \"CssGenerator\", action = \"Index\" });\napp.MapControllerRoute(\"AdminSiteInfo\", \"Admin/SiteInfo/{action}\", new { controller = \"SiteInfo\", action = \"Index\" });\napp.MapControllerRoute(\"AdminSitemap\", \"Admin/Sitemap/{action}\", new { controller = \"Sitemap\", action = \"Index\" });\n\napp.MapReverseProxy();\n\napp.RunScmWebService();\n",
      "search_score": 55,
      "search_reasoning": "Matches 1 keywords: middleware",
      "search_strategy": "keyword",
      "matching_patterns": [
        "middleware"
      ],
      "is_main_file": true
    }
  ],
  "Batch 1 (LogAsyncRequestHttpMiddleware.cs): \u2022 The middleware executes for every ASP-NET request and already deals with telemetry (\u201clogs requests to KazMon\u201d, uses PropertyBagEventSource, inherits AbstractLogRequestHttpMiddleware).  \n\u2022 Inside a middleware we have both HttpContext and Activity.Current, so we can enrich the ongoing \u201cASP.NET HTTP Request\u201d span with extra tags.  \n\u2022 Adding  \n  Activity.Current?.SetTag(\"HTTP_REFERER\", context.Request.Headers[\"Referer\"]);  \n  Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", context.Response.Headers[\"Location\"]);  \n  near the existing logging logic is straightforward and does not require changes elsewhere.  \n\u2022 No other files are needed for this specific attribute injection, therefore only LogAsyncRequestHttpMiddleware.cs is selected.\nBatch 2 (ProfileModule.cs): \u2022 ProfileModule.cs is an IHttpModule that participates in every ASP-NET request, giving it direct access to HttpContext.Request and HttpContext.Response headers, exactly where HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION can be read.  \n\u2022 The file already references DocuSign.CLM.Monitoring and DocuSign.Monitoring, indicating existing span / activity instrumentation infrastructure that can be extended with additional attributes.  \n\u2022 Because the requirement is limited to adding two span attributes and the module runs for every request, a few lines inside ProfileModule\u2019s BeginRequest / EndRequest (or equivalent) handlers can set these attributes on the current span (e.g., Activity.Current or the library\u2019s Span object).  \n\u2022 No other files in the group are needed; ProfileModule.cs alone is sufficient for direct instrumentation.\nBatch 3 (BaseApiHandler.cs): \u2022 The telemetry requirement targets ASP.NET request spans.  \n\u2022 BaseApiHandler.cs is an IHttpHandler base class that all ASHX-style endpoints inherit from, so every request handled by these legacy endpoints passes through this file.  \n\u2022 Inside an IHttpHandler, HttpContext.Current (or the passed-in context) exposes:\n  \u2013 Request.Headers[\"Referer\"]  \n  \u2013 Response.Headers[\"Location\"]  \n\u2022 The .NET instrumentation for ASP.NET automatically creates an Activity (span) for each request and sets Activity.Current.  \n\u2022 Therefore, in BaseApiHandler.ProcessRequest (or equivalent), we can safely obtain Activity.Current and call SetTag / AddTag (or SetCustomProperty depending on the monitoring library) to attach the two required attributes before the request finishes.  \n\u2022 Only BaseApiHandler.cs needs modification; no other files are required for this direct instrumentation.\nBatch 4 (LogAsyncRequestHttpMiddleware.cs): \u2022 The requirement targets ASP.NET request spans. LogAsyncRequestHttpMiddleware is an ASP-NET Core middleware that already deals with request/response telemetry and inherits from AbstractLogRequestHttpMiddleware, indicating an existing Activity/Span instrumentation point.  \n\u2022 The middleware executes for every HTTP request and has direct access to HttpContext.Request.Headers and HttpContext.Response.Headers, so it can read \"Referer\" and \"Location\" header values.  \n\u2022 The file references DocuSign-specific OpenTelemetry helpers (DocuSign.Msf.AspNet.OpenTelemetry.SemanticConventions) and other monitoring utilities, meaning it is already setting span attributes; adding two more attributes is a small, localized change.  \n\u2022 No other files are required: the attribute additions can be done inside this middleware\u2019s existing Activity/Span handling logic.\nBatch 5 (LogAsyncRequestHttpMiddleware.cs): \u2022 LogAsyncRequestHttpMiddleware participates in every ASP.NET request as a middleware, guaranteeing access to both HttpContext.Request and HttpContext.Response headers right when the ASP.NET request span (Activity.Current) is alive.  \n\u2022 The file already references monitoring-related namespaces (DocuSign.Monitoring, PropertyBagEventSource, etc.) and therefore has an existing instrumentation surface that can be extended by simply calling:\n\u2003Activity? span = Activity.Current;  \n\u2003span?.SetTag(\"HTTP_REFERER\", httpContext.Request.Headers[\"Referer\"].ToString());  \n\u2003span?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", httpContext.Response.Headers[\"Location\"].ToString());  \n\u2022 No other files are required because AbstractLogRequestHttpMiddleware (the base class) does not need to change\u2014adding these two SetTag calls in the derived middleware fulfils the requirement without broader refactoring.\n\nHence, one file is sufficient to close the telemetry gap.\nBatch 6 (ProfileMiddleware.cs): \u2022 The telemetry requirement needs per-request enrichment of already-created ASP.NET request spans.  \n\u2022 ProfileMiddleware.cs is an ASP.NET Core middleware that runs on every HTTP request; it has direct access to both HttpContext.Request.Headers and HttpContext.Response.Headers before the pipeline continues/ends.  \n\u2022 The file already references DocuSign.Monitoring and System.Diagnostics, indicating existing Activity/Span usage; therefore Activity.Current is expected to be the ASP.NET request span that we must enrich.  \n\u2022 By adding two SetTag / AddTag calls inside this middleware (one before calling _next for the Referer header and one after for the Location response header), we can satisfy the requirement without touching any other files.\nBatch 7 (ScmLogAsyncRequestHttpMiddleware.cs): \u2022 The requirement targets ASP-NET request spans. ScmLogAsyncRequestHttpMiddleware is an ASP-NET Core middleware that already logs and instruments each HTTP request, exposing HttpContext Request and Response objects.\n\n\u2022 Middleware is the ideal interception point to read:\n  - Request.Headers[\"Referer\"]  \u279c HTTP_REFERER\n  - Response.Headers[\"Location\"] \u279c HTTP_RESPONSE_REDIRECT_LOCATION\n\n\u2022 The file references IServiceInstrumentation and other telemetry utilities, indicating existing Activity/Span creation where SetTag / AddAttribute calls can be added without creating new plumbing.\n\n\u2022 Because the class is abstract and sits high in the request pipeline, adding two SetTag (or Activity.SetTag / Activity.AddTag) calls here will automatically enrich all derived middleware executions, satisfying the requirement application-wide. No other files need changes.\nBatch 8 (MvcAuditedRequestAttribute.cs): \u2022 MvcAuditedRequestAttribute is an MVC ActionFilter that runs for every incoming ASP-NET request and already references DocuSign-specific \u201cMonitoring\u201d/telemetry namespaces.  \n\u2022 Inside an OnActionExecuting / OnActionExecuted / OnResultExecuted override it can access:\n  \u2013 HttpContext.Request.Headers[\"Referer\"] (incoming header)  \n  \u2013 HttpContext.Response.Headers[\"Location\"] (outgoing redirect header)  \n\u2022 The currently-active ASP-NET request span is exposed through System.Diagnostics.Activity.Current.  \n  Calling Activity.Current?.SetTag(\"HTTP_REFERER\", \u2026) and Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", \u2026) adds the required attributes to the existing span without creating new spans.  \n\u2022 No other files are needed; this single attribute is the natural centralized hook for request/response instrumentation and already participates in the app\u2019s telemetry pipeline.\nBatch 9 (HttpRequestAuditHelper.cs): \u2022 The requirement is to enrich the already-present ASP.NET request span with two additional attributes taken from the current HttpContext (Request.Headers[\"Referer\"] and Response.Headers[\"Location\"]).  \n\u2022 HttpRequestAuditHelper.cs is a cross-cutting helper that already receives/derives HttpContext information and references DocuSign.Monitoring (Activity/Span utility). This indicates it is the central place where the request span is started and/or annotated (counter attributes, duration, etc.).  \n\u2022 Because the helper is generic and statically shared, adding two extra Activity.SetTag (or equivalent DocuSign.Monitoring extension) calls here will automatically propagate to every ASP.NET request span created through this helper, fulfilling the requirement with a single change.  \n\u2022 No other files in the group are needed to capture the Referer or Redirect Location headers, so only HttpRequestAuditHelper.cs needs modification.\nBatch 10 (ActivityEnricher.cs): \u2022 ActivityEnricher.cs is a utility whose sole purpose is to enrich the current Activity with additional tags.  \n\u2022 It already receives both the Activity and HttpContext objects, giving direct access to:\n  \u2013 context.Request.Headers[\"Referer\"]  \u2192 needed for HTTP_REFERER  \n  \u2013 context.Response.Headers[\"Location\"] \u2192 needed for HTTP_RESPONSE_REDIRECT_LOCATION  \n\u2022 The file already calls activity.SetTag(\u2026) for other attributes, so adding two more SetTag calls fits the existing pattern and requires no new infrastructure.  \n\u2022 No other files are necessary; the enrichment logic can be fully implemented inside ActivityEnricher.cs.\nBatch 11 (ScmHttpApplication.cs): \u2022 ScmHttpApplication.cs is the ASP-NET (System.Web) HttpApplication class for the CLM web app.  \n\u2022 It already references OpenTelemetry.Trace and DocuSign.CLM.Monitoring, indicating that request-span instrumentation is set up here (typical pattern: Activity.Current represents the \u201cASP.NET HTTP Request Span\u201d).  \n\u2022 Because this file receives all HTTP events (BeginRequest / EndRequest, etc.), it has access to both:\n  \u2013 HttpContext.Current.Request.Headers[\"Referer\"]  \n  \u2013 HttpContext.Current.Response.Headers[\"Location\"] (after a redirect is issued)  \n\u2022 Therefore, inside the appropriate pipeline events we can simply check Activity.Current (or a tracer span wrapper) and call SetTag / SetAttribute to add\n  \u2022 HTTP_REFERER\n  \u2022 HTTP_RESPONSE_REDIRECT_LOCATION\n\u2022 No other files are needed; telemetry can be injected directly in this application-wide location without touching unrelated code.\nBatch 12 (Global.asax.cs): \u2022 Global.asax.cs is the application-level entry point for every ASP.NET request and already references OpenTelemetry.Trace.  \n\u2022 It typically contains Application_BeginRequest / Application_EndRequest (or similar) handlers where Activity.Current is available, making it the natural place to enrich the existing \u201cASP.NET HTTP Request\u201d span generated by AspNetInstrumentation.  \n\u2022 Within these events we can read Request.Headers[\"Referer\"] and Response.Headers[\"Location\"] and attach them to the current Activity via SetTag, fully satisfying the requirement.  \n\u2022 No other files are necessary; the enrichment can be done entirely inside Global.asax.cs without touching configuration or unrelated code.\nBatch 13 (Startup.cs): Startup.cs already contains the OpenTelemetry-related service registration for the ASP.NET Core web application.  \n\u2022 This is where AddAspNetCoreInstrumentation (or similar tracing registration) is typically configured.  \n\u2022 The requirement can be satisfied by adding an Enrich or ActivityProcessor delegate inside that registration to read  \n  \u2013 `context.Request.Headers[\"Referer\"]` \u2192 add Activity tag `HTTP_REFERER`  \n  \u2013 `context.Response.Headers[\"Location\"]` \u2192 add Activity tag `HTTP_RESPONSE_REDIRECT_LOCATION`.  \n\u2022 No other file in the group is needed; Startup.cs is the single point where the tracing pipeline is built, making it the direct and sufficient place for the instrumentation change.\nBatch 14 (Program.cs): \u2022 The requirement is to enrich existing ASP.NET request spans.  \n\u2022 Program.cs is where the ASP.NET Core host and middleware pipeline are built.  \n\u2022 A small custom middleware added in Program.cs can:\n  1. Access HttpContext.Request.Headers[\"Referer\"] and HttpContext.Response.Headers[\"Location\"].\n  2. Check Activity.Current (the ASP.NET request span created by the OpenTelemetry/ASP.NET instrumentation).\n  3. Call Activity.SetTag(\"HTTP_REFERER\", \u2026) and Activity.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", \u2026).  \n\u2022 No other files are necessary; inserting this middleware in Program.cs fully satisfies the telemetry gap.\nBatch 15 (CoreInstrumentationLifetimeService.cs): \u2022 The requirement is to enrich the existing ASP.NET request spans with two extra attributes (HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION).  \n\u2022 Such enrichment is normally done through the OpenTelemetry ASP.NET Core instrumentation by registering an `AspNetCoreInstrumentationOptions.Enrich` (or `Filter`) callback when the tracer provider is built.  \n\u2022 CoreInstrumentationLifetimeService.cs is the project\u2019s central \u201clifetime\u201d service that already configures OpenTelemetry tracing/metrics (it references `OpenTelemetry.Trace`, `OpenTelemetry.Metrics`, and contains the builder logic). Therefore it is the correct and only place where we can extend the instrumentation configuration.  \n\u2022 No other files in this group actually handle HTTP requests or span creation; they simply rely on the configuration that this class sets up. Hence only this file needs modification.  \n\nBy adding an Enrich delegate inside CoreInstrumentationLifetimeService.cs, we can read `HttpContext.Request.Headers[\"Referer\"]` and `HttpContext.Response.Headers[\"Location\"]` and attach them to the current Activity, fulfilling the telemetry requirement without touching other files.\nBatch 16 (WorkflowActivitiesController.cs): \u2022 The requirement is to enrich the existing ASP.NET request span with two extra attributes.  \n\u2022 WorkflowActivitiesController.cs is an MVC controller that executes inside the ASP.NET Core request pipeline, where the \u201cASP.NET HTTP Request\u201d Activity (span) is already active (Activity.Current).  \n\u2022 The file already imports System.Diagnostics and DocuSign-specific telemetry helpers, indicating existing instrumentation practices.  \n\u2022 From within each action (or a common helper in the same controller) we can easily read:\n  \u2013 Request.Headers[\"Referer\"] \u2192 add as Activity.Current?.SetTag(\"HTTP_REFERER\", \u2026)  \n  \u2013 Response.Headers[\"Location\"] (set just before returning) \u2192 add as Activity.Current?.SetTag(\"HTTP_RESPONSE_REDIRECT_LOCATION\", \u2026)  \n\u2022 No other files are necessary; the controller alone has access to both request and response objects and can attach the required tags to the currently-active span.\n\nTherefore, modifying WorkflowActivitiesController.cs is sufficient to close the telemetry gap.\nBatch 17 (Program.cs): \u2022 Program.cs is where the ASP.NET Core service is configured (WebApplication builder, middleware pipeline, and OpenTelemetry/Activity setup appear here).  \n\u2022 To attach additional attributes to every ASP.NET request span you can:  \n  1. Register the ASP.NET Core OpenTelemetry instrumentation with an \u201cEnrich\u201d delegate, or  \n  2. Insert a small custom middleware that, during the request pipeline, fetches Activity.Current (the request span) and sets the attributes HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION from Request.Headers[\"Referer\"] and Response.Headers[\"Location\"].  \n\u2022 Either of these implementations only requires changes in Program.cs (or adding a tiny middleware class referenced from Program.cs). No other files are needed from this group.  \n\u2022 Therefore this file group is capable of meeting the telemetry requirement by modifying Program.cs.\nBatch 18 (Program.cs): \u2022 The requirement is to add two custom attributes (HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION) to the existing ASP.NET incoming-request spans.  \n\u2022 Those spans are created automatically by the OpenTelemetry ASP.NET Core instrumentation. The correct way to enrich them is to register an Enrich callback (or custom middleware) at application start-up.  \n\u2022 Program.cs is the central bootstrapping file where all services (including existing telemetry: AdvancedInsightsService, ServiceMetrics, etc.) are configured via builder.Services. It is the natural place to extend the OpenTelemetry pipeline with AddAspNetInstrumentation(options => { options.Enrich = \u2026 }).  \n\u2022 No other files in this group contain HTTP handling or Activity creation logic, so only Program.cs needs modification.\nBatch 19 (AbstractServicedComponent.cs): Cannot solve gap - The only file in this group (AbstractServicedComponent.cs) is an abstract base class for serviced components. It contains general service-level utilities and references to the monitoring libraries, but it does not:\n\n\u2022 Handle ASP.NET HTTP requests or responses  \n\u2022 Have access to HttpContext, Request.Headers, or Response.Headers  \n\u2022 Create or modify the existing \u201cASP.NET HTTP Request\u201d spans\n\nBecause the code in this group never sees the HTTP pipeline, it cannot capture the Referer or Location headers or add them as span attributes. Therefore this file group cannot implement the required telemetry instrumentation, and no files are selected for modification.\nBatch 20 (Program.cs): \u2022 The requirement is to enrich existing ASP.NET request spans with two HTTP-header-derived attributes.  \n\u2022 Program.cs is the startup/bootstrapping file that builds the ASP.NET Core app and already wires OpenTelemetry through \u201cADEXS.ServiceFramework.OpenTelemetry.Extensions\u201d.  \n\u2022 Because Program.cs controls the middleware pipeline, we can insert a small inline or extracted middleware there that, for every request, checks Activity.Current (the request span created by ASP.NET instrumentation) and adds the tags HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION from Request.Headers[\"Referer\"] and Response.Headers[\"Location\"].  \n\u2022 No other files are present in this group, and the required logic does not need changes elsewhere; therefore Program.cs is the only file that must be modified.\nBatch 21 (Program.cs): \u2022 Program.cs is the startup/boot-strapping file that builds the WebApplication and wires up middleware and OpenTelemetry via ADEXS.ServiceFramework.OpenTelemetry.Extensions.  \n\u2022 Because it owns the HTTP request pipeline (app.Use\u2026/app.Map\u2026 etc.), it is the correct place to insert a small custom ASP.NET Core middleware that inspects Request.Headers[\"Referer\"] and Response.Headers[\"Location\"] and then calls Activity.Current?.SetTag(...).  \n\u2022 No other files are present in this group, and no additional classes are required; the gap can be closed by adding ~10 lines of middleware code in Program.cs just before existing endpoint mappings.\nBatch 22 (Program.cs): Program.cs is the startup/bootstrapping file where the ASP-NET Core request pipeline is built. It already contains service and OpenTelemetry configuration hooks, making it the natural place to register a small custom middleware or OpenTelemetry enrichment delegate that:\n\n1. Reads Request.Headers[\"Referer\"] before the next middleware executes.\n2. Reads Response.Headers[\"Location\"] after the next middleware finishes.\n3. Adds both values to Activity.Current (the ASP.NET HTTP request span) via SetTag.\n\nNo other files in the group are present or required. Therefore, modifying Program.cs alone is sufficient to meet the telemetry requirement.\nBatch 23 (Program.cs): \u2022 The requirement is to enrich existing ASP.NET HTTP request spans with two extra attributes taken from the incoming request and outgoing response headers.  \n\u2022 Program.cs is where the ASP.NET Core pipeline is built and where OpenTelemetry is already configured through ADEXS.ServiceFramework.OpenTelemetry.Extensions.  \n\u2022 A small piece of custom middleware can be registered in Program.cs to:\n  1. Access the current Activity (the ASP.NET automatic request span).\n  2. Read Request.Headers[\"Referer\"] and, after the next delegate runs, Response.Headers[\"Location\"].\n  3. Call activity?.SetTag(...) (or SetAttribute) to add those two attributes.  \n\u2022 No other files are necessary; the middleware can be injected directly in Program.cs right after builder.Build() or during app.Use\u2026 chain.  \n\u2022 Therefore the single file in the group is sufficient to implement the telemetry requirement.\nBatch 24 (OWINStartup.cs): \u2022 The telemetry requirement needs per-request logic (access to Request.Headers and Response.Headers) that runs while the ASP.NET request span (created automatically by the ASP.NET/OpenTelemetry instrumentation) is still the current Activity.  \n\u2022 OWINStartup.cs is the root of the OWIN pipeline for this site. By inserting a small middleware component in this file, we can:\n  1. Read Request.Headers[\"Referer\"] and Response.Headers[\"Location\"] after the downstream pipeline finishes.  \n  2. Retrieve System.Diagnostics.Activity.Current (the request span created by ASP.NET instrumentation).  \n  3. Add the required attributes (SetTag / SetCustomProperty).  \n\u2022 No other files in the group are involved in request processing or span creation, so only OWINStartup.cs needs modification (plus an optional new middleware class placed next to it).  \n\u2022 Therefore this file group can directly implement the instrumentation gap without touching unrelated code.\nBatch 25 (Program.cs): \u2022 The requirement is to add extra attributes (HTTP_REFERER and HTTP_RESPONSE_REDIRECT_LOCATION) to the existing ASP.NET request spans.  \n\u2022 This is typically done where OpenTelemetry / Activity-based tracing for ASP.NET Core is configured. That logic is usually located in Program.cs (or Startup.cs) because that is where services are registered and middleware is added.  \n\u2022 Program.cs is therefore the correct\u2014and only\u2014place in this group where we can hook into AddAspNetCoreInstrumentation or add a custom middleware to enrich spans with the required headers.  \n\u2022 No other files are present in the group, and none are needed to fulfill the instrumentation requirement."
]